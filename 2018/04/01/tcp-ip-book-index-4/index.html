<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon/manifest.json">
  <meta name="google-site-verification" content="yL1R2eDsKDqjPNaOBKp1usSDw8SQNzaO35svs1LKYWw">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"perfectacle.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다.   들어가기에 앞">
<meta property="og:type" content="blog">
<meta property="og:title" content="(네트워크) TCP&#x2F;IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층">
<meta property="og:url" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/index.html">
<meta property="og:site_name" content="오늘도 끄적끄적">
<meta property="og:description" content="오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다.   들어가기에 앞">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/thumb.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/vpc.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/subnet-mask-windows.gif">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/subnet-mask-mac.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/vpc.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/subnet.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/vpc2.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/private-ip.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/routing-table.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/nat-gateway.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-windows.jpg">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-mac.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/subnet-mask-router.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-other-info.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-dhcp.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-mtu.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-routing-table.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-port-forwarding.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/router-port-forwarding2.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/hosts.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/route-53.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/go-daddy.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/traceroute-blog.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/traceroute-naver.png">
<meta property="og:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/naver-domain.png">
<meta property="article:published_time" content="2018-04-01T13:00:38.000Z">
<meta property="article:modified_time" content="2023-07-09T03:12:47.005Z">
<meta property="article:author" content="양권성">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/thumb.png">


<link rel="canonical" href="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"ko","comments":true,"permalink":"https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/","path":"2018/04/01/tcp-ip-book-index-4/","title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층 | 오늘도 끄적끄적</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-87795455-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-87795455-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>







<!--<script data-ad-client="ca-pub-3881550906962162" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="오늘도 끄적끄적" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">오늘도 끄적끄적</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">느리더라도 꾸준하게</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="검색" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>정보</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>태그<span class="badge">257</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>카테고리<span class="badge">50</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>아카이브<span class="badge">218</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C"><span class="nav-number">1.</span> <span class="nav-text">들어가기에 앞서</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EB%AA%A9%EC%B0%A8"><span class="nav-number">2.</span> <span class="nav-text">목차</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%EC%9E%A5-%EB%9D%BC%EC%9A%B0%ED%8C%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B3%84%EC%B8%B5"><span class="nav-number">3.</span> <span class="nav-text">4장, 라우팅과 인터넷 계층</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B3%84%EC%B8%B5%EC%9D%98-%EC%97%AD%ED%95%A0"><span class="nav-number">3.1.</span> <span class="nav-text">4-1. 인터넷 계층의 역할</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-IPv4%EC%99%80-IPv6"><span class="nav-number">3.2.</span> <span class="nav-text">4-2. IPv4와 IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-IPv4%EB%8A%94-32%EB%B9%84%ED%8A%B8-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">4-2-1. IPv4는 32비트 어드레스</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-IPv4-%ED%97%A4%EB%8D%94"><span class="nav-number">3.2.2.</span> <span class="nav-text">4-2-2. IPv4 헤더</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-IP-%ED%8C%A8%ED%82%B7%EC%97%90%EB%8F%84-%EC%9C%A0%ED%86%B5%EA%B8%B0%ED%95%9C%EC%9D%B4-%EC%9E%88%EB%8B%A4"><span class="nav-number">3.2.3.</span> <span class="nav-text">4-2-3. IP 패킷에도 유통기한이 있다.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%EC%A2%81%EC%9D%80-%EA%B8%B8%EC%9D%84-%EC%A7%80%EB%82%A0-%EB%95%8C%EB%8A%94-%EC%9E%91%EA%B2%8C-%EB%B6%84%ED%95%A0%ED%95%B4%EC%84%9C-%EC%A7%80%EB%82%98%EA%B0%84%EB%8B%A4"><span class="nav-number">3.2.4.</span> <span class="nav-text">4-2-4. 좁은 길을 지날 때는 작게 분할해서 지나간다.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B6%84%ED%95%A0%ED%95%98%EA%B3%A0-%EB%B3%B5%EC%9B%90%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95"><span class="nav-number">3.2.5.</span> <span class="nav-text">4-2-5. 데이터를 분할하고 복원하는 방법</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6-IPv6"><span class="nav-number">3.2.6.</span> <span class="nav-text">4-2-6. IPv6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-7-IPv6%EB%A1%9C-%EA%B0%88%EC%95%84%ED%83%80%EA%B8%B0"><span class="nav-number">3.2.7.</span> <span class="nav-text">4-2-7. IPv6로 갈아타기</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4%EC%9D%98-%ED%99%9C%EC%9A%A9"><span class="nav-number">3.3.</span> <span class="nav-text">4-3. IP 어드레스의 활용</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%80%EC%99%80-%ED%98%B8%EC%8A%A4%ED%8A%B8-%EB%B6%80"><span class="nav-number">3.3.1.</span> <span class="nav-text">4-3-1. 네트워크 부와 호스트 부</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4"><span class="nav-number">3.3.2.</span> <span class="nav-text">4-3-2. 어드레스 클래스</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A0%9C%EC%95%BD"><span class="nav-number">3.3.3.</span> <span class="nav-text">4-3-3. 어드레스 클래스의 제약</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%EC%84%9C%EB%B8%8C%EB%84%B7-%EB%A7%88%EC%8A%A4%ED%81%AC-Subnet-Mask"><span class="nav-number">3.3.4.</span> <span class="nav-text">4-3-4. 서브넷 마스크(Subnet Mask)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4%EC%9D%98-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">4-3-5. IP 어드레스의 할당 방법</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-6-%EC%84%9C%EB%B8%8C%EB%84%B7-%EB%A7%88%EC%8A%A4%ED%81%AC%EB%A1%9C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%84%B8%EB%B6%84%ED%99%94%ED%95%98%EA%B8%B0"><span class="nav-number">3.3.6.</span> <span class="nav-text">4-3-6. 서브넷 마스크로 네트워크 세분화하기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-7-%EA%B0%80%EC%A0%95%EC%9D%B4%EB%82%98-%EC%82%AC%EB%AC%B4%EC%8B%A4%EC%97%90%EC%84%9C-%EC%9E%90%EC%9C%A0%EB%A1%AD%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B9%97-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4"><span class="nav-number">3.3.7.</span> <span class="nav-text">4-3-7. 가정이나 사무실에서 자유롭게 사용하는 프라이빗 IP 어드레스</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-8-%ED%8D%BC%EB%B8%94%EB%A6%AD-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4%EC%9D%98-%EA%B4%80%EB%A6%AC"><span class="nav-number">3.3.8.</span> <span class="nav-text">4-3-8. 퍼블릭 IP 어드레스의 관리</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%EB%9D%BC%EC%9A%B0%ED%8C%85%EC%9D%B4%EB%9E%80"><span class="nav-number">3.4.</span> <span class="nav-text">4-4. 라우팅이란?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%EB%9D%BC%EC%9A%B0%ED%8C%85%EA%B3%BC-%EA%B2%BD%EB%A1%9C-%ED%83%90%EC%83%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">4-4-1. 라우팅과 경로 탐색</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C"><span class="nav-number">3.4.2.</span> <span class="nav-text">4-4-2. 라우팅 프로토콜</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%EC%9E%90%EC%9C%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C"><span class="nav-number">3.4.3.</span> <span class="nav-text">4-4-3. 자율 시스템</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%99%80-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C"><span class="nav-number">3.5.</span> <span class="nav-text">4-5. 라우터와 라우팅 프로토콜</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%EC%97%AD%ED%95%A0"><span class="nav-number">3.5.1.</span> <span class="nav-text">4-5-1. 라우터의 역할</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%85%8C%EC%9D%B4%EB%B8%94"><span class="nav-number">3.5.2.</span> <span class="nav-text">4-5-2. 라우팅 테이블</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-%EC%A0%95%EC%A0%81-%EB%9D%BC%EC%9A%B0%ED%8C%85%EA%B3%BC-%EB%8F%99%EC%A0%81-%EB%9D%BC%EC%9A%B0%ED%8C%85"><span class="nav-number">3.5.3.</span> <span class="nav-text">4-5-3. 정적 라우팅과 동적 라우팅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EB%AA%A9%EC%A0%81%EC%A7%80-%EC%A0%95%EB%B3%B4%EA%B0%80-%EC%97%86%EC%9D%84-%EA%B2%BD%EC%9A%B0"><span class="nav-number">3.5.4.</span> <span class="nav-text">4-5-4. 라우팅 테이블에 목적지 정보가 없을 경우</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-5-%EB%8F%99%EC%A0%81-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><span class="nav-number">3.5.5.</span> <span class="nav-text">4-5-5. 동적 라우팅 알고리즘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%98%A4%EB%A5%98%EB%A5%BC-%ED%86%B5%EB%B3%B4%ED%95%98%EB%8A%94-ICMP"><span class="nav-number">3.6.</span> <span class="nav-text">4-6. 네트워크 오류를 통보하는 ICMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%EB%B3%80%ED%99%98"><span class="nav-number">3.7.</span> <span class="nav-text">4-7. 어드레스 변환</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%EB%B3%80%ED%99%98-NAT-%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D"><span class="nav-number">3.7.1.</span> <span class="nav-text">4-7-1. 네트워크 어드레스 변환(NAT)의 동작 방식</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2-NAT%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%A0%9C%EC%95%BD-%EC%82%AC%ED%95%AD"><span class="nav-number">3.7.2.</span> <span class="nav-text">4-7-2. NAT에서 발생할 수 있는 제약 사항</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-3-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%ED%8F%AC%ED%8A%B8-%EB%B3%80%ED%99%98"><span class="nav-number">3.7.3.</span> <span class="nav-text">4-7-3. 네트워크 어드레스 포트 변환</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-4-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%EC%9D%B4-%EA%B0%80%EB%8A%A5%ED%95%98%EA%B2%8C-%ED%95%98%EA%B8%B0"><span class="nav-number">3.7.4.</span> <span class="nav-text">4-7-4. 외부에서 접속이 가능하게 하기.</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-4-1-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%9D%98-%EC%9E%90%EB%8F%99-%ED%99%95%EC%9D%B8"><span class="nav-number">3.7.4.1.</span> <span class="nav-text">4-7-4-1. 메시지의 자동 확인</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-4-2-%ED%8F%AC%ED%8A%B8%ED%8F%AC%EC%9B%8C%EB%94%A9"><span class="nav-number">3.7.4.2.</span> <span class="nav-text">4-7-4-2. 포트포워딩</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85"><span class="nav-number">3.8.</span> <span class="nav-text">4-8. 도메인명</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-1-%ED%98%B8%EC%8A%A4%ED%8A%B8%EB%AA%85%EA%B3%BC-%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85"><span class="nav-number">3.8.1.</span> <span class="nav-text">4-8-1. 호스트명과 도메인명</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-2-DNS-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A7%88%EC%9D%98%ED%95%98%EA%B8%B0"><span class="nav-number">3.8.2.</span> <span class="nav-text">4-8-2. DNS 서버에 질의하기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-3-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0"><span class="nav-number">3.8.3.</span> <span class="nav-text">4-8-3. 도메인의 계층 구조</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-DNS-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0"><span class="nav-number">3.8.4.</span> <span class="nav-text">4-8-4. DNS 서버의 계층 구조</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-5-DNS-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A7%88%EC%9D%98-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95"><span class="nav-number">3.8.5.</span> <span class="nav-text">4-8-5. DNS 서버에 질의 처리하는 과정</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-6-DNS%EC%97%90-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0"><span class="nav-number">3.8.6.</span> <span class="nav-text">4-8-6. DNS에 도메인 등록하기</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-7-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EB%A0%88%EC%BD%94%EB%93%9C%EC%9D%98-%EC%9D%98%EB%AF%B8"><span class="nav-number">3.8.7.</span> <span class="nav-text">4-8-7. 리소스 레코드의 의미</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4%EB%A5%BC-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-DHCP"><span class="nav-number">3.9.</span> <span class="nav-text">4-9. IP 어드레스를 자동으로 할당하는 DHCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-1-DHCP%EC%9D%98-%EC%9E%A5%EC%A0%90"><span class="nav-number">3.9.1.</span> <span class="nav-text">4-9-1. DHCP의 장점</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-2-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95"><span class="nav-number">3.9.2.</span> <span class="nav-text">4-9-2. IP 어드레스 할당 방법</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-ipconfig-%EB%AA%85%EB%A0%B9%EA%B3%BC-ping-%EB%AA%85%EB%A0%B9"><span class="nav-number">3.10.</span> <span class="nav-text">4-10. ipconfig 명령과 ping 명령</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-tracert-%EB%AA%85%EB%A0%B9%EC%9C%BC%EB%A1%9C-%ED%86%B5%EC%8B%A0%EA%B2%BD%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0"><span class="nav-number">3.11.</span> <span class="nav-text">4-11. tracert 명령으로 통신경로 확인하기</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-nslookup-%EB%AA%85%EB%A0%B9%EC%9C%BC%EB%A1%9C-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4-%EC%95%8C%EC%95%84%EB%82%B4%EA%B8%B0"><span class="nav-number">3.12.</span> <span class="nav-text">4-12. nslookup 명령으로 IP 어드레스 알아내기</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="양권성" src="/images/avatar/avatar.png">
  <p class="site-author-name" itemprop="name">양권성</p>
  <div class="site-description" itemprop="description">Toss Server Developer</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">257</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/perfectacle" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;perfectacle" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:perfectacle@gmail.com" title="E-Mail → mailto:perfectacle@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/perfectacle" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;perfectacle" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/avatar.png">
      <meta itemprop="name" content="양권성">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="오늘도 끄적끄적">
      <meta itemprop="description" content="Toss Server Developer">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층 | 오늘도 끄적끄적">
      <meta itemprop="description" content>
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          (네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">작성일</span>

      <time title="Post created: 2018-04-01 13:00:38" itemprop="dateCreated datePublished" datetime="2018-04-01T13:00:38+00:00">2018-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Middle-end/" itemprop="url" rel="index"><span itemprop="name">Middle-end</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Middle-end/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/04/01/tcp-ip-book-index-4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/01/tcp-ip-book-index-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><img src="/2018/04/01/tcp-ip-book-index-4/thumb.png" class>  
<p>오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.<br>백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.<br>이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다.  </p>
<h2 id="들어가기에-앞서"><a href="#들어가기에-앞서" class="headerlink" title="들어가기에 앞서"></a>들어가기에 앞서</h2><p>내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95">OSI 7 Layer</a>를 기준으로 설명을 풀어나가고 있다.<br>OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.<br>하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해<br>실제 구현된 건 대부분 4계층으로 구성된 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8">TCP&#x2F;IP Stack</a>으로 구현이 많이 돼있다.<br>이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.<br>따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/">AWS</a>나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서<br>OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다.  </p>
<p>또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나<br>각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.<br>여기서부터는 프론트는 딱히 몰라도 된다고 생각하는 내용이므로 목차 뒤에 F&#x2F;B를 구분해서 달지 않겠다.  </p>
<p>예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.<br>웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.<br>HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.<br>통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.<br>따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.<br>예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)<br>이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)<br>따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다.</p>
<p>백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.<br>SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.<br>SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.<br>이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.<br>또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.<br>기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데<br>UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.<br>하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.<br>또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.<br>보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…<br>그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며<br>어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다.  </p>
<p>더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.<br>위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)<br>또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)<br>이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다.</p>
<h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol>
<li><a href="/2018/03/30/tcp-ip-book-index/#1%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC">컴퓨터 네트워크</a></li>
<li><a href="/2018/03/31/tcp-ip-book-index-2/#2%EC%9E%A5-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B3%84%EC%B8%B5">네트워크 서비스와 애플리케이션 계층</a></li>
<li><a href="/2018/03/31/tcp-ip-book-index-3/#3%EC%9E%A5-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8F%AC%ED%8A%B8-%EA%B3%84%EC%B8%B5">트랜스포트 계층</a></li>
<li><a href="/#4%EC%9E%A5-%EB%9D%BC%EC%9A%B0%ED%8C%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B3%84%EC%B8%B5">라우팅과 인터넷 계층</a></li>
<li><a href="/2018/04/01/tcp-ip-book-index-5/#5%EC%9E%A5-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%99%80-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EA%B3%84%EC%B8%B5">하드웨어와 네트워크 인터페이스 계층</a></li>
<li><a href="/2018/03/31/tcp-ip-book-index-6/#6%EC%9E%A5-%EB%B3%B4%EC%95%88">보안</a></li>
</ol>
<h2 id="4장-라우팅과-인터넷-계층"><a href="#4장-라우팅과-인터넷-계층" class="headerlink" title="4장, 라우팅과 인터넷 계층"></a>4장, 라우팅과 인터넷 계층</h2><p>OSI 7 Layer 기준 L3(Network Layer)이다.<br>IP 주소를 가지고 송신지로부터 수신지로 데이터를 전달하는 역할을 수행한다.<br>유선 전화번호가 지역 번호를 내장하고 있는 것과는 달리 IP 주소는 지역 정보로 구분되는 게 아니라 네트워크 단위로 할당이 된다.<br>따라서 IP들을 보면 같은 네트워크에 속해있는지, 소규모 네트워크인지 대규모 네트워크인지 정도만 알 수 있다.  </p>
<p>그리고 각 네트워크들은 라우터라는 장비를 통해 연결이 되므로 라우팅 테이블이 복잡하게 연결돼있으면 지리상으로 가까운데도 불구하고<br>데이터 전송을 하는데 오래 걸리는 경우도 존재한다.<br>반대로 지리상으로 먼데 라우팅 테이블이 잘 설계돼있으면 금방 데이터가 도착할 수도 있다.</p>
<h3 id="4-1-인터넷-계층의-역할"><a href="#4-1-인터넷-계층의-역할" class="headerlink" title="4-1. 인터넷 계층의 역할"></a>4-1. 인터넷 계층의 역할</h3><p>IP 주소로 데이터를 전달하는 역할을 한다.<br>바로 다이렉트로 목적지 IP 어드레스를 찌르는 게 아니라 라우터(Router)라는 장비들을 통해서 전송이 이루어진다.<br>클라이언트는 인접한 라우터를 찾고 그 라우터는 또 인접한 라우터들을 찾아서 데이터를 보내려는 목적지와 인접한 라우터까지 이 과정이 반복되고<br>최종 라우터에서 목적지로 데이터를 보낸다.<br>이렇게 라우터를 통해 목적지의 경로를 찾아가는 작업을 라우팅(Routing)이라고 부른다.  </p>
<p>간단하게 가정집을 시나리오로 생각해보자.  </p>
<ol>
<li>내가 웹 브라우저를 통해 네이버로 접속하려고 한다.  </li>
<li>내 컴퓨터가 공유기(라우터의 역할을 수행한다)로 데이터를 쏜다.  </li>
<li>공유기는 모뎀(얘가 라우터의 역할도 한다)로 데이터를 쏜다.</li>
<li>공유기는 다른 라우터들을 통해서 ISP(올레나 SK 브로드 밴드 등등의 인터넷 서비스 제공자) 라우터로 토스를 한다.  </li>
<li>그 라우터가 다른 수많은 라우터를 거쳐 네이버 서버와 연결된 라우터까지 간다.  </li>
<li>해당 라우터가 네이버에게 요청을 보낸다.</li>
</ol>
<p>요즘 들어 핸드폰이며 TV며 냉장고며 IoT가 나오기도 하고 온갖 사물들이 인터넷과 통신을 하면서 IP 주소를 막 할당받기 시작했다.<br>그러면서 진작부터 IP 주소가 고갈되기 시작했다.<br>그래서 등장한 것이 Private IP(사설 IP)이다.<br>공유기를 쓰면 내 컴퓨터와 다른 사람의 컴퓨터가 다른 IP를 사용하는 것 같은데<br>이건 내부적으로 사용하는 private IP나 다른 것이지 외부로 달고 나가는(외부에서 접속 가능한) Public IP(공용 IP)는 하나만 존재한다.<br>그리고 외부에서는 하나의 IP만 할당한 것으로 보이기 때문에 이런 방식으로 IP 주소 부족의 문제를 해결하고 있다.<br>이런 방식과는 별개로 IPv4 주소가 32비트(2^32, 약 42억)여서 42억 개의 IP만 할당이 가능한 데 비해<br>IPv6의 경우에는 128비트(2^128, 3.4028237e+38)로 단위로 표현할 수도 없는 갯수의 IP 할당이 가능하다.<br>하지만 여러 기술의 도입으로 인해 아직 IPv6를 사용하지 않아도 되는 수준인지 IPv6는 딱히 써본 적이 없다.<br>IPv4는 IP 프로토콜을 사용하는데 반해 IPv6는 IPSec이라는 프로토콜을 지원해서 패킷 자체를 암호화하고 있다.<br>그리고 IPv4는 사람한테 익숙한 10진수를 쓰긴 했는데 마지막 자리가 255라는 애매한 숫자로 떨어지는데<br>IPv6는 16진수를 사용해서 마지막 자리가 FF로 떨어져서 그나마 가독성이 조금 올라간 것 같다.</p>
<h3 id="4-2-IPv4와-IPv6"><a href="#4-2-IPv4와-IPv6" class="headerlink" title="4-2. IPv4와 IPv6"></a>4-2. IPv4와 IPv6</h3><h4 id="4-2-1-IPv4는-32비트-어드레스"><a href="#4-2-1-IPv4는-32비트-어드레스" class="headerlink" title="4-2-1. IPv4는 32비트 어드레스"></a>4-2-1. IPv4는 32비트 어드레스</h4><p>IP 주소는 인터넷 계층(혹은 L3) 장비에만 할당되기 때문에 이더넷 카드나 모뎀 등등에는 할당되지 않는다.  </p>
<h4 id="4-2-2-IPv4-헤더"><a href="#4-2-2-IPv4-헤더" class="headerlink" title="4-2-2. IPv4 헤더"></a>4-2-2. IPv4 헤더</h4><p>IPv4 패킷의 헤더에는 송수신지 IP 어드레스나 생존기간, 프로토콜, 체크섬, 버전, 우선순위, 패킷 전체의 길이 등등을 담고 있다.</p>
<h4 id="4-2-3-IP-패킷에도-유통기한이-있다"><a href="#4-2-3-IP-패킷에도-유통기한이-있다" class="headerlink" title="4-2-3. IP 패킷에도 유통기한이 있다."></a>4-2-3. IP 패킷에도 유통기한이 있다.</h4><p>HTTP 1.1 스펙에서 Keep-Alive를 통해 TCP 커넥션의 유효기간을 설정하듯이<br>IP 패킷에도 생존기간을 설정할 수 있다.<br>IP 패킷의 TTL(Time to Live)를 7홉(Hop)으로 설정하면 라우터를 하나 탈 때마다 TTL이 하나씩 깎인다.<br>7홉 내에서 목적지까지 도착하지 못하면 해당 패킷은 소멸된다.<br>패킷을 라우터를 찾기 위해 무한정 뺑뺑이 돌리면 효율이 떨어지므로 TTL이 있는 것 같다.</p>
<h4 id="4-2-4-좁은-길을-지날-때는-작게-분할해서-지나간다"><a href="#4-2-4-좁은-길을-지날-때는-작게-분할해서-지나간다" class="headerlink" title="4-2-4. 좁은 길을 지날 때는 작게 분할해서 지나간다."></a>4-2-4. 좁은 길을 지날 때는 작게 분할해서 지나간다.</h4><p>한 번에 전송할 수 있는 데이터 크기를 MTU(Maximum Transmission Unit)라고 하고<br>통신 경로의 상태(라우터의 상태)에 따라 달라진다.<br>패킷을 보낼 때 다음 라우터의 MTU보다 작으면 해당 MTU 만큼 패킷을 쪼개서 보낸다.<br>하지만 패킷이 중간에 유실되면 복구하기 어려우므로 처음부터 전체 경로에 대해서 MTU를 구하고 해당 MTU만큼 보내는 게 제일 안전하다.</p>
<h4 id="4-2-5-데이터를-분할하고-복원하는-방법"><a href="#4-2-5-데이터를-분할하고-복원하는-방법" class="headerlink" title="4-2-5. 데이터를 분할하고 복원하는 방법"></a>4-2-5. 데이터를 분할하고 복원하는 방법</h4><p>패킷 헤더를 보면 아래와 같은 필드로 데이터를 분할하고 복원한다.</p>
<ul>
<li>식별자: 같은 데이터인지 식별하기 위한 16비트 숫자 값</li>
<li>분할 플래그: 분할 허가 플래그와 이후에 남은 분할이 있는지 표시하기 위한 플래그</li>
<li>프래그먼트 옵션: 원래 데이터에서의 위치 값을 표현하는 13비트 숫자</li>
</ul>
<p>위 헤더 필드를 통해 데이터를 분할하고 복원하게 된다.</p>
<h4 id="4-2-6-IPv6"><a href="#4-2-6-IPv6" class="headerlink" title="4-2-6. IPv6"></a>4-2-6. IPv6</h4><p>IPv4 주소(32비트)의 고갈로 인해 등장(128비트)했는데 private IP 등등의 기술로 인해 IPv4에 산소호흡기를 달아놓은 상태이다.<br>헤더를 보면 버전, 패킷의 우선순위를 결정하는 트래픽 클래스, 데이터 부분의 길이를 담당하는 페이로드의 길이, TTL을 나타내는 홉 리미트, 송수신지 IP 어드레스 등등이 있다.  </p>
<h4 id="4-2-7-IPv6로-갈아타기"><a href="#4-2-7-IPv6로-갈아타기" class="headerlink" title="4-2-7. IPv6로 갈아타기"></a>4-2-7. IPv6로 갈아타기</h4><p>소프트웨어를 새로운 버전으로 마이그레이션 하거나 다른 소프트웨어로 마이그레이션 하는 것은 상당한 일이다.<br>IPv4와 IPv6의 패킷은 서로 호환이 되지 않기 때문에 송신지는 IPv6를 쓰는데 수신지는 IPv4를 쓰는 난감한 상황이 존재하기 마련이다.<br>이런 점을 방지하고자 하나의 장비에서 IPv4, IPv6 두 어드레스를 지원하는 듀얼스택(Dual Stack)이란 기술도 있고,<br>터널링(tunneling)이라는 기술을 통해 IPv6가 오면 IPv4로, IPv4가 오면 IPv6로 변환해주는 기술들이 존재한다.</p>
<h3 id="4-3-IP-어드레스의-활용"><a href="#4-3-IP-어드레스의-활용" class="headerlink" title="4-3. IP 어드레스의 활용"></a>4-3. IP 어드레스의 활용</h3><h4 id="4-3-1-네트워크-부와-호스트-부"><a href="#4-3-1-네트워크-부와-호스트-부" class="headerlink" title="4-3-1. 네트워크 부와 호스트 부"></a>4-3-1. 네트워크 부와 호스트 부</h4><p>IP 어드레스는 네트워크 부분과 호스트 부분으로 구성된다.<br>호스트는 네트워크에 구성된 장비(PC, 스마트폰 등등)을 의미한다.<br>라우터는 송신지 IP 어드레스의 네트워크 부분을 보고 자신과 같은 네트워크에 있는지 외부의 네트워크에 있는지 판단한다.  </p>
<p>네트워크 부분과 호스트 부분을 나눈 이유는 모든 호스트들을 하나의 네트워크로 묶어두면 관리하기 어렵다는 측면에서 나오게 되었다. </p>
<h4 id="4-3-2-어드레스-클래스"><a href="#4-3-2-어드레스-클래스" class="headerlink" title="4-3-2. 어드레스 클래스"></a>4-3-2. 어드레스 클래스</h4><p>하나의 IP 어드레스를 봤을 때 어디까지가 네트워크 부분이고 어디까지가 호스트 부분인지 알 수가 없다.<br>A, B, C, D 클래스에 따라서 네트워크 부분과 호스트 부분의 경계를 알 수 있는데<br>해당 IP를 보고 어떤 클래스에 속했는지는 32비트 중에 앞에 2비트만 보면 알 수 있다.<br>앞에 1비트가 0이면 A 클래스, 앞에 2비트가 10이면 B 클래스, 앞에 3비트가 110이면 C클래스가 된다.  </p>
<p>예를 들면 116.322.45.26을 32비트로 바꾸면 아래와 같다.<br>01110100 101000010 00101101 00011010<br>앞에 1비트가 0이므로 A 클래스에 속하는 IP 주소가 된다.</p>
<p>A 클래스의 IP 범위는 0.0.0.0 ~ 127.255.255.255가 되고,<br>B 클래스의 범위는 128.0.0.0 ~ 191.255.255.255가 되고,<br>C 클래스의 범위는 192.0.0.0 ~ 223.255.255.255가 되고,<br>D 클래스는 멀티 캐스트를 위해 사용되는데 224.0.0.0 ~ 239.255.255.255까지 사용되고, 특이하게 네트워크 부분으로 32비트 전체를 다 사용하고,<br>E 클래스는 240.0.0.0 ~ 255.255.255.255로 미래를 위해 만들어뒀다고 한다.  </p>
<p>A 클래스는 8비트까지가 네트워크 부분인데 앞에 1비트인 0은 고정이므로 실제는 7비트만 사용 가능하고 따라서 128개의 네트워크를 만들 수 있을 거 같은데 책에는 126개라고 나와있다.<br>또한 호스트는 24비트를 사용가능해서 약 1677만개의 호스트가 하나의 네트워크로 묶일 수 있다.<br>매우 대규모의 호스트를 수용할 수 있으므로 특수한 정부 기관 등등에서 쓰이지 않을까 싶다.  </p>
<p>B 클래스는 16비트까지가 네트워크 부분인데 앞에 2비트인 10은 고정이므로 실제는 14비트만 사용해서 약 만 6천 개의 네트워크를 구성할 수 있다.<br>그리고 호스트 부분은 16비트를 사용할 수 있어서 약 6만 5천대의 장비를 연결할 수 있다.<br>아마 대기업&#x2F;중견기업 정도에서 쓰지 않을까 싶다.  </p>
<p>C 클래스는 24비트까지가 네트워크 부분인데 앞에 3비트인 110은 고정이므로 실제는 21비트만 사용해서 약 209만 개의 네트워크를 만들 수 있다.<br>그리고 호스트 부분은 8비트만 사용해서 약 254개의 장비를 연결할 수 있다.<br>일반 가정집이나 중소 기업에 어울리는 네트워크 클래스인 것 같다.<br>8비트라 256개라고 생각할 수 있지만 호스트의 마지막 부분인 255는 브로드캐스팅을 위한 IP로 사용된다.<br>모든 호스트가 브로드캐스팅 IP를 리스닝 하고 있다고 생각하면 된다.<br>그리고 호스트의 첫 번째 부분인 0은 네트워크 주소로써 해당 호스트에 속한 모든 IP를 관리하기 위한 IP이다.<br>따라서 8비트(0~255) 중에 0과 255는 특수한 목적으로 쓰이기 때문에 호스트는 총 254개만 사용 가능한 것이다.</p>
<img src="/2018/04/01/tcp-ip-book-index-4/vpc.png" class title="AWS의 서비스 중 하나인 VPC">  
<p>VPC는 가상의 네트워크라고 보면 된다.<br>IP 주소 범위를 보면 10.2.0.0으로 0.0.0.0 ~ 127.255.255.255에 속하니까 A 클래스 IP 주소이다.  </p>
<h4 id="4-3-3-어드레스-클래스의-제약"><a href="#4-3-3-어드레스-클래스의-제약" class="headerlink" title="4-3-3. 어드레스 클래스의 제약"></a>4-3-3. 어드레스 클래스의 제약</h4><p>클래스 A 같은 경우에 1677만대가 연결된 완전 초대규모 네트워크라고 볼 수 있다.<br>하지만 실제로 하나의 네트워크에서 1677만대의 호스트를 전부 연결하는 곳은 거의 없기 때문에<br>많은 IP 어드레스가 사용되지 않고 낭비된다는 단점이 존재한다.<br>당장 내가 위에 만든 VPC만 봐도 A 클래스인데 과연 1677만대의 호스트를 등록할 일이 있을까?<br>또한 126개의 네트워크보다 더 많은 네트워크를 구성하고 싶을 수도 있을 때는 어떻게 해야할까?</p>
<h4 id="4-3-4-서브넷-마스크-Subnet-Mask"><a href="#4-3-4-서브넷-마스크-Subnet-Mask" class="headerlink" title="4-3-4. 서브넷 마스크(Subnet Mask)"></a>4-3-4. 서브넷 마스크(Subnet Mask)</h4><p>A클래스의 IP이지만 최대 2만대의 호스트만 수용할 예정이라면 15비트(약 3만대의 호스트 수용 가능)만 호스트 부분으로 사용하고,<br>32비트에서 15비트를 뺀 17비트를 네트워크 부분으로 사용하면 어드레스의 낭비를 훨씬 줄일 수 있다.<br>A 클래스의 IP이지만 A 클래스보다 훨씬 적은 호스트를 수용할 예정이고, A 클래스 보다 많은 개의 네트워크를 구성해야한다면 서브넷 마스크를 사용하면 된다.</p>
<p>위의 경우에는 앞에 IP 주소 17비트만 맞으면 동일한 네트워크라고 인식을 시켜야한다.<br>주어진 IP 주소와 서브넷 마스크를 논리 비트 연산자인 &amp;로 AND 연산을 수행했을 때 참이 나오게 해야한다.<br>따라서 17비트에 대한 서브넷 마스크는<br>11111111 11111111 10000000 00000000<br>앞에 17비트를 1로 설정하면 되고, 10진수로 표현하면 255.255.128.0이 된다.<br>그리고 CIDR 블록이란 걸 적용시켜서 표현해보자면 10.2.0.0&#x2F;17이 된다.<br>위 스크린샷에서는 10.2.0.0&#x2F;16이므로 사실상 A 클래스의 IP 주소를 B 클래스의 IP 주소와 같이 분할을 시킨 것이다.  </p>
<p>위 공식을 적용시켜 보자면 A 클래스는 네트워크 부분이 8비트이므로 기본 서브넷마스크는 255.0.0.0이 되고 CIDR 블록으로 0.0.0.0&#x2F;8 과 같은 형태로 표시된다.<br>B 클래스는 네트워크 부분이 16비트이므로 기본 서브넷 마스크는 255.255.0.0이 되고 CIDR 블록으로 적용시켜 보면 128.0.0.0&#x2F;16과 같은 형태가 된다.<br>C 클래스는 네트워크 부분이 24비트이므로 기본 서브넷 마스크는 255.255.255.0이 되고 CIDR 블록으로 적용시켜 보면 192.0.0.0&#x2F;24와 같은 형태가 된다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/subnet-mask-windows.gif" class title="윈도우의 CMD에서 ipconfig를 쳐보면 익숙한 서브넷 마스크가 보인다.">
<img src="/2018/04/01/tcp-ip-book-index-4/subnet-mask-mac.png" class title="맥에서는 환경설정 - 네트워크 - 본인이 연결한 이더넷 - Advanced를 누르고 TCP&#x2F;IP 탭으로 오면 서브넷 마스크를 볼 수 있다.">  

<p>기본적으로 가정집에서는 C 클래스의 IP를 사용하고 서브넷 마스크를 기본적으로 설정하지 않으면 디폴트 서브넷 마스크인 255.255.255.0이 적용된다.  </p>
<h4 id="4-3-5-IP-어드레스의-할당-방법"><a href="#4-3-5-IP-어드레스의-할당-방법" class="headerlink" title="4-3-5. IP 어드레스의 할당 방법"></a>4-3-5. IP 어드레스의 할당 방법</h4><p>IP 어드레스는 네트워크 상에서 호스트(컴퓨터, 라우터, 스마트폰 등등)을 식별하기 위해 사용되는데,<br>전체 32비트 중 네트워크 부를 제외한 호스트 부분만 자유롭게 할당할 수 있다.  </p>
<p>이 때 호스트 부분이 모두 0인 건 네트워크 주소로 사용되고, 모두 1인 건 브로드캐스트 주소로 사용된다.  </p>
<h4 id="4-3-6-서브넷-마스크로-네트워크-세분화하기"><a href="#4-3-6-서브넷-마스크로-네트워크-세분화하기" class="headerlink" title="4-3-6. 서브넷 마스크로 네트워크 세분화하기"></a>4-3-6. 서브넷 마스크로 네트워크 세분화하기</h4><img src="/2018/04/01/tcp-ip-book-index-4/vpc.png" class title="AWS의 서비스 중 하나인 VPC">  
<p>다시 한번 AWS의 VPC를 보자.<br>원래는 A클래스인 걸 네트워크 부분을 16비트로 바꿔서 B클래스로 바꿨으니 이것도 네트워크를 세분화 했다고 할 수 있다.<br>이런 걸 서브넷(Sub Network)라고 부른다.<br>하지만 여기서 끝이 아니다, B클래스를 다시 C클래스나 다른 서브넷 마스크를 사용해서 서브넷 안에 서브넷을 또 만들 수 있다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/subnet.png" class title="AWS에서는 VPC를 다시 서브넷으로 나눌 수 있다.">  
<p>기존에 10.0.2.0&#x2F;16이었던 네트워크를 다시 CIDR Block을 10.2.0.0&#x2F;24로 나누었다.<br>서브넷 마스크는 255.255.255.0이 됐고, 네트워크 부분이 24비트이므로 C클래스 IP 주소로 네트워크를 쪼갰다.</p>
<p>이렇게 서브넷 마스크를 통해 서브넷을 만드는 행위를 서브넷팅(Subnetting)이라고 부른다.  </p>
<p>하지만 이렇게 클래스가 큰 규모에서 더 많은 네트워크를 사용하기 위해, 적은 규모의 호스트를 수용하기 위해 서브넷팅하는 건 매우 효율적이다.<br>하지만 C 클래스의 IP 주소는 애초에 254개의 호스트만 수용 가능하고, 호스트 부분을 1비트씩 줄일 수만 있고 늘릴 수는 없으므로<br>그의 절반인 126개, 62개, 30개, 14개, 6개, 2개, 0개 이렇게 줄어들다보니<br>애초부터 수용가능한 호스트의 갯수가 적은 환경에서는 서브넷팅이 크게 효율적이진 않다.  </p>
<h4 id="4-3-7-가정이나-사무실에서-자유롭게-사용하는-프라이빗-IP-어드레스"><a href="#4-3-7-가정이나-사무실에서-자유롭게-사용하는-프라이빗-IP-어드레스" class="headerlink" title="4-3-7. 가정이나 사무실에서 자유롭게 사용하는 프라이빗 IP 어드레스"></a>4-3-7. 가정이나 사무실에서 자유롭게 사용하는 프라이빗 IP 어드레스</h4><p>프라이빗 어드레스는 같은 네트워크 내에서 충돌만 일어나지 않으면 자유롭게 사용할 수 있는 IP 주소다.<br>옆집 철수의 private ip가 192.168.1.7이고, 나도 private ip가 192.168.1.7인데 통신이 잘 되는 이유는<br>둘은 서로 다른 네트워크 상에 존재하기 때문이다.<br>즉, 다른 공유기에 연결됐기 때문이라고 생각하면 된다.  </p>
<p>A 클래스의 프라이빗 IP 어드레스 범위는 10.0.0.0 ~ 10.255.255.255이고,<br>B 클래스의 프라이빗 IP 어드레스 범위는 172.0.0.0 ~ 172.255.255.255이고,<br>C 클래스의 프라이빗 IP 어드레스 범위는 192.168.0.0 ~ 192.168.255.255이다.<br>이 외의 주소들은 전부 퍼블릭 IP이다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/vpc2.png" class title="AWS는 돈이 많아서인지 A 클래스의 프라이빗 어드레스와 B 클래스의 프라이빗 어드레스를 모두 소유하고 있다.">  
<img src="/2018/04/01/tcp-ip-book-index-4/private-ip.png" class title="우리집에서 private ip 주소를 보니 내 프라이빗 IP는 C 클래스의 IP이다.">  


<p><a href="#4-3-5-IP-%EC%96%B4%EB%93%9C%EB%A0%88%EC%8A%A4%EC%9D%98-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EB%B2%95">IP 어드레스의 할당 방법</a>을 통해 봤듯이 private ip도 마찬가지로 호스트 부분 내에서 할당 받는다.<br>이 때 DHCP란 프로토콜을 통해 브로드캐스트 트래픽으로 사용중인 IP 목록들을 파악해서 사용 가능한 ip를 새로운 호스트에게 할당하는 방식으로 진행되는 것 같다.  </p>
<h4 id="4-3-8-퍼블릭-IP-어드레스의-관리"><a href="#4-3-8-퍼블릭-IP-어드레스의-관리" class="headerlink" title="4-3-8. 퍼블릭 IP 어드레스의 관리"></a>4-3-8. 퍼블릭 IP 어드레스의 관리</h4><p>위에 적어놓은 프라이빗 ip는 같은 네트워크 내에서 통신하기 위한 주소이고, 외부 네트워크와 통신하기 위해서는 퍼블릭 IP가 필요하다.<br>따라서 퍼블릭 IP는 어떠한 경우에도 중복이 일어나면 정상적인 통신이 이루어지지 않는다.<br>따라서 별도의 기관에서 퍼블릭 IP 주소 할당에 대해 관리를 하고, ISP(올레나 SK 브로드밴드 등등)에서 그런 기관으로부터 미리 IP 주소를 대량으로 임대를 하고<br>인터넷 가입자들에게 제공해주는 것이다.  </p>
<p>그리고 브로드캐스트 주소, 네트워크 주소와 별개로<br>예약된 IP 주소가 하나 있는데 바로 자기 자신을 가리키는 127.0.0.1이라는 주소이다.<br>자기 자신을 가리키는 주소이기 때문에 루프백 주소라고 부르기도 한다.</p>
<h3 id="4-4-라우팅이란"><a href="#4-4-라우팅이란" class="headerlink" title="4-4. 라우팅이란?"></a>4-4. 라우팅이란?</h3><p>데이터를 목적지의 IP 주소까지 전달하는 경로를 탐색하는 과정을 라우팅이라고 부른다.  </p>
<h4 id="4-4-1-라우팅과-경로-탐색"><a href="#4-4-1-라우팅과-경로-탐색" class="headerlink" title="4-4-1. 라우팅과 경로 탐색"></a>4-4-1. 라우팅과 경로 탐색</h4><p>라우팅을 통해 찾은 최적의 경로로 데이터를 전달하는데 만약 중간에 다음 라우터에 장애가 발생했으면 다른 라우터로 우회해서 데이터를 전달한다.</p>
<h4 id="4-4-2-라우팅-프로토콜"><a href="#4-4-2-라우팅-프로토콜" class="headerlink" title="4-4-2. 라우팅 프로토콜"></a>4-4-2. 라우팅 프로토콜</h4><p>데이터가 전송될 경로를 찾기 위해 네트워크 상의 각 라우터는 서로 어떤 라우터와 어떤 라우터가 연결돼있는지 정보를 교환한다.<br>이 때 라우팅 프로토콜이 사용되는데 대표적으로 BGP, OSPF, RIP 등이 있다고 한다.  </p>
<h4 id="4-4-3-자율-시스템"><a href="#4-4-3-자율-시스템" class="headerlink" title="4-4-3. 자율 시스템"></a>4-4-3. 자율 시스템</h4><p>ISP 같이 규모가 큰 네트워크에서는 몇 개의 네트워크를 하로 묶어 AS(Autonomous System, 자율 시스템)이라는 단위로 관리를 한다.<br>네트워크 경로를 하나하나 찾는 것보다 AS 같은 큰 덩어리로 라우팅 하면 멀리있는 컴퓨터와도 더 빠른 속도로 통신할 수 있게 된다.</p>
<h3 id="4-5-라우터와-라우팅-프로토콜"><a href="#4-5-라우터와-라우팅-프로토콜" class="headerlink" title="4-5. 라우터와 라우팅 프로토콜"></a>4-5. 라우터와 라우팅 프로토콜</h3><h4 id="4-5-1-라우터의-역할"><a href="#4-5-1-라우터의-역할" class="headerlink" title="4-5-1. 라우터의 역할"></a>4-5-1. 라우터의 역할</h4><p>라우터는 네트워크 간의 패킷을 전달하는 역할을 한다.<br>이 때 라우터는 자신이 가고자하는 목적지의 IP 주소로 가기위해 라우터의 정보를 파악해서 최적의 경로를 구성하게 되는데<br>라우터는 자기 자신이 가야할 바로 다음 라우터의 주소만 알고 있으면 된다.<br>그 이전의 라우터의 경로도 몰라도 되고, 다다음 라우터의 경로를 몰라도 된다.<br>단지 바로 자기가 바로 당장 가야할 경로 그 하나만 알면 그 다음 책임은 그 다음 라우터에게 전가한다.<br>마치 자기 다음 데이터에 대한 참조값만 알고 있는 자료구조인 링크드 리스트와 매우 유사한 느낌이 든다.<br>그런 관점에서 링크드리스트의 노드를 라우터에 빗대어 생각해보면 도움이 많이 될 것이다.  </p>
<p>그럼 일반적인 인터넷 공유기를 사용하는 가정집에서 네이버로 요청을 보내는 시나리오를 상상해보자.  </p>
<ol>
<li>우선 네트워크 내부에 호스트는 프라이빗 ip를 쓰니 192.1.0.3이 프라이빗 IP라고 가정해보자.  </li>
<li>192.1.0.3 호스트에서는 자기와 제일 인접한 라우터인 인터넷 공유기로 패킷을 보낸다.  </li>
<li>호스트와 공유기는 같은 네트워크에 속하므로 프라이빗 ip로 통신하고, 대부분 공유기(라우터)의 ip는 호스트 부분이 1인 경우가 많으니 192.168.0.1로 데이터를 보낸다.  </li>
<li>공유기는 프라이빗 ip와 동시에 퍼블릭 ip도 가지고 있는데 그건 isp로부터 임대받은 ip이다.  </li>
<li>프라이빗 IP를 퍼블릭 ip로 세탁(전문적으로는 NAT, Network Address Translation, 네트워크의 주소를 변환하는 걸 말한다.)해서 ISP에서 준 모뎀으로 패킷을 보낸다.  </li>
<li>모뎀에서는 다시 ISP 쪽으로 라우팅을 하면 지지고 볶고 알아서 네이버로 패킷을 전달해서 네이버는 안전하게 데이터를 전달받을 것이다.</li>
</ol>
<p>5번 과정을 보면 공유기에서 private ip를 public ip로 nat 시켰는데 이는 외부에서는 private ip를 알지 못하기 때문에 응답을 받기 위해선 public ip로 요청을 해야한다.<br>그러면 공유기에 연결된 모든 private ip가 같은 public ip로 바인딩되서 나가나 생각할 수 있는데 별도의 설정이 없다면 내가 아는 한도 내에서는 그렇다.  </p>
<h4 id="4-5-2-라우팅-테이블"><a href="#4-5-2-라우팅-테이블" class="headerlink" title="4-5-2. 라우팅 테이블"></a>4-5-2. 라우팅 테이블</h4><p>라우터는 라우팅을 위해서 목적지 ip 주소와 목적지로 가기 위한 바로 다음 라우터 주소를 저장한 라우팅 테이블을 들고 있다.</p>
<img src="/2018/04/01/tcp-ip-book-index-4/routing-table.png" class title="AWS에서 라우팅 테이블은 특정 VPC에 종속적이다.">  
<p>같은 VPC(네트워크) 내부인 10.2.0.0&#x2F;16에서는 private ip로 통신을 한다는 얘기이고,<br>그 이외의 ip인 0.0.0.0&#x2F;0(모든 트래픽)에서는 인터넷 게이트웨이라는 문지기에게 패킷을 보내는데 얘가 라우터 역할까지 수행한다고 보면 된다.<br>여담으로 aws에서 라우팅 테이블은 특정 서브넷에 적용시킬 수 있다.</p>
<h4 id="4-5-3-정적-라우팅과-동적-라우팅"><a href="#4-5-3-정적-라우팅과-동적-라우팅" class="headerlink" title="4-5-3. 정적 라우팅과 동적 라우팅"></a>4-5-3. 정적 라우팅과 동적 라우팅</h4><p>라우팅 테이블을 만드는 방법에는 크게 두 가지가 있는데 관리자가 수동으로 라우팅 테이블을 만드는 정적 라우팅과<br>라우팅 프로토콜을 사용해서 자동으로 경로 정보를 수집해서 라우팅 테이블을 설정하는 게 동적 라우팅이다.<br>aws의 라우팅 테이블 같은 경우에는 개발자가 직접 세팅하므로 정적 라우팅에 속한다.<br>대부분의 네트워크는 경로가 매우 복잡하므로 동적 라우팅을 사용한다.  </p>
<h4 id="4-5-4-라우팅-테이블에-목적지-정보가-없을-경우"><a href="#4-5-4-라우팅-테이블에-목적지-정보가-없을-경우" class="headerlink" title="4-5-4. 라우팅 테이블에 목적지 정보가 없을 경우"></a>4-5-4. 라우팅 테이블에 목적지 정보가 없을 경우</h4><p>인터넷에는 수많은 네트워크가 연결돼있기 때문에 모든 네트워크의 통신 경로를 저장하는 건 사실상 불가능하다.<br>그래서 한 라우터에 목적지에 대한 정보가 없다면 디폴트 라우터를 사용하는데 디폴트 라우터는 0.0.0.0&#x2F;0으로 세팅돼있다.<br>디폴트 라우터도 설정돼있지 않고, 목적지에 대한 경로도 설정돼있지 않다면 아마 패킷을 제대로 전달하지 못하고 패킷은 혼자 사망할 것이다.  </p>
<h4 id="4-5-5-동적-라우팅-알고리즘"><a href="#4-5-5-동적-라우팅-알고리즘" class="headerlink" title="4-5-5. 동적 라우팅 알고리즘"></a>4-5-5. 동적 라우팅 알고리즘</h4><ul>
<li>거리 벡터형(RIP, Routing Information Protocol이 사용함.)<br>목적지까지의 거리를 살펴보는데 이 거리는 지리상 거리가 아니라 라우터를 몇 개 거치느냐를 뜻하며<br>라우터 하나를 거치는 단위를 1 홉(Hop)이라고 부른다.<br>가장 홉이 낮은 경로로 라우팅 테이블을 설계한다.  </li>
<li>링그 상태형(OSPF, Open Shortest Path First 프로토콜이 사용함.)<br>단순히 거리만 보고 판단하는 게 아니라 어떤 네트워크가 고속이며 덜 혼잡한지까지 파악해서<br>홉은 좀 높더라도 좀 더 빨리 전달할 수 있는 경로로 라우팅 테이블을 설계한다.</li>
</ul>
<h3 id="4-6-네트워크-오류를-통보하는-ICMP"><a href="#4-6-네트워크-오류를-통보하는-ICMP" class="headerlink" title="4-6. 네트워크 오류를 통보하는 ICMP"></a>4-6. 네트워크 오류를 통보하는 ICMP</h3><p>ICMP(Internet Control Message Protocol)은 주로 데이터 전송 중에 문제가 생길 경우,<br>장애 상황을 통보해야할 때 사용한다.<br>데이터가 제대로 동작하지 않았으면 3번 타입을 보내고,<br>네트워크에 새로 연결된 장비가 라우터(공유기)를 찾기 위해 10번 타입으로 브로드캐스팅하고,<br>그 요청을 받은 라우터는 새로운 호스트에게 9번 타입으로 자신의 정보를 알려준다.<br>ICMP 헤더는 IP 헤더 + 타입 + 코드 + 체크섬으로 구성된다.  </p>
<h3 id="4-7-어드레스-변환"><a href="#4-7-어드레스-변환" class="headerlink" title="4-7. 어드레스 변환"></a>4-7. 어드레스 변환</h3><h4 id="4-7-1-네트워크-어드레스-변환-NAT-의-동작-방식"><a href="#4-7-1-네트워크-어드레스-변환-NAT-의-동작-방식" class="headerlink" title="4-7-1. 네트워크 어드레스 변환(NAT)의 동작 방식"></a>4-7-1. 네트워크 어드레스 변환(NAT)의 동작 방식</h4><p>내부 네트워크의 호스트가 외부의 네트워크가 통신을 하려면 퍼블릭 ip가 필요하므로 라우터(공유기)에서 퍼블릭 ip로 변환하고 그걸 통해 외부와 통신을 하게 된다.<br>하지만 외부에서 봤을 때는 여러 호스트들을 하나의 퍼블릭 ip로 퉁쳐서 내보내기 때문에 정확히 어떤 호스트에게 응답을 해줘야하는지 모르게 된다.<br>이런 상황을 방지하고자 라우터는 NAT 하기 전에 프라이빗 ip를 기억해두고 있다가 응답을 받으면 그 프라이빗 ip로 다시 요청을 전송하는 역할을 한다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/nat-gateway.png" class title="AWS에서도 NAT를 지원해준다.">  
<p>AWS에서 NAT를 쓰는 이유는 주로 두 가지이다.  </p>
<ol>
<li>퍼블릭 IP가 없이 프라이빗 IP만 존재하는 서브넷(프라이빗 서브넷, 외부에서 접근 불가능)에서 외부와 통신을 해야할 일이 있을 때<br>퍼블릭 IP가 존재해야 외부의 응답을 받을 수 있으므로 외부에 요청을 보내고 응답을 받기 위해 NAT Gateway를 사용한다.  </li>
<li>외부로 나가는 IP(Outgoing IP)를 하나로 통제하고자 할 때 사용한다.<br>외부 연동사에 IP 등록 요청을 해야하는데 네트워크 내의 모든 서버의 IP를 등록해달라고 하기 거시기 하기 때문에 outgoing ip를 하나로 통제할 때 쓰곤 한다.<br>물론 상황에 따라 네트워크가 속한 지역이나 가용영역 등등에 따라 하나로 통일을 못 하기도 하기는 한다.</li>
</ol>
<h4 id="4-7-2-NAT에서-발생할-수-있는-제약-사항"><a href="#4-7-2-NAT에서-발생할-수-있는-제약-사항" class="headerlink" title="4-7-2. NAT에서 발생할 수 있는 제약 사항"></a>4-7-2. NAT에서 발생할 수 있는 제약 사항</h4><p>서버에서 요청에 대한 응답을 처리해줄 수 있는 것은 라우터에서 어떤 프라이빗 아이피가 퍼블릭 아이피로 매핑됐는지 정보를 기억하고 있기 때문이다.<br>하지만 역으로 서버 쪽에서 클라이언트 쪽을 찌를 때 라우터는 퍼블릭 IP만을 가지고는 프라이빗 ip를 찾을 수 없어서 통신이 불가능한 상황이 발생한다.  </p>
<h4 id="4-7-3-네트워크-어드레스-포트-변환"><a href="#4-7-3-네트워크-어드레스-포트-변환" class="headerlink" title="4-7-3. 네트워크 어드레스 포트 변환"></a>4-7-3. 네트워크 어드레스 포트 변환</h4><p>공교롭게도 같은 네트워크 상의 호스트가 동일한 목적지로 요청을 보내는데 둘의 포트가 같아버리면<br>private ip -&gt; public ip 과정에서 포트 충돌이 일어난다.<br>이러한 상황을 대비해서 NAPT(Network Address Port Translation), 즉 포트까지 같이 변환해야한다.<br>만약에 포트가 충돌나면 라우터는 포트까지 같이 변환하고 원래 포트를 기억하고 있다가 서버에 대한 응답을 올바르게 전달해준다.  </p>
<h4 id="4-7-4-외부에서-접속이-가능하게-하기"><a href="#4-7-4-외부에서-접속이-가능하게-하기" class="headerlink" title="4-7-4. 외부에서 접속이 가능하게 하기."></a>4-7-4. 외부에서 접속이 가능하게 하기.</h4><h5 id="4-7-4-1-메시지의-자동-확인"><a href="#4-7-4-1-메시지의-자동-확인" class="headerlink" title="4-7-4-1. 메시지의 자동 확인"></a>4-7-4-1. 메시지의 자동 확인</h5><p>SNS 같은 경우에 보면 알림이 있으면 클라이언트 쪽으로 push notification을 준다.<br>이는 서버가 클라이언트한테 바로 notification을 주는 게 아니라 내부적으로 클라이언트가 서버를 계속해서 호출해서 가능한 것이다.<br>아니면 소켓을 하나 뚫어놓고(연결을 맺어놓고 끊지 않고), 알림을 줘야할 내용이 있을 때마다 알림을 주는 경우도 있다.  </p>
<h5 id="4-7-4-2-포트포워딩"><a href="#4-7-4-2-포트포워딩" class="headerlink" title="4-7-4-2. 포트포워딩"></a>4-7-4-2. 포트포워딩</h5><p>포워딩이 가지는 느낌을 정확하게 모르겠는데 내가 가지고 있는 느낌을 어느 방향으로 향하게 하는 걸 포워딩이라고 부르는 것 같다.<br>포트포워딩은 특정 포트를 어떤 포트 쪽으로 향하게 하는 그런 느낌이라고 이해하면 될 것 같다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-windows.jpg" class title="윈도우에서는 CMD에서 ipconfig를 치면 본인이 연결한 이더넷에 default gateway의 주소가 라우터(공유기)의 IP 주소이다.">
<img src="/2018/04/01/tcp-ip-book-index-4/router-mac.png" class title="맥에서는 환경설정 - 네트워크 - 본인이 연결한 이더넷 - Advanced를 누르고 TCP&#x2F;IP 탭으로 오면 라우터(공유기)의 IP 주소를 볼 수 있다.">
<p>라우터(공유기)의 IP 주소를 입력해서 접속하자.<br>간혹가다가 무선 인터넷을 통해서는 보안 때문인지 아예 접속조차 안 되고, 유선랜의 경우에만 접근을 허락하는 공유기들도 존재한다.<br>공유기의 기본 ID&#x2F;PW는 메뉴얼이나 공유기 아랫 부분이나 어디 스티커로 붙어있거나 공유기 제조 홈페이지를 참고하며 된다.  </p>
<p>그리고 또 메뉴얼을 참고해서 포트포워딩 메뉴로 오면 되는데 대부분 일반 유저들은 쓰지 않는 메뉴기 때문에 고급 쪽에 붙어있는 경우가 많다.  </p>
<p>포트 포워딩을 보기 전에 몇가지 재밌는 메뉴들을 살펴보자.(공유기에 따라 정보를 노출하지 않거나 제공하지 않는 기능일 수도 있으니 그냥 재미로만 보자.)  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/subnet-mask-router.png" class title="라우터에서 본 서브넷 마스크">  
<p>직접 라우터의 IP 주소와 네트워크의 서브넷 마스크도 조절이 가능한 것 같은데 뭔가 무서워서 함부로 건들지 못하겠다 ㅋㅋ<br>또한 이더넷 카드의 Physical Address인 Mac Address도 있다.</p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-other-info.png" class title="라우터에서 볼 수 있는 다양한 정보들">  
<p>IP 주소는 ISP로부터 할당받은 Public IP를 뜻하고,<br>기본 게이트웨이는 모뎀(이자 라우터 역할도 함)의 퍼블릭 IP를 말하는 것 같다.<br>기본&#x2F;보조 DNS는 URL 창에 IP &lt;-&gt; Domain을 하기 위해 도메인들이 각각 저장된 도메인 네임 서버를 의미하는 것 같다.<br>그리고 고정 IP는 기본적으로 돈이 들기 때문에 IP 주소 변경에 민감한 웹서버에서 주로 사용한다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-dhcp.png" class title="라우터에서 IP 할당에 관여하는 DHCP 설정도 볼 수 있다.">  
<p>IP 주소 대역을 보아하니 호스트는 100~199까지 총 100대만 연결이 가능한 네트워크인 모양이다.<br>또한 임대 시간이 나와있는데 해당 시간을 초과한다고 해서 무조건적으로 IP 주소가 바뀌는 건 아닐 것이다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-mtu.png" class title="라우터에서 인터넷 계층에 쓰이는 세그먼트의 사이즈인 MTU도 설정할 수 있다.">  
<p>웬만하면 기본값인 1500바이트를 건들 일은 없어 보인다.</p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-routing-table.png" class title="정적으로 라우팅 테이블 설계도 가능하다.">
<p>근거리 통신(LAN)에는 192.168.0.0&#x2F;24인 네트워크를 통해 통신이 되고,<br>WAN의 경우에는 xxx.149.166.0&#x2F;25인 네트워크를 타고 통신이 된다.<br>그 외의 경우에는 디폴트 라우팅 테이블에 있는 모뎀(라우터)의 IP 어드레스를 타고 나가게 된다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-port-forwarding.png" class title="공유기 제조사마다 다른데 대부분은 포트포워딩 이라고 표현하고 있다.">  
<p>만약 배틀넷 서버가 클라이언트(192.168.0.181)에게 8123 포트로 요청을 보낸다고 하면<br>위와 같이 등록을 해두면 된다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/router-port-forwarding2.png" class title="웹 서비스를 포트포워딩 하는 경우">  
<p>만약에 클라이언트(192.168.0.181)에서 웹서버를 8080 포트로 열었다고 할 때<br>위와 같이 설정해놓으면 외부에서는 퍼블릭 ip만 입력하면 바로 내가 연 웹서버로 들어올 수 있다. (대표 포트는 생략 가능하기 때문)  </p>
<p>하지만 이런 포트포워딩에도 단점이 존재하는데 포트의 충돌이 일어나기 때문에 하나의 포트는 하나의 호스트 밖에 사용하지 못한다.</p>
<h3 id="4-8-도메인명"><a href="#4-8-도메인명" class="headerlink" title="4-8. 도메인명"></a>4-8. 도메인명</h3><p>IP는 숫자로 구성돼있어서 인간 친화적이지 않으므로, 사람이 알아보기 편한 영단어들과 일부 기호들의 집합으로 이루어진 걸 도메인명이라고 한다.  </p>
<h4 id="4-8-1-호스트명과-도메인명"><a href="#4-8-1-호스트명과-도메인명" class="headerlink" title="4-8-1. 호스트명과 도메인명"></a>4-8-1. 호스트명과 도메인명</h4><p>서로 다른 컴퓨터를 구분하는 식별자로 IP 어드레스와 호스트명이 있는데, 이걸 관리하기 위해 DNS(Domain Name System)이 등장했다.  </p>
<p>우선 도메인을 보기 전에 URL이 어떻게 생겨먹었는지 보자.<br><code>scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]</code><br>scheme는 프로토콜이라고 보면 된다.<br>그리고 나는 프로토콜 뒤에 무조건 :&#x2F;&#x2F;이 붙는 줄 알았는데 mailto 프로토콜의 경우에는 <code>mailto:someone@example.com</code>와 같이 &#x2F;&#x2F;이 붙지 않는 프로토콜도 존재한다.<br>그리고 (s)ftp의 경우에는 <code>ftp://testid:testpass@file.example.com</code>처럼 인증에 필요한 user:password 정보가 URL에 포함돼있는 경우도 존재한다.<br>ssh 프로토콜을 보면 대부분 터미널을 통해서 ssh 라는 명령어를 통해서 접속을 시작하지만 엄연히 URL을 가진다.<br><code>ssh://ec2-user@52.178.112.131</code>과 같은 형태로 접속이 가능하다.<br>위 URL을 보면 user@host의 형태도 보인다.<br>일반적인 웹의 경우에는 user, password, @가 빠진 <code>https://js.org/</code>와 같이 scheme:&#x2F;&#x2F;host&#x2F;만으로도 URL을 표현할 수도 있다.<br><code>http://121.1.33.57:8080/board?no=1#notice</code>와 같이 host 부분은 IP 주소가 돼도 되고, 해당 서비스를 대표하는 대표 포트가 아닐 경우에는 포트번호 생략이 불가능해진다.<br>포트 뒤에 board라는 path가 나왔고, 그 뒤에 ?no&#x3D;1이라는 쿼리 스트링도 붙었다.<br>그리고 #notice라는 fragment를 통해 현재 해당 리소스의 어느 부분?부터 리소스가 보이게 끔 하기도 한다.</p>
<h4 id="4-8-2-DNS-서버에-질의하기"><a href="#4-8-2-DNS-서버에-질의하기" class="headerlink" title="4-8-2. DNS 서버에 질의하기"></a>4-8-2. DNS 서버에 질의하기</h4><p>도메인명에 대응하는 IP 정보가 알고 싶다면 DNS 서버에게 물어보면 된다.<br>위에 라우터(공유기) 설정 스샷에서도 봤듯이 DNS 서버가 컴퓨터 혹은 라우터에 등록이 돼있어야한다.</p>
<h4 id="4-8-3-도메인의-계층-구조"><a href="#4-8-3-도메인의-계층-구조" class="headerlink" title="4-8-3. 도메인의 계층 구조"></a>4-8-3. 도메인의 계층 구조</h4><p>도메인 명은 아래와 같은 계층 구조를 가지고 있다.  </p>
<ol>
<li>루트  </li>
<li>탑 레벨 도메인(TLD, 1차 도메인) - com, org, kr, uk  </li>
<li>2단계 도메인(ANS, Authoritative Name Server,  2차 도메인) - co, go, ac, seoul, busan</li>
<li>3단계 도메인(3차 도메인)</li>
</ol>
<p>위 구조는 예시일 뿐, 실제로는 더 복잡한 계층일 수도 있다.</p>
<h4 id="4-8-4-DNS-서버의-계층-구조"><a href="#4-8-4-DNS-서버의-계층-구조" class="headerlink" title="4-8-4. DNS 서버의 계층 구조"></a>4-8-4. DNS 서버의 계층 구조</h4><p>도메인이 계층 구조를 가지듯이 DNS 서버도 계층적인 구조를 가지고 있다.  </p>
<ol>
<li>루트 네임 서버  </li>
<li>kr, uk 도메인을 관리하는 DNS 서버  </li>
<li>ISP 등에서 관리하는 DNS 서버</li>
</ol>
<p>위 구조는 예시일 뿐, 실제로는 더 복잡한 계층일 수도 있다.  </p>
<p>도메인명 데이터를 직접 관리하는 서버를 DNS 콘텐츠 서버라고 부른다.  </p>
<h4 id="4-8-5-DNS-서버에-질의-처리하는-과정"><a href="#4-8-5-DNS-서버에-질의-처리하는-과정" class="headerlink" title="4-8-5. DNS 서버에 질의 처리하는 과정"></a>4-8-5. DNS 서버에 질의 처리하는 과정</h4><ol>
<li>우선 클라이언트는 DNS 캐시 서버에게 도메인을 던진다.  </li>
<li>DNS 캐시 서버는 자신에게 해당 도메인에 대한 IP가 등록돼있는지 확인한다.  </li>
<li>있으면 바로 IP 주소를 리턴하고, 없으면 루트 네임 서버에 도메인을 던진다.  </li>
<li>루트 네임 서버는 본인이 해당 도메인에 대한 IP가 등록돼있는지 확인한다.  </li>
<li>있으면 IP 주소를 리턴하고, 없으면 해당 정보를 가지고 있는 탑 레벨 도메인 서버의 주소를 던진다.  </li>
<li>DNS 캐시 서버는 다시 탑 레벨 도에민 서버에게 도메인을 던진다.  </li>
<li>있으면 IP 주소를 리턴하고, 없으면 해당 정보를 가지고 있는 다른 DNS 서버의 주소를 던진다.  </li>
<li>DNS 캐시 서버는 다시 응답받은 DNS 서버의 주소로 도메인을 던진다.  </li>
<li>DNS 서버는 자기가 해당 도메인에 대한 IP를 들고 있다면 IP를 리턴하고 없으면 또 다른 DNS 주소를 응답한다.  </li>
<li>DNS 캐시 서버는 도메인에 대한 IP 주소를 받아서 클라이언트에게 응답한다.</li>
</ol>
<p>아래 링크와 동영상도 참고하자.  </p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=2ZUxoi7YNgs">How the DNS works</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=72snZctFFtA">DNS Explained</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://webdir.tistory.com/161">DNS서버(네임서버)의 이해</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://bcho.tistory.com/tag/NS%20%EB%A0%88%EC%BD%94%EB%93%9C">Amazon Route 53 DNS 서비스</a></li>
</ul>
<p>그리고 DNS에서 생략되는 게 하나 있는데 바로 루트를 의미하는 . 이다.<br><a target="_blank" rel="external nofollow noopener noreferrer" href="http://d2.naver.com./helloworld/238638">http://d2.naver.com./helloworld/238638</a> 으로 접속하면 com.뒤에 뭔가 올 거 같은데 입력하지 않고 바로 저렇게 입력해도 잘 접속이 된다.<br>바로 루트를 의미하는 .은 있어도 되고, 없으면 자동으로 내부적으로 붙여주기 때문이다.</p>
<p>DNS 캐시 서버는 하드웨어 단의 캐시 서버이고 자바 같이 소프트웨어 단에서도 DNS 캐시를 설정할 수 있다.  </p>
<ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.lesstif.com/pages/viewpage.action?pageId=17105897">Java VM 의 DNS caching TTL</a>  </li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://charsyam.wordpress.com/2017/12/27/%EC%9E%85-%EA%B0%9C%EB%B0%9C-dns-caching-in-jvm/">DNS Caching in JVM</a></li>
</ul>
<p>운영체제 별로 hosts 파일이 존재한다.<br>인터넷 초창기에는 도메인과 IP 주소를 매핑하기 위해 텍스트 형태의 파일인 hosts 파일을 사용해서 ip 주소를 변환했다.<br>요즘 OS에도 이 파일이 있어 DNS에 등록하기 전의 서버나 DNS에 등록할 수 없는 서버에 접근해야할 때 이 파일을 사용한다.<br>개발 중인 서버를 내부 테스트 할 때 사용하기도 하는데 자신의 컴퓨터에만 적용되기 때문에 테스트하는 모든 컴퓨터가 hosts 파일 자체를 수정하기가 번거로운 경우에는<br>사설 DNS를 직접 구성하기도 하는 것 같다.  </p>
<p>맥의 경우에는 <code>/etc/</code>에 해당 파일이 존재한다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/hosts.png" class title="IPv4와 IPv6의 루프백 어드레스로 127.0.0.1이 등록돼있고, 255.255.255.255로 브로드캐스팅 주소가 등록돼있다.">  
<p>맨 밑에 IP와 asdf.com은 내가 테스트로 등록한 건데, 네이버의 IP이다.<br>이제 내 컴퓨터에서 asdf.com을 입력하면 네이버로 접속이 된다.</p>
<h4 id="4-8-6-DNS에-도메인-등록하기"><a href="#4-8-6-DNS에-도메인-등록하기" class="headerlink" title="4-8-6. DNS에 도메인 등록하기"></a>4-8-6. DNS에 도메인 등록하기</h4><p>도메인은 IP와 마찬가지로 별도로 관리해주는 기관이 있다.<br>ISP 업체가 IP를 임대받아서 개인에게 IP를 할당해주듯이<br>도메인도 마찬가지로 큰 기관에서 전체적으로 관리하고, 등록 대행 업체(ISP 같은 애라고 보면 됨) 같은 사이트에서 관리를 하게 된다.<br>GoDaddy, Route53 등등의 사이트에서 도메인을 등록할 수 있다.<br>과정이 궁금한 사람은 <a href="/2017/11/21/domain-register-godaddy/">(DNS) 1331원에 .com 도메인 사기 (feat. GoDaddy)</a>을 참고하면 된다.  </p>
<p>DNS 서버에 등록되는 정보를 리소스 레코드라고 부르고, 리소스 레코드가 등록된 파일을 존 파일이라고 한다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/route-53.png" class title="AWS의 Route53에서 특정 도메인에 대해 등록된 리소스 레코드">  

<h4 id="4-8-7-리소스-레코드의-의미"><a href="#4-8-7-리소스-레코드의-의미" class="headerlink" title="4-8-7. 리소스 레코드의 의미"></a>4-8-7. 리소스 레코드의 의미</h4><p>각각의 레코드에 대해서는 나도 아직 공부하는 중이므로 아래 링크를 참조하자 ㅠㅠ<br><a target="_blank" rel="external nofollow noopener noreferrer" href="http://ricky840.tistory.com/10">DNS Zone 파일에 쓰이는 레코드 설명</a>  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/go-daddy.png" class title="GoDaddy에 등록된 내 도메인에 대한 리소스 레코드">

<ul>
<li><p>SOA(Start of authority)<br>해당 도메인을 관리하는 DNS 서버를 기술, 링크를 보면 1차 네임 서버(Primary), 2차 네임 서버(Secondary) 사이에 싱크를 맞추기 위한 시간 설정이나<br>재시도를 위한 시간 등등의 설정도 할 수 있다.  </p>
</li>
<li><p>NS(Name Server)<br>Primary, Secondary DNS 서버를 기술, 도메인에 대한 정보를 찾을 수 없으면 이 NS로 보내서 도메인에 대한 정보를 뒤지는 모양이다.  </p>
</li>
<li><p>A<br>도메인과 IP 어드레스를 연결, Route53 같은 경우에는 IP 주소 대신에 AWS Resource에 대한 도메인을 등록할 수 있다.  </p>
</li>
<li><p>CNAME(Canonical Name)<br>도메인에 별칭을 부여한다.<br>해당 도메인을 부르는 이름이 따로 있는데 그거에 대한 별명을 쓴다고 생각하면 된다.<br>내 블로그만 해도 원래는 perfectcle.netlify.com이라는 도메인이 있는데 이 도메인에 blog라는 별칭을 줬다.<br>루트 도메인(Zone Apex, Naked Domain이라고 부르기도 한다.)인 perfectacle.com을 내 돈 주고 샀고, blog라는 서브 도메인을 등록한 것이다.<br>루트 도메인만 돈 내고 쓰면 되고, 서브 도메인은 마음껏 쭉쭉 추가할 수 있고<br>위와 같이 1뎁스가 아니라 dev.blog와 같이 몇 뎁스 씩 쭉쭉 늘려가면서 등록할 수 있다.</p>
</li>
<li><p>MX(Mail eXchanger)<br>xxx@domain 과 같은 형식의 메일 주소와 메일 서버를 연결할 때 사용한다.</p>
</li>
</ul>
<h3 id="4-9-IP-어드레스를-자동으로-할당하는-DHCP"><a href="#4-9-IP-어드레스를-자동으로-할당하는-DHCP" class="headerlink" title="4-9. IP 어드레스를 자동으로 할당하는 DHCP"></a>4-9. IP 어드레스를 자동으로 할당하는 DHCP</h3><p>DHCP는 네트워크에 속한 호스트들에게 IP 어드레스를 자동으로 부여해 사람이 직접 IP를 설정하고 관리하는 수고를 덜어준다.  </p>
<h4 id="4-9-1-DHCP의-장점"><a href="#4-9-1-DHCP의-장점" class="headerlink" title="4-9-1. DHCP의 장점"></a>4-9-1. DHCP의 장점</h4><p>TCP&#x2F;IP가 제대로 동작하려면 네트워크에 속한 호스트의 IP 어드레스가 중복되면 안 된다.<br>퍼블릭 IP는 ISP에서 알아서 할당해주고, 프라이빗 IP도 누군가가 할당을 해줘야한다.<br>그래서 각 네트워크의 호스트한테 일일이 프라이빗 IP를 수동으로 등록해주는 건 매우 번거롭고 힘든 일이다.<br>이걸 자동으로 해주는 게 DHCP인데 대부분의 공유기가 이 역할까지 수행해준다.  </p>
<h4 id="4-9-2-IP-어드레스-할당-방법"><a href="#4-9-2-IP-어드레스-할당-방법" class="headerlink" title="4-9-2. IP 어드레스 할당 방법"></a>4-9-2. IP 어드레스 할당 방법</h4><p>공유기에 새로운 컴퓨터를 연결하면, 아직 IP 주소가 할당되지 않은 상태이고 DHCP 서버(공유기의 IP 주소) 조차 모르는 상황이다.<br>따라서 DHCP 서버를 찾아서 IP 주소를 할당받기 위해 브로드캐스팅을 해야한다.  </p>
<ol>
<li>신규로 연결한 장비는 네트워크에 브로드캐스팅으로 자신의 새로 들어왔음을 알린다.<br>이 때 자신의 IP 주소도 모르므로 IP 프로토콜로 통신하는 게 아니라 ICMP 프로토콜로 통신을 한다.<br>ICMP 타입 10번(Router Solicitation)을 보낸다.</li>
<li>그럼 DHCP 서버가 아닌 애들은 자신과 무관한 내용이므로 해당 패킷을 버린다.<br>그럼 그 요청을 받은 DHCP 서버는 브로드캐스팅으로 사용해야하는 IP 주소를 알려준다.<br>이 때 라우터는 ICMP 타입 9번 메시지(Router Advertisement)를 응답한다.</li>
<li>그럼 그 요청을 받은 새로운 장비는 IP 주소가 할당되고, 나머지 애들은 자신과 상관 없으니까 또 패킷을 버린다.</li>
</ol>
<h3 id="4-10-ipconfig-명령과-ping-명령"><a href="#4-10-ipconfig-명령과-ping-명령" class="headerlink" title="4-10. ipconfig 명령과 ping 명령"></a>4-10. ipconfig 명령과 ping 명령</h3><p>윈도우에서는 cmd에서 ipconfig 명령을 날리면 라우터 주소, 프라이빗 IP 주소, 서브넷 마스크 등등을 알 수 있다.<br>유닉스 환경(linux, mac 등등)에서는 ifconfig를 때리면 된다.<br>근데 맥에서 해당 명령어를 날려보니 보기가 매우 요상해서 Network Utility나 환경 설정의 네트워크 쪽에서 보는 게 더 보기는 편한 것 같다.  </p>
<p>노트북의 경우에는 무선&#x2F;유선 이더넷 아마 두 개가 나올 것이고(아마 무선은 꼭 나올 것이다.),<br>데스크탑의 경우에는 대부분 유선 이더넷 하나만 나올 것이다.<br>무선 이더넷 카드가 없는 경우에는 와이파이로 연결이 안 되니 외&#x2F;내장 무선 이더넷 카드를 사야한다.  </p>
<p>ping 명령어는 서버와 통신할 수 있는지 없는지 알기 위한 명령어이다.<br>해당 서버로부터 응답을 받는데까지 얼마나 알 수도 있기 때문에 네트워크의 혼잡도도 어느정도 파악이 된다.<br>사실 ping 명령어는 ICMP 프로토콜을 사용한다.<br>ICMP 타입 8번 메시지인 echo(수신 측 장비가 존재하는지 확인)를 서버에 날리고,<br>에코 요청을 받은 서버는 0번 타입 메시지인 에코 응답(서버 측 장비가 존재함)을 응답한다.  </p>
<h3 id="4-11-tracert-명령으로-통신경로-확인하기"><a href="#4-11-tracert-명령으로-통신경로-확인하기" class="headerlink" title="4-11. tracert 명령으로 통신경로 확인하기"></a>4-11. tracert 명령으로 통신경로 확인하기</h3><p>unix 환경에서는 traceroute 명령어이다.<br>백문이 불여일견 그냥 샘플을 봐보자.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/traceroute-blog.png" class title="내 블로그 주소를 추적해봤다.">  
<p>CNAME으로 blog를 등록했더니 원래 도메인인 perfectacle.netlify.com의 경로를 추적했고,<br>최종적으로 54.250.174.92이런 IP를 찾아낸 것 같다.</p>
<ol>
<li>공유기 (192.168.0.1)  </li>
<li>모뎀(xxx.xxx.166.1)  </li>
<li>루트(.) DNS 서버(172.21.1.253)  </li>
<li>.com DNS 서버(172.21.0.229)</li>
</ol>
<p>…<br>이런 순서인 것 같다.</p>
<img src="/2018/04/01/tcp-ip-book-index-4/traceroute-naver.png" class title="naver를 추적해봤다.">  
<p>네이버는 IP가 여러 개 물려있고, 그 중에 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.naver.com.nheos.com이라는/">www.naver.com.nheos.com이라는</a> 도메인을 선택해서 추적한 것 같다.  </p>
<ol>
<li>공유기 (192.168.0.1)  </li>
<li>모뎀(xxx.xxx.166.1)  </li>
<li>루트(.) DNS 서버(172.21.1.253)  </li>
<li>.com DNS 서버(172.21.0.229)</li>
</ol>
<p>…<br>이런 순서인 것 같다.  </p>
<img src="/2018/04/01/tcp-ip-book-index-4/naver-domain.png" class title="www.naver.com.nheos.com으로 접속하면 www.naver.com으로 바뀌어서 접속이 된다.">  
<p>302 Moved Temporarily 응답을 받은 걸 볼 수 있다.<br>그리고 실제로 210.89.160.88으로 접속해도 마찬가지의 응답을 볼 수 있다.</p>
<p>tracert&#x2F;traceroute도 서버의 생존 여부를 파악하기 위해 ICMP 프로토콜을 이용한다.<br>요청을 보낼 때 ICMP 타입 8번(에코)를 날리고, 만약 맥시멈 라우트 홉까지 가고도 경로를 찾지 못했으면<br>ICMP 타입 11번(생존 기간이 지난 패킷이라 삭제됨) 응답을 알려준다.  </p>
<p>꼭 도메인일 필요는 없고 IP 주소를 날려도 상관이 없다.  </p>
<h3 id="4-12-nslookup-명령으로-IP-어드레스-알아내기"><a href="#4-12-nslookup-명령으로-IP-어드레스-알아내기" class="headerlink" title="4-12. nslookup 명령으로 IP 어드레스 알아내기"></a>4-12. nslookup 명령으로 IP 어드레스 알아내기</h3><p>윈도우의 CMD나 유닉스 기반 운영체제의 터미널에서 nslookup domain을 입력하면 해당 IP 어드레스와 DNS 서버 정보도 표시해준다.<br>위와 반대로 nslookup ip주소 를 입력해서 도메인 정보를 알아내는 reverse DNS Query라는 것도 있다. </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Network/" rel="tag"># Network</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03/31/tcp-ip-book-index-3/" rel="prev" title="(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 3장 트랜스포트 계층">
                  <i class="fa fa-chevron-left"></i> (네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 3장 트랜스포트 계층
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/04/01/tcp-ip-book-index-5/" rel="next" title="(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 5장 하드웨어와 네트워크 인터페이스 계층">
                  (네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 5장 하드웨어와 네트워크 인터페이스 계층 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2016 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">양권성</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="external nofollow noopener noreferrer" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@10.2.3/dist/mermaid.min.js","integrity":"sha256-JFptYy4KzJ5OQP+Q9fubNf3cxpPPmZKqUOovyEONKrQ="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"exobud","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
