{"meta":{"title":"오늘도 끄적끄적","subtitle":"느리더라도 꾸준하게","description":"Toss Server Developer","author":"양권성","url":"https://perfectacle.github.io","root":"/"},"pages":[{"title":"페이지를 찾을 수 없음","date":"2016-11-10T18:06:26.000Z","updated":"2022-10-30T08:42:16.015Z","comments":false,"path":"404.html","permalink":"https://perfectacle.github.io/404.html","excerpt":"","text":"페이지를 찾을 수 없습니다. 페이지가 삭제되었거나 URL을 확인해주세요."},{"title":"양권성이란...?","date":"2016-11-10T18:06:26.000Z","updated":"2022-10-30T08:42:17.035Z","comments":true,"path":"about/index.html","permalink":"https://perfectacle.github.io/about/index.html","excerpt":"","text":"소프트웨어 디자인, 설계, 아키텍처 Java, Kotlin, Spring (Boot) 힙합, Lofi, 재즈 위 사항에 관심이 많습니다.그 관심을 하나하나 제 것으로 만들기 위해 차근차근 공부해나가는 중입니다. 자작물은 아래와 같습니다. 떡밥밥 keyword-crawler dynamic-table-generator check-browsers async-to-sync perf-chk hexo-theme-overdose-starter 호기심이 많아 디버깅과 삽질을 많이하는 편입니다.이 블로그도 저의 호기심을 정리해놓기 위해 만들었습니다.여러분의 따뜻한 댓글이 저로 하여금 의지를 더 불타게 만듭니다.블로그를 구독하시고자하시는 분들은 아래 RSS Feed를 구독하시면 되겠습니다.https://perfectacle.github.io/atom.xml감사합니다."},{"title":"카테고리","date":"2019-08-22T00:04:07.000Z","updated":"2022-10-30T08:42:17.035Z","comments":false,"path":"categories/index.html","permalink":"https://perfectacle.github.io/categories/index.html","excerpt":"","text":""},{"title":"태그","date":"2019-08-22T00:05:45.000Z","updated":"2022-10-30T08:42:17.035Z","comments":false,"path":"tags/index.html","permalink":"https://perfectacle.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-30T08:42:17.035Z","updated":"2022-10-30T08:42:17.035Z","comments":true,"path":"images/favicon/manifest.json","permalink":"https://perfectacle.github.io/images/favicon/manifest.json","excerpt":"","text":"{\"name\":\"오늘도 끄적끄적\",\"short_name\":\"오늘도 끄적끄적\",\"icons\":[{\"src\":\"/android-chrome-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"}],\"theme_color\":\"#ffffff\",\"background_color\":\"#ffffff\",\"start_url\":\"https://perfectacle.github.io\",\"display\":\"standalone\"}"}],"posts":[{"title":"히카리 CP에서 다양한 시간 설정해보기","slug":"hikari-cp-time-config","date":"2022-09-25T17:06:17.000Z","updated":"2022-10-30T08:42:16.655Z","comments":true,"path":"2022/09/25/hikari-cp-time-config/","link":"","permalink":"https://perfectacle.github.io/2022/09/25/hikari-cp-time-config/","excerpt":"Spring Boot 2에서 제공하는 RDB 관련 의존성을 추가하면 DB의 커넥션 풀을 관리하기 위해 기본적으로 사용하는 HikariCP는 시간 관련해서 다양한 설정들이 있다.하지만 그냥 설명하는 것만 봐서는 무슨 내용인지 헷갈리는 설명들이 있어서 요번에 프로젝트에 도입된 설정들을 포함해 몇가지 정리를 해보았다. maxLifeTime ⏳maxLifetime This property controls the maximum lifetime of a connection in the pool. An in-use connection will never be retired, only when it is closed will it then be removed. On a connection-by-connection basis, minor negative attenuation is applied to avoid mass-extinction in the pool. We strongly recommend setting this value, and it should be several seconds shorter than any database or infrastructure imposed connection time limit. A value of 0 indicates no maximum lifetime (infinite lifetime), subject of course to the idleTimeout setting. The minimum allowed value is 30000ms (30 seconds). Default: 1800000 (30 minutes) 커넥션 풀에서 idle 커넥션이 최대 얼마동안 생존할 수 있냐는 설정이다. (단위는 ms, 기본값은 30분, 최소값은 30초, 0으로 설정하면 무제한)반환될 때마다 idle time은 다시 0으로 초기화 될테니 트래픽이 많이 들어와서 커넥션이 계속 사용되는 서비스라면 이 설정에 의해 커넥션이 종료될 일은 적을 것이다. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (maxLifeTime: 30000ms(30s)) participant C1 as Connection 1 (current idle time: 20s) participant C2 as Connection 2 (current idle time: 15s) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: Connection 1 Hikari -&gt;&gt; Server: Connection 1 Server -&gt;&gt; Hikari: releaseConnection(Connection 1) Hikari -&gt;&gt; C1: release (reset idle time to 0s)","text":"Spring Boot 2에서 제공하는 RDB 관련 의존성을 추가하면 DB의 커넥션 풀을 관리하기 위해 기본적으로 사용하는 HikariCP는 시간 관련해서 다양한 설정들이 있다.하지만 그냥 설명하는 것만 봐서는 무슨 내용인지 헷갈리는 설명들이 있어서 요번에 프로젝트에 도입된 설정들을 포함해 몇가지 정리를 해보았다. maxLifeTime ⏳maxLifetime This property controls the maximum lifetime of a connection in the pool. An in-use connection will never be retired, only when it is closed will it then be removed. On a connection-by-connection basis, minor negative attenuation is applied to avoid mass-extinction in the pool. We strongly recommend setting this value, and it should be several seconds shorter than any database or infrastructure imposed connection time limit. A value of 0 indicates no maximum lifetime (infinite lifetime), subject of course to the idleTimeout setting. The minimum allowed value is 30000ms (30 seconds). Default: 1800000 (30 minutes) 커넥션 풀에서 idle 커넥션이 최대 얼마동안 생존할 수 있냐는 설정이다. (단위는 ms, 기본값은 30분, 최소값은 30초, 0으로 설정하면 무제한)반환될 때마다 idle time은 다시 0으로 초기화 될테니 트래픽이 많이 들어와서 커넥션이 계속 사용되는 서비스라면 이 설정에 의해 커넥션이 종료될 일은 적을 것이다. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (maxLifeTime: 30000ms(30s)) participant C1 as Connection 1 (current idle time: 20s) participant C2 as Connection 2 (current idle time: 15s) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: Connection 1 Hikari -&gt;&gt; Server: Connection 1 Server -&gt;&gt; Hikari: releaseConnection(Connection 1) Hikari -&gt;&gt; C1: release (reset idle time to 0s) 히카리 CP에서 커넥션을 가져오고 반납하는 과정을 대략적으로 그려보면 위와 같을 것이다.커넥션 풀에 있는 idle 커넥션을 가져와서 사용하고 반납할 때는 idle time을 다시 0으로 초기화해서 반납하는 것이다. 위와 같은 상황에서 15초가 지났다고 할 때 어떻게 될까…?? sequenceDiagram autonumber participant Hikari as HikariCP (maxLifeTime: 30000ms(30s)) participant C2 as Connection 2 (current idle time: 30s) participant C1 as Connection 1 (current idle time: 15s) Hikari -&gt;&gt; C2: close() C2 -&gt;&gt; Hikari: remove from Connection Pool HikariCP에서는 내부적으로 maxLifeTime에 도달한 idle conenection을 종료하고 커넥션 풀에서 제거하는 스케쥴러가 돌고 있다.그리고 커넥션들이 동시에 종료돼서 성능 상 이슈를 유발하는 것을 방지하고자 각 커넥션 사이에 ms 단위의 차이를 두고 순차적으로 종료시키고 있다.자세한 내용은 다음 블로그에 나와있다.HikariCP는 test-while-idle과 같은 커넥션 갱신 기능이 없을까? maxLifeTime을 DBMS의 wait_timeout 보다 길게 설정한 경우maxLifeTime을 지나치게 길게 설정했거나 아무런 설정도 하지 않았을 경우에 가끔 아래와 같은 warn 로그를 보게 된다. (주로 트래픽이 없는 어드민 류의 서버에서 종종 발생했던 거 같다.) 12hikari-pool - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@1e2db70 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value. 위 로그는 DB에 설정한 wait_timeout(DBMS마다 파라미터 이름은 다를 수 있다.) 보다 maxLifeTime을 길게 줬을 경우 발생할 수 있다. (여기서는 MySQL을 사용한다고 가정하고 설명한다.)MySQL의 경우 아래와 같이 쿼리를 날려서 wait_timeout을 확인해볼 수 있다. (기본값은 28800(s)로 8시간이다.) 1show global variables like &#x27;wait_timeout&#x27; MySQL의 wait_timeout 기본값은 8시간이고, maxLifeTime의 기본값은 30분이라서 발생하지 않을텐데 MySQL의 wait_timeout이 maxLifeTime 보다 짧을 때 어떻게 동작하는지 알아보자. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (maxLifeTime: 600000ms(10m)) participant C1 as Connection 1 (current idle time: 5m) participant C2 as Connection 2 (current idle time: 4m) participant MySQL as MySQL (wait_timeout: 300s(5m)) MySQL -&gt;&gt; C1: close Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: failed to getConnection (already closed connection) Hikari -&gt;&gt; C1: remove from connection pool Hikari -&gt;&gt; C2: getConnection() C2 -&gt;&gt; Hikari: Connection 2 Hikari -&gt;&gt; Server: Connection 2 MySQL에서는 wait_timeout에 도달한 idle connection을 끊어버린다.하지만 MySQL은 해당 커넥션을 어떤 어플리케이션에서 사용하는지 모르니 해당 어플리케이션에도 커넥션을 사용하지 말라는 패킷을 보낼 수 없다.따라서 우리가 짠 어플리케이션에는 HikariCP에 아직도 종료된 커넥션이 남아있는 것이다.이 때 우리가 해당 커넥션을 풀에서 꺼내려고 하면 warn 로그가 뜨는 것이다.하지만 warn 로그이기 때문에 유효한 connection을 제대로 획득했다면 서비스 장애로까지 전파되지는 않을 것이다. (connection 획득에 실패했으면 다른 에러로그가 찍혔을 것이다.)따라서 warn 로그에 나와있는대로 maxLifeTime을 줄여야한다. (네트워크 지연 등등을 고려하여 wait_timeout 보다 2~3초 정도 짧게 잡아주는 걸 권장하는 것으로 알고 있다.)위 warn 로그에 대한 내용도 다음 블로그에 자세하게 나와있다.HikariCP Failed to Validate Connection Warning 이야기 connectionTimeout ⏳connectionTimeout This property controls the maximum number of milliseconds that a client (that’s you) will wait for a connection from the pool. If this time is exceeded without a connection becoming available, a SQLException will be thrown. Lowest acceptable connection timeout is 250 ms. Default: 30000 (30 seconds) 커넥션을 맺는데 걸리는 시간을 의미하며 이 시간은 단순히 하나의 물리적인 커넥션을 맺는데 걸리는 시간을 의미하는 게 아니라 커넥션 풀에서 커넥션을 획득하는데 걸리는 시간을 의미한다. 더이상 커넥션을 맺지 못하는 상황에 도달했는데 connectionTimeout 내에 유효한 커넥션을 획득하지 못하는 경우커넥션 풀에 유효한 커넥션이 없으면 새로운 커넥션을 맺게 되는데 maximumPoolSize 등에 도달하는 등의 상황에 의해 더이상 커넥션을 맺지 못하게 될 가능성이 있다.이런 상황에 어떻게 되는지 한 번 살펴보자. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (connectionTimeout: 1100ms(1.1s), maximumPoolSize: 2) participant C1 as Connection 1 (in use) participant C2 as Connection 2 (in use) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; Hikari: wait 1.1s untill get available connection Hikari -&gt;&gt; Server: throw SQLException(connection timeout) 유효한 커넥션을 획득하지 못해 DB를 사용하지 못하는 상황이기 때문에 아마 해당 API는 제대로 처리하지 못하고, 이런 상황이 오래 유지되면 전면 장애도 발생할 수 있을 것이다.이런 상황이 발생하는데는 아래와 같은 이유 등등이 있을 것이다. 장기간 커넥션을 물고 있을만한 상황은 없는지? 슬로우 쿼리가 발생해서 커넥션을 오래 물고 있는 커넥션은 없는지? 이런 경우 슬로우 쿼리의 원인을 찾아서 해결해야한다.슬로우 쿼리 로그를 남기고 있지 않다면 access log 등등을 통해 당시 오래 걸렸던 API를 찾는다던지 해서 오래 걸리는 쿼리의 explain을 떠서 원인도 분석해보자. (올바른 index를 타지 않아 풀 텍스트 스캔을 돌고 있었다던지…?) 롱 트랜잭션(트랜잭션 안에서 외부 API 호출과 같이 오래 걸리는 작업을 한다던지)으로 인해 커넥션을 오래 유지하고 있다던지?트랜잭션의 범위를 최소화하여야한다.하나의 큰 트랜잭션이 아닌 작은 범위의 트랜잭션으로 잘게 쪼개고, 각 트랜잭션을 보장할 수 있도록 별도의 상태를 더 두고 수동 롤백 전략(롤백 코드 직접 작성)을 취해야할 수도 있다. OSIV(Open Session In View)에 의해 커넥션을 과도하게 물고있는 것은 아닌지…?스프링 부트 1부터 2까지 OSIV는 기본값으로 활성화 돼있다.그리고 Spring Data JPA에서 Hibernate를 사용할 경우 Hibernate의 기본값을 덮어씌우는 것들이 존재한다.Spring Boot 2.x의 Spring Data JPA에서 기본적으로 사용하는 Hibernate 5.2+의 커넥션 핸들링 전략(PhysicalConnectionHandlingMode)은 DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT이다. (최대한 커넥션을 늦게 획득하고 트랜잭션이 종료되기 전에도 SQL 문이 하나 종료될 때마다 커넥션을 반납하는 전략)하지만 Spring Boot 2.x에서는 Hibernate의 기본값을 무시하고 DELAYED_ACQUISITION_AND_HOLD로 덮어씌우고 있다. (최대한 커넥션을 늦게 획득하고 요청이 끝나는 시점인 엔티티매니저가 close 되는 시점에 커넥션풀에 커넥션을 반납하는 전략)위 전략은 DELAYED_ACQUISITION이기 때문에 엔티티 매니저가 생성되는 시점인 컨트롤러가 요청을 받는 시점에는 커넥션을 획득하지 않는다.커넥션이 정말 필요한 트랜잭션을 만난다던지, 쿼리를 날려야하는 상황이 올 때만 비로소 커넥션을 획득한다.그리고 트랜잭션이 끝나거나 단건 쿼리가 종료됐음에도 불구하고 Lazy 로딩된 엔티티를 언제 조회하게 될지 모르기 때문에 커넥션을 다시 반납하지 않는 것 같다.하지만 이로 인해 커넥션을 과도하게 오래 물고 있을 수 있기 때문에 커넥션 풀 고갈을 유발해서 장애가 발생할 수 있다.따라서 OSIV를 킨 상황에서는 PhysicalConnectionHandlingMode를 DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION(최대한 늦게 획득하고 트랜잭션 종료 즉시 반납)을 설정하는 게 커넥션 풀 고갈을 방지할 수 있다.근본적으로 OSIV를 비활성화 시키면 굳이 PhysicalConnectionHandlingMode를 따로 설정할 필요가 없지만 이미 운영중인 서비스의 OSIV를 비활성화 시키면 런타임에 언제 장애(LazyInitializationException)를 맞을지 모르니 추천하지 않는다. 커넥션풀 사이즈(maximumPoolSize)를 너무 작게 유지한 건 아닌지?내가 생각하기에는 트래픽이 얼마 안 들어올 줄 알고 DB 자원을 아끼려고 커넥션풀 사이즈를 작게 잡았는데 이로 인해 커넥션풀 고갈이 생각보다 빨리 발생할 수 있다.평상시 트래픽&#x2F;피크 시간의 트래픽 추이를 분석해서 적절한 사이즈를 지정해주자 (물론 단일 서버로 서비스할 때는 계산하기 쉽겠지만 여러 서버에서 서비스하면 좀 더 복합적인 요소를 계산해야할 것이다.) connectionTimeout을 너무 짧게 유지한 건 아닌지?예제에서는 1.1초(1초 안에 DB 서버에서 syn+ack가 오지 않으면 OS 레벨에서 TCP Syn Retransmission을 하기 때문에 한 번 정도 TCP 3Way Handshake를 더 하게 된다, 물론 OS 설정에 따라 Retransmission 주기는 다르지만 대부분의 리눅스는 1초였던 걸로 기억한다.)로 지정했다.하지만 어플리케이션 서버와 DB 서버의 네트워크가 불안정하거나 물리적 거리가 멀다던지, 아니면 그다지 빠른 응답을 보장할 필요가 없는 서비스(내부 스케쥴러에서 돈다던지)라면 connectionTimeout을 늘리는 것도 고려해보아야한다. validationTimeout ⏳validationTimeout This property controls the maximum amount of time that a connection will be tested for aliveness. This value must be less than the connectionTimeout. Lowest acceptable validation timeout is 250 ms. Default: 5000 커넥션의 유효성(사용 가능한 상태인지)을 검사하는데 걸리는 최대 마지노선 시간이라고 보면 된다. (기본값은 5초이고, 최소값은 250ms)그리고 connectionTimeout 보다 짧게 유지해야한다고 하는데 HikariCP의 커넥션 유효성 검증 전략을 우선 짚고 이해해야한다. 다른 DB Connection Pool에서는 idle connection을 계속 유지하려고 select 1과 같은 무의미한 쿼리를 지속적으로 날려서 커넥션을 유지한다.HikariCP에서는 이런 것조차 오버헤드(여러 대의 서버에서 여러 커넥션이 주기적으로 쿼리를 날리면 생각보다 오버헤드가 클 수도 있다.)라고 판단하는 듯하다. (관련 이슈: https://github.com/brettwooldridge/HikariCP/issues/766)따라서 HikariCP에서는 주기적으로 쿼리를 날리지 않는다.대신 JDBC4 이상의 드라이버를 사용한다면 단순한 validation 패킷 정도만 날리는 것만으로도 커넥션의 유효성을 검사할 수 있다. 아래 상황에 대해서 커넥션의 유효성을 검사한 이후에 아직 커넥션이 끊기지 않은 상태이니 사용 가능한 커넥션이라 판단해서 풀에 남기던지, 아니면 제거하던지 하게 된다. 커넥션을 DB에서 새로 맺을 때 커넥션 풀에서 커넥션을 획득할 때 커넥션의 idle time이 keepaliveTime에 도달했을 때 참고로 validationTimeout이 발생하면 Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@63123dfa (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value. 요런 warn 로그가 발생하곤 한다.해당 로그 이후에 커넥션 획득에 실패했다는 에러 로그 같은 게 남지 않았으면 서비스가 장애까지 이어지지 않았다고 판단하면 된다.저 로그 이후 connectionTimeout 이내에 유효한 커넥션을 획득했으니 에러로그가 남지 않았을 거다.validationTimeout은 정말 작은 패킷을 주고 받기 때문에 어지간해서 발생하지 않는데 아래 상황에 발생할 수 있다.다만 warn이기 때문에 너무 자주 발생하는 게 아니면 즉각 조치가 필요하지는 않을 것 같고, noise라고 느껴질 정도로 과하게 느껴지면 connectionTimeout과 validationTimeout을 함께 조금씩 늘려보는 것도 고려해보아야한다. 네트워크가 불안정하거나 DB 서버에서 어떤 사유에 의해 연결을 먼저 끊은 상황이거나 물리적으로 거리가 먼데 비해 과도하게 짧게 잡았거나 근데 connectionTimeout과 validationTimeout은 어떤 상관관계가 있기에 validationTimeout을 더 짧게 설정하라는 걸까? validationTimeout이 connectionTimeout 보다 짧지 않은 경우sequenceDiagram autonumber participant Server participant Hikari as HikariCP (connectionTimeout: 1100ms(1.1s), validationTimeout: 1100ms(1.1s)) participant C1 as Connection 1 (idle) participant C2 as Connection 2 (idle) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: after validationTimeout(1.1s), failed to getConnection (Failed to validate connection) Hikari -&gt;&gt; C1: remove from connection pool Hikari -&gt;&gt; Server: throw SQLException(connection timeout) validationTimeout이 connectionTimeout 보다 짧지 않기 때문에 오롯이 커넥션 하나가 살아있는지 확인하느라 시간을 다 쓸 수 있다.빠르게 validation을 멈추고 다음 커넥션 획득을 시도했더라면 성공할 수도 있지 않았을까…?? validationTimeout이 connectionTimeout 보다 짧은 경우sequenceDiagram autonumber participant Server participant Hikari as HikariCP (connectionTimeout: 1100ms(1.1s), validationTimeout: 1000ms(1s)) participant C1 as Connection 1 (idle) participant C2 as Connection 2 (idle) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: after validationTimeout(1s), failed to getConnection (Failed to validate connection) Hikari -&gt;&gt; C1: remove from connection pool Hikari -&gt;&gt; C2: getConnection() C2 -&gt;&gt; Hikari: Connection 2 Hikari -&gt;&gt; Server: Connection 2 위에 얘기했던대로 validationTimeout을 너무 과하게 잡아서 다른 커넥션 획득 시도의 기회조차 잃어버릴 수 있기 때문에이를 방지하고자 validationTimeout이 connectionTimeout 보다 짧게 설정하면 커넥션 획득 시도를 여러 번 할 수 있기 때문에 장애를 방지할 수도 있다.하지만 그렇다고 해서 connectionTimeout을 너무 길게 잡으면 우리 시스템은 온전히 처리했지만 클라이언트 측 시스템에서 Read Timeout이 발생할 수 있으니 이 부분은 상황에 맞게 설정해야한다. keepaliveTime ⏳keepaliveTime This property controls how frequently HikariCP will attempt to keep a connection alive, in order to prevent it from being timed out by the database or network infrastructure. This value must be less than the maxLifetime value. A “keepalive” will only occur on an idle connection. When the time arrives for a “keepalive” against a given connection, that connection will be removed from the pool, “pinged”, and then returned to the pool. The ‘ping’ is one of either: invocation of the JDBC4 isValid() method, or execution of the connectionTestQuery. Typically, the duration out-of-the-pool should be measured in single digit milliseconds or even sub-millisecond, and therefore should have little or no noticible performance impact. The minimum allowed value is 30000ms (30 seconds), but a value in the range of minutes is most desirable. Default: 0 (disabled) idle connection에 대해서 keepaliveTime에 도달하면 주기적으로 커넥션의 유효성을 검증한다. (최소값은 30분, 기본값은 비활성화(0)이다.)커넥션이 살아있다고 해도 idle time이 0으로 초기화 되는 건 아니고 그냥 커넥션이 잘 살아있는지 확인하는 것 뿐이다. idle connection은 다양한 사유에 의해 DB 서버로부터 먼저 커넥션이 끊길 수 있다. maxLifeTime이 DBMS의 wait_timeout 보다 긴 경우 DB 서버의 리소스 부족 등등으로 인해 불필요한 idle 커넥션을 종료시키는 경우 keepaliveTime을 설정하지 않은 경우위와 같이 DB 서버에서 먼저 커넥션을 끊은 경우 아래와 같은 오버헤드가 발생할 수 있다. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (keepaliveTime: 0(disabled)) participant C1 as Connection 1 (closed) participant C2 as Connection 2 (idle) Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C1: getConnection() C1 -&gt;&gt; Hikari: failed to getConnection (already closed connection) Hikari -&gt;&gt; C1: remove from connection pool Hikari -&gt;&gt; C2: getConnection() C2 -&gt;&gt; Hikari: Connection 2 Hikari -&gt;&gt; Server: Connection 2 Connection 1은 이미 종료됐기 때문에 굳이 커넥션 획득을 할 필요가 없었다.하지만 HikariCP는 그 사실을 모르기 때문에 Connection 1 획득 절차가 끼어들게 되고 이 시간만큼 지연이 발생해서 혹시 connectionTimeout이 발생한다고 하면 장애가 발생할 수도 있다. keepaliveTime을 설정한 경우keepaliveTime을 설정하지 않았을 때의 문제는 커넥션이 종료됐다는 사실을 트래픽을 받은 시점에 알게 된다는 것이다.트래픽을 받았을 때는 최대한 빠른 응답성을 보장해야하는데 저런 자잘한 것들로 인해 빠른 응답성을 보장하지 못하거나 장애를 유발할 수도 있게 된다. (간헐적일 수도 있겠지만…) 그럼 keepaliveTime을 설정했을 때 어떤 장점이 있는지 알아보자. sequenceDiagram autonumber participant Server participant Hikari as HikariCP (keepaliveTime: 30000ms (30s)) participant C1 as Connection 1 (closed) participant C2 as Connection 2 (idle) Hikari -&gt;&gt; C1: isConnectionAlive (when keepaliveTime is up) C1 -&gt;&gt; Hikari: Failed to validate connection (already closed connection) Hikari -&gt;&gt; C1: remove from connection pool Server -&gt;&gt; Hikari: getConnection() Hikari -&gt;&gt; C2: getConnection() C2 -&gt;&gt; Hikari: Connection 2 Hikari -&gt;&gt; Server: Connection 2 트래픽을 받기 전부터 Connection 1의 종료사실을 인지하고 커넥션 풀에서 제거했기 때문에 트래픽이 들어왔을 때는 바로 유효한 커넥션인 Conenction 2부터 획득을 시도했다.사소하고 찰나의 시간으로 인식할 수도 있지만 대용량 트래픽에서 이런 것들이 쌓이게 됐을 때 힘을 발휘할 수 있을 것 같다.또한 DB에 뭔가 문제가 있다는 상황, 혹은 네트워크가 불안정하다는 상황을 트래픽을 받은 시점이 아닌 미리 파악할 수 있다는 장점도 존재한다.서버가 엄청 많이 떠있는 서버는 keepaliveTime을 너무 짧게 설정하면 오히려 그게 오버헤드를 유발할 수도 있기 때문에 적절한 튜닝이 필요한 것 같다. 마치며처음에는 maxLifeTime과 connectionTimeout 정도만 신경썼는데 DevOps(SRE 겸임) 개발자 분께서 올려주신 PR을 보고 저 설정은 도대체 무엇일까… 하고 고민하면서질문하고 공부하면서 정리한 내용이 머릿속으로는 어느정도 있었는데 그림으로 한 번 그려보니 어떤 상황에 문제가 있고 어떤 문제를 해결하는지 좀 더 명쾌해진 것 같다.아직 보지도 못한 설정들도 많을텐데 이런식으로 정복해나가면 그래도 조금이나마 더 나은 엔지니어가 되지 않을까? 싶다. 참조 링크 HikarCP Github MySQL Server System Variables HikariCP는 test-while-idle과 같은 커넥션 갱신 기능이 없을까? HikariCP Failed to Validate Connection Warning 이야기","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"DB","slug":"Note/DB","permalink":"https://perfectacle.github.io/categories/Note/DB/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://perfectacle.github.io/tags/MySQL/"},{"name":"HikariCP","slug":"HikariCP","permalink":"https://perfectacle.github.io/tags/HikariCP/"},{"name":"DB","slug":"DB","permalink":"https://perfectacle.github.io/tags/DB/"}]},{"title":"TDD는 Design Acitivity이다.","slug":"tdd-is-design-activity","date":"2022-06-06T14:39:22.000Z","updated":"2022-10-30T08:42:16.947Z","comments":true,"path":"2022/06/06/tdd-is-design-activity/","link":"","permalink":"https://perfectacle.github.io/2022/06/06/tdd-is-design-activity/","excerpt":"1~2년 전 쯤 존경하는 개발자 분과 함께 A Brief History of Mock Objects라는 아티클을 함께 본 적이 있다.개인적으로 이렇게 특정 개념의 근본이 된다던지, 해당 분야의 대가들이 쓴 아티클들을 함께 보는 것으로 인해 굉장히 많은 인사이트들이 생겼던 것 같다.객체의 테스트 때문에 추가했던 getter로부터의 해방을 위해 고민하던 것으로 시작한 게 Mock의 탄생이라는 사실을 알게 되었을 때는 정말 위대한 탄생이라고 생각했다. 그리고 문득 시간이 지나 해당 아티클을 다시 보고 싶어졌다. (물론 해당 아티클은 테스트 주도 개발로 배우는 객체 지향 설계와 실천 책의 후기에 한글로 적혀있다.)아티클을 보던 중에 후반 부분에 Mock과 관련해서 Mock Roles, not Objects라는 논문까지 썼다는 걸 보고 해당 논문까지 봐야 Mock에 대해 정확한 이해를 할 수 있을 것 같아 해당 논문을 보게 되었다.그리고 목의 역사와 마찬가지로 해당 논문도 너무나 감명이 깊어 한 번 느낀점이나 내용을 정리해보고 싶었다. Writing tests is a design activity먼저 TDD(Test Driven Development)에는 크게 두 가지 관점이 존재할 것 같다. 첫 번째로 “검증”이다.코드들이 의도대로 동작하는지, 버그는 없는지 검증하는 것이다.이를 통해 프로덕션에 코드를 내보내도 된다는 자신감이 올라가고, 리팩토링을 하거나 신규 기능을 추가하더라도 코드의 동작은 변하지 않았음에 확신을 가질 수 있다.","text":"1~2년 전 쯤 존경하는 개발자 분과 함께 A Brief History of Mock Objects라는 아티클을 함께 본 적이 있다.개인적으로 이렇게 특정 개념의 근본이 된다던지, 해당 분야의 대가들이 쓴 아티클들을 함께 보는 것으로 인해 굉장히 많은 인사이트들이 생겼던 것 같다.객체의 테스트 때문에 추가했던 getter로부터의 해방을 위해 고민하던 것으로 시작한 게 Mock의 탄생이라는 사실을 알게 되었을 때는 정말 위대한 탄생이라고 생각했다. 그리고 문득 시간이 지나 해당 아티클을 다시 보고 싶어졌다. (물론 해당 아티클은 테스트 주도 개발로 배우는 객체 지향 설계와 실천 책의 후기에 한글로 적혀있다.)아티클을 보던 중에 후반 부분에 Mock과 관련해서 Mock Roles, not Objects라는 논문까지 썼다는 걸 보고 해당 논문까지 봐야 Mock에 대해 정확한 이해를 할 수 있을 것 같아 해당 논문을 보게 되었다.그리고 목의 역사와 마찬가지로 해당 논문도 너무나 감명이 깊어 한 번 느낀점이나 내용을 정리해보고 싶었다. Writing tests is a design activity먼저 TDD(Test Driven Development)에는 크게 두 가지 관점이 존재할 것 같다. 첫 번째로 “검증”이다.코드들이 의도대로 동작하는지, 버그는 없는지 검증하는 것이다.이를 통해 프로덕션에 코드를 내보내도 된다는 자신감이 올라가고, 리팩토링을 하거나 신규 기능을 추가하더라도 코드의 동작은 변하지 않았음에 확신을 가질 수 있다. 두 번째로 “설계”이다.나의 코드를 검증하려고 테스트를 짜려고 하는데 테스트를 짜기가 힘들다면 “Code Smell”이 난다고 할 수 있다. (코드에 뭔가 구린 내가 나는 것이다.)이를 통해 적절한 책임을 가진 객체로 쪼갬으로 인해 더 나은 설계로 유도해낼 수 있을 것이다. 나는 첫 번째 목적인 검증에 좀 더 집중했다.더 나은 설계도 물론 중요하지만 일단 버그가 없는 게 “1순위”라고 생각했기 때문이다.하지만 그러다보니 TDD를 하려고 할 때, 즉 신규 기능을 구현할 때 테스트를 먼저 짜려고 할 때 어디서부터 코드를 짜야할지, 뭘 테스트해야할지 막막했다.아직 검증할 게 없는데 뭘 검증한단 말인가?그래서 번번이 테스트부터 짜보겠다는 실패로 돌아가고, 코드를 짠 후에 내가 코드를 제대로 짰는지 검증하는 목적으로 테스트를 나중에 작성했다. 나의 이런 TDD는 접근 방법부터 잘못됐던 것 같다.Test “Driven” Development면 테스트가 (나의 어플리케이션 코드를) 주도해야하는데 전혀 주도하고 있지 못했다.자꾸 나의 어플리케이션 코드를 테스트에 끼워맞출 생각(어떻게 이 부분을 검증할까)만 하고 있다보니 단순히 “테스트만 먼저 짜면 TDD다”라고 생각했던 것 같다.물론 “검증” 또한 포기할 수 없는 부분이다.하지만 여기에 너무 매몰되다보니 결국 테스트가 나의 코드를 주도하게 하지 못하게 됐던 것 같다. 그러다보니 이렇게 논문까지 쓰고 TDD의 대가라고 부를 법한 사람들은 무슨 생각을 가지고 실제로 TDD를 어떻게 수행하는지 너무나 궁금했다.논문을 보니 내가 생각했던 관점과 완전 다른 관점을 가지고 있었다. Writing tests is a design activity,…This changes design from a process of invention,where the developer thinks hard about what a unit of code should do and then implements it,to a process of discovery,where the developer adds small increments of functionality and then extracts structure from the working code.…Using TDD has many benefits but the most relevant is thatit directs the programmer to think about the design of code from its intended use,rather than from its implementation. 테스트를 작성하는 것은 Design Activity(설계 행위)이며,Design Activity는 design(코드의 설계)을 발명(invention)의 과정(어떤 코드가 무엇을 해야하고 어떻게 구현해야할지)에서 발견(discovery)의 과정(조그만 기능을 추가하고 동작하는 코드로부터 구조를 추출하는)으로 바꾼다고 설명하고 있다.번역이 매끄럽지는 않지만 대충 어떤 뉘앙스인지 생각해보면 발명이라는 건 어떤 걸 만들어야겠다는 명확한 목표를 가지고 있는 것이고, 발견이라는 것은 명확한 목표를 가지고 있기 보다는 추상적인 무언가를 떠오르고 탐색하던 과정 중에 튀어나오는 것이 아닐까 싶다.따라서 전자의 관점으로 설계를 하게 되면 어떤 일을 어떻게 해야하는 객체들이 명확하게 정의돼있다보니 설계가 매우 딱딱하게 강결합이 될 것이다.이는 코드의 구조를 바꾸기 어렵다는 것을 뜻하며 구체적인 타입으로 확정짓는 것을 뜻하는 것 같다.하지만 후자의 관점으로 설계를 하게 되면 무엇을 만들긴 해야하는데 아직 어떻게 해야하는지 명확하게 정의된 게 없다보니 두루뭉실하게 “이런 객체가 필요하지 않을까?”라는 작은 발견의 과정(작은 기능의 추가)을 반복해서 수행해나가다보니 설계가 유연하게 약결합 될 것이다.이는 코드의 구조를 바꾸기 쉽다는 것을 뜻하며 추상적인 타입(인터페이스)를 사용한다는 것을 뜻하는 것 같다. 그리고 TDD에는 많은 이점들이 존재하지만 가장 중요한 건 개발자의 사고를 (구체적인) 구현이 아니라 코드의 설계에 대해 생각하도록 “지시”한다는 것이라고 한다.이러한 지시를 통해 내 코드가 테스트에 의해 “주도”되는 것이 아닐까 싶다.즉, 테스트가 내 코드를 주도하려면(테스트에 의한 개발이 되려면) 이러한 지시를 따라야하고, 이는 검증이 아닌 “설계”를 테스트의 주된 목적이라고 생각해야 달성 가능한 목표같다. Need-Driven Development그럼 TDD가 Design Activity라는 것은 알았는데 어떻게 더 나은 설계를 만들 것인가…?나는 그 답은 Need-Driven Development(Top-Down Development)를 통해 달성할 수 있다고 믿는다. A core principle of Lean Development is that value should be pulled into existence from demand,rather than pushed from implementation:“The effect of ‘pull’ is that production is not based on forecast;commitment is delayed until demand is present to indicate what the customer really wants.” 영어를 잘 하지 못해 뉘앙스를 정확히 이해한 건지는 모르겠지만, Lean Development(개발 프로세스에서 비효율 적인 부분을 제거한 방법론 정도로 알고 있다.)의 핵심 원칙은 존재하는 요구사항(existence from demand)에서 가치를 뽑아와야한다(be pulled)는 것 같다.예측에 의해 뭔가를 만들어내기 보다는 “고객이 정말로 원하는 것”이 실제로 나타낼 때까지 commitment(뭔가를 확정짓는…?)를 계속 뒤로 미루라는 것 같다.고객도 자신이 무엇을 원하는지 정확히 모르기 때문에 요구사항이 명확해질 때까지 계속 요구사항을 명쾌하게 만들어나가는 과정이 필요한 것 같다. “혹시 이런 기능도 필요하지 않을까?”라고 생각하다 보면 위와 같은 형태의 소프트웨어가 나오게 될 가능성이 높을 것이다. 결국 “정말 필요한 기능”만 개발하라는 것인데 어떻게 해야하는 것일까…?? By testing an object in isolation,the programmer is forced to consider an object’s interactions with its collaborators in the abstract,possibly before those collaborators exist.TDD with Mock Objects guides interface design by the services that an object requires,not just those it provides.This process results in a system of narrow interfaces each of which defines a role in an interaction between objects,rather than wide interfaces that describe all the features provided by a class.We call this approach Need-Driven Development. 단위 테스트에서 개발자는 객체와 협력객체 사이의 상호작용을 신경쓰도록 강요된다.그것또한 추상적인 레벨에서 이루어지는데 왜냐하면 협력 객체들은 아직 존재도 하기 전이기 때문이다.왜냐하면 TDD에 의해 테스트를 먼저 작성하고, Need-Driven Development에 의해 불필요한 객체는 아직 생성도 하기 전이기 때문이다.이 시점에서 협력 객체는 커녕 아직 테스트하고자 하는 객체도 만들어지기 이전이다.Mock Object로 TDD를 하는 건 단순히 객체가 제공하는 것 뿐만이 아니라 해당 객체가 필요로 하는 요구사항에 의해 인터페이스 설계를 가이드 한다.이런 과정을 통해 narrow 인터페이스를 가진 시스템이 나오게 된다.여기서 narrow한 인터페이스란 건 객체 사이의 상호작용에서 특정 역할만 수행한다는 것을 의미한다는 것 같다.반면에 wide한 인터페이스는 여기저기서 사용할 수 있는 걸 뜻하며 하는 일이 굉장히 많은 객체를 뜻하는 것 같다.이런 접근법을 Need-Driven Devlopment라고 부른다는데 좀 더 자세한 예시는 아래 나오게 된다. To fulfil the needs of A, we discover that it needs a service S.While testing A, we mock the responsibilities of S without defining a concrete implementation. A의 요구사항을 만족시키기 위해 S라는 서비스가 필요하다는 걸 발견(discovery)하게 된다.이 때 S의 구체적인 구현을 정의하는 것이 아니라 해당 책임을 모킹한다. Once we have implemented A to satisfy its requirements we can switch focus and implement an object that performs the role of S…This process will then discover services required by B,which we again mock out until we have finished our implementation of B A의 요구사항 구현이 모두 끝났으면 이제 S의 “역할”을 수행하는 객체를 구현하는 것에 집중할 수 있다.이제 B(S의 역할을 수행하는)가 필요로하는 서비스를 발견하는 절차들이 진행된다.그리고 B의 구현이 끝날 때까지 그런 서비스들은 모킹하게 된다. Our experience is that systems we produce this way tend towards very flat class hierarchies.This avoids well-known problems, such as the Fragile Base Class,which make systems harder to understand and modify. 이런 식으로 필요한 객체와 역할들을 발견(탐색)해 나가는 과정에서 매우 flat한 클래스 계층이 나온다고 한다.이는 깨지기 쉬운(Fragile) Base Class 문제를 피할 수도 있다.많은 클래스들이 해당 클래스에 의존하는 구조가 아니라 인접한 객체끼리만 관계를 맺고 있기 때문이 아닐까 싶다.또한 상속이 아닌 인터페이스를 사용하고 있기 때문에 인터페이스가 바뀌지 않는 한 부모 객체에 영향을 받지 않는 것도 한 몫 하는 것 같다. (자바8의 인터페이스는 부모 인터페이스에 기본 구현체(default method)가 존재할 수 있긴 하지만…) This process is similar to traditional Top-Down Development,in which the programmer starts at the highest level of abstraction and proceeds, layer by layer, to fill in the detail.The intention is that each layer of code is written in a coherent terminology,defined in terms of the next level of abstraction Need-Driven Development는 전통적인 Top-Down Development와도 유사한데Top-Down Development에서는 가장 높은 레벨의 추상화에서 시작해서 구체적인 내용을 구현하기 위해 계층 별로 접근하게 된다.각 계층의 코드는 다음 단계의 추상화에 정의된 “일관된 용어”로 작성된다.핵심은 “일관된 용어로 정의된다”는 것에 있는 것 같다.이는 일관된 추상화 수준을 뜻하는 게 아닐까? Programming from the Bottom-Up has different risks.All the authors have had the experience of developing a supporting class in isolation,as part of a larger task,only to find that the result was not right because we had misunderstood something. 반면 Bottom-up으로 프로그래밍 하는 건 다른 리스크를 가지고 있다. (논문에서 Top-Down은 각 레이어에서 중복을 야기한다는 리스크를 명시하고 있다.)독립된 환경에서 개발해봤는데 뭔가 잘못 이해하고 개발한 게 있어서 결과가 올바르지 않은 걸 발견했다는 것이다.아마 이게 필요하지 않을까? 나는 이거까지 책임져야하지 않을까? 하고 예측을 기반으로 각자 개발을 하다보니 나중에 객체 간의 협력을 해야할 때 뭔가 미묘하게 안 맞는 부분이 계속 생겼던 게 아닐까 싶다. Need-Driven Development이라는 아티클을 보면 Need-Driven Development(Top-Down)과 Bottom-up의 차이가 좀 더 명확히 느껴질 것이다. 결론TDD는 단순히 테스트를 “먼저” 작성하는 게 아니라 테스트가 내 코드를 “주도”하게 만들어야하는 것 같다.그럼 좀 더 테스트가 막강한 권력을 가지고 테스트가 내 코드를 어떠한 길로 인도(guide)해야하는 것 같다.좀 더 강하게는 강제(force)하거나 지시(direct)를 내려야하는 것 같다.나는 멍청하고 테스트가 내 코드가 어떻게 구현해야하는지 명령을 내리는 것이다. 그런 관점에서 보면 단순 “검증”만으로는 뭔가 부족했던 것 같다.그걸 모르고 계속 TDD 거리니 매번 실패 했던 게 아닐까 싶다. 해당 논문을 읽고 나니 “Design Activity”가 무엇인지, 요구사항이 왜 중요한 것인지 좀 더 알게 된 거 같다.","categories":[{"name":"Test","slug":"Test","permalink":"https://perfectacle.github.io/categories/Test/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://perfectacle.github.io/tags/TDD/"},{"name":"mock","slug":"mock","permalink":"https://perfectacle.github.io/tags/mock/"},{"name":"test","slug":"test","permalink":"https://perfectacle.github.io/tags/test/"},{"name":"design","slug":"design","permalink":"https://perfectacle.github.io/tags/design/"}]},{"title":"(Tomcat) ClientAbortException은 왜 발생할까? (Part 2)","slug":"client-abort-exception-deep-dive-part-02","date":"2022-03-20T10:30:19.000Z","updated":"2022-10-30T08:42:16.335Z","comments":true,"path":"2022/03/20/client-abort-exception-deep-dive-part-02/","link":"","permalink":"https://perfectacle.github.io/2022/03/20/client-abort-exception-deep-dive-part-02/","excerpt":"서버에서 아주 가끔가다가 ClientAbortException(java.io.IOExceiption: Broken pipe)이 발생해서 어떨 때 발생하는지 딥다이브 해봄. 적다보니 글이 길어져 글을 나누었는데 해당 글을 읽기 전에 (Tomcat) ClientAbortException은 왜 발생할까? (Part 1)을 먼저 보는 것을 추천함. https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/ClientAbortException.html","text":"서버에서 아주 가끔가다가 ClientAbortException(java.io.IOExceiption: Broken pipe)이 발생해서 어떨 때 발생하는지 딥다이브 해봄. 적다보니 글이 길어져 글을 나누었는데 해당 글을 읽기 전에 (Tomcat) ClientAbortException은 왜 발생할까? (Part 1)을 먼저 보는 것을 추천함. https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/ClientAbortException.html Extend IOException to identify it as being caused by an abort of a request by a remote client. 외부 클라이언트 측에서 요청을 abort(중단) 시켰을 때 발생하는 예외로 보인다.톰캣에서 발생시키는 예외인데 Spring Boot의 Web(Mvc) 모듈에서 기본적으로 사용하는 게 Embedded Tomcat이기 때문에 많은 분들께서 자주 마주치지 않았을까… 싶다.구글링 해보면 뭐 브라우저 이슈(API 응답이 오기 전에 새로고침을 했다던가, 뒤로가기를 했다던가 등등)니 뭐니 하는데 내가 겪은 상황은 server → server 통신에서 발생한 것이기 때문에 서버 간의 통신 관점에서만 파보았다. 삽질을 해보고 싶은 사람은 https://github.com/perfectacle/client-abort-exception-playground 을 clone 하면 된다. 그리고 ClientAbortException이 발생해도 스프링에서 기본적으로 HandlerExceptionResolver에서 예외를 핸들링하기 때문에 로그에는 아무것도 남지 않는다.따라서 해당 에러가 발생하는지 에러 로그로 명확히 확인해보는 게 훨씬 직관적이기 때문에 아래 @RestControllerAdvice를 추가했다. 123456789101112@RestControllerAdviceclass ControllerAdvice &#123; private val log = LoggerFactory.getLogger(this::class.java) @ExceptionHandler(value = [Exception::class]) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) fun handleException(e: Exception): ResponseEntity&lt;Void&gt; &#123; log.error(e.message, e) return ResponseEntity.internalServerError().build() &#125;&#125; N줄 요약 클라이언트가 응답 패킷을 받는 와중에 Read Timeout 시간을 초과하면 각 응답 패킷의 시간 간격은 Read Timeout 안에 왔지만 모든 응답 패킷은 Read Timeout 안에 오지 않았다면 Read Timeout의 의미는 모든 응답 패킷을 받는데까지 걸리는 시간이 아니라 각 응답 패킷 사이의 Timeout을 의미한다. (그래서 Apach HTTP Client는 오해의 소지를 줄이고자인지 socketTimeout이라고 부르고 있다.) 따라서 총 응답 패킷을 다 받는데까지는 Read Timeout에 설정한 시간을 초과해도 클라이언트&#x2F;서버 모두 아무런 오류가 발생하지 않는다. 각 응답 패킷의 시간 간격이 Read Timeout 안에 오지 않은 경우 Read Timeout의 의미는 각 응답 패킷 사이의 Timeout을 의미한다. 응답 패킷이 계속해서 잘 오다가 특정 패킷 하나만 Read Timeout을 초과하더라도 Read Timeout이 발생한다. 클라이언트 측에서 Read Timeout이 발생해서 소켓을 종료한 이후에도 서버 측에서 응답 패킷을 보내면 ClientAbortException이 발생한다. ClientAbortException을 해결하려면? 프로세스(메인 함수)가 종료되더라도 Passive Close로부터 FIN 패킷을 받지 않으면 클라이언트&#x2F;서버의 소켓은 닫히지 않는다. (오동작을 막기 위해 대기하는 것으로 알고 있음.)하지만 Passive Close로부터 FIN 패킷이 아닌 다른 패킷이 오면 Active Close에서는 RST 패킷을 보낸 후 소켓을 닫는다.60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨) 만큼) 동안 대기 후에도 Passive Close에게 아무런 패킷이 오지 않으면 Active Close는 RST 패킷을 보내고 소켓을 닫는다.1234567# mac (60_000ms)sysctl -a | grep net.inet.tcp.fin_timeoutnet.inet.tcp.fin_timeout: 60000# linux alpine (60s)sysctl -a | grep net.ipv4.tcp_fin_timeoutnet.ipv4.tcp_fin_timeout = 60 소켓이 정상 종료된 경우에 ACTIVE_CLOSE 측에서 소켓이 바로 사라지는 게 아니라 오동작을 막기 위해 TIME_WAIT 상태로 대기하다가 사라지게 되는데 그 전까지는 해당 소켓(로컬ip:로컬port, 서버ip:서버port 쌍)을 사용하지 못한다.대기 시간은 대부분 60초(OS마다 다르지만 2 * MSL(Maximum Segment Lifetime, OS 커널 레벨에 하드코딩 돼있는데 대다수의 리눅스는 60로초 설정됨) 동안 대기 후에 사라지게 된다.1234567# mac (2 * msl = 2 * 15_000ms = 30_000ms)sysctl -a | grep net.inet.tcp.mslnet.inet.tcp.msl: 15000# linux alpinesysctl -a | grep msl# 몇몇 linux os는 tcp_fin_timeout을 2*msl로 사용하는 os도 있다고 함. (alpine linux도 아무것도 안 나오는 거 보면 그런 거 같음) HTTP Client 구현체마다 다르겠지만 Apache HTTP Client의 경우 Keep-Alive를 사용한다고 했음에도 불구하고 요청이 정상적으로 처리되지 않는 경우(Read Timeout 발생, 500 Internal Sever Error 응답을 받는다던지… 모든 4xx, 5xx가 포함되는 건 아님)에는 커넥션을 커넥션 풀에 반납하지 않고(재사용하지 않고) 종료한다. 클라이언트가 응답 패킷을 받는 시간이 Read Timout을 초과한 경우1. 각 응답 패킷의 시간 간격은 Read Timeout 안에 왔지만 모든 응답 패킷은 Read Timeout 안에 오지 않은 경우서버 쪽 API에서 큰 응답을 준다고 가정 12345678910@RestControllerclass LargeResponseController &#123; private val log = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/large&quot;) fun slow(): String &#123; log.info(&quot;request is arrived!&quot;) return &quot;done!&quot;.repeat(1_000_000) &#125;&#125; 클라이언트 측은 응답을 받다가 끊어야하기 때문에 리드 타임아웃 설정을 25ms로 매우 짧게 설정함. 12345678910111213141516171819202122232425262728fun main() &#123; val readTimeout = Duration.ofMillis(25L) val restTemplate = RestTemplate( HttpComponentsClientHttpRequestFactory( HttpClientBuilder .create() .setMaxConnPerRoute(100) .setMaxConnTotal(100) .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy()) .setDefaultRequestConfig( RequestConfig.custom().setSocketTimeout(readTimeout.toMillis().toInt()).build() ) .build() ) ) try &#123; restTemplate.getForObject(&quot;http://localhost:8080/large&quot;, String::class.java) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; println(&quot;[$&#123;LocalDateTime.now()&#125;] request is done!&quot;) &#125; // 커넥션 풀에 있는 커넥션을 바로 종료하지 않기 위해 10초간 슬립 Thread.sleep(10_000L) println(&quot;[$&#123;LocalDateTime.now()&#125;] main function is done!&quot;)&#125; 데모 영상 클라이언트 로그 (콘솔에 응답을 로깅하느라 짤림…)12345678910111206:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!do&quot;06:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;ne!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done&quot;06:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!d&quot;06:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;one!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!don&quot;06:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;e!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!done!&quot;06:56:05.670 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection [id: 0][route: &#123;&#125;-&gt;http://localhost:8080] can be kept alive for 60.0 seconds06:56:05.670 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: set socket timeout to 006:56:05.670 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 1; route allocated: 1 of 100; total allocated: 1 of 100][2022-03-20T06:56:05.674] request is done![2022-03-20T06:56:15.679] main function is done!Process finished with exit code 0 06:56:05.670에 마지막 응답 패킷을 받음 (06:56:05.670 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;e!done!done!done!done!done!done!done!done!done!done!don...) 06:56:05.670에 커넥션을 종료하지 않고 커넥션 풀에 반납함 (Keep-Alive 설정에 따라 60초 동안 idle 상태의 커넥션이라도 보관함, 06:56:05.670 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 1; route allocated: 1 of 100; total allocated: 1 of 100]) 06:56:15.679에 메인함수 종료 서버 로그12022-03-20 06:56:05.568 INFO 86561 --- [nio-8080-exec-1] c.e.playground.LargeResponseController : request is arrived! 06:56:05.568에 요청 도착 패킷 로그 (소켓 상태)12345678910111213141516171819202122231 2022-03-20 06:56:05.565966 127.0.0.1 127.0.0.1 TCP 68 51612 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=4237975396 TSecr=0 SACK_PERM=1232 2022-03-20 06:56:05.566176 127.0.0.1 127.0.0.1 TCP 68 8080 → 51612 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=3590453492 TSecr=4237975396 SACK_PERM=1233 2022-03-20 06:56:05.566202 127.0.0.1 127.0.0.1 TCP 56 51612 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=4237975396 TSecr=3590453492234 2022-03-20 06:56:05.566226 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 8080 → 51612 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3590453492 TSecr=4237975396235 2022-03-20 06:56:05.568288 127.0.0.1 127.0.0.1 HTTP 274 GET /large HTTP/1.1236 2022-03-20 06:56:05.568329 127.0.0.1 127.0.0.1 TCP 56 8080 → 51612 [ACK] Seq=1 Ack=219 Win=408064 Len=0 TSval=3590453495 TSecr=4237975399237 2022-03-20 06:56:05.582682 127.0.0.1 127.0.0.1 TCP 8248 8080 → 51612 [PSH, ACK] Seq=1 Ack=219 Win=408064 Len=8192 TSval=3590453510 TSecr=4237975399 [TCP segment of a reassembled PDU]238 2022-03-20 06:56:05.582700 127.0.0.1 127.0.0.1 TCP 8248 8080 → 51612 [PSH, ACK] Seq=8193 Ack=219 Win=408064 Len=8192 TSval=3590453510 TSecr=4237975399 [TCP segment of a reassembled PDU]239 2022-03-20 06:56:05.582717 127.0.0.1 127.0.0.1 TCP 8248 8080 → 51612 [PSH, ACK] Seq=16385 Ack=219 Win=408064 Len=8192 TSval=3590453510 TSecr=4237975399 [TCP segment of a reassembled PDU]240 2022-03-20 06:56:05.582730 127.0.0.1 127.0.0.1 TCP 8248 8080 → 51612 [PSH, ACK] Seq=24577 Ack=219 Win=408064 Len=8192 TSval=3590453510 TSecr=4237975399 [TCP segment of a reassembled PDU]241 2022-03-20 06:56:05.582740 127.0.0.1 127.0.0.1 TCP 56 51612 → 8080 [ACK] Seq=219 Ack=8193 Win=400064 Len=0 TSval=4237975414 TSecr=3590453510...856 2022-03-20 06:56:05.648652 127.0.0.1 127.0.0.1 TCP 12387 8080 → 51612 [PSH, ACK] Seq=4987837 Ack=219 Win=408064 Len=12331 TSval=3590453575 TSecr=4237975479 [TCP segment of a reassembled PDU]857 2022-03-20 06:56:05.648660 127.0.0.1 127.0.0.1 TCP 56 51612 → 8080 [ACK] Seq=219 Ack=4987837 Win=250048 Len=0 TSval=4237975479 TSecr=3590453575858 2022-03-20 06:56:05.653137 127.0.0.1 127.0.0.1 TCP 12387 [TCP Retransmission] 8080 → 51612 [PSH, ACK] Seq=4987837 Ack=219 Win=408064 Len=12331 TSval=3590453579 TSecr=4237975479859 2022-03-20 06:56:05.653169 127.0.0.1 127.0.0.1 TCP 68 51612 → 8080 [ACK] Seq=219 Ack=5000168 Win=499008 Len=0 TSval=4237975483 TSecr=3590453575 SLE=4987837 SRE=5000168860 2022-03-20 06:56:05.666381 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 51612 → 8080 [ACK] Seq=219 Ack=5000168 Win=763648 Len=0 TSval=4237975497 TSecr=3590453575861 2022-03-20 06:56:05.670136 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 51612 → 8080 [ACK] Seq=219 Ack=5000168 Win=1025792 Len=0 TSval=4237975500 TSecr=3590453575866 2022-03-20 06:56:16.068837 127.0.0.1 127.0.0.1 TCP 56 51612 → 8080 [FIN, ACK] Seq=219 Ack=5000168 Win=1045248 Len=0 TSval=4237985900 TSecr=3590453575867 2022-03-20 06:56:16.068992 127.0.0.1 127.0.0.1 TCP 56 8080 → 51612 [ACK] Seq=5000168 Ack=220 Win=408064 Len=0 TSval=3590463996 TSecr=4237985900870 2022-03-20 06:56:16.069677 127.0.0.1 127.0.0.1 TCP 56 8080 → 51612 [FIN, ACK] Seq=5000168 Ack=220 Win=408064 Len=0 TSval=3590463996 TSecr=4237985900871 2022-03-20 06:56:16.069725 127.0.0.1 127.0.0.1 TCP 56 51612 → 8080 [ACK] Seq=220 Ack=5000169 Win=1045248 Len=0 TSval=4237985900 TSecr=3590463996 231 ~ 233번 패킷은 TCP 3 Way Handshake (syn, syn&#x2F;ack, ack) 235번 패킷에서 클라이언트 → 서버로 HTTP 요청 패킷 전송 (06:56:05.568288) 236번 패킷에서 서버가 요청 잘 받았다고 클라이언트한테 ACK 패킷 전송 (06:56:05.568329) 237번 패킷은 서버에서 온 응답인데 ACK를 받은 06:56:05.568329에서 Read Timeout으로 설정한 25ms 이전에 도착함 (06:56:05.582682) 238 ~ 240번 패킷은 서버에서 응답 패킷을 쪼개서 보내고 있음 (06:56:05.582700 ~ 06:56:05.582730) 241번 패킷은 클라이언트가 서버한테 응답 패킷 잘 받았다고 ACK 패킷을 보내고 있음 (06:56:05.582740) 858번 패킷은 마지막 응답 패킷인데 패킷 유실 때문인지 재전송을 하고 있다. (06:56:05.653137)원래 클라이언트가 생각했던 Read Timeout 25ms는 최초 ACK를 받은 06:56:05.568329 시점부터 계산해보면 06:56:05.593329이다.근데 마지막 응답 패킷이 온 걸 보면 06:56:05.653137으로 실제로는 ACK를 받은 시점으로부터 85ms가 흘렀다.즉, Read Timeout은 클라이언트의 모든 요청을 받은 시간이 아닌 각 응답 패킷을 받는데까지 걸리는 시간이다. 859번 패킷에서 응답 패킷을 잘 받았다는 마지막 ACK 패킷을 서버에게 보내고 있다. (06:56:05.653169) 866 ~ 871번 패킷은 TCP Connection Termination (FIN&#x2F;ACK&#x2F;FIN&#x2F;ACK)이다. (06:56:16.068837 ~ 06:56:16.069725)클라이언트가 먼저 연결을 종료하겠다는 FIN 패킷을 보냈기 때문에 클라이언트가 Active Close서버는 클라이언트로부터 FIN 패킷을 받았기 때문에 서버는 Passive Close가 됨(무조건 클라이언트가 Active Close는 아니고 경우에 따라서 다름)마지막 패킷을 받은 이후 10초 동안 메인 함수의 Thread.sleep을 했기 때문에 10초 이후에 메인 함수가 종료(프로세스가 종료)되면서 커넥션을 끊게 되는 것이다. 소켓이 종료된 이후에 바로 해당 소켓이 사라지는 게 아니라 오동작을 막기 위해 30초(OS마다 다르지만 2 * MSL(Maximum Segment Lifetime, OS 커널 레벨에 하드코딩 돼있는데 대다수의 리눅스는 60로초 설정됨, 내가 쓰는 맥os는 30초)) 동안 TIME_WAIT 상태에서 대기를 함. (06:56:16) 30초가 지나면 소켓이 사라지고 해당 소켓(로컬ip:로컬port, 서버ip:서버port 쌍)을 재사용 할 수 있다. (06:56:47) 2. 각 응답 패킷의 시간 간격이 Read Timeout 안에 오지 않은 경우서버 쪽 API에서 각 응답을 주는 패킷의 지연시간이 제각각이라고 가정 1234567891011121314151617181920212223242526272829303132333435@RestControllerclass StreamResponseController &#123; private val executor = Executors.newCachedThreadPool() private val log = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/stream&quot;) fun stream(): ResponseEntity&lt;ResponseBodyEmitter&gt; &#123; val emitter = ResponseBodyEmitter() executor.execute &#123; try &#123; Thread.sleep(100L) emitter.send(&quot;hello, once&quot;, MediaType.TEXT_PLAIN) log.info(&quot;hello, once&quot;) Thread.sleep(100L) emitter.send(&quot;hello, twice&quot;, MediaType.TEXT_PLAIN) log.info(&quot;hello, twice&quot;) Thread.sleep(500L) // 최대 지연 시간 emitter.send(&quot;hello, thrice&quot;, MediaType.TEXT_PLAIN) log.info(&quot;hello, thrice&quot;) Thread.sleep(100L) emitter.send(&quot;bye&quot;, MediaType.TEXT_PLAIN) log.info(&quot;bye&quot;) emitter.complete() &#125; catch (e: Exception) &#123; emitter.completeWithError(e) log.error(e.message, e) &#125; &#125; return ResponseEntity(emitter, HttpStatus.OK) &#125;&#125; 클라이언트 측은 서버 측 응답 패킷의 최대 지연 시간보다 짧게 Read Timeout을 설정함. 1234567891011121314151617181920212223242526272829fun main() &#123; val readTimeout = Duration.ofMillis(200L) val restTemplate = RestTemplate( HttpComponentsClientHttpRequestFactory( HttpClientBuilder .create() .setMaxConnPerRoute(100) .setMaxConnTotal(100) .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy()) .setDefaultRequestConfig( RequestConfig.custom().setSocketTimeout(readTimeout.toMillis().toInt()).build() ) .build() ) ) try &#123; restTemplate.getForObject(&quot;http://localhost:8080/stream&quot;, String::class.java) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; println(&quot;[$&#123;LocalDateTime.now()&#125;] request is done!&quot;) &#125; // 커넥션 풀에 있는 커넥션을 바로 종료하지 않기 위해 10초간 슬립 Thread.sleep(10_000L) println(&quot;[$&#123;LocalDateTime.now()&#125;] main function is done!&quot;)&#125; 데모 영상 클라이언트 로그123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858610:04:13.248 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://localhost:8080/stream10:04:13.254 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]10:04:13.282 [main] DEBUG org.apache.http.client.protocol.RequestAddCookies - CookieSpec selected: default10:04:13.285 [main] DEBUG org.apache.http.client.protocol.RequestAuthCache - Auth cache not set in the context10:04:13.285 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection request: [route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100]10:04:13.289 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection leased: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 1 of 100; total allocated: 1 of 100]10:04:13.290 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Opening connection &#123;&#125;-&gt;http://localhost:808010:04:13.293 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connecting to localhost/127.0.0.1:808010:04:13.294 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:55447&lt;-&gt;127.0.0.1:808010:04:13.294 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: set socket timeout to 20010:04:13.294 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Executing request GET /stream HTTP/1.110:04:13.294 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Target auth state: UNCHALLENGED10:04:13.294 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Proxy auth state: UNCHALLENGED10:04:13.294 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; GET /stream HTTP/1.110:04:13.294 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept: text/plain, application/json, application/*+json, */*10:04:13.294 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Host: localhost:808010:04:13.294 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Connection: Keep-Alive10:04:13.295 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)10:04:13.295 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept-Encoding: gzip,deflate10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;GET /stream HTTP/1.1[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept: text/plain, application/json, application/*+json, */*[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Host: localhost:8080[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Connection: Keep-Alive[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept-Encoding: gzip,deflate[\\r][\\n]&quot;10:04:13.295 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;HTTP/1.1 200 [\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Transfer-Encoding: chunked[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Date: Sun, 20 Mar 2022 01:04:13 GMT[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Keep-Alive: timeout=60[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Connection: keep-alive[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;b[\\r][\\n]&quot;10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;hello, once[\\r][\\n]&quot;10:04:13.402 [main] DEBUG org.apache.http.headers - http-outgoing-0 &lt;&lt; HTTP/1.1 200 10:04:13.402 [main] DEBUG org.apache.http.headers - http-outgoing-0 &lt;&lt; Transfer-Encoding: chunked10:04:13.402 [main] DEBUG org.apache.http.headers - http-outgoing-0 &lt;&lt; Date: Sun, 20 Mar 2022 01:04:13 GMT10:04:13.402 [main] DEBUG org.apache.http.headers - http-outgoing-0 &lt;&lt; Keep-Alive: timeout=6010:04:13.402 [main] DEBUG org.apache.http.headers - http-outgoing-0 &lt;&lt; Connection: keep-alive10:04:13.404 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Connection can be kept alive for 60000 MILLISECONDS10:04:13.406 [main] DEBUG org.springframework.web.client.RestTemplate - Response 200 OK10:04:13.407 [main] DEBUG org.springframework.web.client.RestTemplate - Reading to [java.lang.String] as &quot;application/octet-stream&quot;10:04:13.506 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;c[\\r][\\n]&quot;10:04:13.507 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;hello, twice[\\r][\\n]&quot;10:04:13.712 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;10:04:13.712 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection10:04:13.713 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Connection discarded10:04:13.713 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100]10:04:13.715 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Socket closed&quot;[2022-03-20T10:04:13.719] request is done!org.springframework.web.client.RestClientException: Error while extracting response for type [class java.lang.String] and content type [application/octet-stream]; nested exception is java.net.SocketTimeoutException: Read timed out at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:120) at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:778) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:334) at com.example.playground.StreamResponseRestTemplatePlaygroundKt.main(StreamResponseRestTemplatePlayground.kt:29) at com.example.playground.StreamResponseRestTemplatePlaygroundKt.main(StreamResponseRestTemplatePlayground.kt)Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84) at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137) at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153) at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280) at org.apache.http.impl.io.ChunkedInputStream.getChunkSize(ChunkedInputStream.java:261) at org.apache.http.impl.io.ChunkedInputStream.nextChunk(ChunkedInputStream.java:222) at org.apache.http.impl.io.ChunkedInputStream.read(ChunkedInputStream.java:183) at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:135) at java.io.FilterInputStream.read(FilterInputStream.java:133) at java.io.PushbackInputStream.read(PushbackInputStream.java:186) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.Reader.read(Reader.java:140) at org.springframework.util.StreamUtils.copyToString(StreamUtils.java:91) at org.springframework.http.converter.StringHttpMessageConverter.readInternal(StringHttpMessageConverter.java:96) at org.springframework.http.converter.StringHttpMessageConverter.readInternal(StringHttpMessageConverter.java:44) at org.springframework.http.converter.AbstractHttpMessageConverter.read(AbstractHttpMessageConverter.java:199) at org.springframework.web.client.HttpMessageConverterExtractor.extractData(HttpMessageConverterExtractor.java:114) ... 5 more[2022-03-20T10:04:23.725] main function is done!Process finished with exit code 0 10:04:13.294에 서버와 커넥션 맺음. (10:04:13.294 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:55447&lt;-&gt;127.0.0.1:8080) 10:04:13.295에 요청 전송 (10:04:13.295 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; ...) 10:04:13.401에 첫 번째 응답이 옴 (대략 100ms 이후에 옴, 10:04:13.401 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;hello, once[\\r][\\n]&quot;) 10:04:13.507에 두 번째 응답이 옴 (대략 100ms 이후에 옴, 10:04:13.507 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;hello, twice[\\r][\\n]&quot;) 10:04:13.712에 Read Timeout 발생 (마지막 패킷이 온 이후로 정확히 우리가 설정한 200ms 후에 발생함, 10:04:13.712 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;) 10:04:13.712 ~ 10:04:13.715에 커넥션 종료 (Keep-Alive 설정했음에도 불구하고, 정상적인 응답을 받지 못했으면 커넥션을 종료함. 10:04:13.712 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection) 10:04:23.725에 메인함수 종료 서버 로그123456789101112131415161718192021222324252627282930313233343536373839404142432022-03-20 10:04:13.401 INFO 54891 --- [pool-1-thread-3] c.e.playground.StreamResponseController : hello, once2022-03-20 10:04:13.506 INFO 54891 --- [pool-1-thread-3] c.e.playground.StreamResponseController : hello, twice2022-03-20 10:04:14.012 INFO 54891 --- [pool-1-thread-3] c.e.playground.StreamResponseController : hello, thrice2022-03-20 10:04:14.118 ERROR 54891 --- [pool-1-thread-3] c.e.playground.StreamResponseController : java.io.IOException: Broken pipeorg.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:310) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:273) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:118) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at sun.nio.cs.StreamEncoder.implFlush(StreamEncoder.java:297) ~[na:1.8.0_322] at sun.nio.cs.StreamEncoder.flush(StreamEncoder.java:141) ~[na:1.8.0_322] at java.io.OutputStreamWriter.flush(OutputStreamWriter.java:229) ~[na:1.8.0_322] at org.springframework.util.StreamUtils.copy(StreamUtils.java:148) ~[spring-core-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:126) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:44) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:227) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler$HttpMessageConvertingHandler.sendInternal(ResponseBodyEmitterReturnValueHandler.java:212) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler$HttpMessageConvertingHandler.send(ResponseBodyEmitterReturnValueHandler.java:205) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitter.sendInternal(ResponseBodyEmitter.java:205) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitter.send(ResponseBodyEmitter.java:199) ~[spring-webmvc-5.3.16.jar:5.3.16] at com.example.playground.StreamResponseController.stream$lambda-0(StreamResponseController.kt:35) ~[main/:na] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_322] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_322] at java.lang.Thread.run(Thread.java:750) ~[na:1.8.0_322]Caused by: java.io.IOException: Broken pipe at sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[na:1.8.0_322] at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.write(IOUtil.java:65) ~[na:1.8.0_322] at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:470) ~[na:1.8.0_322] at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:135) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1376) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:766) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:719) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:709) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:573) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.filters.ChunkedOutputFilter.flush(ChunkedOutputFilter.java:157) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:221) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:1255) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:402) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.Response.action(Response.java:209) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:306) ~[tomcat-embed-core-9.0.58.jar:9.0.58] ... 17 common frames omitted 10:04:13.401에 첫 번째 응답 전송 10:04:13.506에 두 번째 응답 전송 (100ms 지연) 10:04:14.012에 세 번째 응답 전송 (500ms 지연) 10:04:14.118에 ClientAbortException(java.io.IOException: Broken pipe) 발생 소켓이 종료된 상태에서 “bye”라는 응답 패킷을 전송하려다 발생함. 패킷 로그워낙 순식간에 지나가서 netstat으로 소켓의 상태는 관찰하지 못함. 1234567891011121314174 2022-03-20 10:04:13.293423 127.0.0.1 127.0.0.1 TCP 68 55447 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=811634482 TSecr=0 SACK_PERM=1175 2022-03-20 10:04:13.293697 127.0.0.1 127.0.0.1 TCP 68 8080 → 55447 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=3020801649 TSecr=811634482 SACK_PERM=1176 2022-03-20 10:04:13.293717 127.0.0.1 127.0.0.1 TCP 56 55447 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=811634482 TSecr=3020801649177 2022-03-20 10:04:13.293729 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 8080 → 55447 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3020801649 TSecr=811634482178 2022-03-20 10:04:13.295356 127.0.0.1 127.0.0.1 HTTP 275 GET /stream HTTP/1.1 179 2022-03-20 10:04:13.295402 127.0.0.1 127.0.0.1 TCP 56 8080 → 55447 [ACK] Seq=1 Ack=220 Win=408064 Len=0 TSval=3020801651 TSecr=811634484180 2022-03-20 10:04:13.401563 127.0.0.1 127.0.0.1 TCP 202 8080 → 55447 [PSH, ACK] Seq=1 Ack=220 Win=408064 Len=146 TSval=3020801757 TSecr=811634484 [TCP segment of a reassembled PDU]181 2022-03-20 10:04:13.401620 127.0.0.1 127.0.0.1 TCP 56 55447 → 8080 [ACK] Seq=220 Ack=147 Win=408128 Len=0 TSval=811634590 TSecr=3020801757182 2022-03-20 10:04:13.506841 127.0.0.1 127.0.0.1 TCP 73 8080 → 55447 [PSH, ACK] Seq=147 Ack=220 Win=408064 Len=17 TSval=3020801863 TSecr=811634590 [TCP segment of a reassembled PDU]183 2022-03-20 10:04:13.506895 127.0.0.1 127.0.0.1 TCP 56 55447 → 8080 [ACK] Seq=220 Ack=164 Win=408128 Len=0 TSval=811634696 TSecr=3020801863184 2022-03-20 10:04:13.713445 127.0.0.1 127.0.0.1 TCP 56 55447 → 8080 [FIN, ACK] Seq=220 Ack=164 Win=408128 Len=0 TSval=811634902 TSecr=3020801863185 2022-03-20 10:04:13.713503 127.0.0.1 127.0.0.1 TCP 56 8080 → 55447 [ACK] Seq=164 Ack=221 Win=408064 Len=0 TSval=3020802069 TSecr=811634902186 2022-03-20 10:04:14.012150 127.0.0.1 127.0.0.1 TCP 74 HTTP/1.1 200 [TCP segment of a reassembled PDU]187 2022-03-20 10:04:14.012215 127.0.0.1 127.0.0.1 TCP 44 55447 → 8080 [RST] Seq=221 Win=0 Len=0 174 ~ 176번 패킷은 TCP 3 Way Handshake (syn, syn&#x2F;ack, ack) 178번 패킷에서 클라이언트 → 서버로 HTTP 요청 패킷 전송 (10:04:13.295356) 179번 패킷에서 서버가 요청 잘 받았다고 클라이언트한테 ACK 패킷 전송 (10:04:13.295402) 180번 패킷은 서버에서 온 첫 번째 응답 패킷(hello, once)인데 ACK를 받은 10:04:13.295402에서 Read Timeout으로 설정한 200ms 이전에 도착함 (10:04:13.401563) 181번 패킷은 서버에서 보낸 응답 패킷을 잘 받았다는 ACK 패킷을 클라이언트 -&gt; 서버로 보내고 있음. (10:04:13.401620) 182번 패킷은 서버에서 온 두 번째 응답 패킷(hello, twice)인데 마지막 응답 패킷(hello, once)을 받은 10:04:13.401563에서 Read Timeout으로 설정한 200ms 이전에 도착함 (10:04:13.506841) 183번 패킷은 서버에서 보낸 응답 패킷을 잘 받았다는 ACK 패킷을 클라이언트 -&gt; 서버로 보내고 있음. (10:04:13.506895) 184번 패킷은 서버에서 온 마지막 응답 패킷(hello, twice)을 받은 10:04:13.506841에서 Read Timeout으로 설정한 200ms이 넘도록 아무런 패킷이 오지 않아 Read Timeout이 발생해서 서버 측에 FIN&#x2F;ACK 패킷을 날려서 커넥션을 종료할 준비를 하고 있음. (10:04:13.713445) 185번 패킷에서 서버가 클라이언트로부터 FIN&#x2F;ACK 패킷을 잘 받았다고 반대로 ACK 패킷을 클라이언트에게 보냄 (10:04:13.713503) 클라이언트가 먼저 연결을 종료하겠다는 FIN 패킷을 보냈기 때문에 클라이언트가 Active Close서버는 클라이언트로부터 FIN 패킷을 받았기 때문에 서버는 Passive Close가 됨(무조건 클라이언트가 Active Close는 아니고 경우에 따라서 다름)그리고 아직까지는 서버(Passive Close)로부터 FIN 패킷을 받은 게 아니기 때문에 소켓이 정상적으로 종료된 게 아님. 186번 패킷에서 서버 → 클라이언트로 HTTP 세 번째 응답 패킷(hello, thrice) 전송 (10:04:14.012150, 마지막 응답 패킷(hello, twice)를 보낸 10:04:13.506841에서 500ms가 지난 시점임.) 187번 패킷을 보면 서버에서 FIN 패킷이 온 게 아니기 때문에 클라이언트는 다시 서버에게 RST 패킷을 보내서 소켓을 닫을 준비를 한다. (10:04:14.012215) 소켓이 닫혔기 때문에 “bye”라는 응답패킷은 전송되지 않았다. ClientAbortException을 해결하려면? 서버 측에서 처리 속도를 더 빠르게 한다. 처리 속도는 빠르지만 응답이 크다면 응답의 사이즈를 줄인 API를 제공한다 (불필요한 필드 제거 or 페이징 API 제공) 클라이언트 측 리드 타임아웃 설정값을 늘린다. 정 합의가 안 된다면 ClientAbortException을 핸들링 해서 log.info로만 남긴다. (장애 상황은 아니라서 불필요한 노이즈라고 판단된다는 가정 하에) 클라이언트 측에서는 ReadTimeout이 발생했다면(ClientAbortException 여부와 상관 없이), 장애 상황(고객에게 돈은 출금이 됐는데 주문은 완료처리 안 됐다던지)을 막기 위해 서버 측에 취소 API 같은 걸 호출하거나 상태 조회 API 같은 걸 호출한 이후 내가 처리를 따로 해야하는 건지 아닌지 판단한 후에 올바른 처리를 해줘야한다.","categories":[{"name":"tomcat","slug":"tomcat","permalink":"https://perfectacle.github.io/categories/tomcat/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://perfectacle.github.io/tags/Tomcat/"}]},{"title":"(Tomcat) ClientAbortException은 왜 발생할까? (Part 1)","slug":"client-abort-exception-deep-dive-part-01","date":"2022-03-20T03:30:19.000Z","updated":"2022-10-30T08:42:16.191Z","comments":true,"path":"2022/03/20/client-abort-exception-deep-dive-part-01/","link":"","permalink":"https://perfectacle.github.io/2022/03/20/client-abort-exception-deep-dive-part-01/","excerpt":"서버에서 아주 가끔가다가 ClientAbortException(java.io.IOExceiption: Broken pipe)이 발생해서 어떨 때 발생하는지 딥다이브 해봄. 적다보니 글이 길어져 글을 나누었는데 해당 글을 읽고 난 후에 (Tomcat) ClientAbortException은 왜 발생할까? (Part 2)를 마저 보는 것을 추천함. https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/ClientAbortException.html","text":"서버에서 아주 가끔가다가 ClientAbortException(java.io.IOExceiption: Broken pipe)이 발생해서 어떨 때 발생하는지 딥다이브 해봄. 적다보니 글이 길어져 글을 나누었는데 해당 글을 읽고 난 후에 (Tomcat) ClientAbortException은 왜 발생할까? (Part 2)를 마저 보는 것을 추천함. https://tomcat.apache.org/tomcat-9.0-doc/api/org/apache/catalina/connector/ClientAbortException.html Extend IOException to identify it as being caused by an abort of a request by a remote client. 외부 클라이언트 측에서 요청을 abort(중단) 시켰을 때 발생하는 예외로 보인다.톰캣에서 발생시키는 예외인데 Spring Boot의 Web(Mvc) 모듈에서 기본적으로 사용하는 게 Embedded Tomcat이기 때문에 많은 분들께서 자주 마주치지 않았을까… 싶다.구글링 해보면 뭐 브라우저 이슈(API 응답이 오기 전에 새로고침을 했다던가, 뒤로가기를 했다던가 등등)니 뭐니 하는데 내가 겪은 상황은 server → server 통신에서 발생한 것이기 때문에 서버 간의 통신 관점에서만 파보았다. 삽질을 해보고 싶은 사람은 https://github.com/perfectacle/client-abort-exception-playground 을 clone 하면 된다. 그리고 ClientAbortException이 발생해도 스프링에서 기본적으로 HandlerExceptionResolver에서 예외를 핸들링하기 때문에 로그에는 아무것도 남지 않는다.따라서 해당 에러가 발생하는지 에러 로그로 명확히 확인해보는 게 훨씬 직관적이기 때문에 아래 @RestControllerAdvice를 추가했다. 123456789101112@RestControllerAdviceclass ControllerAdvice &#123; private val log = LoggerFactory.getLogger(this::class.java) @ExceptionHandler(value = [Exception::class]) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) fun handleException(e: Exception): ResponseEntity&lt;Void&gt; &#123; log.error(e.message, e) return ResponseEntity.internalServerError().build() &#125;&#125; N줄 요약 클라이언트가 응답 패킷을 받기 전에 연결을 끊으면 ReadTimeout이 발생한 지 60초가 지나기 전에 응답 패킷을 보낸다면 (바로 소켓의 연결을 끊는 게 아니라 오동작을 막기 위해 60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨)) 동안 대기를 함.)1234567# mac (60_000ms)sysctl -a | grep net.inet.tcp.fin_timeoutnet.inet.tcp.fin_timeout: 60000# linux alpine (60s)sysctl -a | grep net.ipv4.tcp_fin_timeoutnet.ipv4.tcp_fin_timeout = 60 응답 패킷이 아주 작은 경우 (하나의 응답패킷에 담길 만큼) 아직 소켓이 완전히 닫힌 게 아니기 때문에 응답 패킷을 보낼 수 있기 때문에 ClientAbortException이 발생하지 않는다. ClientAbortException만 발생하지 않을 뿐이지, 클라이언트 측에서 정상적으로 응답 패킷을 받을 수 있는 건 아니다. 응답 패킷이 큰 경우 (하나의 응답 패킷에 담기지 않을 만큼) 아직 소켓이 완전히 닫힌 게 아니기 때문에 몇 개의 응답 패킷을 보낼 수 있다. 이 때는 ClientAbortException만 발생하지 않을 뿐이지, 클라이언트 측에서 정상적으로 응답 패킷을 받을 수 있는 건 아니다. 클라이언트 측에서는 FIN 패킷이 오길 원했는데 예상치 못한 패킷이 왔기 때문에 서버 측에 RST 패킷을 보낸 후 소켓을 닫는다. 나머지 응답 패킷을 보내려고 했는데 소켓이 닫혔기 때문에 서버 측에서 응답 패킷을 보내려다가 ClientAbortException이 발생한다. ReadTimeout이 발생한 지 60초가 지난 이후에 응답 패킷을 보낸다면 (혹은 클라이언트 측 서버 셧다운(배포 혹은 컴퓨터 종료)으로 인해 소켓이 종료된 이후에 보낸다면) 클라이언트가 ReadTimeout이 발생했다고 바로 소켓의 연결을 끊는 게 아니라 오동작을 막기 위해 60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨) 만큼) 동안 대기를 함. 그리고 60초가 지나면 클라이언트&#x2F;서버 소켓은 모두 종료됨. 이 상태에서 서버에서 응답 패킷을 보내려고 하면 소켓이 종료됐기 때문에 서버 측에서 응답 패킷을 보내려다가 ClientAbortException이 발생한다. ClientAbortException을 해결하려면? 프로세스(메인 함수)가 종료되더라도 Passive Close로부터 FIN 패킷을 받지 않으면 클라이언트&#x2F;서버의 소켓은 닫히지 않는다. (오동작을 막기 위해 대기하는 것으로 알고 있음.)하지만 Passive Close로부터 FIN 패킷이 아닌 다른 패킷이 오면 Active Close에서는 RST 패킷을 보낸 후 소켓을 닫는다.60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨) 만큼) 동안 대기 후에도 Passive Close에게 아무런 패킷이 오지 않으면 Active Close는 RST 패킷을 보내고 소켓을 닫는다. HTTP Client 구현체마다 다르겠지만 Apache HTTP Client의 경우 Keep-Alive를 사용한다고 했음에도 불구하고 요청이 정상적으로 처리되지 않는 경우(Read Timeout 발생, 500 Internal Sever Error 응답을 받는다던지… 모든 4xx, 5xx가 포함되는 건 아님)에는 커넥션을 커넥션 풀에 반납하지 않고(재사용하지 않고) 종료한다. 클라이언트가 응답 패킷을 받기 전에 연결을 끊는 경우1. Read Timeout 발생 후 60초 이내(소켓이 닫히기 전)에 응답 패킷을 전송하는 경우1-1. 클라이언트 측에서 Read Timeout 발생 후 60초 이내(소켓이 닫히기 전)에 응답 패킷을 하나만 전송하는 경우 (응답이 작은 경우)서버 쪽 API에서 처리하는데 10초 소요되고, 매우 작은 문자열을 응답한다고 가정 1234567891011121314@RestControllerclass SlowResponseController &#123; private val log = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/slow&quot;) fun slow(): String &#123; log.info(&quot;request is arrived!&quot;) Thread.sleep(10_000L) log.info(&quot;slow process is done!&quot;) return &quot;done!&quot; &#125;&#125; 클라이언트 측 리드 타임아웃 설정은 3초로 서버 쪽 처리 시간보다 더 짧게 설정함 12345678910111213141516171819202122232425262728fun main() &#123; val readTimeout = Duration.ofSeconds(3L) val restTemplate = RestTemplate( HttpComponentsClientHttpRequestFactory( HttpClientBuilder .create() .setMaxConnPerRoute(100) .setMaxConnTotal(100) .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy()) .setDefaultRequestConfig( RequestConfig.custom().setSocketTimeout(readTimeout.toMillis().toInt()).build() ) .build() ) ) try &#123; restTemplate.getForObject(&quot;http://localhost:8080/slow&quot;, String::class.java) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; println(&quot;[$&#123;LocalDateTime.now()&#125;] request is done!&quot;) &#125; // 커넥션 풀에 있는 커넥션을 바로 종료하지 않기 위해 10초간 슬립 Thread.sleep(10_000L) println(&quot;[$&#123;LocalDateTime.now()&#125;] main function is done!&quot;)&#125; 데모 영상 클라이언트 로그12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686921:15:26.241 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://localhost:8080/slow21:15:26.247 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]21:15:26.277 [main] DEBUG org.apache.http.client.protocol.RequestAddCookies - CookieSpec selected: default21:15:26.280 [main] DEBUG org.apache.http.client.protocol.RequestAuthCache - Auth cache not set in the context21:15:26.280 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection request: [route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100]21:15:26.284 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection leased: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 1 of 100; total allocated: 1 of 100]21:15:26.285 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Opening connection &#123;&#125;-&gt;http://localhost:808021:15:26.289 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connecting to localhost/127.0.0.1:808021:15:26.289 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:60596&lt;-&gt;127.0.0.1:808021:15:26.289 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: set socket timeout to 300021:15:26.290 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Executing request GET /slow HTTP/1.121:15:26.290 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Target auth state: UNCHALLENGED21:15:26.290 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Proxy auth state: UNCHALLENGED21:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; GET /slow HTTP/1.121:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept: text/plain, application/json, application/*+json, */*21:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Host: localhost:808021:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Connection: Keep-Alive21:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)21:15:26.290 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept-Encoding: gzip,deflate21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;GET /slow HTTP/1.1[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept: text/plain, application/json, application/*+json, */*[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Host: localhost:8080[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Connection: Keep-Alive[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept-Encoding: gzip,deflate[\\r][\\n]&quot;21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;[\\r][\\n]&quot;21:15:29.296 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;21:15:29.296 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection21:15:29.297 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Shutdown connection21:15:29.297 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Connection discarded21:15:29.297 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100][2022-03-19T21:15:29.306] request is done!org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;http://localhost:8080/slow&quot;: Read timed out; nested exception is java.net.SocketTimeoutException: Read timed out at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:785) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:334) at com.example.playground.slow.SlowResponseRestTemplatePlaygroundKt.main(SlowResponseRestTemplatePlayground.kt:28) at com.example.playground.slow.SlowResponseRestTemplatePlaygroundKt.main(SlowResponseRestTemplatePlayground.kt)Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84) at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137) at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153) at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56) at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259) at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163) at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157) at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273) at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56) at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:87) at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48) at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66) at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:776) ... 4 more[2022-03-19T21:15:39.315] main function is done!Process finished with exit code 0 21:15:26.289에 서버와 커넥션 맺음. (21:15:26.289 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:60596&lt;-&gt;127.0.0.1:8080) 21:15:26.290에 요청 전송 (21:15:26.290 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; ...) 21:15:29.296에 Read Timeout 발생 (정확히 우리가 설정한 3초 후에 발생함, 21:15:29.296 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;) 21:15:29.296 ~ 21:15:29.297에 커넥션 종료 (Keep-Alive 설정했음에도 불구하고, 정상적인 응답을 받지 못했으면 커넥션을 종료함. 21:15:29.296 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection) 21:15:39.315에 메인함수 종료 서버 로그122022-03-19 21:15:26.291 INFO 8275 --- [nio-8080-exec-3] c.e.s.SlowResponseController : request is arrived!2022-03-19 21:15:36.297 INFO 8275 --- [nio-8080-exec-3] c.e.s.SlowResponseController : slow process is done! 21:15:26.291에 요청 도착 21:15:36.297에 처리 완료 (10초 걸림) 아무런 에러 로그를 출력하지 않기 때문에 서버 측에서는 클라이언트가 올바르게 응답을 처리했는지 알 방법이 없다. 패킷 로그 (소켓 상태)12345678910239 2022-03-19 21:15:26.289278 127.0.0.1 127.0.0.1 TCP 68 60596 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=3550708683 TSecr=0 SACK_PERM=1240 2022-03-19 21:15:26.289504 127.0.0.1 127.0.0.1 TCP 68 8080 → 60596 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=2530353116 TSecr=3550708683 SACK_PERM=1241 2022-03-19 21:15:26.289530 127.0.0.1 127.0.0.1 TCP 56 60596 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3550708683 TSecr=2530353116242 2022-03-19 21:15:26.289547 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 8080 → 60596 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=2530353116 TSecr=3550708683243 2022-03-19 21:15:26.291192 127.0.0.1 127.0.0.1 HTTP 273 GET /slow HTTP/1.1 244 2022-03-19 21:15:26.291233 127.0.0.1 127.0.0.1 TCP 56 8080 → 60596 [ACK] Seq=1 Ack=218 Win=408064 Len=0 TSval=2530353118 TSecr=3550708685245 2022-03-19 21:15:29.297321 127.0.0.1 127.0.0.1 TCP 56 60596 → 8080 [FIN, ACK] Seq=218 Ack=1 Win=408256 Len=0 TSval=3550711691 TSecr=2530353118246 2022-03-19 21:15:29.297383 127.0.0.1 127.0.0.1 TCP 56 8080 → 60596 [ACK] Seq=1 Ack=219 Win=408064 Len=0 TSval=2530356124 TSecr=3550711691247 2022-03-19 21:15:36.298103 127.0.0.1 127.0.0.1 HTTP 222 HTTP/1.1 200 (text/plain)248 2022-03-19 21:15:36.298215 127.0.0.1 127.0.0.1 TCP 44 60596 → 8080 [RST] Seq=219 Win=0 Len=0 239 ~ 241번 패킷은 TCP 3 Way Handshake (syn, syn&#x2F;ack, ack) 243번 패킷에서 클라이언트 → 서버로 HTTP 요청 패킷 전송 (21:15:26.291192) 244번 패킷에서 서버가 요청 잘 받았다고 클라이언트한테 ACK 패킷 전송 (21:15:26.291233) 245번 패킷에서 클라이언트는 커넥션을 종료한다고 FIN&#x2F;ACK 패킷을 서버에게 전송 (21:15:29.297321, 정확히 HTTP 패킷 보내고 3초 후(read timeout)임.) 246번 패킷에서 서버가 클라이언트로부터 FIN&#x2F;ACK 패킷을 잘 받았다고 반대로 ACK 패킷을 클라이언트에게 보냄 (21:15:29.297383) 클라이언트가 먼저 연결을 종료하겠다는 FIN 패킷을 보냈기 때문에 클라이언트가 Active Close서버는 클라이언트로부터 FIN 패킷을 받았기 때문에 서버는 Passive Close가 됨(무조건 클라이언트가 Active Close는 아니고 경우에 따라서 다름)그리고 아직까지는 서버(Passive Close)로부터 FIN 패킷을 받은 게 아니기 때문에 소켓이 정상적으로 종료된 게 아님. 서버 측 소켓의 상태는 CLOSE_WAIT(클라이언트가 보낸 FIN 패킷을 받았으므로)이고, 클라이언트 측 소켓의 상태는 FIN_WAIT_2(서버가 보낸 ACK 패킷을 받았으므로)이다. (21:15:29) 서버는 클라이언트로부터 FIN 패킷을 받았지만 아직 보낼 패킷이 남아있기 때문인지 클라이언트에게 FIN 패킷을 보내지 않음.그리고 Active Close(클라이언트) 측에서는 오동작을 막기 위해 바로 소켓의 연결을 끊는 게 아니라 60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨) 만큼) 동안 대기하게 됨. (21:15:35) 247번 패킷에서 서버 → 클라이언트로 HTTP 응답 패킷 전송 (21:15:36.298103, 클라이언트가 요청 보낸 21:15:26.291192로부터 10초가 지난 시간임) 248번 패킷에서 클라이언트 → 서버로 RST 패킷 전송 (21:15:36.298215) When an unexpected TCP packet arrives at a host, that host usually responds by sending a reset packet back on the same connection. A reset packet is simply one with no payload and with the RST bit set in the TCP header flags.출처: https://www.pico.net/kb/what-is-a-tcp-reset-rst/ 클라이언트 측에서는 소켓 연결 종료를 준비하고 있었는데 서버 측으로부터 의도치 않은 HTTP 패킷이 왔기 때문에 더 이상 패킷을 받을 수 없다는 RST 패킷을 전송한 것으로 보임. (원래는 서버에서 FIN 패킷을 한 번 보내주고 클라이언트가 다시 ACK 패킷을 보내서 소켓을 종료해야한다.) RST 패킷을 전송한 이후에 클라이언트&#x2F;서버 측 소켓이 정상적으로 종료됨 (21:15:36) 1-2. 클라이언트 측에서 Read Timeout 발생 후 60초 이내(소켓이 닫히기 전)에 응답 패킷을 여러 개 전송하는 경우 (응답이 큰 경우)서버 쪽 API에서 처리하는데 10초 소요되고, 매우 큰 문자열을 응답한다고 가정 1234567891011121314@RestControllerclass SlowLargeResponseController &#123; private val log = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/slow-large&quot;) fun slow(): String &#123; log.info(&quot;request is arrived!&quot;) Thread.sleep(10_000L) log.info(&quot;slow large process is done!&quot;) return &quot;done!&quot;.repeat(1_000_000) &#125;&#125; 클라이언트 측 리드 타임아웃 설정은 3초로 서버 쪽 처리 시간보다 더 짧게 설정함 12345678910111213141516171819202122232425262728fun main() &#123; val readTimeout = Duration.ofSeconds(3L) val restTemplate = RestTemplate( HttpComponentsClientHttpRequestFactory( HttpClientBuilder .create() .setMaxConnPerRoute(100) .setMaxConnTotal(100) .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy()) .setDefaultRequestConfig( RequestConfig.custom().setSocketTimeout(readTimeout.toMillis().toInt()).build() ) .build() ) ) try &#123; restTemplate.getForObject(&quot;http://localhost:8080/slow-large&quot;, String::class.java) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; println(&quot;[$&#123;LocalDateTime.now()&#125;] request is done!&quot;) &#125; // 커넥션 풀에 있는 커넥션을 바로 종료하지 않기 위해 10초간 슬립 Thread.sleep(10_000L) println(&quot;[$&#123;LocalDateTime.now()&#125;] main function is done!&quot;)&#125; 데모 영상 클라이언트 로그12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686905:19:22.860 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://localhost:8080/slow-large05:19:22.867 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]05:19:22.895 [main] DEBUG org.apache.http.client.protocol.RequestAddCookies - CookieSpec selected: default05:19:22.898 [main] DEBUG org.apache.http.client.protocol.RequestAuthCache - Auth cache not set in the context05:19:22.899 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection request: [route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100]05:19:22.903 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection leased: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 1 of 100; total allocated: 1 of 100]05:19:22.903 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Opening connection &#123;&#125;-&gt;http://localhost:808005:19:22.905 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connecting to localhost/127.0.0.1:808005:19:22.906 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:50422&lt;-&gt;127.0.0.1:808005:19:22.906 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: set socket timeout to 300005:19:22.906 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Executing request GET /slow-large HTTP/1.105:19:22.906 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Target auth state: UNCHALLENGED05:19:22.907 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Proxy auth state: UNCHALLENGED05:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; GET /slow-large HTTP/1.105:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept: text/plain, application/json, application/*+json, */*05:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Host: localhost:808005:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Connection: Keep-Alive05:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)05:19:22.907 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept-Encoding: gzip,deflate05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;GET /slow-large HTTP/1.1[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept: text/plain, application/json, application/*+json, */*[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Host: localhost:8080[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Connection: Keep-Alive[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept-Encoding: gzip,deflate[\\r][\\n]&quot;05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;[\\r][\\n]&quot;05:19:25.913 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;05:19:25.913 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection05:19:25.915 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Shutdown connection05:19:25.916 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Connection discarded05:19:25.916 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100][2022-03-20T05:19:25.920] request is done!org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;http://localhost:8080/slow-large&quot;: Read timed out; nested exception is java.net.SocketTimeoutException: Read timed out at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:785) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:334) at com.example.playground.SlowLargeResponseRestTemplatePlaygroundKt.main(SlowLargeResponseRestTemplatePlayground.kt:28) at com.example.playground.SlowLargeResponseRestTemplatePlaygroundKt.main(SlowLargeResponseRestTemplatePlayground.kt)Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84) at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137) at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153) at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56) at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259) at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163) at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157) at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273) at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56) at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:87) at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48) at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66) at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:776) ... 4 more[2022-03-20T05:19:35.925] main function is done!Process finished with exit code 0 05:19:22.906에 서버와 커넥션 맺음. (05:19:22.906 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:50422&lt;-&gt;127.0.0.1:8080) 05:19:22.907에 요청 전송 (05:19:22.907 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; ...) 05:19:25.913에 Read Timeout 발생 (정확히 우리가 설정한 3초 후에 발생함, 05:19:25.913 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;) 05:19:25.913 ~ 05:19:25.915에 커넥션 종료 (Keep-Alive 설정했음에도 불구하고, 정상적인 응답을 받지 못했으면 커넥션을 종료함. 05:19:25.913 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection) 05:19:35.925에 메인함수 종료 서버 로그123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384852022-03-20 05:19:22.908 INFO 63172 --- [nio-8080-exec-2] c.e.p.SlowLargeResponseController : request is arrived!2022-03-20 05:19:32.913 INFO 63172 --- [nio-8080-exec-2] c.e.p.SlowLargeResponseController : slow large process is done!2022-03-20 05:19:32.937 ERROR 63172 --- [nio-8080-exec-2] com.example.playground.ControllerAdvice : java.io.IOException: Broken pipeorg.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:353) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:783) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:688) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:388) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:366) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) ~[na:1.8.0_322] at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:282) ~[na:1.8.0_322] at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125) ~[na:1.8.0_322] at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:135) ~[na:1.8.0_322] at java.io.OutputStreamWriter.write(OutputStreamWriter.java:220) ~[na:1.8.0_322] at java.io.Writer.write(Writer.java:157) ~[na:1.8.0_322] at org.springframework.util.StreamUtils.copy(StreamUtils.java:147) ~[spring-core-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:126) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:44) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:227) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:293) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:183) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:78) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:135) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.16.jar:5.3.16] at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) [tomcat-embed-core-9.0.58.jar:4.0.FR] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.16.jar:5.3.16] at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) [tomcat-embed-core-9.0.58.jar:4.0.FR] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:359) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1735) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.58.jar:9.0.58] at java.lang.Thread.run(Thread.java:750) [na:1.8.0_322]Caused by: java.io.IOException: Broken pipe at sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[na:1.8.0_322] at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.write(IOUtil.java:65) ~[na:1.8.0_322] at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:470) ~[na:1.8.0_322] at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:135) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1376) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:766) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.writeBlocking(SocketWrapperBase.java:586) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:530) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.doWrite(Http11OutputBuffer.java:547) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.filters.IdentityOutputFilter.doWrite(IdentityOutputFilter.java:73) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:194) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.Response.doWrite(Response.java:615) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:340) ~[tomcat-embed-core-9.0.58.jar:9.0.58] ... 62 common frames omitted 05:19:22.908에 요청 도착 05:19:32.913에 처리 완료 (10초 걸림) 05:19:32.937에 ClientAbortException(java.io.IOException: Broken pipe) 발생 패킷 로그 (소켓 상태)12345678910111213141516143 2022-03-20 05:19:22.906081 127.0.0.1 127.0.0.1 TCP 68 50422 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=3840422295 TSecr=0 SACK_PERM=1144 2022-03-20 05:19:22.906253 127.0.0.1 127.0.0.1 TCP 68 8080 → 50422 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=3598884109 TSecr=3840422295 SACK_PERM=1145 2022-03-20 05:19:22.906270 127.0.0.1 127.0.0.1 TCP 56 50422 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3840422295 TSecr=3598884109146 2022-03-20 05:19:22.906283 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 8080 → 50422 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=3598884109 TSecr=3840422295147 2022-03-20 05:19:22.908202 127.0.0.1 127.0.0.1 HTTP 279 GET /slow-large HTTP/1.1148 2022-03-20 05:19:22.908223 127.0.0.1 127.0.0.1 TCP 56 8080 → 50422 [ACK] Seq=1 Ack=224 Win=408064 Len=0 TSval=3598884111 TSecr=3840422297149 2022-03-20 05:19:25.915247 127.0.0.1 127.0.0.1 TCP 56 50422 → 8080 [FIN, ACK] Seq=224 Ack=1 Win=408256 Len=0 TSval=3840425304 TSecr=3598884111150 2022-03-20 05:19:25.915291 127.0.0.1 127.0.0.1 TCP 56 8080 → 50422 [ACK] Seq=1 Ack=225 Win=408064 Len=0 TSval=3598887118 TSecr=3840425304163 2022-03-20 05:19:32.935627 127.0.0.1 127.0.0.1 TCP 8248 8080 → 50422 [PSH, ACK] Seq=1 Ack=225 Win=408064 Len=8192 TSval=3598894139 TSecr=3840425304 [TCP segment of a reassembled PDU]164 2022-03-20 05:19:32.935668 127.0.0.1 127.0.0.1 TCP 8248 8080 → 50422 [PSH, ACK] Seq=8193 Ack=225 Win=408064 Len=8192 TSval=3598894139 TSecr=3840425304 [TCP segment of a reassembled PDU]165 2022-03-20 05:19:32.935695 127.0.0.1 127.0.0.1 TCP 8248 8080 → 50422 [PSH, ACK] Seq=16385 Ack=225 Win=408064 Len=8192 TSval=3598894139 TSecr=3840425304 [TCP segment of a reassembled PDU]166 2022-03-20 05:19:32.935704 127.0.0.1 127.0.0.1 TCP 44 50422 → 8080 [RST] Seq=225 Win=0 Len=0167 2022-03-20 05:19:32.935715 127.0.0.1 127.0.0.1 TCP 44 50422 → 8080 [RST] Seq=225 Win=0 Len=0168 2022-03-20 05:19:32.935719 127.0.0.1 127.0.0.1 TCP 44 50422 → 8080 [RST] Seq=225 Win=0 Len=0169 2022-03-20 05:19:32.935721 127.0.0.1 127.0.0.1 TCP 8248 8080 → 50422 [PSH, ACK] Seq=24577 Ack=225 Win=408064 Len=8192 TSval=3598894139 TSecr=3840425304 [TCP segment of a reassembled PDU]170 2022-03-20 05:19:32.935741 127.0.0.1 127.0.0.1 TCP 44 50422 → 8080 [RST] Seq=225 Win=0 Len=0 143 ~ 145번 패킷은 TCP 3 Way Handshake (syn, syn&#x2F;ack, ack) 147번 패킷에서 클라이언트 → 서버로 HTTP 요청 패킷 전송 (05:19:22.908202) 148번 패킷에서 서버가 요청 잘 받았다고 클라이언트한테 ACK 패킷 전송 (05:19:22.908223) 149번 패킷에서 클라이언트는 커넥션을 종료한다고 FIN&#x2F;ACK 패킷을 서버에게 전송 (05:19:25.915247, 정확히 HTTP 패킷 보내고 3초 이후(read timeout)임.) 150번 패킷에서 서버가 클라이언트로부터 FIN&#x2F;ACK 패킷을 잘 받았다고 반대로 ACK 패킷을 클라이언트에게 보냄 (05:19:25.915291) 클라이언트가 먼저 연결을 종료하겠다는 FIN 패킷을 보냈기 때문에 클라이언트가 Active Close서버는 클라이언트로부터 FIN 패킷을 받았기 때문에 서버는 Passive Close가 됨(무조건 클라이언트가 Active Close는 아니고 경우에 따라서 다름)그리고 아직까지는 서버(Passive Close)로부터 FIN 패킷을 받은 게 아니기 때문에 소켓이 정상적으로 종료된 게 아님. 서버 측 소켓의 상태는 CLOSE_WAIT(클라이언트가 보낸 FIN 패킷을 받았으므로)이고, 클라이언트 측 소켓의 상태는 FIN_WAIT_2(서버가 보낸 ACK 패킷을 받았으므로)이다. (05:19:26) 서버는 클라이언트로부터 FIN 패킷을 받았지만 아직 보낼 패킷이 남아있기 때문인지 클라이언트에게 FIN 패킷을 보내지 않음.그리고 Active Close(클라이언트) 측에서는 오동작을 막기 위해 바로 소켓의 연결을 끊는 게 아니라 60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨)) 동안 대기하게 됨. (05:19:32) 163번 패킷에서 서버로부터 HTTP 응답이 오는데 너무 커서 한 번에 오지 않고 여러 패킷에 걸쳐서 전송됨. (05:19:32.935627)TCP 패킷은 순서를 보장하지 않기 때문에 클라이언트 측에서 재조립하여야하는데 그걸 위해 현재 시퀀스 넘버(1)와 다음 패킷의 시퀀스 넘버(8193)를 알려주고 있음. 164번 패킷을 보니 또 응답 패킷인데 현재 패킷의 시퀀스 넘버는 8193이니 163번 패킷의 다음 패킷이고, 그 다음 패킷의 시퀀스 넘버는 16385임. (05:19:32.935668) 165번 패킷을 보니 또 응답 패킷인데 현재 패킷의 시퀀스 넘버는 16385이니 164번 패킷의 다음 패킷이고, 그 다음 패킷의 시퀀스 넘버는 24577임. (05:19:32.935695) 166 ~ 168번 패킷을 보면 클라이언트는 FIN_WAIT_2 상태이기 때문에 서버로부터 FIN 패킷이 올 것을 예상했는데 3번이나 다른 패킷이 왔기 때문에 RST 패킷을 3번 보냄 (05:19:32.935704~ 05:19:32.935719) 169번 패킷을 보면 서버 측에 RST 패킷을 보내긴 했지만 아직 소켓이 닫히기 이전이기 때문에 그사이에 또 서버 → 클라이언트로 응답패킷이 왔다. (05:19:32.935721)여전히 응답이 더 남았기 때문에 다음 패킷의 시퀀스 넘버도 함께 보내줬다. 170번 패킷을 보면 또 서버에서 FIN 패킷이 온 게 아니기 때문에 클라이언트는 다시 서버에게 RST 패킷을 보내서 소켓을 닫을 준비를 한다. (05:19:32.935741) 그리고나서 진짜로 클라이언트&#x2F;서버의 소켓이 닫혔다. (05:19:33) 2. 클라이언트 측에서 Read Timeout 발생 후 60초 이후(소켓이 닫힌 후)에 응답 패킷을 전송하는 경우서버 쪽 API에서 처리하는데 70초 소요된다고 가정 1234567891011121314@RestControllerclass VerySlowResponseController &#123; private val log = LoggerFactory.getLogger(this::class.java) @GetMapping(&quot;/very-slow&quot;) fun verySlow(): String &#123; log.info(&quot;request is arrived!&quot;) Thread.sleep(70_000L) log.info(&quot;very slow process is done!&quot;) return &quot;done!&quot; &#125;&#125; 클라이언트 측 리드 타임아웃 설정은 3초로 서버 쪽 처리 시간보다 훨씬 짧게 설정함 12345678910111213141516171819202122232425262728fun main() &#123; val readTimeout = Duration.ofSeconds(3L) val restTemplate = RestTemplate( HttpComponentsClientHttpRequestFactory( HttpClientBuilder .create() .setMaxConnPerRoute(100) .setMaxConnTotal(100) .setKeepAliveStrategy(DefaultConnectionKeepAliveStrategy()) .setDefaultRequestConfig( RequestConfig.custom().setSocketTimeout(readTimeout.toMillis().toInt()).build() ) .build() ) ) try &#123; restTemplate.getForObject(&quot;http://localhost:8080/very-slow&quot;, String::class.java) &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; finally &#123; println(&quot;[$&#123;LocalDateTime.now()&#125;] request is done!&quot;) &#125; // 커넥션 풀에 있는 커넥션을 바로 종료하지 않기 위해 10초간 슬립 Thread.sleep(10_000L) println(&quot;[$&#123;LocalDateTime.now()&#125;] main function is done!&quot;)&#125; 데모 영상 클라이언트 로그12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686923:43:15.010 [main] DEBUG org.springframework.web.client.RestTemplate - HTTP GET http://localhost:8080/very-slow23:43:15.016 [main] DEBUG org.springframework.web.client.RestTemplate - Accept=[text/plain, application/json, application/*+json, */*]23:43:15.042 [main] DEBUG org.apache.http.client.protocol.RequestAddCookies - CookieSpec selected: default23:43:15.045 [main] DEBUG org.apache.http.client.protocol.RequestAuthCache - Auth cache not set in the context23:43:15.046 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection request: [route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100]23:43:15.050 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection leased: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 1 of 100; total allocated: 1 of 100]23:43:15.050 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Opening connection &#123;&#125;-&gt;http://localhost:808023:43:15.052 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connecting to localhost/127.0.0.1:808023:43:15.053 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:62960&lt;-&gt;127.0.0.1:808023:43:15.053 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: set socket timeout to 300023:43:15.053 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Executing request GET /very-slow HTTP/1.123:43:15.053 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Target auth state: UNCHALLENGED23:43:15.053 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Proxy auth state: UNCHALLENGED23:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; GET /very-slow HTTP/1.123:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept: text/plain, application/json, application/*+json, */*23:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Host: localhost:808023:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Connection: Keep-Alive23:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)23:43:15.054 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Accept-Encoding: gzip,deflate23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;GET /very-slow HTTP/1.1[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept: text/plain, application/json, application/*+json, */*[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Host: localhost:8080[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Connection: Keep-Alive[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;User-Agent: Apache-HttpClient/4.5.13 (Java/1.8.0_322)[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept-Encoding: gzip,deflate[\\r][\\n]&quot;23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;[\\r][\\n]&quot;23:43:18.058 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;23:43:18.059 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection23:43:18.060 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Shutdown connection23:43:18.060 [main] DEBUG org.apache.http.impl.execchain.MainClientExec - Connection discarded23:43:18.060 [main] DEBUG org.apache.http.impl.conn.PoolingHttpClientConnectionManager - Connection released: [id: 0][route: &#123;&#125;-&gt;http://localhost:8080][total available: 0; route allocated: 0 of 100; total allocated: 0 of 100][2022-03-19T23:43:18.067] request is done!org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;http://localhost:8080/very-slow&quot;: Read timed out; nested exception is java.net.SocketTimeoutException: Read timed out at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:785) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:711) at org.springframework.web.client.RestTemplate.getForObject(RestTemplate.java:334) at com.example.playground.VerySlowResponseRestTemplatePlaygroundKt.main(VerySlowResponseRestTemplatePlayground.kt:30) at com.example.playground.VerySlowResponseRestTemplatePlaygroundKt.main(VerySlowResponseRestTemplatePlayground.kt)Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84) at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137) at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153) at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:280) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138) at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56) at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259) at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163) at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:157) at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273) at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125) at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272) at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186) at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89) at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110) at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83) at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56) at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:87) at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48) at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66) at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:776) ... 4 more[2022-03-19T23:43:28.073] main function is done!Process finished with exit code 0 23:43:15.053에 서버와 커넥션 맺음. (23:43:15.053 [main] DEBUG org.apache.http.impl.conn.DefaultHttpClientConnectionOperator - Connection established 127.0.0.1:62960&lt;-&gt;127.0.0.1:8080) 23:43:15.054에 요청 전송 (23:43:15.054 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; ...) 23:43:18.058에 Read Timeout 발생 (정확히 우리가 설정한 3초 후에 발생함, 23:43:18.058 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[read] I/O error: Read timed out&quot;) 23:43:18.059 ~ 23:43:18.060에 커넥션 종료 (Keep-Alive 설정했음에도 불구하고, 정상적인 응답을 받지 못했으면 커넥션을 종료함. 23:43:18.059 [main] DEBUG org.apache.http.impl.conn.DefaultManagedHttpClientConnection - http-outgoing-0: Close connection) 23:43:28.073에 메인함수 종료 서버 로그1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980812022-03-19 23:43:15.055 INFO 47262 --- [nio-8080-exec-4] c.e.s.VerySlowResponseController : request is arrived!2022-03-19 23:44:25.059 INFO 47262 --- [nio-8080-exec-4] c.e.s.VerySlowResponseController : very slow process is done!2022-03-19 23:44:25.062 ERROR 47262 --- [nio-8080-exec-4] c.e.playground.ControllerAdvice : java.io.IOException: Broken pipeorg.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:310) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:273) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:118) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at sun.nio.cs.StreamEncoder.implFlush(StreamEncoder.java:297) ~[na:1.8.0_322] at sun.nio.cs.StreamEncoder.flush(StreamEncoder.java:141) ~[na:1.8.0_322] at java.io.OutputStreamWriter.flush(OutputStreamWriter.java:229) ~[na:1.8.0_322] at org.springframework.util.StreamUtils.copy(StreamUtils.java:148) ~[spring-core-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:126) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.StringHttpMessageConverter.writeInternal(StringHttpMessageConverter.java:44) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.http.converter.AbstractHttpMessageConverter.write(AbstractHttpMessageConverter.java:227) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:293) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:183) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:78) ~[spring-web-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:135) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1067) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:963) ~[spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.3.16.jar:5.3.16] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.3.16.jar:5.3.16] at javax.servlet.http.HttpServlet.service(HttpServlet.java:655) [tomcat-embed-core-9.0.58.jar:4.0.FR] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.3.16.jar:5.3.16] at javax.servlet.http.HttpServlet.service(HttpServlet.java:764) [tomcat-embed-core-9.0.58.jar:4.0.FR] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.3.16.jar:5.3.16] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117) [spring-web-5.3.16.jar:5.3.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:197) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:135) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:359) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:399) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:889) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1735) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.58.jar:9.0.58] at java.lang.Thread.run(Thread.java:750) [na:1.8.0_322]Caused by: java.io.IOException: Broken pipe at sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[na:1.8.0_322] at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93) ~[na:1.8.0_322] at sun.nio.ch.IOUtil.write(IOUtil.java:65) ~[na:1.8.0_322] at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:470) ~[na:1.8.0_322] at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:135) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1376) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:766) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:719) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:709) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:573) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.filters.IdentityOutputFilter.flush(IdentityOutputFilter.java:117) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:221) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:1255) [tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:402) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.coyote.Response.action(Response.java:209) ~[tomcat-embed-core-9.0.58.jar:9.0.58] at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:306) ~[tomcat-embed-core-9.0.58.jar:9.0.58] ... 56 common frames omitted 23:43:15.055에 요청 도착 23:44:25.059에 처리 완료 (70초 걸림) 23:44:25.062에 ClientAbortException(java.io.IOException: Broken pipe) 발생 패킷 로그 (소켓 상태)12345678997 2022-03-19 23:43:15.053056 127.0.0.1 127.0.0.1 TCP 68 62960 → 8080 [SYN] Seq=0 Win=65535 Len=0 MSS=16344 WS=64 TSval=2309492195 TSecr=0 SACK_PERM=198 2022-03-19 23:43:15.053210 127.0.0.1 127.0.0.1 TCP 68 8080 → 62960 [SYN, ACK] Seq=0 Ack=1 Win=65535 Len=0 MSS=16344 WS=64 TSval=234888919 TSecr=2309492195 SACK_PERM=199 2022-03-19 23:43:15.053225 127.0.0.1 127.0.0.1 TCP 56 62960 → 8080 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=2309492195 TSecr=234888919100 2022-03-19 23:43:15.053235 127.0.0.1 127.0.0.1 TCP 56 [TCP Window Update] 8080 → 62960 [ACK] Seq=1 Ack=1 Win=408256 Len=0 TSval=234888919 TSecr=2309492195101 2022-03-19 23:43:15.055087 127.0.0.1 127.0.0.1 HTTP 278 GET /very-slow HTTP/1.1 102 2022-03-19 23:43:15.055106 127.0.0.1 127.0.0.1 TCP 56 8080 → 62960 [ACK] Seq=1 Ack=223 Win=408064 Len=0 TSval=234888922 TSecr=2309492198103 2022-03-19 23:43:18.060226 127.0.0.1 127.0.0.1 TCP 56 62960 → 8080 [FIN, ACK] Seq=223 Ack=1 Win=408256 Len=0 TSval=2309495203 TSecr=234888922104 2022-03-19 23:43:18.060286 127.0.0.1 127.0.0.1 TCP 56 8080 → 62960 [ACK] Seq=1 Ack=224 Win=408064 Len=0 TSval=234891927 TSecr=2309495203119 2022-03-19 23:44:18.060374 127.0.0.1 127.0.0.1 TCP 44 62960 → 8080 [RST, ACK] Seq=224 Ack=1 Win=408256 Len=0 97 ~ 99번 패킷은 TCP 3 Way Handshake (syn, syn&#x2F;ack, ack) 101번 패킷에서 클라이언트 → 서버로 HTTP 요청 패킷 전송 (23:43:15.055087) 102번 패킷에서 서버가 요청 잘 받았다고 클라이언트한테 ACK 패킷 전송 (23:43:15.055106) 103번 패킷에서 클라이언트는 커넥션을 종료한다고 FIN&#x2F;ACK 패킷을 서버에게 전송 (23:43:18.060226, 정확히 HTTP 패킷 보내고 3초 후(read timeout)임.) 104번 패킷에서 서버가 클라이언트로부터 FIN&#x2F;ACK 패킷을 잘 받았다고 반대로 ACK 패킷을 클라이언트에게 보냄 (23:43:18.060286) 클라이언트가 먼저 연결을 종료하겠다는 FIN 패킷을 보냈기 때문에 클라이언트가 Active Close서버는 클라이언트로부터 FIN 패킷을 받았기 때문에 서버는 Passive Close가 됨(무조건 클라이언트가 Active Close는 아니고 경우에 따라서 다름)그리고 아직까지는 서버(Passive Close)로부터 FIN 패킷을 받은 게 아니기 때문에 소켓이 정상적으로 종료된 게 아님. 서버 측 소켓의 상태는 CLOSE_WAIT(클라이언트가 보낸 FIN 패킷을 받았으므로)이고, 클라이언트 측 소켓의 상태는 FIN_WAIT_2(서버가 보낸 ACK 패킷을 받았으므로)이다. (23:43:18) 서버는 클라이언트로부터 FIN 패킷을 받았지만 아직 보낼 패킷이 남아있기 때문인지 클라이언트에게 FIN 패킷을 보내지 않음.그리고 Active Close(클라이언트) 측에서는 오동작을 막기 위해 바로 소켓의 연결을 끊는 게 아니라 60초(OS마다 다르지만 tcp_fin_timeout(대다수의 리눅스는 60로초 설정됨)) 동안 대기하게 됨. (23:44:17) 119번 패킷에서 이제 기다릴만큼 다 기다렸는데도 서버 측에서 FIN 패킷이 오지 않기 때문에 클라이언트 → 서버로 RST, ACK 패킷을 날림. (23:44:18.060374, 정확하게 서버로 ACK 패킷 받은 이후부터 60초간 대기한 후 전송) RST 패킷을 전송한 이후에 클라이언트&#x2F;서버 측 소켓이 정상적으로 종료됨 (23:44:18) ClientAbortException을 해결하려면? 서버 측에서 처리 속도를 더 빠르게 한다. 처리 속도는 빠르지만 응답이 크다면 응답의 사이즈를 줄인 API를 제공한다 (불필요한 필드 제거 or 페이징 API 제공) 클라이언트 측 리드 타임아웃 설정값을 늘린다. 정 합의가 안 된다면 ClientAbortException을 핸들링 해서 log.info로만 남긴다. (장애 상황은 아니라서 불필요한 노이즈라고 판단된다는 가정 하에) 클라이언트 측에서는 ReadTimeout이 발생했다면(ClientAbortException 여부와 상관 없이), 장애 상황(고객에게 돈은 출금이 됐는데 주문은 완료처리 안 됐다던지)을 막기 위해 서버 측에 취소 API 같은 걸 호출하거나 상태 조회 API 같은 걸 호출한 이후 내가 처리를 따로 해야하는 건지 아닌지 판단한 후에 올바른 처리를 해줘야한다.","categories":[{"name":"tomcat","slug":"tomcat","permalink":"https://perfectacle.github.io/categories/tomcat/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://perfectacle.github.io/tags/Tomcat/"}]},{"title":"(Gradle) 테스트 의존성 관리하기 (feat. java-test-fixtures 플러그인)","slug":"gradle-java-test-fixtures-plugin","date":"2022-03-13T00:02:03.000Z","updated":"2022-10-30T08:42:16.619Z","comments":true,"path":"2022/03/13/gradle-java-test-fixtures-plugin/","link":"","permalink":"https://perfectacle.github.io/2022/03/13/gradle-java-test-fixtures-plugin/","excerpt":"들어가기에 앞서(Gradle) implementation vs api에서는 compile&#x2F;runtime 의존성을 관리하는 방법에 대해 정리했다.하지만 이는 실제 src&#x2F;main 경로에 대해서만 의존성을 관리하는 것이지 src&#x2F;test 경로에서 사용하는 테스트 의존성(testCompileClasspath, testRuntimeClasspath)에 대해서는 딥하게 다루지 않았다.테스트도 관리해야할 대상이고 하나의 소프트웨어라는 관점에서 테스트의 의존성 조차도 신경을 써줘야한다. testImplementation","text":"들어가기에 앞서(Gradle) implementation vs api에서는 compile&#x2F;runtime 의존성을 관리하는 방법에 대해 정리했다.하지만 이는 실제 src&#x2F;main 경로에 대해서만 의존성을 관리하는 것이지 src&#x2F;test 경로에서 사용하는 테스트 의존성(testCompileClasspath, testRuntimeClasspath)에 대해서는 딥하게 다루지 않았다.테스트도 관리해야할 대상이고 하나의 소프트웨어라는 관점에서 테스트의 의존성 조차도 신경을 써줘야한다. testImplementation 기본적으로 implementation과 api로 의존성을 추가한 경우에도 testCompileClasspath, testRuntimeClasspath에 추가돼서 테스트에서도 사용이 가능하다.하지만 compileClasspath, runtimeClasspath에도 추가되다보니 실제 프로덕션에서는 사용할 필요가 없고, 테스트에서만 사용할 목적으로 testImplementation을 많이 사용한다. testImplementation으로 의존성을 관리하기 위해서는 java 플러그인을 활성화해야한다. 123plugins &#123; id &#x27;java&#x27;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (java는 gradle core 플러그인이기 때문에 plugins 모듈에 별도로 정의 안 하고도 서브 모듈들에게 적용이 가능하다.) 123subprojects &#123; apply plugin: &#x27;java&#x27;&#125; build.gradle.kts에서는 kotlin jvm 플러그인만 활성화 시켜주면 된다. 123plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (kotlin jvm 플러그인은 gradle core 플러그인이 아니기 때문에 plugins 모듈에 별도로 정의 해놔야 서브 모듈들에게 적용이 가능하다.) 1234567plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125;subprojects &#123; apply(plugin = &quot;org.jetbrains.kotlin.jvm&quot;)&#125; 그리고 의존성 추가를 위해 build.gradle(or build.gradle.kts)에 아래와 같이 디펜던시들을 추가하게 된다. 123dependencies &#123; testImplementation(&quot;org.junit.jupiter:junit-jupiter:5.8.2&quot;)&#125; 실제로 gradle dependency를 보게되면 compileClasspath와 runtimeClasspath에는 추가되지 않고, testCompileClasspath와 testRuntimeClasspath에만 추가된 걸 볼 수 있다. testCompileClasspath에 추가됐기 때문에 src&#x2F;test에서 junit 5를 사용할 수 있다. compileClasspath에 추가되지 않았기 때문에 src&#x2F;main에서는 junit 5를 사용할 수 없다. 테스트 경로에 있는 클래스들을 외부로 노출시키기단일 모듈의 경우에는 testImplementation, testCompileOnly, testRuntimeOnly 정도로 테스트 전용으로 의존성을 관리할 수 있다.하지만 멀티 모듈의 경우에는 조금 복잡해진다. 라이브러리: jakcson-core, spring-tx, 우리 프로젝트 내에서 만드는 모듈들 등등 컨슈머: 프로젝트 내에서 라이브러리를 사용하는 모듈, 우리 프로젝트에서 위 라이브러리들을 사용하는 모듈 등등 프로젝트에 두 가지 모듈(producer와 consumer)을 만들어서 차이점을 확인해보자. producer는 모듈을 제공하는 측이고, consumer는 모듈을 소비하는 측이다.따라서 consumer 모듈의 build.gradle(또는 build.gradle.kts)를 보면 producer 모듈에 의존하는 모습을 볼 수 있다. 123dependencies &#123; implementation(project(&quot;:producer&quot;))&#125; 이 때 producer 모듈에 기본 생성자는 없고, 생성자에 인자가 많아서 생성하기 번거로운 클래스가 있다고 가정해보자. 123456789101112131415public class Some &#123; public final String name; public final int age; public final String hobby; public final String address; public final String zipCode; public Some(final String name, final int age, final String hobby, final String address, final String zipCode) &#123; this.name = name; this.age = age; this.hobby = hobby; this.address = address; this.zipCode = zipCode; &#125;&#125; 테스트에서 생성자에 모든 인자를 넣어서 매번 생성하기 번거로우므로 아래와 같은 빌더를 src&#x2F;test 하위 경로에 만들자. 12345678910111213141516171819202122232425262728293031323334353637383940414243public final class SomeBuilder &#123; public String name; public int age; public String hobby; public String address; public String zipCode; private SomeBuilder() &#123; &#125; public static SomeBuilder aSome() &#123; return new SomeBuilder(); &#125; public SomeBuilder withName(String name) &#123; this.name = name; return this; &#125; public SomeBuilder withAge(int age) &#123; this.age = age; return this; &#125; public SomeBuilder withHobby(String hobby) &#123; this.hobby = hobby; return this; &#125; public SomeBuilder withAddress(String address) &#123; this.address = address; return this; &#125; public SomeBuilder withZipCode(String zipCode) &#123; this.zipCode = zipCode; return this; &#125; public Some build() &#123; return new Some(name, age, hobby, address, zipCode); &#125;&#125; 이제 내가 원하는 인자들만 설정하고 나머지는 빌더에 설정된 기본값을 사용하여 테스트에서 쉽게 해당 객체를 찍어낼 수 있다. 1234567public class SomeTest &#123; @Test void test() &#123; final Some givenSome = SomeBuilder.aSome().withName(&quot;name&quot;).build(); // ... &#125;&#125; producer 모듈에서 테스트 작성 시에 이렇게 SomeBuilder를 통해 원하는 객체를 원하는 모양으로 쉽게 찍어낼 수 있었는데 consumer 모듈에서는 어떨까?? consumer 모듈에서는 producer 모듈의 src&#x2F;main에 있는 Some 클래스에는 접근이 가능한데 src&#x2F;test에 있는 SomeBuilder 클래스에는 접근이 안 된다. 왜 그런 걸까??우선 프로젝트를 빌드해보자. 1234567891011121314151617181920212223242526./gradlew build1:03:15 AM: Executing &#x27;build&#x27;...&gt; Task :producer:compileJava&gt; Task :producer:processResources NO-SOURCE&gt; Task :producer:classes&gt; Task :producer:jar&gt; Task :consumer:compileJava NO-SOURCE&gt; Task :consumer:processResources NO-SOURCE&gt; Task :consumer:classes UP-TO-DATE&gt; Task :consumer:jar&gt; Task :consumer:assemble&gt; Task :consumer:compileTestJava&gt; Task :consumer:processTestResources NO-SOURCE&gt; Task :consumer:testClasses&gt; Task :consumer:test&gt; Task :consumer:check&gt; Task :consumer:build&gt; Task :producer:assemble&gt; Task :producer:compileTestJava&gt; Task :producer:processTestResources NO-SOURCE&gt; Task :producer:testClasses&gt; Task :producer:test&gt; Task :producer:check&gt; Task :producer:build 그리고 나서 producer 모듈의 빌드된 jar를 까보면 src&#x2F;main에 있는 Some 클래스만 존재하는 걸 볼 수 있다.애초에 jar 파일에 SomeBuilder가 존재하지 않기 때문에 consumer 모듈에서는 접근조차 불가능한 것이다. 그럼 문제를 어떻게 해결해야할까?가장 간단한 방법은 consumer 모듈의 src&#x2F;test에도 똑같이 SomeBuilder 파일을 복붙하는 방법이다.하지만 IDE의 리팩토링 기능으로 관리가 되지 않기 때문에 동일한 파일을 두 번 관리해야한다는 매우 비효율을 낳게 된다. 구세주 java-test-fixtures 플러그인src&#x2F;main에 있는 파일만 jar로 뽑듯이 src&#x2F;test에 있는 파일들도 jar로 뽑아내기 위해 gradle에는 java-test-fixtures라는 플러그인이 존재한다. 먼저 src&#x2F;test 하위 경로에 있는 파일들을 노출시키고 싶은 producer 모듈의 build.gradle 파일에 java-test-fixtures 플러그인을 추가해주자. 123plugins &#123; id &#x27;java-test-fixtures&#x27;&#125; build.gradle.kts 같은 경우에는 아래와 같이 추가하면 된다. 123plugins &#123; `java-test-fixtures`&#125; 플러그인을 추가한 후 producer 모듈에 새로운 경로를 추가하려고 하면 인텔리제이와 같은 IDE에서 testFixtures 경로를 자동으로 추천해주게 된다. 그리고 testFixtures 하위에 있는 파일들은 아래와 같은 특징을 가진다. they can see the main source set classes (src&#x2F;testFixtures에 존재하는 클래스에서 src&#x2F;main에 존재하는 클래스에 접근 가능) test sources can see the test fixtures classes (src&#x2F;test에 존재하는 테스트 클래스에서 src&#x2F;testFixtures 클래스에 접근 가능) java-test-fixtures 플러그인을 추가하기 전에는 testCompileClasspath와 testRuntimeClasspath만 존재하고, junit 5만 의존성으로 가지고 있는 모습이다. java-test-fixtures 플러그인을 추가하고 보면 testFixturesCompileClasspath와 testFixturesRuntimeClasspath가 추가된 모습을 볼 수 있다.testCompileClasspath와 testRuntimeClasspath에 포함된 producer 모듈들은 아마 producer&#x2F;src&#x2F;main, producer&#x2F;src&#x2F;testFixtures 모듈이 아닐까 싶다.그리고 testFixturesCompileClasspath와 testFixturesRuntimeClasspath에 포함된 producer 모듈은 producer&#x2F;src&#x2F;main 모듈이 아닐까 싶다. 그렇기에 SomeBuilder를 src&#x2F;test에서 src&#x2F;testFixutres로 옮겨도 아무런 문제가 없다. testFixtures에서는 main에 있는 Some에는 접근이 가능하지만 test에 있는 SomeTest2에는 접근이 불가능하다. test에서는 main에 있는 Some과 testFixtures에 있는 SomeBuilder에 모두 접근이 가능하다. main에서는 당연하게도 test에 있는 SomeTest와 testFixtures에 있는 SomeBuilder에 모두 접근이 불가능하다. 이 상태에서 다시 빌드를 때려보자 123456789101112131415161718192021222324252627282930./gradlew build1:22:00 AM: Executing &#x27;build&#x27;...&gt; Task :producer:compileJava&gt; Task :producer:processResources NO-SOURCE&gt; Task :producer:classes&gt; Task :producer:jar&gt; Task :consumer:compileJava NO-SOURCE&gt; Task :consumer:processResources NO-SOURCE&gt; Task :consumer:classes UP-TO-DATE&gt; Task :consumer:jar&gt; Task :consumer:assemble&gt; Task :consumer:compileTestJava&gt; Task :consumer:processTestResources NO-SOURCE&gt; Task :consumer:testClasses&gt; Task :consumer:test&gt; Task :consumer:check&gt; Task :consumer:build&gt; Task :producer:assemble&gt; Task :producer:compileTestFixturesJava&gt; Task :producer:compileTestJava&gt; Task :producer:processTestResources NO-SOURCE&gt; Task :producer:testClasses&gt; Task :producer:processTestFixturesResources NO-SOURCE&gt; Task :producer:testFixturesClasses&gt; Task :producer:testFixturesJar&gt; Task :producer:test&gt; Task :producer:check&gt; Task :producer:build 기존에는 보지 못했던 testFixtures 관련 태스크들이 수행된 것을 볼 수 있다. :producer:compileTestFixturesJava :producer:processTestFixturesResources :producer:testFixturesClasses :producer:testFixturesJar 그리고 빌드된 jar를 보면 *-test-fixtures.jar 파일이 추가됐고, 해당 jar를 까보면 testFixtures 하위에 존재하던 SomeBuilder가 존재한다.이렇듯 java-test-fixtures 플러그인은 src&#x2F;test 하위에 존재하는 불필요한 테스트 클래스는 jar에 포함시키지 않고 내가 원하는 클래스들만 jar에 추가시켜준다. 하지만 이렇게 test-fixtures.jar로 빌드했다고 해서 바로 consumer 모듈에서 사용할 수 있는 건 아니다. consumer 모듈의 의존성을 보면 testCompileClasspath와 testRuntimeClasspath에 producer 모듈이 존재하긴 하는데 이건 일반 jar(src&#x2F;main을 빌드한)만 의존성으로 가지고 있다는 뜻이다. 아래와 같이 test-fixtures.jar(src&#x2F;testFixtures를 빌드한)도 의존성으로 추가해줘야한다. 1testImplementation(testFixtures(project(&quot;:producer&quot;))) testImplementation으로 추가했기 때문에 compileClasspath와 runtimeClasspath에는 전혀 차이가 존재하지 않고, testCompileClasspath와 testRuntimeClasspath에만 producer 모듈(test-fixtures.jar)이 의존성에 추가된 걸 볼 수 있다. 이렇게 consumer 모듈의 테스트 클래스에서도 producer 모듈의 src&#x2F;testFixtures에 존재하는 SomeBuilder와 producer 모듈의 src&#x2F;main에 존재하는 Some 클래스에 모두 접근이 가능한 것을 볼 수 있다.그리고 jar에 포함되지 않는 producer 모듈의 src&#x2F;test에 존재하는 SomeTest 클래스에는 접근이 불가능하다. 당연히 consumer 모둘의 src&#x2F;main에 존재하는 클래스에서는 producer 모듈의 src&#x2F;testFixtures에 존재하는 SomeBuilder에는 접근이 불가능하다.대신 producer 모듈의 src&#x2F;main에 존재하는 Some 클래스에는 접근이 가능하다. 테스트 의존성을 외부로 노출시키기만약 producer 모듈에서 인메모리 db로 테스트 할 일이 있어서 h2 db를 testRuntimeOnly로 추가했다고 가정해보자.(h2 db의 클래스는 우리 테스트 클래스에서 직접 사용하기 보다는 Spring Boot Auto Configuration 등등에서 런타임에 사용하기 때문에 testCompileClasspath에는 추가될 필요가 딱히 없다.) 1testRuntimeOnly(&quot;com.h2database:h2:2.1.210&quot;) testRuntimeOnly로 추가했기 때문에 testRuntimeClasspath를 제외한 다른 클래스패스에는 h2가 추가되지 않았다. testCompileClasspath에 존재하지 않기 때문에 테스트 클래스에서 H2 관련 클래스를 사용해서 컴파일 하면 컴파일 타임에 오류가 난다. (왜 IDE에서는 빨간 줄이 생기지 않는지 의문이다. 일시적 버그인가…) 그리고 consumer 모듈에서도 h2를 사용하여 테스트를 진행한다고 가정해보자. 하지만 단순히 producer 모듈에 testRuntimeOnly로 h2를 추가했다 하더라도 consumer 모듈의 testRuntimeClasspath에는 노출되지 않는다.producer 모듈은 (testFixtures)compile&#x2F;runtimeClasspath를 기준으로 jar 파일을 생성하고 consumer 모듈에서 해당 jar 파일에 의존하게 되는데 h2는 해당 클래스패스에는 존재하지 않고, testRuntimeClasspath에만 존재하기 때문이다. 따라서 producer 모듈의 testFixturesCompileClasspath&#x2F;testFixturesRuntimeClasspath에 추가해야 test-fixtures.jar에 의존성이 추가되고 1testFixturesRuntimeOnly(&quot;com.h2database:h2:2.1.210&quot;) consumer 모듈에서도 test-fixtures.jar를 의존성으로 추가해줘야 1testImplementation(testFixtures(project(&quot;:producer&quot;))) consumer 모듈의 testRuntimeClasspath에도 h2가 의존성으로 추가된 모습을 볼 수 있다.","categories":[{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/tags/gradle/"}]},{"title":"(Gradle) implementation vs api","slug":"gradle-implementation-vs-api","date":"2022-03-12T19:43:25.000Z","updated":"2022-10-30T08:42:16.611Z","comments":true,"path":"2022/03/12/gradle-implementation-vs-api/","link":"","permalink":"https://perfectacle.github.io/2022/03/12/gradle-implementation-vs-api/","excerpt":"3줄 요약 implementation을 사용하자 implementation을 사용하더라도 라이브러리를 사용하는 consumer 측의 runtimeClassPath에 추가되기 때문에 런타임 의존성 충돌이 발생할 수 있으니 의존성은 최대한 적게 추가하자. api가 필요한 건지 100번 고민하고 설계가 잘못된 건 아닌지 의심해 본 후 api를 사용한다. (api는 consumer의 compile&#x2F;runtimeClassPath에 모두 추가된다.) 들어가기에 앞서의존성(라이브러리&#x2F;프레임워크)을 추가하기 위해 build.gradle(or build.gradle.kts)에 아래와 같이 디펜던시들을 추가하게 된다. 1234dependencies &#123; api(&quot;org.springframework.boot:spring-boot-starter-web&quot;) implementation(&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;)&#125;","text":"3줄 요약 implementation을 사용하자 implementation을 사용하더라도 라이브러리를 사용하는 consumer 측의 runtimeClassPath에 추가되기 때문에 런타임 의존성 충돌이 발생할 수 있으니 의존성은 최대한 적게 추가하자. api가 필요한 건지 100번 고민하고 설계가 잘못된 건 아닌지 의심해 본 후 api를 사용한다. (api는 consumer의 compile&#x2F;runtimeClassPath에 모두 추가된다.) 들어가기에 앞서의존성(라이브러리&#x2F;프레임워크)을 추가하기 위해 build.gradle(or build.gradle.kts)에 아래와 같이 디펜던시들을 추가하게 된다. 1234dependencies &#123; api(&quot;org.springframework.boot:spring-boot-starter-web&quot;) implementation(&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;)&#125; 참고로 compile은 depreacate 됐기 때문에 사용하면 안 되고 implementation을 쓰라고 나와있다. (compile은 api와 마찬가지로 consumer의 (test)compile&#x2F;runtimeClassPath에 모두 추가되니 사용하지 않는 게 좋다.) The compile configuration has been deprecated for dependency declaration.This will fail with an error in Gradle 7.0. Please use the implementation configuration instead.Consult the upgrading guide for further information: https://docs.gradle.org/6.9/userguide/upgrading_version_5.html#dependencies_should_no_longer_be_declared_using_the_compile_and_runtime_configurations 123@Deprecated(message = &quot;The compile configuration has been deprecated for dependency declaration. Please use the &#x27;implementation&#x27; configuration instead.&quot;)fun DependencyHandler.`compile`(dependencyNotation: Any): Dependency? = add(&quot;compile&quot;, dependencyNotation) 그럼 implementation은 뭐고 api는 뭘까?? implementationimplementation으로 의존성을 관리하기 위해서는 java 플러그인을 활성화해야한다. 123plugins &#123; id &#x27;java&#x27;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (java는 gradle core 플러그인이기 때문에 plugins 모듈에 별도로 정의 안 하고도 서브 모듈들에게 적용이 가능하다.) 123subprojects &#123; apply plugin: &#x27;java&#x27;&#125; build.gradle.kts에서는 kotlin jvm 플러그인만 활성화 시켜주면 된다. 123plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (kotlin jvm 플러그인은 gradle core 플러그인이 아니기 때문에 plugins 모듈에 별도로 정의 해놔야 서브 모듈들에게 적용이 가능하다.) 1234567plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125;subprojects &#123; apply(plugin = &quot;org.jetbrains.kotlin.jvm&quot;)&#125; 출처: https://docs.gradle.org/current/userguide/java_plugin.html#tab:configurations 기본적으로 implementation으로 의존성을 추가한다는 사실은 아래 클래스패스에 추가한다는 사실이다. compileClassPath: main 경로에서 해당 모듈을 컴파일할 때 사용함, 우리가 spring-tx 모듈의 @Transactional 어노테이션을 사용하는데 컴파일 클래스패스에 존재하지 않는다면 컴파일에 실패함. (대표적으로 lombok이 어노테이션 프로세서에 의해 소스코드에 있는 어노테이션을 해석하여 실제로 소스코드로 컴파일 할 때는 전부 사라지기 때문에 compileClassPath에만 존재하면 되고, runtimeClassPath에는 필요없는 경우이다. 그래서 lombok을 compileOnly로 추가하는 게 좋다.) runtimeClassPath: main 경로에서 해당 모듈을 런타임에서 사용함, 우리가 컴파일한 소스코드를 실행할 때(런타임) spring-tx 모듈의 @Transactional 어노테이션을 사용하는데 런타임 클래스패스에 존재하지 않는다면 @Transactional을 사용하는 코드로 진입 시에 NoClassDefFoundError나 ClassNotFoundException과 같은 에러&#x2F;예외가 발생하며 서버가 제대로 뜨지 않거나 서버는 떴는데 특정 API만 호출하면 장애가 발생할 수도 있다. (대표적으로 mysql-connector-java 같은 경우가 우리가 소스코드에서 직접적으로 사용하지는 않기 때문에 compileClassPath에서는 필요 없는데 런타임에 jdbc 드라이버라던지 HikariCP 등등에서 사용할 것이기 때문에 runtimeClassPath에만 존재하면 되고, compileClassPath에는 필요없는 경우이다. 그래서 mysql-connector-java를 runtimeOnly로 추가하는 게 좋다.) testCompileClassPath: test 경로에서 해당 모듈을 컴파일할 때 사용함, 우리가 spring-boot-test 모듈의 @SpringBootTest 어노테이션을 사용하는데 컴파일 클래스패스에 존재하지 않는다면 컴파일에 실패함. (대표적으로 junit 같은 경우가 실제 어플리케이션을 구동하는데는 필요하지 않고, 테스트를 수행하는데 필요하기 때문에 testImplementation으로 추가하는 게 좋다.) testRuntimeClassPath: test 경로에서 해당 모듈을 런타임에서 사용함, 우리가 컴파일한 소스코드를 실행할 때(런타임) spring-boot-test 모듈의 @SpringBootTest 어노테이션을 사용하는데 런타임 클래스패스에 존재하지 않는다면 @SpringBootTest을 사용하는 코드로 진입 시에 NoClassDefFoundError나 ClassNotFoundException과 같은 에러&#x2F;예외가 발생하며 테스트가 실패하게 됨. (대표적으로 h2 db 같이 테스트에서 사용할 목적으로 쓰이는 인메모리 db의 경우 우리가 소스코드에서 직접 사용하는 게 아니라 Spring Boot의 특정 Auto Configuration에서 사용하기 때문에 컴파일 할 때는 필요 없어서 testCompileClassPath에는 존재할 필요가 없고, 런타임에서만 사용하기 때문에 testRuntimeClassPath에는 존재해야하는 경우이다. 그래서 h2는 testRuntimeOnly로 추가하는 게 좋다.) 실제로 implementation으로 jackson-core 모듈을 추가하고 보면 4가지 클래스패스에 모두 추가된 걸 볼 수 있다. apiapi로 의존성을 관리하기 위해서는 java-library 플러그인을 사용해야한다. 123plugins &#123; id &#x27;java-library&#x27;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (java-library는 gradle core 플러그인이기 때문에 plugins 모듈에 별도로 정의 안 하고도 서브 모듈들에게 적용이 가능하다.) 123subprojects &#123; apply plugin: &#x27;java-library&#x27;&#125; build.gradle.kts에서는 똑같이 kotlin jvm 플러그인만 활성화 시켜주면 된다. 123plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125; 멀티 모듈인 경우 아래와 같이 활성화 시켜줘야한다. (kotlin jvm 플러그인은 gradle core 플러그인이 아니기 때문에 plugins 모듈에 별도로 정의 해놔야 서브 모듈들에게 적용이 가능하다.) 1234567plugins &#123; kotlin(&quot;jvm&quot;) version &quot;$kotlinVersion&quot;&#125;subprojects &#123; apply(plugin = &quot;org.jetbrains.kotlin.jvm&quot;)&#125; 출처: https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph 이미지를 보면 implementation과 마찬가지로 api도 compileClassPath, runtimeClassPath, testCompileClassPath, testRuntimeClassPath에 추가된다고 나와있다. 실제로 api로 jackson-core 모듈을 추가하고 보면 4가지 클래스패스에 모두 추가된 걸 볼 수 있다. implementation vs api여태까지 봤을 때는 둘 다 compileClassPath, runtimeClassPath, testCompileClassPath, testRuntimeClassPath에 추가된다는 걸 봐서 큰 차이점은 없어보인다. 하지만 이건 해당 모듈을 사용하는 컨슈머 입장이 돼봐야 그 차이점을 알게 된다. 라이브러리: jakcson-core, spring-tx, 우리 프로젝트 내에서 만드는 모듈들 등등 컨슈머: 프로젝트 내에서 라이브러리를 사용하는 모듈, 우리 프로젝트에서 위 라이브러리들을 사용하는 모듈 등등 프로젝트에 두 가지 모듈(producer와 consumer)을 만들어서 차이점을 확인해보자. 먼저 producer 모듈에 의존성을 추가할 때 implementation과 api로 각각 추가해보자 implementation으로 추가한 jackson-core와 api로 추가한 commons-lang3 모듈이 모두 클래스패스에 추가됐다. consumer 쪽에서 producer 모듈을 의존성으로 추가하는데 여기서 차이점이 나온다. (producer 모듈을 api로 추가해도 마찬가지다.)producer 모듈에서 implementation으로 추가했던 의존성인 jackson-core는 (test)runtimeClassPath에만 추가되고, (test)compileClassPath에는 추가되지 않았다.그리고 api로 추가했던 의존성인 commons-lang3는 모든 클래스패스에 추가됐다. (test)compileClassPath에 의존성을 전파하지 않음으로써 얻는 이점들은 다음과 같다. implementation의 장점 1: 불필요한 의존성 전파를 막아준다. consumer module의 compileClassPath에 있는 commons-lang3 모듈 같은 경우에는 실제 소스코드에서 사용이 가능하다. 하지만 consumer moudle의 compileClassPath에 없는 jackson-core 같은 경우에는 실제 소스코드에서 사용이 불가능하다.compileClassPath에 없기 때문에 consumer 모듈에서 직접적인 사용이 불가능한 것이지, runtime에 jackson-core를 사용하는 producer 모듈을 사용하는 것에는 아무런 문제가 없다. (runtimeClassPath에 있기 때문에)producer 모듈에 jackson-core를 이용하는 클래스를 작성해보자. 123456789import com.fasterxml.jackson.core.JsonParser;public class Sample &#123; void a() &#123; // 아무 의미 없지만 jackson-core 모듈을 사용하는데 아무 이상이 없다는 걸 보여주기 위해 사용함. final JsonParser.Feature allowComments = JsonParser.Feature.ALLOW_COMMENTS; System.out.println(&quot;test~&quot;); &#125;&#125; 그리고 consumer 모듈에서 jackson-core를 이용하는 Sample 클래스를 사용하는 클래스를 작성해보자. 123456public class Some &#123; public static void main(String[] args) &#123; final Sample sample = new Sample(); sample.a(); // test~ &#125;&#125; Some 클래스의 메인 함수를 호출하면 Sample 클래스의 a 메서드가 호출되서 test~ 문자열이 정상적으로 호출되는 걸 볼 수 있다.consumer 모듈 입장에서는 불필요한 의존성 전파(jackson-core 모듈이 consumer까지 전파)되는 걸 막아줘서 import 자체가 되지 않다보니 자동완성에서 import 할 수 있는 가짓수가 줄어들다보니 어떤 클래스를 사용해야하는지 고민할 시간이 줄어들고(생산성 향상),producer 입장에서는 해당 모듈을 외부로 노출시키지 않다보니 마음대로 구현체를 갈아끼워도 컴파일 타임에 오류가 나지 않을 것이라는 신뢰가 어느정도 생긴다는 장점이 존재한다. implementation의 장점 2: compileClassPath의 의존성 충돌이 일어나지 않는다.producer 모듈에 guava를 implementation으로 추가해보자 1implementation(&quot;com.google.guava:guava:31.0.1-jre&quot;) 그리고 consumer 모듈에도 똑같이 guava 모듈을 추가하는데 굉장히 하위 버전을 추가해보자 1implementation(&quot;com.google.guava:guava:10.0&quot;) 그리고 이번에는 producer 모듈에서 api로 추가했었던 commons-lang3 모듈을 consumer 모듈에 추가하는데 버전을 좀 낮게 추가해보자. 1implementation(&quot;org.apache.commons:commons-lang3:3.0&quot;) 이제 consumer 모듈의 classPath를 보면 producer 모듈에서 api로 추가했던 commons-lang3 같은 경우에는 (test)compile&#x2F;runtimeClassPath에서 의존성 충돌이 나서 producer 모듈에 추가한 가장 최신 버전인 3.12.0이 적용됨 producer 모듈에서 implement로 추가했던 guava 같은 경우에는 (test)compileClassPath에는 consumer 모듈에 추가한 10.0이 적용됨, (test)runtimeClassPath에서는 의존성 충돌이 나서 producer 모듈에 추가한 가장 최신 버전인 31.0.1-jre가 적용됨 즉, implementation을 쓰면 consumer 입장에서 소스코드를 직접 작성하는 것과 연관이 있는 (test)compileClassPath는 의존성이 전파가 되지 않았기 때문에 consumer 모듈에 추가한 버전이 적용되었고,소스코드를 실제 실행하는데 필요한 (test)runtimeClassPath는 의존성이 전파됐기 때문에 의존성 충돌에 의해 가장 최신버전이 적용된다. (안 그러면 런타임에 메서드나 클래스를 찾을 수 없다는 오류가 발생할 수 있다.)반대로 최신버전에서는 사라진 코드를 사용했다면 컴파일은 성공하는데 런타임에 오류가 발생할 수도 있기 때문에 runtime 의존성도 체크하면서 사용해야 안전하다. (최대한 런타임 의존성과 호환성이 맞는 버전을 사용해야 안전하다.) 반면 api를 쓰면 (test)compile&#x2F;runtimeClassPath에 모두 의존성을 전파하기 때문에 의존성 충돌로 인해 원하는 버전을 쓰려면 버전을 강제하는 방법을 쓰거나 해야해서 사용하기가 좀 구려진다. implementation의 장점 3: compileClassPath에 포함되지 않기 때문에 라이브러리 측에서 의존성을 변경해도 컨슈머는 재컴파일 하지 않아도 된다.consumer 측에서 producer에서 api로 의존성을 추가한 commons-lang3를 사용한다고 해보자. 12345678import org.apache.commons.lang3.StringUtils;public class Some &#123; public static void main(String[] args) &#123; StringUtils.isBlank(&quot;asf&quot;); System.out.println(&quot;hello~&quot;); &#125;&#125; 그리고 producer 측에서 commons-lang3 모듈의 의존성 버전을 바꿔보자. 1api(&quot;org.apache.commons:commons-lang3:3.10&quot;) 그리고 consumer 측의 Some 클래스의 main 함수를 실행하면 Some 클래스는 하나도 수정한 게 없는데 다시 컴파일 하는 걸 볼 수 있다. 1234567891011126:04:36 AM: Executing &#x27;:consumer:Some.main()&#x27;...&gt; Task :producer:compileJava&gt; Task :consumer:compileJava&gt; Task :consumer:processResources UP-TO-DATE&gt; Task :consumer:classes&gt; Task :producer:processResources NO-SOURCE&gt; Task :producer:classes&gt; Task :producer:jar UP-TO-DATE&gt; Task :consumer:Some.main()hello~ 하지만 producer에서 implementation으로 추가했던 jackson-core나 guava 같은 경우에는 consumer 측의 (test)compileClassPath에는 포함조차 돼있지 않기 때문에 해당 모듈은 의존성을 바꾼다 하더라도 consumer에서는 컴파일을 할 필요가 없다. 1234567891011126:05:36 AM: Executing &#x27;:consumer:Some.main()&#x27;...&gt; Task :producer:compileJava&gt; Task :consumer:compileJava UP-TO-DATE&gt; Task :consumer:processResources UP-TO-DATE&gt; Task :consumer:classes UP-TO-DATE&gt; Task :producer:processResources NO-SOURCE&gt; Task :producer:classes&gt; Task :producer:jar UP-TO-DATE&gt; Task :consumer:Some.main()hello~ implementation의 장점 4: compileClassPath 사이즈가 줄어들었기 때문에 컴파일 속도가 빨라진다.컴파일 클래스패스가 줄어들었다는 것은 컴파일 해야할지 말아야할지 판단할 근거도 줄었다는 뜻이다.위에서 보듯이 producer에서 api로 추가한 모듈들은 consumer에서 사용하는지, 안 하는지에 따라서 해당 클래스를 재컴파일 해야하는지 말아야하는지 비교를 해야한다.하지만 전부 implementation으로 막혀있다면 그 비교 대상 자체가 확연히 줄어들게 될 것이다.그로 인해 컴파일 속도가 빨라진다. (엄청나게 빨라지는 것까지는 아니겠지만… 의존성이 많으면 많을 수록 더 큰 빛을 발할 것 같다.) 언제 implementaion을 쓰고 언제 api를 써야할까?https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_recognizing_dependencies Prefer the implementation configuration over api when possible 일단 무지성으로 implementation을 쓰고 어쩔 수 없을 때만 고민 한 100번 정도 한 다음에 api를 쓰면 된다. implementation을 써야할 때 any type that is used in the following list is irrelevant to the ABI, and therefore should be declared as an implementation dependency:• types exclusively used in method bodies• types exclusively used in private members• types exclusively found in internal classes (future versions of Gradle will let you declare which packages belong to the public API) ABI(Application Binary Interface)와 무관한 케이스에는 implementation을 쓰면 된다. 타입이 메서드 바디 안에서만 쓰이는 경우 타입이 프라이빗 멤버(변수&#x2F;메서드 등등)에서만 쓰이는 경우 타입이 인터널 클래스에서만 쓰이는 경우 api를 써야할 때 An API dependency is one that contains at least one type that is exposed in the library binary interface, often referred to as its ABI (Application Binary Interface). This includes, but is not limited to:• types used in super classes or interfaces• types used in public method parameters, including generic parameter types (where public is something that is visible to compilers. I.e. , public, protected and package private members in the Java world)• types used in public fields• public annotation types ABI(Application Binary Interface)와 관련있는 케이스에는 api를 쓰면 된다. 타입이 인터페이스나 슈퍼 클래스에서 쓰이는 경우 타입이 public&#x2F;protected&#x2F;package private 메서드의 파라미터(메서드의 인자 혹은 리턴타입 및 제네릭 파라미터 타입)에서 쓰일 때 타입이 퍼블릭 필드에서 쓰일 때 퍼블릭 어노테이션 타입일 때 그럼 implementation만 쓰면 만사 OK일까??아니다, 최대한 의존성을 줄여야한다.implementation이라 할지라도 (test)runtimeClassPath에 포함되기 때문에 의존성 충돌로 인해 문제가 발생할 수 있다.런타임 의존성 충돌로 인해 실제 런타임에 내가 만든 소스코드가 제대로 동작하지 않을 수 있다.내가 사용한 모듈(컴파일 클래스패스에 추가한) 버전에서는 존재하는 메서드였는데 런타임 의존성 충돌로 최신버전으로 주입됐을 때 최신버전에서는 삭제된 메서드일 때 NoSuchMethodException 같은 게 날 수 있다.혹은 라이브러리의 버전이 바뀌면서 내부 동작이 바뀌는 등의 무서운 일이 발생한다면 더욱 큰 장애로 이어질 수도 있다.그리고 컴파일 타임에 발견되지 않고 런타임에 발견되는 문제는 해당 코드 블럭이 실행돼야지만 발견되는 장애이기 때문에 더더욱 무섭다.","categories":[{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/categories/gradle/"}],"tags":[{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/tags/gradle/"}]},{"title":"(독서노트) 제로 투 원 (ZERO to ONE) Part. 01","slug":"book-review-zero-to-one-part-01","date":"2022-01-22T15:02:19.000Z","updated":"2022-10-30T08:42:16.187Z","comments":true,"path":"2022/01/22/book-review-zero-to-one-part-01/","link":"","permalink":"https://perfectacle.github.io/2022/01/22/book-review-zero-to-one-part-01/","excerpt":"평상 시 독서를 거의 안 하고, 짧은 글, 짧은 영상 위주의 인스턴트 식으로 살다보니 독해능력이 엄청나게 떨어졌다.글을 읽어도 제대로 이해하지 못하고, 한 2~3문장 이전에 읽은 글이 기억나지 않는다.책을 읽고, 해당 책이 좋다는 사실까지는 알았는데 이 책이 그래서 하고자 하는 말은 무엇이지? 무슨 내용의 책이지?를 남들에게 요약해서 설명해주려해도 설명할 수가 없었다.책을 읽긴 읽었는데 그래서 뭐? 책을 읽기 전과 책을 읽은 후의 나는 어떤 변화가 있나? 어떤 발전이 있나?… 그냥 책 하나 읽었다는 자기 만족 밖에 되지 않았다.빠르게 정보를 습득하는 것도 중요하지만, 정보가 남아있지 않다면 그 시간마저 버린 것이기 때문에 이렇게 기록이라도 하는 의식적인 노력을 들여야 조금이나마 내 자신이 개선될 것 같아 노트를 남긴다.+로 비판적 책읽기(책에 있는 내용을 무지성으로 수용하는 게 아니라 문장 하나, 단어 하나하나가 의미하는 게 무엇인지 곱씹어보기, 작가가 헛소리 하는 건 없는지 의심해보기)를 통해 작가와 소통하며 책을 읽는 듯한 느낌을 느껴보려고 하는 것도 있음. 제로 투 원 (ZERO to ONE) 참고로 나는 개정되기 이전 버전을 읽었음.읽게 된 계기는 회사 동료가 이 책을 읽고 가슴이 설렜다고 함.그래서 사내에 기증된 도서에도 있길래 읽었음.나의 난독+독해능력이 너무 딸려서 줄을 치면서(그나마 내용을 기억하기 위한 최소한의 행위&#x2F;노력) 읽고 싶었지만 회사 책이라 그러지는 못함.그러다보니 그냥 읽기만 하고 다음날 되면 전날 내용 다 까먹음.그러다보니 내가 이 책을 읽고 있기는 한데 남들한테 이 책이 무슨 내용이고 왜 좋고 어떤 영감을 받았는지 왜 추천하는지 하나도 설명하지 못함.그래서 2독을 결심하고 조금이나마 노력을 들여 나의 기억력 + 독해력 향상을 위해 노트에 받아적다가 팔도 아프고, 아무 노트에 대충 정리해놓다보니 나중에 잊혀질까 아까워서 그냥 블로그에 적기로 결심함.물론 손으로 적었을 때가 노력이 제일 많이 들어가다보니 기억이나 독해력 향상에는 도움이 많이 되는 것 같지만,노트에 적고 또 장기보존을 위해 블로그에 또 적자니 시간도 아깝고… 시간이 무한정 한 것이 아니기 때문에 걍 블로그에 적기로 결심. 참고로 이 책은 새로운 것을 창조하는 회사를 만드는 방법을 다루는 책임.따라서 스타트업 창업을 생각하거나 본인의 야망을 어떻게 실현시킬지, 어떤 생각으로 일을 하거나 인생을 살아가야하는지에 대한 도움이 될만한 책이라고 생각함.굳이 창업 안 하더라도 성공한 사람, 혁신을 이뤄낸 사람들은 어떻게 생각하고 어떻게 행동했는지 를 통해 배울 수 있는 점이 많음.","text":"평상 시 독서를 거의 안 하고, 짧은 글, 짧은 영상 위주의 인스턴트 식으로 살다보니 독해능력이 엄청나게 떨어졌다.글을 읽어도 제대로 이해하지 못하고, 한 2~3문장 이전에 읽은 글이 기억나지 않는다.책을 읽고, 해당 책이 좋다는 사실까지는 알았는데 이 책이 그래서 하고자 하는 말은 무엇이지? 무슨 내용의 책이지?를 남들에게 요약해서 설명해주려해도 설명할 수가 없었다.책을 읽긴 읽었는데 그래서 뭐? 책을 읽기 전과 책을 읽은 후의 나는 어떤 변화가 있나? 어떤 발전이 있나?… 그냥 책 하나 읽었다는 자기 만족 밖에 되지 않았다.빠르게 정보를 습득하는 것도 중요하지만, 정보가 남아있지 않다면 그 시간마저 버린 것이기 때문에 이렇게 기록이라도 하는 의식적인 노력을 들여야 조금이나마 내 자신이 개선될 것 같아 노트를 남긴다.+로 비판적 책읽기(책에 있는 내용을 무지성으로 수용하는 게 아니라 문장 하나, 단어 하나하나가 의미하는 게 무엇인지 곱씹어보기, 작가가 헛소리 하는 건 없는지 의심해보기)를 통해 작가와 소통하며 책을 읽는 듯한 느낌을 느껴보려고 하는 것도 있음. 제로 투 원 (ZERO to ONE) 참고로 나는 개정되기 이전 버전을 읽었음.읽게 된 계기는 회사 동료가 이 책을 읽고 가슴이 설렜다고 함.그래서 사내에 기증된 도서에도 있길래 읽었음.나의 난독+독해능력이 너무 딸려서 줄을 치면서(그나마 내용을 기억하기 위한 최소한의 행위&#x2F;노력) 읽고 싶었지만 회사 책이라 그러지는 못함.그러다보니 그냥 읽기만 하고 다음날 되면 전날 내용 다 까먹음.그러다보니 내가 이 책을 읽고 있기는 한데 남들한테 이 책이 무슨 내용이고 왜 좋고 어떤 영감을 받았는지 왜 추천하는지 하나도 설명하지 못함.그래서 2독을 결심하고 조금이나마 노력을 들여 나의 기억력 + 독해력 향상을 위해 노트에 받아적다가 팔도 아프고, 아무 노트에 대충 정리해놓다보니 나중에 잊혀질까 아까워서 그냥 블로그에 적기로 결심함.물론 손으로 적었을 때가 노력이 제일 많이 들어가다보니 기억이나 독해력 향상에는 도움이 많이 되는 것 같지만,노트에 적고 또 장기보존을 위해 블로그에 또 적자니 시간도 아깝고… 시간이 무한정 한 것이 아니기 때문에 걍 블로그에 적기로 결심. 참고로 이 책은 새로운 것을 창조하는 회사를 만드는 방법을 다루는 책임.따라서 스타트업 창업을 생각하거나 본인의 야망을 어떻게 실현시킬지, 어떤 생각으로 일을 하거나 인생을 살아가야하는지에 대한 도움이 될만한 책이라고 생각함.굳이 창업 안 하더라도 성공한 사람, 혁신을 이뤄낸 사람들은 어떻게 생각하고 어떻게 행동했는지 를 통해 배울 수 있는 점이 많음. 머릿말: 0이 1이 되려면익숙한 것을 베끼는 건 1 -&gt; N이 되는 꼴임. (모방, 쉬움)새로운 걸 만들어야 0 -&gt; 1이 되는 것임. (창조, 어려움)창조(새로운 걸 만드는 행위)는 모든 순간에서 단 한번만 일어남: 검색엔진을 만들어서 제 2의 래리 페이지, 세르게이 브린이 될 수 있는가? 그건 모든 순간에 있어서 단 한 번 밖에 일어날 수 없는 행위임.내가 검색엔진 만들면 그냥 1이 N이 되는 거임. (아니면 이미 많은 아이디어라면 N에서 N+@가 되는 거고…) 12345678나의 생각: 무엇이 창조이고 무엇이 모방인가? 그 기준은 무엇인가? 창조가 아니면 전부 노답인가? One of them(모방)이 부정적이긴 하지만 후발주자들이 성공하는 케이스도 있지 않은가? 1 -&gt; N이 되다가 그 안에서 0 -&gt; 1을 찾아야하는 걸까??모든 걸 0에서 시작할 필요는 없는 것 아닐까??1 -&gt; N을 잘하는 것도 힘든데 0 -&gt; 1은 평생 시도도 못해보는 거 아닐까?? 토스도 토스뱅크(카카오뱅크의 모방 아닌가?), 토스증권(이미 다른 증권사들이 하는 거 따라하는 거 아닌가?)을 보면 모방인 거 같은데...결국 그 안에서 창조를 만들어내야한다는 뜻일까?아니면 0 -&gt; 1이라는 행위를 내가 너무 맹신하고 있나? 꼭 0 -&gt; 1일 필요는 없는 것 아닐까? 아니면 내가 0 -&gt; 1이라는 행위에 대해 제대로 이해하지 못하고 있는 건 아닐까?? 하지만 이런 창조(0 -&gt; 1)는 매우 어렵고 수많은 기적이 필요함.하지만 인간은 그런 기적을 만들어 낼 수 있음.그리고 그 기적을 기술(technology)이라고 부름.기술이 기적인 이유는 더 적은 것으로 더 많은 일을 해주기 때문. (오프라인 결제는 점원이 병목이지만 온라인 결제는 그런 병목도 없음, 그냥 서버만 있으면 더 많은 결제를 받아낼 수 있음. 점포도 필요 없고 인건비도 안 나가고 서버비만 나감.) 12345나의 생각: 결국엔 기술력이 핵심이란 것일까??창조적인 아이디어가 있어도 기술이 뒷받침 해주지 못하면 결국 실현 불가능한 아이디어이니까...??그럼 개발자인 나는 아이디어를 실현시킬 수 있는 기술력을 쌓는데 더 많은 노력을 해야할까??아이디어가 없어서(사실 아이디어를 짜내는 행위도 잘 하지 않으니 이건 핑계겠지만...) 사이드 프로젝트나 창업 생각은 하지도 못하고 있는데지금 내가 잘 할 수 있는 것(기술력 쌓기, 대용량 트래픽 잘 받아내기, 생산성 향상시키기 등등)인 기술력 향상에 더 집중하다보면 번뜩이는 아이디어를 빠르게 구현할 수 있지 않을까?? 책에서 이런 내용들은 초등학교 2학년 때나 배울법한 기본적인 사실이라고 함. (산업혁명(농업사회에서 자동화 사회? 석탄… 공장의 발전??) 같은 것을 배우는 그런 시점을 말하는 것인가??)근데 우리가 이런 것들을 배웠음에도 불구하고 자주 까먹는 이유(애초에 이런 걸 생각조차 하지 못하는 이유)는 대부분 했던 일을 반복하는 세상속에서 우리가 살고 있기 때문이다. 123456789101112131415나의 생각: 반복하다보면 결국 익숙해지기 마련임.익숙해지면 편해지기 마련이고 편한 쪽으로 계속 가려는 게 사람 심리인 것 같음.결국 그 편함을 계속 추구하고 안주하는 게 제일 위험하다고 봄.발전이 없기 때문.지속적으로 comfort zone을 벗어나려는 노력을 하고 불편하고 스트레스를 받지만 그런 노력이 없다면 발전이 없는 거 같음.결국 반복되는 일상을 살다보니 기술력이 핵심이다(이건 내 생각), 기적을 만들어내야한다 라는 사실을 까먹고 살아가는 것 같음.반복되는 일상 속에서도 이건 왜 이렇게 해야하지? 이렇게 하면 더 편할 거 같은데? 왜 여기저기 정보가 파편화 돼있지?내 손 안 타고, 비개발자들도 확인하기 편하게 할 수는 없을까? 반복되는 업무를 어떻게 하면 내 손을 거치지 않고 끝낼 수 있을까?이런 생각을 계속 하다보면 결국 뭐라도 깨작대고 그 깨작댄 순간들로 인해 나에게 업무에 더 몰입할 수 있는 시간들이 주어지고 결국 생산성 향상으로 이루어짐.결국 나를 대신하는 무언가를 계속해서 만들어내는 기술력(자동화)가 나에게는 있기 때문에 이런 것들이 실현 가능한 것임.시간 없다, 할 일이 너무 많다 이런 핑계를 대지 않고 주말에라도 이런 것들을 찾아서 개선하는 노력을 조그만한 것이라도 하다보면(업무 환경을 개선할 수 있는 자동화 툴들을 많이 만들다던지)결국 생각이 발전/진화하여 더 큰 꿈을 이루어내는 아이디어까지 나오고 그간 내가 쌓아왔던 기술력이 빛을 발휘하지 않을까...??여튼 반복/편안함을 정말 위험한 신호로 받아들이고 끊임없이 Comfort zone을 벗어나 내 자신을 불편하게 만들고 그 불편함을 편하게 만들어서남들은 불편한 게 너무나 많은데 나한테는 그런 것들이 너무나 자연스럽고 익숙해서 더 많은 걸 이루어낼 수 있는 사람이 돼야겠음. 그동안의 모든 혁신은 창조에서 왔음.그리고 성공한 사람들은 예기치 못한 곳에서 가치를 찾았는데 기본적인 원리를 충실히 했기 때문임. 123456789101112131415161718192021222324252627나의 생각: 내 생각에는 창조가 아니고 모방으로도 성공한 사람 많은 거 같은데??모방만 해도 빡센데??아니면 내가 혁신이라는 것을 너무 과소평가하고 있나?혁신은 정말 대단하고 그 누구도 상상하지 못하고, 상상을 했더라도 실현 가능성이 넘사 급이고, 그 넘사를 이뤄내야 혁신인가?사람들의 행동패턴을 변화하고, 사회에 긍정적인 영향을 끼치고, 인류를 구원한다는 그런 사명감으로 똘똘 뭉친 아이디어들을 실현했을 때 혁신이라고 부를 수 있는 것인가?혁신이란 게 그렇게 대단한 것이라면 나는 살면서 혁신을 이뤄낼 수 있을까??아니면 혁신에도 크기가 있는 게 아닐까?큰 혁신을 한 번에 이뤄내기는 어렵지만 자그만한 혁신들을 조금씩 꾸준히 이뤄내다 보면 그게 결국 큰 혁신이 되어 미래를 바꿀 수도 있는 것은 아닐까?내가 이뤄낼 수 있는 혁신들에는 무엇이 있을까??개발자인 내가 사회에 어떤 영향을 미칠 수 있을까??당장은 안 떠오르니까 사내에서 동료들에게 긍정적인 영향력을 끼칠 수 있는 혁신의 아이템을 발굴하고 실천/개선해나가다 보면 뭔가 나오지 않을까??코드리뷰를 좀 더 적극적으로 잘 도와준다거나? 주말에 공부한 내용들을 공유한다거나? 그들도 기술에 관심을 가지도록 내가 더 많은 노력을 기울여서 성장하는 조직을 만든다거나...?뭐 여러가지 아이디어들이 있을테지만 벌써부터 이런 걸 실천하고 성공적으로 마칠 생각을 하니 주말에 쉬면 안 되겠다는 생각이 들면서 피로감이 몰려온다...또한 기본적인 원리를 충실히 했기 때문이라고 하는데...그럼 나는 기본적인 원리를 충실히 지키지 않았나? 내가 알고있는 기본이 그들이 알고 있는 기본과는 다르거나 그 커버리지가 엄청 차이가 나는 걸까??TDD의 기본이라고 하면 테스트를 먼저 짜는 것이지만 나는 그것을 지키지 못하고 답답한 마음에 먼저 어플리케이션 소스코드 짜고 그 이후에 테스트를 끼워 맞추고 있는데...어찌보면 기본적인 원리(테스트를 먼저 짠다)도 지키지 않고, 그 기본적인 원리를 지키기 위한 또다른 원리(프로덕션 코드에 바로 적용하기 어려우니 개인적으로 시간을 내어 익숙해지기 위한 훈련을 한다거나... 아니면 더 작은 단위에 대한 테스트를 먼저 짜보는 연습을 한다던가)를 모르기 때문이 아닐까??기본에 충실해라, 급할 수록 돌아가라... 라는 말을 많이 하지만 나의 성격이 급하고 시간이 없다는 핑계로 막 일하는 경우가 많은 것 같다.결국 그런 걸 개선하려면 어떻게 해야할까?어떻게 하면 급박한 상황 속에서도 평정심을 유지하며 기본을 지킬 수 있을까?실무를 하면서 당장은 고치기 힘들 것이므로 주말/평일에 따로 시간을 내서 기본에 충실하는 훈련을 해야하지 않을까?그런 훈련 방법에는 무엇이 있을까? 그리고 그 훈련을 효율적으로 하기 위해서는 어떻게 해야할까...??생각에 생각이 꼬리를 물고 결국 실천은 안 하고... 생각만 하면 피곤하고... 주말에 누워서 띵까띵까 유튜브나 보고 있고...성공한 사람이 되기 위해서는 정말 힘든 거 같다, 근데 뭐 생각해 보면 당연한 이치인 거 같기도 하고...평범한 사람들이 살듯이 주말에 띵까띵까 놀면서 성공하고 위대한 사람이 되고싶다고 생각하는 건 심하게 말하면 미친 생각, 도둑놈 심보/로또를 바라는 격이고 나에겐 그런 천운이 있지 않으니 정도를 가야하는 게 맞는 것 같다. 1. 미래를 향해 도전하라.Q: 정말 중요한 진실인데 남들이 당신한테 동의해주지 않는 것은 무엇인가요?A: 대부분의 사람은 X라고 믿지만, 진실은 Y예요. 진실이 Y일지라도 Y라고 믿는 사람이 많지 않고(그건 많은 사람들이 알고 있는 진실일테므로, 책에서는 현재 교육 시스템이 문제가 있다고 지적하는 걸 예로 들고 있다.),흔한 논쟁 중 한 쪽의 주장이 되지 않아야 좋은 대답이라고 할 수 있다고 한다. (책에선 신은 존재하지 않는다는 걸 예로 들고있다.)대부분의 사람이 X라고 믿는 이유는 학교에서 배우는 지식은 모든 사람들이 동의한 내용이기 때문이고,내가 Y라고 믿는 이유는 미래를 예견했기 때문이다. (물론 정확하지 않을 수 있겠지만…?)미래가 중요한 이유는 세상이 현재(지금 우리가 보는 세상)와 다를 것이기 때문이다.따라서 현재와 10년 후의 미래가 다르지 않다면 그건 미래가 아직도 10년이나 남았다는 것을 의미한다.하지만 현재와 10년 후의 미래가 급격하게 달라진다면, 그건 미래가 코앞에 와있다는 뜻이다. 또한 이런 미래를 바라볼 수 있는 예견 능력(천재적인 아이디어)이 있다 할지라도 어찌보면 불편한 사실일 수 있는 이 내용을 내뱉을 수 있는 용기가 더 훌륭하다고 말한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344나의 생각: 책에서 미래는 아직 오지 않은 순간들의 총합이라고 했는데 나에겐 정말 충격이었다. (1독 할 때는 충격도 받지 못했다, 이 책을 빨리 읽어야겠다는 생각 때문에 이런 깨우침을 느끼지 못한 것 같다.)그 말 뜻을 또 곱씹어보면 현재와 미래가 다르지 않으면 아직 아무런 것도 오지 않은 것이고 그런 미래는 미래라고 부를 수 없는 것이다.그냥 미래가 시간이 지나서 미래라고 부를 수 있는 게 아니라 발전적인 미래를 뜻하는 건가?? 싶었다.그런 의미에서 또 생각해보면 과거 오스트랄로피테쿠스 시절에는 엄청나게 발전이 느렸지만 요즘에는 발전의 속도가 정말 미쳤다. (스마트폰의 발전만 보더라도...) 그렇다면 우리는 더욱 더 미래를 앞당기고 있고, 과거 조상들이 살았던 시간보다 더 많은 시간을 사는 듯한 효과를 누리는 것이 아닐까?? 과거에는 어떤 발전/혁신을 이뤄내려면 수십~수백년이 걸렸다면 지금은 수개월 사이에도 혁신이 나오기도 한다. 그런 반복된 일상들을 살아왔던 조상에 비하면 우리는 몇배, 아니 몇십배는 더 많은 미래와 세상을 경험하며 살아가는 것이 아닐까?? 이렇게 되면 우리는 지구의 수명도 점점 더 앞당기게 되는 것 같고(원래는 지구의 수명이 10억년이었다면 우리가 자꾸 미래를 앞당겼기 때문에 탄소를 많이 써서 5억년으로 줄였다던지...)그러다보니 환경의 중요성도 많이 깨달아야 할 것 같다.또 이건 잡설인데 미래를 자꾸 앞당긴다고 하다보니... 나이가 들면 들 수록 세월이 빠르게 흘러간다고 생각하는 것도 미래를 계속 앞당기고 있기 때문이 아닐까?라는 말도 안 되는 망상을 해보게 되었다. (생각해보면 나이가 들면 들 수록 세월이 빠르게 흘러간다고 생각하는 이유는 뇌의 어떤 작용이 나이가 들면서 달라지기 때문이 아닐까??)그리고 대부분의 사람들이 X라고 믿는 이유도 학교에서 배우는 지식들이 모든 사람들이 동의한 내용이라고 한 것도 좀 충격이었다.뭐 강남 대치동에 부잣집 자제들이 고액과외해서 서울대 가도 죽도 못 쓰는 사람들이 있다는 얘기를 들은 적이 있는데 이유들이 그런 것 때문 아닐까? 무지성 주입식 교육으로 과외선생님이 하라는대로 시키고 대학교 가니까 자유가 주어지니 어찌 해야할지 모르는 게 아닐까?그리고 어쩌저찌 대학에서는 잘 했다 할지라도 교수 마저도 사라지니 이제 또 능동적으로 어떻게 해야할지 몰라서 그런 게 아닐까?결국 그런 울타리 안에서 보호받다가 나왔을 때 어찌해야할지 모르는 현상이 나타나지 않으려면 선생님/교수/교과서/책 등등 많은 사람들이 신뢰하기로 합의한 내용에 대해서 비판적으로 받아들여야하지 않을까 싶다. 나야 뭐 고등학교 때는 그냥 공부를 잘 안 해서 무지성 수용할 것도 없었고, 하지만 대학을 가서 강의의 질에 엄청난 실망을 하고 교수와 학과, 더 나아가 학교에 대한 신뢰감이 바닥을 쳤다. 만약 내가 다른 학생들처럼 관심없는데 점수 맞춰서 학과를 왔거나 평상 시 관련 정보 습득을 게을리 했다면 나도 좋은 게 좋은 거지, 교수님이 우리보다 얼마나 더 많은 경험과 지식이 있을텐데 다 맞는 말씀 하시겠지 라고 생각했을 것 같다.물론 좋은 학교의 좋은 교수님이었다면 나에게 다른 인상을 심어줘서 무지성 수용을 했을지 모르겠지만, 그 때 안 좋은 학교의 안 좋은 교수들을 만남으로 인해 교수님들이 이상한 소리 하는 건 아닌지 의심하고 필터링 하게 되었다. 또한 내가 이렇게 비판적으로 생각해볼 수 있던 원인 중 하나는 주변에 개발자들을 알고 있었기 때문이다.오프라인 스터디를 통해 알게 된 스승 격이라 볼 수 있는 개발자 분들께 교수님께 들은 얘기가 실무에서도 먹히는지, 요즘 개발 생태계가 진짜 그렇게 돌아가는 게 맞는지물어보고 검증해보면서 그게 맞는 말인지 틀린 말인지 판단할 수 있는 기준이 생기게 되었다. 물론 나의 검증이 틀렸을 수도 있지만 적어도 나에겐 사실 여부를 판단할 수 있는 리소스(어찌보면 인맥)이 있었기 때문에 비판적으로 정보를 습득할 수 있었다. 이렇게 비판적으로 생각해볼 수 있는 힘을 기르려면 평상시 관련 정보 습득도 게을리하지 않고, 카더라~ 소식(블로그 등등)보다는 공식 문서나 오피셜 자료들 위주로 사실에 입각해 정보를 수용하는 자세를 가져야할 것 같다. 물론 무지성 수용이 빠르고 쉽게 정보를 습득할 수 있다는 측면에서는 너무나 편하고, 모든 내용을 비판적으로 수용하려면 시간을 한없이 써야하니 둘 사이의 밸런스를 잘 맞춰야할 것 같다.그리고 내가 정반대라고 믿게 된 이유는 미래를 예견했기 때문인데...(현재는 아니지만 미래에는 세상이 달라질 것이므로 미래 관점에서는 해당 사실이 진실이 되는 케이스)미래를 정확하게 예견하면 그럼 선두주자가 되는 것인가? 결국 선두주자가 되어 남들은 아무도 하지 못하는 시장에 들어가서 독점을 해야한다는 뜻일까??근데 그 미래가 너무 먼 미래라면 또 어떨까? 이것도 결국 너무 멀지 않은 미래에 대한 예견을 통해 선두주자가 되어야하는 것일까??근데 선두주자가 되었어도 결국 후발주자에게 빼앗기는 경우도 많은데...결국 미래를 예견하여 선두주자가 되었다 하더라도 후발주자가 따라오지 못할만큼의 격차를 그 사이에 엄청나게 벌려놓아서 시장을 잡아먹어야한다는 뜻인 것 같다.그리고 천재적인 아이디어(미래 예견 능력?)보다도 중요한 것이 용기라고 하는데 아마 이런 내용 중에는 다소 불편한 진실들이 많기 때문이 아닐까 싶다...사람들이 이건 무조건 맞지! 라고 생각하는 내용에 반대되는 개념을 들고오면 싸이코인가? 라고 생각할 수도 있기 때문이다. (지구는 둥글다 같은...??)근데 뭐 토스 팀의 코어밸류(핵심 문화, 가치) 중 하나인 불편함을 감수하는 용기(Dare to Make Conflicts)도 이런 걸 강조하기 위함이 아닐까 싶다. 좋은 게 좋은 거지~라고 생각하고 넘어갔다가 나중에 후폭풍이 몰려오는 경우가 많다. 그냥 상대방이 마음에 들지 않아 태클을 거는 게 아니라 정말 감정은 다 빼고 여러가지 근거(데이터를 기반한)를 토대로 피드백을 주는 것이다.여기서 또 어떻게 피드백을 줄 것인지는 개개인의 역량인 것 같지만 나는 다소 직설적으로 말하는 편이다.그걸 처음에 좀 거부감이 드는 사람도 있을지 모르겠지만, 나도 좋은 게 좋은 거지~ 란 생각으로 참으면서 많이 살아왔는데 그게 결국 좋게 끝난 적은 많지 않은 것 같다. (여러 인간관계에서 그렇게 살아왔는데 상대방은 몰라도 나는 불만족스러웠다.)또한 사사로운 감정이 들어간 관계라면 더더욱 이런 용기를 내는 게 나중에 나에게 올 여파가 두려워서 많이 용기를 못내는 편인데 회사는 프로답게 일을 하는 공간이고, 프로끼리 사사로운 감정에 얽매이기 보다는 더 나은 방향으로 나아가기 위해서는 더 빠르고 정확한 피드백 전달을 위해선 잔인할만큼 직설적인 필요도 있는 것 같다.그런 측면에서 나는 용기가 있는 사람인가? 싸가지 없는 사람인가? 가끔 고민이 들 때가 있기도 하지만, 주변 동료들의 피드백으로는 직설적이기 때문에 피드백이 더 정확하게 작동한 거 같다는 내용이 있어서 앞으로도 이런 자세를 고수하지 않을까 싶다.물론 잔인할만큼 직설적이라고 해서 상대방에 대한 리스펙 없이 말을 하면 싸가지가 없어질 것이기 때문에 리스펙은 하되 정확한 사실 기반으로 전달하려는 그 밸런스 조절은 잘 해야할 것 같다. 하지만 미래를 정확히 예견할 수 있는 사람은 아무도 없다고 한다.그럼에도 불구하고 아래 두 가지 사실은 확실하다고 한다. 미래는 지금과는 다를 것이라는 점만약 그렇지 않다면 엄청난 위기라는 사실일까…? 미래의 뿌리는 현재의 세상일 것이라는 점그럼 현재를 정확히 판단해야 미래를 예견할 수 있는 능력을 키울 수 있을까??책에서도 사람들의 의견과 반대되는 의견을 낼 줄 아는 사람은 현재를 바라보는 시각의 차이가 있기 때문이라고 한다.결국 현재를 통찰하는 능력을 키우라는 거 같당. (물론 그 현재는 과거의 미래이기 때문에 과거에 대한 통찰도 중요한 거 같다.) 0에서 1로: 진보된 미래 수평적 진보: 효과가 입증된 것을 카피하는 것(1 -&gt; n), 우리가 이미 알고 있는 것이기 때문에 미래가 쉽게 그려진다.ex) 한 개의 타자기를 보고 100개의 타자기로 만드는 것, 글로벌화 (한 곳에서 성공한 것을 모든 곳에서 성공하게 만드는 것), 중국(미국을 따라잡는 것, 하지만 모든 과정을 카피하는 게 아니라 중간에 불필요한 과정은 스킵) 수직적 진보(집중적 진보): 새로운 일을 하는 것(0 -&gt; 1), 아무도 한 적이 없는 일을 하는 것이기 때문에 미래가 쉽게 상상되지 않는다.ex) 한 개의 타자기를 보고 워드프로세서를 만드는 것, 기술(technology, 굳이 컴퓨터 기술일 필요는 없고 새롭고 더 나은 방식으로 무언가를 가능하게 해주는 모든 것) 123456789101112나의 생각: 역시 빠른 성장에는 모방(카피)만 한 게 없는 것 같다.중국이 그렇~게 빨리 성장한 것도 모조리 다 짝퉁에 세계의 공장(값싼 인건비로 인한) 역할을 했기 때문이 아닐까 싶다. 하지만 그로인한 사이드 이펙트도 엄청난 것 같다. 결국 미국이 견제할 만큼 중국이 무서운 속도로 성장하자 미국에서는 중국을 견제하기 시작했고, 중국 자체적으로도 점점 성장 곡선이 꺾이고 있기 때문이다. 그럼 답은 빠른 카피/글로벌화를 이뤄가면서 동시에 새로운 기술로써 혁신(창조 행위)을 이루어내야하는 것일까??혁신만 하려면 불확실한 미래에 엄청 큰 배팅이고, 카피만 하다가는 언젠가 한계에 도달할테고...둘 다 어려운데(혁신이 훨씬 어렵긴 하지만) 둘을 동시에 할 수나 있을까??카피를 통해 감을 잡은 후에 혁신을 이뤄내야할까?아니면 혁신을 먼저 계획하고 그를 위한 여러 모방을 하다가 점점 호랑이 이빨 드러내듯이 슬슬 혁신을 해야하는 걸까??근데 토스에서 처음에 간편송금 한 거 보면 아무도 들어오지 않았던 시장을 공략(0-&gt;1)을 했기 때문에 성공한 거 같은데...그럼 역시나 여러가지 혁신을 계속해서 돌려보고, 그 중에 하나 맞는 걸 찾아서 쫙 끌어올려야하는 걸까??역시 쉽지않당. 한동안 글로벌화가 진행되고 나면 여러 가지 융합과 획일성이 확대될 것이라고 대부분 생각한다고 함.그를 뒷받침하는 증거로 선진국은 devloped(개발이 완료된)이라고 부르고, 개발도상국은 developing(개발 중인)으로 나누었다는 점이다.선진국들은 이미 이룰 것을 다 이뤄서 끝마친 상태고, 개발도상국들은 선진국을 그저 따라잡는다는 의미를 내포하고 있다고 한다. 12345678910111213141516나의 생각: 영어를 몰라서 선진국과 개발도상국의 의미를 그냥 뉴스나 사전만을 통해 접했는데 영어 단어로 보고 나니 체감이 확 됐다. 사회적으로 합의된 일반적인 통념(선진국은 더이상 발전이 없고, 개발도상국은 선진국을 따라가기만 하는...)이 무엇인지 알 수 있어 엄청난 충격이었다.근데 너무나 무서운 생각같다.이미 개발이 다 완료돼서 더이상 발전이 없는 나라에서 산다고? 나는 미국이 정말 살기 좋은 나라라고 생각했는데 그게 끝이라면? 미래가 현재와 똑같다면?그럼 국민들의 행복지수는 지금이 사상 최대치가 아닌가? 이 이상 행복할 수 없는 최대한계치에 도달한 거 같은데??개발도상국이 더 행복지수가 높다는 걸 얼핏 들었던 거 같은데 그 이유가 여기서 나오는 게 아닐까? 그들에게는 앞으로 끊임없는 발전이 있을 것이기 때문에?? (물론 모든 국민이 그렇게 생각하는 것은 아니겠지만...)난 선진국을 developed(개발이 완료된) 상태라고 생각해서 이름을 지었다는 것부터 그 이름을 지은 사람이 얼마나 쉽게 만족하는지 알 수 있을 것 같다. (정말 심각하게 표현하자면 무능하다고 까지 생각이 든다.)여기서 끝내버린다고? 그럼 후대의 자손들은? 우리들의 미래는? 그런 것도 생각하지 않고 저런 단어를 썼단 말인가?물론 선진국이라고 해서 발전이 없는 것은 아니지만 저런 단어를 보면 &quot;아 우리 할만큼 했어~&quot;라고 생각해서 금방 다른 나라에 역전될 것만 같아 불안하다.나는 한국이 선진국(developed)일지는 몰라도 마인드 만큼은 개발도상국(developing)을 지녔으면 좋겠다.나만 해도 이미 developed 상태라고 생각해서 공부를 멈추고 마땅한 노력 없이 그냥 토스에 평생 직장으로 천년만년 살아야지~ 란 생각을 가지기 시작하면 너무나 위험할 것 같다. (물론 그 안에서 다양한 챌린지를 통해 성장하긴 하겠지만...)아직도 주니어라고 생각하고(연차가 많지도 않고, 내가 생각한 미래와 현실 사이의 나의 기술 역량의 괴리감은 엄청나기 때문에...) 여기가 나의 최대치라고 생각하면 너무나 비참해진다.인생에 있어 큰 행복이나 취미도 없고 그나마 만족감을 느끼는 일과 성장에 있어서 이게 최대치라고 하면 앞으로 나는 어디서 행복을 찾는단 말인가...? (아직 자신에 대한 불만족이 너무 커서 행복하지가 않다.)내가 행복감을 느낄 만한게 크게 없기 때문에 그나마 행복/만족감을 느끼는 측면에서 계속 developing을 해야 내가 지속가능한 삶을 살 수 있을 것 같다.그걸 위해서는 끊임없이 comfort zone을 의식적으로 벗어나려고 노력을 해야할 것 같다. 피터 틸(작가)은 대부분의 사람은 글로벌화가 미래를 결정할 것이라고 생각하지만, 기술이 더 중요하다고 말한다.만약 글로벌화가 미친듯이 진행되어 중국&#x2F;인도의 인구가 미국 사람들처럼 똑같이 에너지를 쓴다면 에너지는 고갈될 것이고 지구의 환경은 더더욱 빠르게 황폐화될 것이기 때문이다.또한 시간이 흐른다고 해서 자연스레 새로운 기술이 나타나는 것도 아니다.과거 오스트랄로피테쿠스 시절을 생각해보면 얼마나 발전이 더뎠는가? 그런 사회에서 성공은 남의 것을 빼앗는 것 뿐이다. (영토 전쟁 등등)그러다 점점 시간이 흐르면서 원시시대의 농경, 중세의 풍차 등등의 간헐적인 진보만 있다가 1760년대에 증기기관이 출현하면서 폭발적 진보가 있었다.이런 폭발적인 진보가 1970년대까지 이어진 결과 우리는 미래는 더 진보된 미래가 돼있으리라는 사실을 믿게 되었다.하지만 그런 일들은 일어나지 않았으며 최근까지의 진보는 대부분 컴퓨터&#x2F;통신 분야가 주를 이루었다.저절로 세계가 더 나은 미래로 간다는 믿음은 잘못된 사실이었던 것이다. 1234567891011121314151617181920212223242526나의 생각: 뭐 에너지 처럼 희소성이 있다거나 지구 환경에 피해를 끼치는 요소 말고도 글로벌화의 종말은 더이상 발전없는 미래가 될 것 같기도 하다.지구의 모든 인구에게 글로벌화가 진행됐다면 그 이후는? 출산률이 더더욱 줄어들 게 될 미래에는?결국 글로벌화도 중요하지만 그보다 중요한 건 기술인 것 같다.그리고 그 기술을 그냥 막연하게 언젠가는 이런 세상이 오겠지~ 라고 천하태평한 마인드로 살아가는 것도 잘못된 믿음인 것 같다.나만해도 초등학생 때 2030년을 생각하면서 그림을 그려보라고 학교에서 시키면 날아다니는 자동차를 타겠지~ 같은 뻔한 그림을 그렸다.아직 2030년이 되려면 8년이 남긴 했지만 가까운 미래로 다가오자 그게 현실성이 있다고 생각이 되는가?결국 그런 혁신이 오려면 더 많은 시간이 걸리거나 아니면 그러한 시간을 앞당길만한 더 대단한 혁신들이 쏟아져나와야 할 것 같다.하지만 그런 미래는 이런 안일한 태도로는 절대 오지 않으리란 사실에는 틀림이 없는 것 같다.근데... 그럼 나는 어떻게 살아가야하는가?그냥 맨날 하던대로 자바(코틀린)/스프링(부트) 써서 개발하고 살아가는데... 미래를 혁신시킬만한 다른 기술들(오픈소스, 라이브러리/프레임워크 등등)을 만들어내야하는가?아니면 지금 내가 쓰고 있는 기술이라고 하더라도 그 기술들로 더 새로운 기술(비즈니스)를 창출해나가야할까?그것만이 답일까? 토스에서 10인분을 하도록 하는 건 혁신이 아닐까?그리고 글로벌화가 꼭 1 -&gt; N일까?에 대한 고민도 해보게 되었다.결국 기업이 0 -&gt; 1을 해서 국내시장을 잡아먹었다 하면 세계 시장으로 눈을 돌리게 될 것이다.하지만 국내에서 하던대로 1 -&gt; N이 끝날까? 그만큼 단순한 일일까?각 나라만의 문화와 여러가지 상황들이 있을텐데 절대 아닐 것이다.우리나라에서는 이게 당연한 건데 그 나라에서는 아닐 수 있다. 이런 걸 해결해나가는 것도 어찌보면 0 -&gt; 1이 아닐까??그렇게 봤을 때 1 -&gt; N 안에서도 잘게 쪼개보면 무수히 많은 0 -&gt; 1이 있지 않을까?? 싶다.이 책에서는 글로벌화 보다는 기술에 중심을 두고 있다보니 글로벌화에 대해 개인적으로 부정적 혹은 좀 낮게 보는 경향이 있는 것 같은데 이 또한 쉽지 않은 것 같다.결국 큰 그림과 인생에 있어서 마인드는 0 -&gt; 1을 끊임없이 만들어내려고 해야할테고 그 안에서 자연스레 1 -&gt; N도 이뤄내지 않을까?? 싶다.이건 여담이지만 지도를 보더라도, 해외를 나가보더라도 진짜 한국만을 가지고 생각하는 것은 우물 안 개구리이다.그런 관점에서 보면 1 -&gt; N만 달성했다 하더라도 진짜 대단한 것이다.근데 0 -&gt; 1을 이뤄내는 사람은... 정말 어떤 사람들일까?? 존경심이 생긴다. 신생기업과 새로운 생각새로운 기술은 새로운 모험, 즉 무언가를 새로 시작하며 나타나는 경우가 많다고 한다.세상을 더 나은 곳으로 변화시킨 주체는 일종의 사명감으로 똘똘 뭉친 소규모 집단들이었다.큰 조직에서는 새로운 것을 개발하기가 어렵고, 관료적 계급 조직은 행동이 굼뜨고, 이해관계가 잔뜩 맞물려있는 조직은 위험을 감수하지 않는다.반대편 극단인 외톨이형 천재(혼자)는 예술이나 문학의 고전을 남길지는 몰라도 산업 하나를 통째로 변화시키지는 못한다. (있다 해도 매우매우매우 드물 듯)즉, 신생기업이 제대로 돌아가려면 실제로 뭔가 할 수 있을 만큼 작은 규모로 유지되어야 한다. 12345678910111213141516나의 생각: 전형적인 대기업의 꼰대스러움/정치/실무역량과 관계 없는 이력서,면접 때문에 큰 조직에 대한 부정적 인식은 너무나 컸다.하지만 내가 1인 개발자에 대해 좀 과대평가 했던 부분도 있는 것 같다. 1인 개발자가 매달 게임 앱을 출시해서 광고비 같은 걸로 쏠쏠하게 돈을 번다는 걸 보고 오~ 괜찮은데? 라고 생각했는데 나의 꿈이 작았던 것 같다.결국 그런 사람이 이 세상에 어떤 영향을 끼쳤단 말인가? 그냥 본인 혼자 만족하는 수준에 그쳤다. (뭐 내가 모르는 영향력이 있을테지만 적어도 내가 기대하는 바 보다는 작은 것 같다.)처음엔 혼자 시작할지 몰라도 결국 마음이 맞고 미친 듯 헌신/몰입할 준비가 된 소수의 인원들로 똘똘 뭉쳐 키워나가야하는 것 같다.군중 심리인가... 사람이 많으면 누군가는 하겠지? 라고 사람들이 수동적인 자세를 취하기 마련이다.하지만 나 말고 할 사람이 없다면? 나라도 해야한다면? 그럼 하게 된다.비슷한 경험을 한 적이 있는데 바로 한 사람의 퇴사로 인해 깨닫게 되었다.해당 팀에서 중요 인물 한 사람이 퇴사하자 다른 인원들이 더 능동적으로 바뀌었다. 그 사람이 하던 업무를 내가 해야되니까... 즉 너무 인원이 많으면 그 사람들이 전부 100% 이상의 실력 발휘를 하지 못하는 것 같다. (그렇다고 그 팀이 인원이 많았던 것은 아니지만 한 사람의 커버리지가 너무 넓었던 건 아닌가 싶다.) 또한 요즘 드는 생각이 토스 정도면 대기업 아닌가? 이미 고일대로 고인 것인가?하지만 토스에서 제품을 만들고 그 안에서 성장과 혁신을 만들어내는 속도와 규모를 보면 전혀 그렇지 않다는 생각이 들지 않는다.외부에서 바라봤을 때는 매출 규모라던지, 기업 가치라던지, 인원이라던지 이런 외형적으로 보이는 요소에만 집중할 수 밖에 없는데 그런 기준에서는 분명 대기업이라고 보일지 모른다.하지만 조직들을 잘게 쪼개어 그 안에서 수많은 스타트업처럼 일하는 형태들로 인해 곳곳에서 성장과 혁신이 지속될 수 있는 것 같다.그럼에도 불구하고 토스의 찐 초창기만큼은 아닐테지만... 그래도 이정도 규모에서 이정도 속도감으로 일한다는 것은 상상하기 힘들다. 그리고 좀 더 극적으로 말하면 신생기업은 지금과는 다른 미래를 만들기 위한 당신의 계획을 납득시킬 수 있는 최대치의 사람이라고 한다.또한 새로운 생각이 민첩함 보다 중요하다고 하는데 규모가 작아야 새로운 생각을 더 자유롭게 할 수 있다고 한다. 그리고 이 책은 특정 지식의 기록은 아니고 메뉴얼도 아니라고 한다.오히려 이 책은 생각하는 연습을 해보는 자습서라서 여러 질문에 관한 책이라고도 한다.생각이야말고 신생기업이 반드시 해야할 일이고, 당연시 되는 생각에 의문을 제기하고 백지상태에서 다시 사업을 생각해야한다고 한다. 12345678910111213141516171819202122232425262728293031323334353637나의 생각: 신생 기업이 단순히 소규모라고 해서 규모만 중요한 게 아닌 거 같다.마음 맞는 사람도 그만큼 중요하고 그 마음 맞는 사람이 얼마나 더 나은 미래로 이끌만큼 역량이 되고, 나의 계획을 미래의 다른 사람들에게 얼마나 납득시킬 수 있는가? 도 중요한 것 같다.이 사람이 나하고 마음이 잘 맞을 수 있다. 그래서 쿵짝쿵짝 잘 할 수 있다.하지만 그 다음은? 미래는? 사람이 더 들어오지 않을 것인가?그럼 내가 그 때도 여전히 새로운 사람을 계속 설득하고 있을 것인가? 아니면 팀원들이 설득할 것인가? 그리고 또 그 다음 미래에는?결국 이 물음에 대한 해답은 성장하는 조직에 있는 것 같다.내가 토스 초기에 입사했을 때 시니어 개발자(진짜 내 인생에 있어서 나에게 막대한 영향을 끼쳤고 진심으로 리스펙하는 분) 분께 늦은 시간에 코드리뷰를 요청하여 새벽까지 진행된 적이 여러 번 있었다.그 때마다 나는 너무 죄송하지만... 그래도 뽑아먹을 건 뽑아먹어야지?? 라는 생각이 들었고 어느날 힘드시진 않는지, 짜증나지는 않는지 여쭤보았다.그 분께서는 물론 피곤하고 힘들긴 하지만 &quot;성장하는 조직과 성장하는 문화&quot;를 만드는 과정이라고 생각한다고 하셨다.지금 내가 힘들지라도 이 사람을 성장시켜서 그 사람이 이제는 어엿한 1인분을 하게 되어 나의 일을 덜어준다면...?또한 거기서 멈추는 게 아니라 성장하는 문화까지 습득하여 다른 팀원들의 성장까지 돕는다면?그리고 그 팀원들마저도 성장하는 문화를 기여하는데 도움이 된다면?무한히 성장하는 조직이 되지 않을까??나는 내 팀이 이렇게 되길 바란다.내가 막 그렇게 훌륭한 개발자는 아니지만 그래도 마인드만큼은 훌륭한 개발자들을 따라가려고 한다.내가 리스펙하는 사람이 나에게 막대한 영향을 끼쳐서 과거 우리팀이 성장했던 것 만큼 나도 성장하는 팀과 문화를 만들어 정말 남들이 같이 일하고 싶어하는 팀, 개발 역량 쭉쭉 성장하고미친듯한 몰입감과 열정/호기심으로 똘똘 뭉친 사람들끼리 그런 팀/세상을 만들고 싶다는 열망으로 가득하다.이렇게 되기 위해서는 나의 팀원은 나보다도 더 훌륭한 사람들로 가득차야 나도 자극받고 그로 인해 긍정적인 효과들이 무한대로 늘어날 것이다.물론 이 와중에 이런 문화를 같이 만들어나가는 게 아니라 누리러만 오는 사람도 있을 것이다. 물론 업무 효율에는 단기적으로 없는 것보다 있는 것이 낫겠지만... 정말 내가 스타트업을 꾸린다고 했을 때 이런 사람을 잘 보고 걸러내야 할 것 같다. 그런 측면에서 내가 토스 문화를 누리기만 하는 사람은 아닌지... 약간은 뜨끔하다.그리고 이 책이야말로 정말 비판적 책읽기를 권장하고 있었는데 역시 나의 낮은 독해능력으로 인해 그 중요도를 간파하지 못했다.당연시 되는 생각에 의문을 제기하고... 이거 정말 중요하다.지금 그렇게 책을 읽고 정리하니까 20페이지 읽는데만 4시간이나 걸리는 것 같다...또한 비판적 책읽기를 더 넓히면 책읽기에서 그치는 게 아니라 비판적으로 사고하기로 실생활에 옮길 수도 있다.이걸 정말 잘 하는 사람은 토스팀 리더인 승건 님 같다.승건 님과 많은 대화를 해보거나 승건 님에 대해 잘 아는 것은 아니지만, 미팅을 한 번 했을 때 나는 너무나 당연하고 절대 바뀌지 않고 이걸 할려면 너무나 많은 노력이 들어 할 엄두도 못 내고 있는 내용에 대해&quot;왜 그래야만 하죠? 너무 이상한데요? 이게 말이나 되는 얘기인가요?&quot;라는 얘기를 들었을 때 망치로 머리를 얻어맞은 기분이었다.물론 나는 디테일한 사항을 알고 있어서 더 그 내용에 대한 맥락이 많아 부정적으로 생각한 경향이 없잔아 있었겠지만, 어떻게 감히 그런 상상을 하고 그걸 입밖으로 내뱉는 용기가 있는 거지?진짜 이 사람 대단하다... 쩐다... 라고 생각한 순간 중 한 부분이었다.또한 특정 일을 두고도 나는 이걸 하면 뭐 때문에 안 되고, 어떤 민원이 있을 것이며 CS가 빗발칠 것이다 등등 안 되는 이유만 수십 수백가지를 댔었다.하지만 우리가 계속 그러한 태도로 나오자 한 사람은 &quot;왜 자꾸 안 되는 이유만 찾냐? 그걸 되게 하려면 어떤 이슈들을 해결하면 되는지 생각해보면 좋지 않겠냐?&quot;라는 피드백을 간접적으로 들었다.그 당시에도 머리에 좀 충격이 왔지만, 역시나 안 되는 이유가 너무 절대적이라 행동으로 옮기지 못했다.하지만 어떤 결정적 이유로 인해 그 일을 해야만 했고, 최선은 아니지만 차선책을 찾아서 어찌저찌 꾸역꾸역 진행한 경험이 있다.개인적으로 임팩트도 컸고 굉장히 잘 한 일이라고 생각하는데 그 때는 왜 그렇게 보수적으로 생각했는지 모른다.물론 아직 풀어가야할 숙제들이 많이 남아있지만, 그래도 고객 경험을 개선했다는 점에는 이견이 없기 때문에 앞으로도 이렇게 좀 비판적으로 사고하고 되게 할려면 어떻게 해야하는가?에 대해 포커싱하여 생각하고 움직여야할 것 같다. 음… 생각보다 시간이 많이 걸려서 나머지 파트는 언제 작성 할 수 있을지… 이런 식으로 계속 읽어나갈 수 있을지는 고민이다.(매일매일이 주말이라면 이렇게 할텐데 평일에는 이렇게까지 시간이 안 날 때가 많고, 여기에만 올인을 할 수 없으므로…)","categories":[{"name":"Notes","slug":"Notes","permalink":"https://perfectacle.github.io/categories/Notes/"},{"name":"독서","slug":"Notes/독서","permalink":"https://perfectacle.github.io/categories/Notes/%EB%8F%85%EC%84%9C/"}],"tags":[{"name":"독서노트","slug":"독서노트","permalink":"https://perfectacle.github.io/tags/%EB%8F%85%EC%84%9C%EB%85%B8%ED%8A%B8/"},{"name":"제로 투 원","slug":"제로-투-원","permalink":"https://perfectacle.github.io/tags/%EC%A0%9C%EB%A1%9C-%ED%88%AC-%EC%9B%90/"},{"name":"ZERO to ONE","slug":"ZERO-to-ONE","permalink":"https://perfectacle.github.io/tags/ZERO-to-ONE/"}]},{"title":"라스베가스를 다녀오고... 5편 (feat. AWS re:Invent 2021) - 세미자 마지막 날부터 인천공항까지","slug":"las-vegas-aws-reinvent-05","date":"2021-12-31T23:27:31.000Z","updated":"2022-10-30T08:42:16.823Z","comments":true,"path":"2021/12/31/las-vegas-aws-reinvent-05/","link":"","permalink":"https://perfectacle.github.io/2021/12/31/las-vegas-aws-reinvent-05/","excerpt":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) - 현재 게시물 용기내어 한마디라도 건네보기어젯 밤 re:Play 행사를 갔다오고 나서 없던 자신감이 샘솟고 좀 더 미국에서만 경험할 수 있는 것을 경험해보고 싶다는 생각에 가득찼다.그러다보니 동료 한 분과 아침식사를 하면서 무조건 외국 엔지니어들과 대화를 해보겠다는 목표를 세웠다. 일단 테이블에 앉을 때도 2명 정도 앉아있으면서 우리한테 대답해줄 거 같은 착한 사람을 물색하였다.목표를 포착하고 앉아서 말없이 우리끼리만 대화를 하였다.그러다 동료가 용기내어 말을 걸었고, 알고보니 그들은 United 항공사 소프트웨어 엔지니어들이었다.대충 뭔 이야기를 했던 것 같은데 잘 기억은 안 나고 ‘우리 샌프란시스코에서 너네 항공사 타고 라스베가스로 왔어~’와 같은 시덥잖은 대화를 했던 것 같다.","text":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) - 현재 게시물 용기내어 한마디라도 건네보기어젯 밤 re:Play 행사를 갔다오고 나서 없던 자신감이 샘솟고 좀 더 미국에서만 경험할 수 있는 것을 경험해보고 싶다는 생각에 가득찼다.그러다보니 동료 한 분과 아침식사를 하면서 무조건 외국 엔지니어들과 대화를 해보겠다는 목표를 세웠다. 일단 테이블에 앉을 때도 2명 정도 앉아있으면서 우리한테 대답해줄 거 같은 착한 사람을 물색하였다.목표를 포착하고 앉아서 말없이 우리끼리만 대화를 하였다.그러다 동료가 용기내어 말을 걸었고, 알고보니 그들은 United 항공사 소프트웨어 엔지니어들이었다.대충 뭔 이야기를 했던 것 같은데 잘 기억은 안 나고 ‘우리 샌프란시스코에서 너네 항공사 타고 라스베가스로 왔어~’와 같은 시덥잖은 대화를 했던 것 같다. 그리고 나서 너무 비통했다…왜 시덥잖은 얘기 밖에 하지 못하는 것일까…그 시덥잖은 얘기마저도 왜 이리 하기 힘든 걸까…글로벌 트렌드, 외국인들은 어찌 생각하는지, 그들은 어떻게 일하는지, 어떤 기술 문화를 가지고 있는지, 세계가 주목하고 있는 문제들은 무엇일지…너무나 궁금했지만 차마 물어볼 수가 없었다. 물어볼 줄도 모르고 얘기해줘봤자 이해도 못할 것이기 때문이다. 이대로 가기에는 너무나 아쉬워서 밥대신 빵이랑 커피만 들고 또 목표물을 수색하였다.어느정도 선해 보이는 사람들이 눈에 들어왔고 그대로 앉아서 ‘How are you?’같은 시덥잖은 안부를 물어보았다.알고보니 그들은 어떤 공공기관 사람이었고 엔지니어는 아니고 매니저였다.뭐 대충 한국은 정부에서 클라우드에 대한 신뢰도가 없어서 도입하기 정말 힘들다 너네 신기하다 했는데 뭐 그들도 자기네들도 정부의 제제 등등 때문에 빡세게는 못 쓴다고 했다.엔지니어가 아니면 그닥 할 말이 없어서 어느 정도 얘기하다가 빠이쳤다. 이대로 가기에는 또 안타까웠다. 결국 시덥잖은 얘기 말고 한 게 없지 않은가…그래서 이번에는 좀 더 전략적으로 다가갔다.리인벤트 참석자들이 메고 있는 목걸이는 검은줄이면 참석자, 노란줄이면 AWS 직원이었다.그래서 한 번 노란줄을 공략해보기로 했고 마침 혼자 밥먹고 있는 사람이 눈에 들어와서 두리번 거리는 척 하다 가서 앉았다.또 시작은 밥먹는 척 하다가 ‘How’s Going?’ 같은 시덥잖은 안부 인사로 시작하였다.그리고 대화하다보니 그는 AWS의 솔루션 아키텍트였고, 한 기업의 M&amp;A 때문에 기술적인 컨설팅 같은 걸 해주고 있다고 하였다.토스페이먼츠도 LGU+의 전자결제사업부와 M&amp;A를 진행했기 때문에 공통점이 있다고 판단하여 옳다구나 싶어 허접한 영어를 막 내뱉었다.그들의 구닥다리 시스템 때문에 일일이 배포하고 롤백도 수기로 하다가 장애가 난 사례를 얘기해주었다.Server 1 deploy, server 2 deploy, server 3 deploy... oh bug has occured! server 1 rollback, server 2 rollback, then they said rollback is done! but sometimes bug still occured!진짜 occured 어떻게 발음해야하는 건지, 장애를 버그라고 얘기하면 되는 건지, 롤백이 완료되었다는 뭐라고 얘기해야하는 건지, 여전히 장애는 발생한다는 걸 영어로 뭐라고 얘기해야하는 건지…무지성으로 랩하듯 그냥 말했다, 뭐라도 그와 공감대를 형성해야 기술적인 주제로 얘기를 이어나갈 수 있을 것 같았다.다행히 바디랭귀지와 서버1 서버2 서버3의 임팩트가 있었는지 그도 웃으면서 내 얘기에 공감해주었다.그리고 우리가 닥친 상황(레거시 시스템을 신규 시스템으로 마이그레이션)들을 얘기하면서 Strangler Fig 패턴에 대해 말해주며 점진적으로 기능을 마이그레이션 하는 것에 대해 설명해주었다.뭔 소린지 잘 몰랐지만 Strangler Fig 패턴에 대한 세션을 들을 수 있었는데 너무 피곤해서 안 들었던 과거가 후회되었다.그리고 용기내면 이렇게 조그만 인사이트라도 얻을 수 있는 사람이 존재하는데… 영어를 한다면?? 얼마나 큰 인사이트를 얻을 수 있는 기회가 여기 라스베가스에 있었던 것일까… 정말 비통했다. 이렇게 한바탕 외국인과 얘기를 해보고 나니 정말 한국만큼 핸디캡을 가지고 사는 나라도 없는 것 같았다. (다른 아시아인들은 잘 모르겠지만…)국적을 빼놓고 보면 영어를 할 줄 알면 국적은 중요하지 않았다.그들은 리모트로 일하면서 서로 다른 국가에 있는 사람들과 협업하고 리인벤트에 와서도 서로의 국가가 중요한 게 아니라 그냥 대화를 하면 되는 거였다.하지만 우리는 Where are you from? 같은 게 필수 질문이 되었다.그게 뭐가 중요한가? 그들이 어떤 환경에서 일하고 어떤 생각으로 일하고 어떤 문제를 얼마나 나이스하게 푸는 것이 중요한 건데…정말 한국만 빼놓고 위아더월드로 그들만의 리그가 형성된 것 같았다.그리고 한국 사람들을 보면 진짜 한국사람 끼리끼리 몰려다니고 그런 문화 자체가 다른 외국인들이 다가오기 힘들게 하는 문화같아 보이기도 하였다.그냥 멀리서 뭉쳐다니는 사람 보면 ‘아 한국인인가보다…’하고 생각이 들 정도였다. 한국의 문화가 유독 뭉쳐다니는 거 좋아하는 것 같은데 이런 문화는 버려야할 문화…까지는 아닌데 좀 약해져야할 필요가 있다고 본다.그렇기 때문에 용기내어 누군가에게 다가가기도 힘들고, 그 조직 외에 있는 사람이 들어오기도 힘든 문화인 것 같다.그리고 영어 교육 진짜 뜯어고쳐야하는 것 같다.말하기&#x2F;듣기 위주로 가르쳐서 진짜 영어 할 줄만 알면 한국인들도 엄청난 메리트를 타고 나는 것이라고 본다.번역기가 아무리 발달됐다고 해도 해외에서 로밍 제대로 안 터지고, 음성 인식 제대로 안 되고 그걸로 대화하다가 맥이 끊긴다.그냥 관광지 가서 바디랭귀지 하는 수준 밖에 번역기는 발달되지 않은 것 같다.정말 영어는 정말정말진짜진짜 중요하다는 것을 또 새삼 깨닫게 되었다. 라스베가스의 한 청년 래퍼 아침 식사를 마치고 세션을 들으러 가던 도중 육교에서 색소폰을 불고 있는 사람을 만나게 되었다.평상시 재즈힙합도 좋아해서 이 공연도 꽤 즐겁게 들었다.비트는 내 스타일이었지만 목소리는 조금 앵앵대는 느낌이 있어서 영 내 스타일은 아니었지만 굉장히 좋은 경험이었다.물론 뭐라고 하는지는 못 알아들었다. (아이스크림 같은 건 들렸다.) 세일즈포스 부스에 방문하다 밖에서 봤을 때 굉장히 이쁘게 꾸민 부스가 있었다.바로 세일즈포스였는데 세일즈포스란 기업은 평상시 관심있던 기업이 아니다보니 얘네들이 무슨 문제를 풀었는지 궁금했다. (굿즈도 받을 겸…)근데 보다보니 세일즈포스가 슬랙도 인수했다는 사실을 이 때 알게 되었다.대충 보니까 쇼핑몰 같은 거 만들기 쉽게하는 솔루션들이랑 뭐 여러가지 있어보였는데 크게 눈에 들어오는 건 없었다.영어만 된다면 더 물어보고 싶었는데… 역시나 영어가 안되니 뭘 더 물어보고 싶어도 물어볼 수가 없었다. 다시 관광모드로…마지막 날이라 그런지 들을만한 세션이 얼마 없기도 하고 점심 장소로 이동을 하면서 주변 관광지들을 둘러보았다. 한국으로 치면 먹자골목 같은 분위기가 나는데 또 라스베가스 만의 분위기가 나서 신기했다.한편으로는 평일 낮에 이런데 오는 사람들은 뭐하는 사람일까… 이 사람들도 휴가내고 놀러온 사람일까… 싶었다. 계속 가다보니 인앤아웃 버거집도 보였다.점심 예약을 하지 않았더라면 한 번 먹어봤을 법 한데… 좀 아쉬웠다. 플라밍고가 살고 있는 플라밍고 호텔 지나가다보니 플라밍고 호텔도 보였다. 플라밍고 호텔은 이름에서 알 수 있듯이 실제로 플라밍고를 볼 수 있다.새들이 지저귀는 소리가 마치 숲속에서 지저귀는 새들의 소리 같았다. 플라밍고 호텔도 내부에 볼만한 것들이 많으니 라스베가스에 왔으면 한 번 가볼법한 것 같다.이렇게 라스베가스는 호텔마다 특색이 있어서 시간이 된다면 한번 쭉 둘러보는 것도 좋은 것 같다. (공짜로 볼만한 요소들이 많다.) 고든램지가 운영하는 Pub &amp; Grill 회사 동료 분이 예약해주셔서 고든램지가 운영한다는 Pub &amp; Grill에서 점심을 먹게 되었다. 엄청 짰다.확실히 미국 음식들은 짜다.같이 갔던 사람의 말로는 이거 만드려면 무슨 양파가 카라멜 색이 될 때까지 엄청 열심히 뭐 굽는대나 해야한다고 한다.노력은 가상한데 그에 비해 맛은 훌륭하지 못했다. 그냥저냥… 짠 거 빼면 좀 먹을만 했던 것 같다. 위에 어니언 스프가 좀 짰다면 얘랑 같이 먹으면 좀 간이 맞는 듯 했다.빵이 들어가있는 샐러드인데 좀 더 힘을 준 샐러드 느낌이었다.다른 동료 분께서 시켜서 먹어봤는데 맛있었다. 이게 메인 요리였을 것이다.소스 담은 것부터가 힘을 잔뜩 실은 느낌이었다.확실히 고기가 고급지다는 것이 느껴졌지만 역시나 짰다.짠 거 빼고는 너무나 맛있었고, 덕분에 소스는 그닥 안 찍어먹었던 거 같다.미국인들이 왜 이렇게 성인병에 많이 걸리는지 알게 된 것 같았다. 푸딩인 줄은 모르겠고 그냥 초코빵 같은 거 위에 아이스크림이 얹어져있었다.단짠단짠 조합에 부합해보이긴 하지만 이것도 몹시나 달았던 것 같았다.그래도 계속 짠 걸 먹는 것에 비해 오랜만에 달달한 걸 먹으니 먹을만 했다.맛은 좋았다. (좀 많이 달았던 거 같긴 하지만…) 시저스 호텔과 미라지 호텔 지나가다가 또 시저스 호텔이 보여서 한 방 찍어보았다.로마 황제 시저를 테마로 만든 호텔인 건지 로마의 건축문화를 본따 만든 듯한 조형물들이 많이 보였다. 미라지 호텔도 보았는데 폭포처럼 잘 꾸며놓았다.미라지 호텔은 화산쇼가 유명하다는데 그거는 눈으로는 봤는데 사진으로 남겨놓은 거는 딱히 없다.실제로 미라지 호텔 건너편에서 지나가다가 보았는데도 불길 때문에 좀 따뜻하다는 느낌이 들 정도였다. 이제는 우리가 헤어져야 할 시간… 샌프란시스코 공항에서 경유를 위해 기다리다가 무슨 유기농 음식점? 같은 곳에 들어가서 뭔지도 모르고 수프를 시켰는데… 웬 꿀꿀이 죽이 나왔다.만원도 넘었는데 돈이 너무 아까웠고 억지로 먹다가 버렸다.그리고 신기한 건 미국은 분리수거를 크게 안 하는 건지 그냥 음식물도 쓰레기통에 다 버리는 것 같았다. 마지막으로 한국으로 14시간 가량의 비행을 끝으로 이번 여행을 끝마쳤다…라고 생각하기도 잠시 한국에서는 또 코로나가 빵 터지면서 입국 절차도 까다로워져 여기서만 1시간 넘게 대기했다.또한 해외입국자는 코로나 검사를 무조건 받아야하는데 보건소에서 이거 기다리는 것만 2시간 반을 기다렸다…한국에는 새벽에 들어왔지만 막상 집에 들어가니 점심시간이 넘었고 너무나 추웠다.그리고 10일 간의 자가격리 기간동안 집에만 있으니 너무 답답했고, 다행히 음성이 나와서 그 후에는 무사히 출근할 수 있었다. AWS re:Invent를 끝마치고나서 소감 (12&#x2F;03 ~ 12&#x2F;05)정말정말정말 좋은 경험이었다. (영어를 할 수 있었더라면 배가 되었겠지만…)비록 기술적 인사이트는 크게 얻지 못하였다 할지라도 내 인생에 있어서 큰 성장을 한 것 같았다. 백날 천날 영어가 중요하다… 중요하다… 라고 듣기만 하고 영어로 된 아티클도 대충 배경지식으로 때려맞추고 소스코드로 검증해보는 식으로 했지만실시간으로 사람들과 소통하려고 하다보니… 이건 정말 답이 없었다.영어가 됐다면 기회의 땅 미국에서 더 많은 사람들과 대화하며 많은 인사이트를 얻어낼 수 있었을텐데 한 편으로는 아쉬웠다. 또한 미국이라는 나라와 그 나라의 문화를 체험한다는 정말 값진 경험을 하게 되었다.내가 살면서 미국이란 나라를 가볼 일이 있을까… 라는 생각으로 살아갔는데 정말 수천만원 어치의 경험을 한 것 같다.내가 생각했던 미국과 직접 겪어본 미국은 달랐다.미국 기업에 취업해서 미국에서 살아볼 수도 있지 않을까? 라는 생각을 가진 적이 있긴 했지만 직접 경험하고 오니 난 무조건 한국에서 살겠다고 마음 먹었다.땅덩어리가 넓으니 차가 없으면 살기가 너무 힘들고(대중교통을 경험하지 않아서인지 정확한 판단은 아니겠지만), 주변 편의시설까지 가는데도 너무 힘들었다.우리나라는 그냥 호텔 1층에 편의점이 있거나 주변에 널린 게 편의점인데 여기는 편의점 같은 곳을 가려면 또 호텔 밖으로 걸어서 육교랑 횡단보도를 몇 번이나 건너가야 했다.그리고 편의점이라 부를법한 곳에 라면도 없었고, 내 입맛에 맞는 것은 별로 없었다.팁 문화도 생소하기도 하고 얼마를 줘야할지 이런 거 고민할 필요도 없는 한국 가게들이 너무나 편해보였다.그리고 길거리에는 대마초 냄새를 종종 맡을 수 있었고, 도시에 군견과 경찰을 보면 그나마 치안 좋은 게 이정도인데 여기 살려면 정말 정신을 바짝 차려야하는 것 같았다.이렇게 직접 경험하고 나니 한국만큼 살기 편안하고 좋은 나라는 없다는 것을 깨닫게 되고 그런 곳은 잠깐 여행만 갔다 오고 한국에서 계속 살아야겠다는 다짐을 했다. 그리고 AWS 리인벤트를 경험하고 나서 고용 문화에 대해서도 다시 생각해보게 되었다.우리나라는 노인 빈곤률이 높고 일자리도 잘 취업이 되지 않는다고 한다.하지만 리인벤트에 진행 안내 요원으로 일을 했던 사람을 보면 아마 단기 아르바이트일 거 같았고, 나이가 지긋하신 분들도 많았다.그런 분들이라고 해서 일을 못하는 것도 아니고 친절하게 일을 하고 즐겁게 일을 하는 것을 보니 이게 진짜 노인 공경인 건가… 고령화 사회에 기업들이 이런 일자리들을 줘야하는 것이 아닌가 하는 생각이 들었다.우리나라는 유교문화라고는 하지만 말만 노인 공경하는 것 같은데 이런 실질적인 부분에서 오히려 미국이 노인 공경을 잘하는 것처럼 보였다. 또한 미국인들의 문화 중에 신기했던 게 모르는 사람한테도 인사 건네고 말을 건넨다는 것이다.엘레베이터에서 처음 만난 노부부가 우리 보고 굿모닝을 시전하고, aws 리인벤트 참석하는 다른 외국인들이 너네도 리인벤트 때문에 왔냐고 물어보고…심지어 아침을 먹을 때도 같은 테이블에 있었던 사람들이 우리에게 먼저 말을 걸어주기도 하였다.이런 게 정인가… 싶기는 하지만 한국인들이 정이 많다 뭐 이런 얘기를 하지만 나는 차라리 이런 부분에서 정이 있다는 것을 느꼈다.한국에서는 주변 이웃끼리도 인사를 잘 안 하는데 미국의 이런 문화에서는 정말 이웃끼리도 잘 지낼 것 같다는 생각이 들었다.그리고 한국은 괜히 뭐 잘못 하면 ‘왜 나대냐’라는 듯한 시선이 있는데 미국에서는 이런 분위기에 대해서 굉장히 자유롭고 관대한 것 같았다.그러다보니 이런 문화 속에서 더 토론이나 자유로운 의견 공유가 가능한 것 같았다.그리고 MBTI에서 I(내향적)와 E(외향적)이 있는데 미국인들은 죄다 E처럼 보였다.행사 진행요원 할아버지와 할머니가 춤추고 재미나게 일을하는 걸 보면 정말 일을 재미있고 신나게 하는 듯 해보였다.근데 얘기하는 걸 들어보면 둘은 오늘 처음 만났거나 AWS 행사에서 처음 만난 것 같았다.그들은 인생도 즐겁게 살고, 일도 즐겁게 하는 듯 해 보였다.어떻게 그렇게 사는 걸까? 그건 자연스레 뿌리박힌 그들의 문화(인사를 자유롭게 건네고, 말은 먼저 건네도 이상하게 보지 않는 문화)와 관련이 있지 않을까 싶었다. 한국은 정말 살기 좋은 동네이고 치안도 짱짱맨인 동네이다.하지만 사람들 간에 살아가는 방식이나 문화 측면에서는 너무 보수적인 것들은 좀 버려야할 필요가 있다고 본다.그래야 더 자유로운 의사소통이 되고 다양한 의견 공유를 통해 더 나은 방향으로 나아갈 수 있으리라고 본다.한국 사람들이 머리는 정말 똑똑한데 그들만의 리그에 갇혀 산다는 느낌도 들어서 글로벌 트렌드도 주도한다던지 그들과 함께 어우러져 세계를 이끌어나갈 수 있는 기업과 인재들이 더욱 더 나오길 바란다. 앞으로 인생에 다시는 이런 좋은 기회와 경험들이 주어질지 모르겠지만, 앞으로 올 기회를 잡기 위해 준비된 사람이 되어야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"}]},{"title":"라스베가스를 다녀오고... 4편 (feat. AWS re:Invent 2021) - 세미나 넷째 날","slug":"las-vegas-aws-reinvent-04","date":"2021-12-31T21:28:31.000Z","updated":"2022-10-30T08:42:16.795Z","comments":true,"path":"2021/12/31/las-vegas-aws-reinvent-04/","link":"","permalink":"https://perfectacle.github.io/2021/12/31/las-vegas-aws-reinvent-04/","excerpt":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) - 현재 게시물 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 날아서 그랜드캐니언까지라스베가스에 오기 전까지만 해도 잘 몰랐는데 라스베가스와 그랜드캐니언은 가까웠다.물론 차를 타고 가면 갔다 오는데 하루 종일이 걸릴 정도라서 그닥 가깝다고 느껴지지 않을지 모르지만… 미국의 땅덩어리를 생각해보면 가까운 수준인 것 같다.새벽부터 차를 타고 갈 체력도 없기도 하고… 우리는 관광이 주 목적이 아닌 AWS 리인벤트가 주 목적이기 때문에 하루를 몽땅 날려버릴 수는 없었다.그리고 차를 타고 가는 것도 매우 지루하기도 하고 주변 풍경도 막상 크게 볼 것이 없다고 한다.그러다보니 비용이 비싸긴 하지만… (인당 56만원 정도 냈던 것 같다.)","text":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) - 현재 게시물 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 날아서 그랜드캐니언까지라스베가스에 오기 전까지만 해도 잘 몰랐는데 라스베가스와 그랜드캐니언은 가까웠다.물론 차를 타고 가면 갔다 오는데 하루 종일이 걸릴 정도라서 그닥 가깝다고 느껴지지 않을지 모르지만… 미국의 땅덩어리를 생각해보면 가까운 수준인 것 같다.새벽부터 차를 타고 갈 체력도 없기도 하고… 우리는 관광이 주 목적이 아닌 AWS 리인벤트가 주 목적이기 때문에 하루를 몽땅 날려버릴 수는 없었다.그리고 차를 타고 가는 것도 매우 지루하기도 하고 주변 풍경도 막상 크게 볼 것이 없다고 한다.그러다보니 비용이 비싸긴 하지만… (인당 56만원 정도 냈던 것 같다.) 버스를 타고 헬기장까지 이동하고 나서야 뭔가 헬기를 탄다는 게 실감이 났다.나는 헬리콥터하면 영화에서 밖에 보지 못했기 때문에 뭔가 양옆이 뚫려있고, 머신건 같은 게 달려있어서 굉장히 위험하다고 생각을 했다.그러다보니 신체포기 각서 같은 걸 서명하고 탑승할 줄 알았는데 그런 건 없었고, 양 옆에 문도 있어서 나름 안전하였다. 헬기가 이륙하는 장면을 찍어보았는데 정말 이때부터 실감이 제대로 났다. 헬기로 후버댐을 보니 진짜 미국의 대자연의 경관을 한껏 만끽할 수 있었다. 헬기로 이동하는 중에 절벽을 깎아 내린듯 한 비슷비슷한 풍경들이 눈에 들어왔다.차로 이걸 몇시간 동안 지나갈 생각을 하면 너무 지루했을 것 같다.역시 돈이 짱인 거 같다. (돈으로 시간을 살 수 있다는 말이 무엇인지 크게 체감하였다.) 헬기에서 착륙한 후 그랜드캐니언을 한바퀴 쭉 찍어보았다. (뒤에 더 있지만 사람 얼굴들이 좀 나와서 잘랐다.) 주위를 삥 둘러보았는데 뭐 비슷한 광경이었다.미국의 대자연… 우와… 한 1~2분 정도 체감한 것 같다.그 이상의 감흥이 오지는 않았지만 뭐 그래도 한국에서 해볼 수 없는 경험이었고 자연들도 아름다웠기 때문에 나름 만족한다.하지만 누가 또 오자고 하면 글쎄… 다시 올 정도는 아닌 것 같다.그리고 이런 척박한 환경에 선인장도 자라고, 까마귀도 날아다니는 걸 보고 진짜 어디에든 생물이 존재는 한다는 사실도 신기했다. 아점 겸 해서 다과를 준비해줬다.이것도 헬기 예약할 때 들어가있는 거긴 한데 여기선 뭐든 무서워서 이거 돈 안 내는 거냐고 물어보고 먹었다.그리고 좀 느긋하게 먹고 싶었는데 헬기 기사가 시간 됐다고 싸갈 거면 싸가라고 재촉하였다. (물론 바람도 많이 불어서 좀 춥기도 하였다.) 돌아가는 길에도 몇컷 찍기는 했는데 이미 오면서 본 광경이기도 하고 비슷비슷해 보여서 흥미가 좀 떨어진 상태이긴 했다. 다시 일상 속으로…오전에는 관광모드로 그랜드캐니언을 갔다왔다면 오후에는 라스베가스에 온 본질인 AWS 세션 듣기에 집중했다.그 중에도 넷플릭스 세션들이 인사이트 얻기 좋다는 얘기를 들어서 넷플릭스의 Keeping Netflix reliable using prioritized load shedding 세션을 들었다. 발표자료는 이미 2020년 11월에 넷플릭스 테크 블로그에 올라온 Keeping Netflix Reliable Using Prioritized Load Shedding을 토대로 제작되었다. 어떻게 하면 넷플릭스가 서비스의 품질을 더 지킬 수 있는 건지에 대한 세션 발표였다. 나는 뒷단 서비스들이 망가졌을 때 서킷브레이커를 도입하여 장애 전파를 막는 것까지만 생각하였다.하지만 트래픽이 너무 과하거나 기타 등등의 사유로 API Gateway가 힘들어한다면…? 같은 상황은 생각해보지 못했다.넷플릭스는 트래픽이 하도 많아져 이런 상황까지 겪어봤을테고, 무작정 서버를 증설하는 대신 다른 방법으로 문제를 해결했다. (물론 너무 심각하면 증설해야하지만)트래픽의 우선순위를 부여하여 리소스가 얼만큼 남았을테니 중요하지 않은 트래픽들은 실패로 떨구고… 하는 방식을 통해 유저의 실시간 스트리밍에는 영향이 절대 없도록 했다는 내용이다.영어로 진행된 세션이니만큼 100% 이해를 하지는 못했지만, 괜히 넷플릭스가 테크 기업이 된 게 아니구나… 이런 식으로까지 생각을 해서 문제 해결을 해야하는구나… 하고 깨달았다.나의 경우에도 대입해보면 결제&#x2F;환불 같은 중요 트래픽은 살리고 그 나머지 트래픽은 실패로 떨굼으로써 어떻게든 결제와 환불에는 문제가 없게 끔 트래픽에 우선순위를 정할 수도 있겠구나… 하는 생각이 들었다. 그리고 세션이 끝나고 넷플릭스 엔지니어가 질문을 받는 시간을 가졌는데… 영어를 할 줄 모르지만 괜히 주변에 가서 뭐라도 하나 더 줏어 들었다.이해가 되지는 않았지만 세계적인 엔지니어와 영어로 대화하는 다른 엔지니어를 보면서… 너무 부러웠다.우리가 가지고 있는 문제들은 넷플릭스 엔지니어라면 어떻게 해결했을까? 그들은 어떤 문화와 사고방식을 갖고 있길래 이런 식으로까지 기술을 도입하게 된 것일까?영어를 하지 못한다는 사실이 너무나 가슴이 아팠던 상황이었다… 또 다시 관광모드로… 저녁은 Hot N Juicy crawfish에서 먹었다.해산물이 나온다는 거 말고 아무것도 모른 채로 먹었는데 살짝 매콤하지만 맛있었다.비닐 장갑을 껴도 그 사이로 국물이 슬쩍 들어오는 것도 같았고… 손에 냄새도 좀 벤다는 점이 단점인 것 같았다.그리고 뭐 먹긴 하는데 메뉴가 계속 먹다보면 질리기도 하고 배가 막 엄청 부르지는 않았다.그리고 TV에는 또 무슨 소 제압하기? 같은 대결을 하는지 카우보이들이 나와서 줄을 던져서 황소를 얼마나 빠른 시간 안에 제압하는지를 겨루는 방송이 나오고 있었다.정말 미국은 카우보이 문화가 많이 발달한 것 같았다.나는 스페인의 투우 같은 것만 생각했었는데 미국도 서부 시대에 카우보이 문화가 많이 발달했다고 한다. 간지 터지는 흑인 드러머 나는 개인적으로 힙합을 좋아하고 그 중에서도 드럼의 쿵치딱 거리는 소리가 좋아 붐뱁 장르를 좋아한다.그러다보니 3개월 정도 드럼을 배우기도 하였고 드럼 소리를 좋아하는 편이었다.근데 우연히 길을 가던 도중에 조약하지만 드럼 요소라 불릴만한 장비를 갖추고 있고… 거기다 소울풀 한 흑인이 앉아있다?이건 못 참치~란 생각으로 한 곡 연주해줄 수 있냐고 물어보자 돈을 내야 연주해준다고 하였다.어디서 들었는데 ‘프로는 돈으로 말한다’라는 얘기가 있었는데 딱 그 말이 떠오르면서 프로처럼 보였다.그리고 팁을 주겠다 얘기하고 바로 즉흥연주가 시작되었다.흑인의 드럼연주도 기가 막혔지만 진짜 간지 터지는 포인트는 백인 노인과의 합주이다.나는 둘이 팀인 줄 알았다, 근데 알고보니 백인 노인도 그냥 길가던 행인 중 한명이었다.내가 생각한 예술가의 이상적인 그림이었고 정말 나의 심금을 울리는 연주였다.바로 당장 귀국하자마자 드럼 레슨 끊어야겠다고 생각이 들 정도였다. (하지만 아직까지 드럼 학원은 등록하지 않았다.)이런 사람들이야말로 돈을 잘 벌어야하고 잘 돼야한다는 생각에 나름 팁을 두둑히 줬던 걸로 기억한다.한국에도 이런 공연들이 많아졌으면 하고 나의 심금을 울릴 수 있는 이런 연주라면 그에 대응하는 대가를 지불하고 볼 용의가 얼마든지 있다. 라스베가스 속 에펠탑 조약하지만 에펠탑을 흉내낸 관광코스가 있길래 가보았다.안에 들어가는 건 공짜지만 타워 위로 올라가서 구경하는 것은 돈을 내야한다. 진짜 라스베가스에서 카지노 빼면 섭할 정도로 어딜가나 카지노가 보였다. 우리나라도 남산타워에 사랑의 자물쇠인가 뭐시기인가… 있는데 어디가 원조인지 궁금해졌다. 에펠타워 꼭대기까지는 엘레베이터를 타고 이동하는데 이렇게 투명하게 뻥 뚫려있어서 밖이 보인다. 에펠타워 꼭대기에서 본 뷰도 정말 멋졌다.그리고 뜻밖에 다른 외국인 커플이 프로포즈하는 장면도 보았다.결혼하려면 이정도 되는 근사한 곳에 와서 반지 주면서 프로포즈를 해야 결혼할 수 있는 것 같았다.여자는 감동한 듯 울먹이며 남자를 끌어안았다. (이 순간 모두가 박수를 치며 축하해주었다.)근데 여기서 또 재밌는게 남자&#x2F;여자 둘 만 있던 게 아니라 남자 측 엄마로 추측되는 사람도 함께 있었다는 사실이다.우리나라로 치면 시어머니 앞에서 남자가 프로포즈를 한 건데… 마마보이인가? 이 생각도 살짝 들기도 하면서 문화 충격이었다.한국에서 좀 과장해서 막장드라마 시나리오였다면 시어머니가 ‘네가 우리 애를 벌써부터 잡는구나 잡아?’하는 시나리오도 연출될 수 있을만한 그림이었다.하여튼 미국이란 동네는 참으로 신기했다. 에펠타워의 하나의 장점은 벨라지오 호텔의 분수쇼를 위에서 볼 수 있다는 사실이었다.땅에서 보는 분수쇼도 멋있었지만 위에서 본 분수쇼는 또 달랐다.땅에서 보면 1차원 적으로 밖에 보지 못해 분수가 일렬로 나열돼있는 줄 알았는데 위에서 보니 동그란 모양의 분수도 있다는 사실을 알 수 있게 되었다. 이런 타워 아래로 내려오면 국룰처럼 기념품 가게가 있다.나는 여태까지 ty가 Thank You의 줄임말인 줄 알았는데 브랜드 로고라는 걸 처음 알게 되었다. re:Play re:Play는 AWS re:Invent에서 행사 마지막 전날 밤에 진행되는 파티 같은 행사이다.진짜 이건 미쳤다. 말로 설명이 안 된다. 테크 기업에서 스케일이 큰 행사를 하기도 힘든데 이렇게 넓은 대지를 빌려 파티 문화까지 만들었다고?정말 정말 이건 미쳤다고 생각이 들고 아마존이란 기업에 존경심이 생겼다. 입구를 따라 쭉 들어오다보면 월드 디제이 페스티벌 마냥 디제이가 신나는 음악을 흔들어 제끼고 있었다. 그 와중에 오징어게임을 리믹스 한 음악을 틀고 있었다. 국뽕이 차오르는 순간이었다. re:Play에는 탁구 등등 여러 놀이거리도 있었지만 우리는 장애물 피하기 같은 것과 팀먹고 연타하여 누가 제일 빠르게 누르나 같은 걸 해보았다. 뭐니뭐니 해도 re:Play의 꽃은 디제잉인 것 같았다.한국에서는 클럽 같은 곳을 한 번 밖에 가보지 않았고 재미도 없었지만, 시간이 흐른 탓인지 나름 재미있었다.하지만 미국이라 그런지 이런 곳에서까지 대마초를 피는 사람이 있었고 정말 냄새가 역해서 토하는 줄 알았다. 대마초하니까 떠오른 건데 마약에 호기심이 있다가도 그 역한 냄새를 맡으면 호기심이 싹 사라진다.라스베가스에서도 특정 길거리를 지나가거나 하면 항상 역한 대마초 냄새가 났다.처음에는 몸 한 3주간 안 씻은 노숙자 몸에서 나는 냄새인 줄 알았는데 대마초 냄새였다.정말 그정도로 역하고 미국이란 나라에 한 번 더 충격을 받게 된 계기였다. 행사가 끝날 때 쯤 나오면 사람이 몰릴 것 같아 미리 나오면서 또 어디 줏어먹을 거 없나… 두리번 거리는 하이에나처럼 돌아다니다가 티셔츠를 득템하였다.행사 막바지라 그런지 필요한 만큼 다 가져가라고 해서 진짜 한 10장은 들고 온 것 같았다.2장은 집에서 잠옷으로 요긴하게 쓰고 있고, 나머지는 회사 동료들에게 뿌렸다. 세미나 넷째 날까지의 소감 (12&#x2F;02)아침 일찍부터 스케쥴을 시작해서 밤 늦게까지 놀다보니 하루가 참 길었다.확실히 그랜드캐니언을 보니 미국은 자연도 그 나라에 일부분인 것 마냥 엄청난 스케일을 자랑하였다.캠핑 같은 거 좋아하는 사람한테는 천국일 거 같다는 생각이 들었다.또한 넷플릭스라는 기업의 기술역량에 다시 한 번 존경심이 생겼다.평상시 Hystrix니 Zuul이니 여러 오픈소스를 만들 정도의 기업이라 기술 중심 기업이라는 것은 어느정도 알고 있었는데 역시나 스케일이 다른 것 같았다. 그리고 넷째 날이 정말 제대로 라스베가스를 즐겼다는 생각이 들었다.간지 폭발하는 흑인 드러머를 만난 건 내 인생에 있어서 잊을 수 없었다.또한 re:Play라는 미친 파티를 경험하고 나서 아마존에 대한 존경심이 샘솟았다. 내일만 버티면 된다는 생각에 이제 좀 마음이 놓이는 날이었다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"}]},{"title":"라스베가스를 다녀오고... 3편 (feat. AWS re:Invent 2021) - 세미나 셋째 날","slug":"las-vegas-aws-reinvent-03","date":"2021-12-31T20:42:31.000Z","updated":"2022-10-30T08:42:16.791Z","comments":true,"path":"2021/12/31/las-vegas-aws-reinvent-03/","link":"","permalink":"https://perfectacle.github.io/2021/12/31/las-vegas-aws-reinvent-03/","excerpt":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) - 현재 게시물 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 미국의 원할머니 보쌈이 AWS에서 발표를 한다고?? (12&#x2F;01)요번 리인벤트에서는 특정 서비스에 딥다이브 하기 보다는 좀 더 추상적인 ‘아키텍처’ 관점의 세션들을 많이 들어보았다.내가 AWS의 서비스에 대한 이해도가 낮기도 하다보니 내 소스코드에도 적용 가능한 추상적인, 이론적인 내용들은 무엇이 있을까?하다보니이벤트 드리븐, 클라우드 네이티브, 모던, next generation 뭐 이런 키워드 있는 것들을 주로 들었던 것 같다.하지만 영어가 되지 않아 대부분 이해가 되지 않던 와중 나를 충격에 빠뜨린 세션이 있었다.","text":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) - 현재 게시물 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 미국의 원할머니 보쌈이 AWS에서 발표를 한다고?? (12&#x2F;01)요번 리인벤트에서는 특정 서비스에 딥다이브 하기 보다는 좀 더 추상적인 ‘아키텍처’ 관점의 세션들을 많이 들어보았다.내가 AWS의 서비스에 대한 이해도가 낮기도 하다보니 내 소스코드에도 적용 가능한 추상적인, 이론적인 내용들은 무엇이 있을까?하다보니이벤트 드리븐, 클라우드 네이티브, 모던, next generation 뭐 이런 키워드 있는 것들을 주로 들었던 것 같다.하지만 영어가 되지 않아 대부분 이해가 되지 않던 와중 나를 충격에 빠뜨린 세션이 있었다. Building next-gen applications with event-driven architectures라는 세션이었는데 이벤트 드리븐에 꽂혀서 신청했던 세션이다.나는 당연히 테크 기업이 나와서 발표를 하겠거니… 라고 생각했는데 타코벨에서 나와서 발표를 하였다.잠깐만... 타코벨?? 타코... 그 멕시코 음식 파는 기업 아니야??라는 생각이 뇌리를 스쳐지나갔다.우리나라로치면 원할머니 보쌈이 AWS 리인벤트에 나와서 이벤트 드리븐 아키텍쳐로 자기네들이 가진 문제를 풀었다고 하는 것이다.말이 되는가? 원할머니 보쌈은 음식이 메인이고 기껏해야 배민이나 쿠팡이츠, 요기요 같은 플랫폼 기업에 음식점 등록하고 수수료 떼는 게 끝 아닌가?우리나라에서 푸드 테크기업이라고 불리면서 직접적으로 음식을 만들어 파는 곳이 있는가? 라고 했을 때 떠오르는 곳이 없었다. 그래… 타코벨에서 AWS를 어찌저찌 썼다고 치자… 그래서 그들은 무슨 문제를 풀었던 걸까?? 미국의 슈퍼볼 같은 행사의 TV 광고를 한 번 때리면 주문량이 미친 듯이 폭주한다는 것이다.그래서 그들은 배달기사 &#x2F; 음식점 &#x2F; 고객 사이에서 발생하는 상호작용 사이에서 이벤트 드리븐을 적용했다는 것이다.그것도 서버리스로!! 그래서 미친듯이 폭발하는 트래픽을 견뎌낼 수 있었다고 한다… 이들은 배민 같은 중간 플랫폼 사업자들을 끼지 않고 직접 배달을 하고 있었고, 음식점 포스에도 기술을 도입했다.생각이나 해보자… 월드컵 경기 중간에 TV에서 네네치킨 광고를 한다고 네네치킨에서 이벤트 드리븐 아키텍쳐를 상상이나 할 수 있을까?그냥 배민 같은 곳이 안 터지길 빌어야하는 것이다. 이걸 보고 또 느낀 점이 있었다…역시 사업은 글로벌로 해야하는구나… 그래야 어떤 비즈니스도 돈이 될 정도의 트래픽들이 모인다는 사실이다.우리나라가 미국 정도의 인구규모만 되더라도 내수시장에서 먹고 살 수 있겠지만… 이미 한국은 저출산 시대와 그 사이에 피터지는 경쟁으로 인해 거대 플랫폼 기업들이 다 뜯어먹고 있는 시장같아 보였다.미국 정도 규모에서 일부만 먹더라도… 한국에서의 10%와 미국에서의 10%는 정말 하늘과 땅 차이이기 때문에 인구가 깡패라는 점도 느꼈다.우리나라가 미국 정도 인구 규모에 슈퍼볼 같이 배달이 폭주할 만한 행사들이 종종 있다면… 원할머니 보쌈에서도 이벤트 드리븐 아키텍쳐를 고민할 날이 오지 않을까?? 이번 세션이 나한테 큰 충격을 준 만큼 정말 질문하고 싶은 내용이 많았다. 한국에서는 단순 음식점이 테크기업이 된 사례는 없는 것으로 알고 있는데 너네는 어떻게 이런 생각을 했냐? 우버이츠 이런 거 쓸법도 한데… 서버리스? 그거 쓰면 미리 서버 배포 안 해놔도 순간 미칠듯한 트래픽 버틸 수 있니? 대부분 오토스케일링이 되기 전에 피크 치고 서버 다 뻗어서 미리 2~3배 서버 증설해놓는데 서버리스는 그럴 필요가 없는 거니? 우리는 스프링을 써서 서버리스로 소스코드 관리하면 재사용성도 떨어지고, 어플리케이션 컨텍스트 띄우느라 콜드스타트도 굉장히 심할 거 같은데… 너네는 어떻게 이런 문제를 해결했니? 스프링에는 적합하지 않다고 생각하니? 세션을 들은지 한참이 지난 지금에 와서도 이렇게 질문들이 생각이 나는데… 이런 질문을 할 수 없는 나의 영어 실력이 참으로 비통했다.진짜… 영어를 할 줄 아는 사람이면 나 정도는 금방 제끼겠구나… 영어가 내 앞길을 막는 날이 언젠가 올 줄 알았는데 오늘이 그날이구나… 하고 느꼈다.라고 말하면서 이전 포스트에서도 말했듯이 영어공부를 열심히 하지 않는 걸 보면… 어디 해커스 학원 같은데 돈이라도 쳐발라야 돈이 아까워서 공부를 할까 싶다. 점점 지쳐가는 일상들…라스베가스에 온지 4일 째가 되었다.그러다보니 먹고자고 세션 듣는 것들이 일상이 되었다. 그럼에도 불구하고 aws에서 제공하는 식단들은 너무나 물렸고, 이제는 맛도 없다고 느껴지고… 얼른 육개장 사발면 한사발 얼큰하게 때리고 싶은 마음 뿐이었다… 시차적응이 된 것도 같지만 아침부터 세션을 듣고 호텔들을 돌아다니다보면 지치는 건 마찬가지였다.세션을 들어도 이해가 잘 되지 않으니 자포자기같은 심정을 먹다보니 자연스레 체력을 좀 보충하자는 생각에 또 리플렉션 룸에서 휴식을 청했다.리플렉션 룸에서 쉬면서 노트북으로 Self-paced lab도 할 수 있어서 그나마 좀 내 템포대로 진행할 수 있어 편했다. 소소한 행복 찾기세션을 듣기도 더이상 지치다보니 자연스레 ‘미국에서만 할 수 있는 걸 찾아보자’란 생각에 또 AWS 부스 이곳 저곳 기웃기웃 거렸다.하지만 역시 언어의 장벽에 막히고 자신감이 많이 줄어들은 상태라 많은 곳을 둘러보지는 못했다. 그러다 뭔가 미국에서 밖에 할 수 없는 것이 눈에 들어왔다.정확한 명칭은 뭔지는 모르겠지만 카우보이 뭐시기가 아닐까… 싶다.확실히 미국은 이런 카우보이 문화가 발달한 것인지 이런 놀이문화도 있는 것이 신기했다.내 앞에 여러 사람들이 10초 대 초반에 떨어지는 걸 보고 나는 더 오래 버티리라는 다짐을 하고 올라타게 되었다.근데 막상 찍힌 동영상을 보니 즐기기 보다는 ‘기록을 깨겠다’라는 경쟁심으로 불타있어 보였다.다른 외국인들은 한손으로 타고 소리도 지르고 즐기던데… 나는 즐기러 온 게 아닌가? 라는 생각이 들었다.여기까지 와서도 어떻게든 이겨보겠다는 그런 생각에 스트레스를 날려보내려면 마음을 다르게 고쳐먹어야겠다는 생각도 들었다. 셋째 날도 그냥 지나가다가 또 안 찍은 것 같은 공간을 몇 개 찍어보았다.셋째 날은 그냥저냥 지쳐서 크게 한 건 없던 것 같다. 세미나 셋째 날까지의 소감 (12&#x2F;02)셋째 날에도 영어의 필요성을 절실히 체감하였지만 타코벨 세션이 정말 큰 충격을 주었다.일개 음식점이라고 생각했던 기업이 테크기업이 됐다고?? 이벤트 드리븐 아키텍쳐를 고민한다고??우리나라에서 감히 상상이나 할 수 있겠는가? 원할머니 보쌈이나 네네치킨 같은 곳에서…??왜 미국을 기회의 땅이라고 하는 건지… 왜 미국 같은 곳에 와서 경험을 해봐야하는 건지 뼈저리게 느낀 날이었다.우리나라에서는 조그만 비즈니스도 스케일이 커질 수 있고, 낙후한 산업이라고 생각했던 부분들이 미국에서는 거기마저도 기술을 도입하고 클라우드 위에서 돌아간다는 것이 신기했다.영어를 못해도 이정도 깨달음을 얻을 수 있는데… 영어를 할 수 있었더라면 그들에게서 얼만큼의 인사이트들을 얻어낼 수 있을까?감히 상상조차 되지 않았고, 영어 할 줄 아는 사람들이 진짜진짜 너무너무 부러웠다. 그리고 셋째 날 쯤… 되다보니 한국에 가고싶어졌다.첫날에는 우와~ 라스베가스다~ 주변 풍경도 너무 삐까뻔쩍하고 멋있다~ 란 생각에 가득차있었다.하지만 하루 이틀 지나다보니 그런 게 일상이 되었고, 오늘도 내일도 먹고자고세션듣고 먹고자고세션듣고 반복일 걸 생각하니 지루했다. (거기다 영어까지 못하니…)남들은 여행으로 힐링을 한다지만 나는 딱히 힐링이 된다는 느낌 보다는 그냥 침대에 누워서 유튜브 보는 게 더 행복했다.한편으로는 내 사비를 들여 친구들과 여행을 오면 좀 다른 느낌일까… 싶기도 했다.나한테 이정도면 장기여행이고, 여행에 대한 나의 가치관을 다시 생각하게 된 계기가 된 것 같아 나중에 유럽여행에 대한 것도 고민을 좀 해봐야할 것 같다.살면서 유럽도 별로 가볼 일이 없어서 가보긴 할 거 같지만 과연 내 생각만큼 즐겁고 행복할지는 이번 여행을 통해 더더욱 불확실해졌다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"}]},{"title":"라스베가스를 다녀오고... 2편 (feat. AWS re:Invent 2021) - 세미나 둘째 날","slug":"las-vegas-aws-reinvent-02","date":"2021-12-31T18:06:31.000Z","updated":"2022-10-30T08:42:16.779Z","comments":true,"path":"2021/12/31/las-vegas-aws-reinvent-02/","link":"","permalink":"https://perfectacle.github.io/2021/12/31/las-vegas-aws-reinvent-02/","excerpt":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) - 현재 게시물 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 어느정도 익숙해지기 시작한 세미나 둘째 날 베네시안 호텔에 아침부터 키노트가 있어서 이동을 하였다.그래도 반복되는 길을 이틀 동안 왔다갔다 하다보니 도시의 풍경과 길들이 익숙해지기 시작했다.또 신기한 것은 라스베가스 호텔 근처에서는 24시간 내내 음악 소리가 들리는 것 같았다.밤에는 시끄러운 음악이 들렸던 것 같은데 아침에는 또 잔잔한 음악이었나… 여튼 분위기에 맞는 음악이 길거리에 울려퍼지는 게 신기했다.","text":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) 2편 - 세미나 둘째 날 (11&#x2F;30) - 현재 게시물 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 어느정도 익숙해지기 시작한 세미나 둘째 날 베네시안 호텔에 아침부터 키노트가 있어서 이동을 하였다.그래도 반복되는 길을 이틀 동안 왔다갔다 하다보니 도시의 풍경과 길들이 익숙해지기 시작했다.또 신기한 것은 라스베가스 호텔 근처에서는 24시간 내내 음악 소리가 들리는 것 같았다.밤에는 시끄러운 음악이 들렸던 것 같은데 아침에는 또 잔잔한 음악이었나… 여튼 분위기에 맞는 음악이 길거리에 울려퍼지는 게 신기했다. 어제만 해도 김치나 라면이 마려웠는데 잠자고 일어나니 그새 까먹고 빵보니 또 눈이 돌아가서 두 개나 집었다.약간 좀 과하게 집었나… 생각이 들어 뒤를 쳐다봤는데 외국인들도 빵은 하나만 집고 있었다.평상시에 아침도 잘 먹지 않는데 두개는 역시나 과했는지 한 개 밖에 먹지 못했다. 아침을 먹고 키노트 세션을 들으러 갔는데 대기시간에 유명한지 안 유명한지 모르겠는 밴드가 공연을 하였다. 키노트가 시작되어 연설을 했고 내가 샌프란시스코 - 라스베가스로 이동할 때 탔던 United 항공사라던지 나스닥 거래소라던지 이런 기업들이 어떻게 AWS를 사용해서 문제를 해결했는지 설명해주었다.영어라서 뭔소린지 제대로 못 알아듣고, 그냥 그런갑다~란 생각으로 듣곤 했다.나중에 알고보니 키노트는 동시통역을 제공해줬다고 한다.근데 다른 키노트에서 들어보았는데 헤드셋이 너무 압박해서 귀가 아픈데 막상 주변 잡음은 다 들렸다.그리고 영어를 한국어로 통역하다보니 어순이 맞지 않아 발표자가 한참 말하고 나서 한국어로 따다다다 통역을 하는 경우도 생겼고,무엇보다 통역하는 사람이 엔지니어가 아닌 거 같은 게 통역의 퀄이 썩… 좋지 않았다. 키노트가 끝나서 또 다른 세션 장소로 이동 중이었는데 아침부터 DJ는 열일하고 있었다.어제 저녁에도 다른 DJ가 있었던 것 같은데 아마 몇교대를 계속 돌리는 것 같았다… 그리고 칠판같은 공간에 여러 낙서가 있었고 기업을 홍보하는 듯한 문구도 있었다.나는 악필이라 딱히 적지 않았고 동료 분께서 회사명을 적은 걸 기념해서 한 컷 찍어보았다.(가끔 이렇게 영어 속에 다른 한글로 된 기업들의 문구를 보면 뭔가 반갑고 신기했다.) 코로나 검사를 받기 위한 여정코시국이다보니 입국할 때도 코로나 PCR 음성 검사 확인서가 있어야했다. (물론 출국할 때도 영문으로 된 확인서가 필요하기에 한국에서 8만원 가량을 내고 민간 병원에서 진행하였다.)백신 2차 접종여부에 따라 달라지지만 나는 2차 접종을 했기 때문에 출국하기 72시간 이전에 검사받은 확인서가 필요하였다.금요일 저녁에 출국이기 때문에 적당히 화요일 오후에 진행하였다.무료로 해주는 곳은 시간이 좀 걸려서 혹시나 출국 전까지 안 나올 가능성이 존재하여 따로 유료로 하는 곳도 알아보았는데 호텔까지 와서 검사를 해주는데 30만원 가량이 들었다.리스크에 도박을 해야했지만 30만원은 좀 선넘는다는 생각에 무료로 하거나 좀 더 싸게 할 수 있는 방법을 찾아보게 되었다.대부분이 드라이브 쓰루 검사 밖에 지원을 해주지 않았지만 curative 사이트에서 라스베가스에 Walk in(차 없이 걸어서) 검사가 가능한 곳을 찾았다.혼자 리스크를 감수하기에는 좀 쫄려서 동료 한 명을 섭외하고 같이 무료로 코로나 검사 예약을 진행하였다. 택시를 타고 이동하였는데 이상한 자동차 전시물과 건물, 주차장 말고 코로나 검사라고 보일법한 공간이 보이지 않았다.그래서 뭔가 이상하여 건물을 쭉 한바퀴 돌아도 여전히 코로나 검사 안내 표지판이 하나도 보이지 않아 직원으로 보이는 사람 아무나 붙잡고 물어보았다.뭐 영어는 잘 통하지 않았지만 대충 어느 방향으로 가라 정도까지만 알아듣고 또 가다가 이해가 안 되면 주변에 있는 사람 붙잡고 물어볼 예정이었다.직원이 안내한 공간으로 아무리 가도 주차장 말고 다른 큰 건물 같은 건 보이지 않았다.그러다 주차장 가장 구석에 컨테이너 박스가 하나 있는 것이 보였고 거기서 코로나 검사를 진행한다는 작은 안내표시판 같은 게 있어서 그걸 보고 겨우겨우 코로나 검사를 마칠 수 있었다.가끔 코로나 검사 결과가 너무 빨리 나와 72시간이라는 기준을 준수하지 못하는 경우도 있어서 일부러 해당 시간 지나서 결과가 나오게 해달라고 얘기를 하고 그 다음날 검사 결과 이메일이 날아와서 코로나 검사는 다행히 잘 끝마칠 수 있었다. 세션 말고 할만한 건 뭐가 있지? 세션을 계속 듣긴 듣는데 집중은 안 되고… 이해는 안 되고… 슬슬 지쳐갔다.과연 세션을 무리해서 듣는 게 의미가 있을까? 라스베가스 현지에서만 할 수 있는 건 뭘까? 하고 고민하다가 찾은 게 Self-paced lab이었다.들어가면 강의실에 온 거 마냥 자리에 PC(안타깝게 윈도우)들이 깔려있고 AWS 콘솔에 로그인을 하면 상황을 선택하여 AWS의 서비스들을 사용하여 해결하는 방식으로 AWS 서비스에 익숙해질 수 있게 만들어주었다.들어가니 한국인 AWS 솔루션 아키텍트 사람도 있어서 간단한 대화를 나누었다. 내가 AWS를 직접 썼더라면 더 다양한 걸 물어봤을텐데 평상시 사용을 하지 않아서 궁금증이 덜 한 상태에서 만나서 별로 얘기할 껀덕지는 없었다.그리고 나는 이해도가 느려서 그냥 상황 해결만 하는 것에 그치지 않고 이것 저것 설정을 바꿔보고 어떻게 동작하는지 궁금해서 뭔가 하나를 익히는데 오랜 시간이 걸리는 편이었는데 다른 일정 때문에 하나의 시나리오도 제대로 끝내지 못해 아쉬웠다. 저녁 먹기 전까지 또 시간이 살짝 붕 떠서 엑스포 구경을 갔다.여기서부터 진짜 영어의 필요성을 절실히 체감하였다.우선 여기 있는 기업들의 이름을 처음 들어보는 것도 많았는데 그들이 풀고자 하는 문제는 무엇이고, 그들의 솔루션들을 썼을 때 얼마나 편리해지는지 궁금했다.그들은 어떤 AWS 서비스들을 사용해서 문제를 해결했는지 등등 궁금한 것은 많았는데 영어가 되지 않으니 용기가 생기지 않았다.그들 입장에서도 말이 통해야 설명할 맛이 나고 홍보를 할텐데 대화도 안 통하는 사람이 와서 뻘쭘하게 서있거나 제대로 질문도 못하면 뭐라고 생각할까? 란 생각이 들어 선뜻 말을 걸지 못했다.그래서 그냥 낯익은 기업이 보이면 스티커 가져가도 되냐? (Can I get some stickers?)와 같은 수준의 영어만 말하고 스티커만 몇 개 수집하고 말았다.진짜 영어를 하지 못한다는 게 비통하다는 걸 처음으로 깨닫게 되는 순간이었다.세션 이해 못하는 것 정도야 나중에 유튜브에서 다시 보면 되겠지… 정도로 말았는데 글로벌 테크 기업에서 주된 관심사는 무엇일까? 그들은 어떻게 해결했을까? 등등어떻게 보면 여기에서 밖에 얻지 못할 것 같은 정보들을 하나도 얻지 못했다.역시 기회는 준비된 자에게 오고, 준비가 되지 않은 자는 이렇게 회사에서 돈을 퍼줘서 떠먹여줘도 먹지 못한다는 사실을 절실히 깨닫게 되었다.(라고 말하지만 그럼에도 불구하고 한국에 와서 열심히 영어공부하지 않는 걸 보면 사람은 쉽게 바뀌지 않는 것 같다…) 또 다시 관광모드로… 저녁은 진생이란 곳에서 먹었다.한인식당이다보니 들어가마자 TV에서 K-pop 같은 게 틀어져있었고 종업원들도 한국인이고 한국인 손님들도 많아서 뭔가 한국에 온 듯한 이질감이 들었다.김치찌개 같은 얼큰한 걸 먹지 않아서 아쉬웠지만 그래도 삼겹살 같은 한국 음식을 먹었다는 것에 위안 삼았다. 저녁을 먹고 주변을 좀 둘러다 보다 들어가기로 했는데 뉴욕뉴욕 호텔을 만나게 되었다.베네시안 호텔이 이탈리아 베니스를 테마로 만들어졌다면 뉴욕뉴욕 호텔은 미국의 뉴욕을 테마로 만들어진 호텔이다.한국에서 비슷하게 영어마을 같은 게 있지만 이건 진짜 제대로 흉내낸 듯한 느낌이었다. (개인적으로는 제대로 흉내냈다고 느꼈지만 동료들은 그냥 어줍짢게 흉내낸 느낌이 든다고도 하였다.) 관광지 답게 기념품 상점들이 많았다.그것도 단순한 기념품 상점이 아닌 글로벌 기업들의 기념품 상점이라고 하니 궁금하였다. (하지만 뭐 하나도 사지는 않았다.) 코카콜라 기념품 샵인데 진짜 별에 별 게 다 있었다.코카콜라 찐팬들이라면 눈 돌아갈테지만 나는 그정도까지는 아니고 즐겨먹는 음료이기 때문에 그냥 눈으로만 즐겼다.귀여운 북극곰 인형 정도 하나 사서 조카한테 줄까 싶었지만 인형은 너무 많다고 누나가 그래서 딱히 사지는 않았다. m&amp;m’s라는 초콜릿인지 과자 기업의 기념품 샵도 있었다.자주 먹지는 않지만 그냥 슈퍼마켓에서 종종 보던 로고라서 궁금증에 들어갔고 가족단위로 놀러온 사람들에게는 좋은 관광코스가 될 것 같았다.아이들도 좋아하는 듯 보였다.하지만 여기서도 뭐 딱히 사지는 않았다. 그리고 마지막 날의 대미를 장식을 벨라지오 호텔의 분수쇼를 관람하였다. 벨라지오 호텔의 분수쇼는 꼭 한 번 보는 걸 추천한다.물론 계속 하는 건 아니고 30분인가 몇분 주기로 하긴 하지만 안 보고 오면 너무 아까운 쇼인 것 같다. 세미나 둘째 날까지의 소감 (11&#x2F;30)영어의 필요성을 절실히 체감하였다.기회의 땅이라는데 나는 준비가 안 돼있어서 남이 떠먹여줘도 기회를 얻지 못했다.진짜 영어를 할 줄 아는 건 쇼미더머니 치트키를 쓰는 것이나 다름이 없는 것 같았다.내가 아무리 기술적 역량이 뛰어난다한들 세상의 흐름에 뒤쳐지는 건 너무나 빠르게 진행이 될 것 같았다.라고 말하고 한국에 와서 영어 공부를 열심히 하지 않는 걸 보면… 음… 어떻게 해야 사람이 바뀔런지 궁금하기도 하다. 또한 둘째 날부터 그나마 호텔 근방을 조금이나마 벗어나보았다.코로나 검사를 하러 우버인가 리프트를 타고 근방으로 가보긴 했는데 확실히 차 없으면 미국에서는 관광이 너무 힘들 것 같았다.영어도 안 되니 대중교통을 이용하여 원하는 목적지까지 가는 건 너무나 두려웠다. (로밍을 했는데 인터넷이 잘 되지 않아 지도 앱을 보고 따라가는 것도 한계가 있어보였다.)그리고 호텔 주변은 그냥 일반 도심같은 느낌이 들었는데 차를 타고 조금만 이동하니 주변이 사막이라는 걸 체감할 수 있게 끔 황량한 풍경들이 조금씩 보이는 것 같았다.둘째 날부터 조금씩 호텔 근방을 벗어나보고 벨라지오 분수쇼도 보고 하다보니 ‘아… 드디어 라스베가스에 왔구나…’라는 느낌이 들었다.그 전까지는 근방에서만 활동하다보니 그냥 AWS 리인벤트 세션 들으러 온 기분 밖에 나지 않았는데 뭔가 주변 관광 코스라고 할법한 공간들을 돌아다녀 보니 라스베가스에 왔다는 느낌을 조금이나마 체감할 수 있었다. 그리고 잠들기 전에 또 느낀 게 하나 있다.어떻게 마지막 날까지 버티지?버틴다는 생각이 들은 이유는 기름진 음식들, 반복된 패턴(일어나서 밥먹고 세션듣고 밥먹고 세션듣고 밥먹고 잠자기), 세션을 들어도 이해가 안 되니 지루함이 컸다.마지막 날까지 버텨내야한다는 생각을 하다보니 점점 더 무리하게 세션을 듣는 것을 포기하고 선택과 집중을 해야겠다는 생각이 들었다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"}]},{"title":"라스베가스를 다녀오고... 1편 (feat. AWS re:Invent 2021) - 인천공항에서 세미나 첫 날까지","slug":"las-vegas-aws-reinvent-01","date":"2021-12-31T14:29:31.000Z","updated":"2022-10-30T08:42:16.743Z","comments":true,"path":"2021/12/31/las-vegas-aws-reinvent-01/","link":"","permalink":"https://perfectacle.github.io/2021/12/31/las-vegas-aws-reinvent-01/","excerpt":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) - 현재 게시물 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 인천공항에서 라스베가스까지… (11&#x2F;28)한국시간 기준 일요일 저녁 출발이었고, 코시국이라 인천공항은 사람이 별로 없었다.하지만 미국으로 가는 항공편만 사람이 좀 북적여서 수하물을 붙이는데 30분 가량 걸렸다.","text":"회사에서 좋은 기회가 생겨 AWS re:invent(2021&#x2F;11&#x2F;29 ~ 2021&#x2F;12&#x2F;03)에 참석할 기회가 생겼다.영어도 잘 못하고, 평상시 AWS를 직접 쓰지 않은지 오래 되기도 했지만 견문을 넓히자는 차원에서 지원하여 갔다오게 되었다.살면서 미국에 처음 가보는 것이다보니 미국에서만 할 수 있는 걸 해보자라는 목표를 세우고 갔으나 많은 실패들이 있었고, 영어가 잘 안되다보니 aws reinvent 컨벤션 후기 보다는 라스베가스 여행기가 되어버린 것 같았다.기술적인 부분에서 인사이트를 크게 얻지 못해 창피하여 aws reinvent 후기는 적지 못하고, 미국이라는 기회의 땅에 가본 경험을 휘발성 데이터로 냅두기 아까워 기억들이 더이상 날아가기 전에 이렇게라도 기록을 해둬야할 거 같아서 이 글을 쓰게 되었다.쓰다보니 사진이 많아서인지 글이 좀 루즈해지는 감이 없잖아 있어 파트를 좀 쪼개보았다. 1편 - 인천공항에서 세미나 첫 날까지 (11&#x2F;28 ~ 11&#x2F;29) - 현재 게시물 2편 - 세미나 둘째 날 (11&#x2F;30) 3편 - 세미나 셋째 날 (12&#x2F;01) 4편 - 세미나 넷째 날 (12&#x2F;02) 5편 - 세미나 마지막 날부터 인천공항까지(12&#x2F;03 ~ 12&#x2F;05) 인천공항에서 라스베가스까지… (11&#x2F;28)한국시간 기준 일요일 저녁 출발이었고, 코시국이라 인천공항은 사람이 별로 없었다.하지만 미국으로 가는 항공편만 사람이 좀 북적여서 수하물을 붙이는데 30분 가량 걸렸다. 코시국이라 기내식이 없을 줄 알았는데 식욕은 거스를 수 없는 본능이기 때문인지 나왔다.생애 첫 기내식이라 기대를 품고 먹었고 그냥저냥 나쁘지 않게 먹었다. 또 몇시간이 흘러 두 번째 기내식이 나왔다.10시간이 넘는 비행시간이라 그런지 두 번이나 나왔는데 두 번째부터 물렸다.그냥 먹고 자고 먹고 자고 마치 사육당하는 기분이었다. 바로 라스베가스로 가는 게 아니라 샌프란시스코 공항에 경유하게 되었다.인천공항까지만 하더라도 미국으로 간다는 느낌이 전혀 들지 않았다.한국인에게 체크인 하고, 한국인 승무원이 탑승하고, 비행기에도 대부분이 한국인이어서 미국을 간다는 것이 체감되지 않았다.하지만 샌프란시스코 공항에 도착하고 나서부터는 광고판이며 간판이며 모두 영어였다.또한 비행기에서도 바로 내 옆자리에 외국인이 앉아있었고, 또 한국과의 가장 큰 차이점은 승무원들의 외모였다.한국은 승무원하면 ‘젊고 이쁘다’인데 미국은 ‘인종도 다양하고 연령도 다양하다’였다.연세가 좀 있는 듯한 흑인 승무원 분도 계셨는데 왠지 모르게 전문성이 가득해보였다.이렇듯 한국과 미국은 승무원이라는 직종에서부터도 큰 차이가 있어보였다. 카지노의 도시답게 라스베가스는 공항부터 카지노가 보였다. 공항에 택시들이 줄서있는 건 어딜가나 국룰인 것 같다. 본격 호텔(Wynn) 도착 우리는 Wynn Las Vegas 호텔에 머무르게 되었다.근데 입구에서부터 정말 압도되었고… 내부는 이미 크리스마스 장식이 너무 이쁘게 되어있었다.한국에서 이런 호텔을 가본 적이 없었다보니(있는지도 모르겠지만) 여기 정말 호텔이 맞나?란 생각이 들 정도로 너무너무 근사했다. 크리스마스 장식의 감동도 잠시… 카지노의 도시답게 호텔에는 카지노 슬롯머신들이 삐까뻔쩍하게 즐비해있다.전에 일본에 놀러간 적이 있었는데 카지노와 비슷한 빠칭코를 경험 한 적이 있었다.그 때 일본인들은 빠칭코에는 관심은 없고 그냥 시간을 죽이러 오는 사람들도 많아보였다.약속시간까지 기다리기 애매할 때 빠칭코 가게에 가서 그냥 머신을 돌려만 놓고 핸드폰을 보는 사람들도 많았기 때문이다.카지노도 그런 느낌으로 하는 걸까… 궁금증이 많았지만 겁도 나고 피곤했기 때문에 바로 시도해보지는 않았다. 오션뷰도 아닌 Crypto 뷰…AWS Reinvent 기간이라 그런지 힐튼 호텔 광고에 crypto.com이 보이니 뭔가 오묘했다…시간이 지나면 데이터독이나 기타 테크 기업들의 광고도 나왔다. 방은 아쉽게도 1인실이 아닌 2인실이었다. (이것마저 1인실을 바라면 너무 도둑놈 같아 보인다.)슬리퍼는 당연히 없을 것 같아서 한국에서 하나 가져왔고, 호텔에 있는 음료&#x2F;과자 같은 거 밑에 저울이 달려있어 무게가 조금이라도 달라지면 바로 과금이 된다고 했다. 걸어서 베네시안(Ventian) 호텔로… (feat. Midnight Madness)호텔에서 짐정리 한 후 세미나 등록을 위해 The Venetian Resort Las Vegas 호텔로 이동을 하였다.나도 잘 몰랐는데 라스베가스의 호텔들은 세미나나 각종 컨벤션들을 위해 사용된다고 한다.호텔 안에 그런 걸 위해 별도의 공간들이 많이 마련돼있고, AWS는 단순 한 호텔이 아닌 Wynn, Venetian, Caesars Forum 등등 다양한 곳에서 진행이 되었다.호텔 간 이동거리는 걸어서 한 15분 정도 걸렸던 것 같고, 그 안에 카지노도 있기 때문에 길을 헤매는 경우도 많았다.그러다보니 하루에 최소 2만보는 걸었고 아침 일찍부터 듣게되면 오후에는 시차적응 + 안하던 걷기 운동을 하게 됨에 따른 피로감이 몰려와서 졸리곤 하였다. 베네시안 호텔로 걸어서 약 15분 정도를 이동하였는데 그냥 길거리들이 다 삐까뻔쩍하고 관광의 도시답게 정말 잘 꾸며놓았다.속으로 그래… 이게 미국이지… 이런 생각을 하면서 걸었다. 베네시안 호텔은 이탈리아의 관광도시인 베니스(Venezia)를 테마로 만든 호텔이라고 한다.그래서인지 이탈리아에나 있을 법한 분위기들을 주로 연출하고 있는데 바다에서 배를 타는 듯한 느낌의 관광상품도 있는데 나중에 가족이나 연인끼리 오면 그냥 한번 해볼법 한 것 같다. 베네시안 호텔에 들어가서 aws 리인벤트를 등록하러 가는데 AWS 로고가 보이고 관련된 장소들이 등장하자 뭔가 압도되는 느낌이 들었다.아무리 국내에서 날고 긴다하는 테크 기업들이 있다지만 ‘글로벌 기업은 진짜 다르구나… 어떻게 이런 스케일로 행사를 진행할 수 있지??’ 이런 생각이 들었다.또 한편으로 ‘나 놀러온 게 아니라 세미나 들으러 온 거였지?’ 하고 정신이 확 들기도 했다. Registration 부스에 가서 등록을 마치고 Swag 부스에서 AWS Reinvent 10주년 기념 후드집업도 받았다. 등록을 마치고 미국에서의 첫끼니는 아웃백에서 먹게 되었다.아웃백의 본고장인 미국에서 먹는다는 것에 매우 설렜지만 주문을 하는 것부터가 난항이었다.한국 아웃백도 별로 가본 적이 없어서 메뉴도 잘 모르고 선택할 것도 많아서 선택장애가 오곤 하였는데 미국은 영어로 된 메뉴판에서 영어로 주문한다고 하니 거기서부터가 난관이었다.다행히 일행 중에 영어를 잘하시는 분이 계셔서 주문을 성공적으로 마치고 아주 맛있게 먹었다.또한 미국이라 그런지 양이 참 많았다. 7명이서 메뉴를 5개 시켰는데도 남을 정도였다. 아, 여담으로 아웃백은 가게를 찾아 들어가는 것부터가 또 문제였다.아웃백은 2층에 있는데 2층으로 가려면 1층을 통해 갔어야했는데 1층에 또 카지노가 있어서 어디로 가야하는지부터도 찾는데 시간이 좀 걸렸었다.진짜 라스베가스는 카지노 없으면 섭할 정도로 카지노는 어딜 가나 존재하는 것 같았다. 저녁을 먹고 AWS 리인벤트의 전야제인 Midnignt Madness에 참석하였는데일반인 참여자가 올라와서 락음악에 맞추어 허공에 드럼&amp;기타질하기, OX 퀴즈 등등 같은 것이 진행되었지만 미국 블랙코메디인지 나하고는 코드가 잘 맞지 않았다.그리고 한국은 잘 모르겠지만 미국은 묘기 스포츠 같은 것들이 잘 형성돼있어서인지 자전거&amp;스케이트 보드로 엄청난 퍼포먼스를 보여주었다. 본격 AWS re:Invent 시작 (11&#x2F;29, 1일차) 윈 호텔의 커튼은 자동으로 걷고, 칠 수 있다. 첫날은 아침을 제공해주지 않았고, 스타벅스에 가서 샌드위치랑 커피로 간단히 떼웠다.본토 스타벅스라 그런지 아침부터 대기줄이 길었고, 한번 쯤 미국 스타벅스에 가본다는 자그마한 목표도 달성을 해보았다. 그리고 시간이 좀 남아서 reflection room을 돌아보았다. reflection room이라는 용어를 처음 들어봐서 구글에 검색해보았을 때는 ‘와… 거울이 가득한 고요한 방에서 명상을 하는 공간인가? 심신의 안정을 찾는 공간인가?’라는 생각이 들면서 이런 공간까지 있는 진짜 대단한 행사라는 생각이 들었다. 하지만 실상은 그냥 공간하나 대여해서 요가매트 깔아놓고 알아서 명상&amp;요가 하는 공간이었다.나는 요가나 명상을 별로 해본 적이 없다보니 실제로는 시차 적응이 안 돼서 졸릴 때 종종 리플렉션 룸에 와서 잠을 청하곤 했다. (빈백도 있어서 잠 자기 편안했다.)호텔까지 가려면 또 20분 가량 걸어서 가야하다보니 엄두도 안 났는데 그래도 휴식하기 적당한 공간이라 종종 애용하였다.그리고 또 놀란 게 이슬람교인지 모르겠지만 오후에 특정 시간이 되니 하나 둘 리플렉션 룸으로 오더니 특정 방향을 보고 절을 하는 것을 보고 ‘와… 찐 종교인이구나…’하고 신기했던 경험도 있다. 점심부터는 AWS 측에서 제공해줘서 가까운 호텔에 가면 먹을 수 있었다.아웃백을 먹을 때까지만 해도 고기나 기름진 음식이 너무 좋았고 초딩 입맛인 나한테는 너무나 좋았다.하지만 아침에 스타벅스에서 샌드위치를 먹고 나서 점심에도 또 샌드위치를 먹을 생각을 하니… 너무나 물렸다.쌀은 없고, 얼큰한 음식도 없어서 이때부터 조금씩 고통이었다.그래도 아직은 세미나 첫날이기 때문에 먹을만 하였다. 세션을 듣긴 들었는데… 영어이다보니 이해 안 되는 게 태반이었다. (AWS를 안 쓰다보니 이해가 안 되는 것도 많았고…)확실히 이 때부터 영어의 필요성을 체감하기 시작한 것 같다. 어제는 베네시안 호텔 외부를 주로 봤다면 베네시안 호텔에서 세션을 듣다보니 베네시안 호텔 내부도 돌아다니다 어제는 못봤던 곳들도 많이 보게 되었다.그러다 베네시안 호텔 2층에서 마치 하늘이 뚫려있는 듯한 공간을 만났다.하지만 정말 세트장처럼 꾸며놓아서 저기서 밥을 먹게 된다면 진짜 이탈리아 베니스에 온듯한 느낌이 들 것 같았다. 일반적인 세션 말고 리더십 세션은 오페라나 뮤지컬 공연장 같은 큰 공간에서 하였다. 첫날 저녁은 라스베가스에서 유명한 쌀국수 집이라는 Pho Kim Long에 다녀왔다.막상 찍고보니 음식 사진은 없고 간판만 찍었다.맛의 조예가 깊지 않다보니 뭐 엄청 대단하다… 다르다… 특별하다… 라고 느끼기보다는 그냥 뭐 먹을만 했다? 맛있다? 정도였다.그래도 계속되는 샌드위치&#x2F;고기 파티에서 조금은 벗어나서 색다른 음식을 먹을 수 있어 좋았다.그래도 김치랑 라면이 마렵긴 마찬가지였다. 대충 첫날의 일정을 마치고 돌아오면서 어디서 못 본 것 같은 분수라서 한 컷 찍었다. 첫날의 일정이 생각보다 빡세서 일행은 이슈를 처리하다가 중간에 잠이 들어버렸다… 세미나 첫날까지의 소감 (11&#x2F;28 ~ 11&#x2F;29)인천공항에서(11&#x2F;28)부터 세미나 첫날(11&#x2F;29)까지의 소감은 ‘이제 첫날이라고?’였다.15~6시간 정도 되는 긴 비행(중간 경유시간 포함)부터 낯선 문화, 기름진 음식들, 그리고 세션을 들으러 호텔을 이리저리 이동하는 것까지…아직 첫날 밖에 끝나지 않았다는 것이 믿기지 않았다.인천에서 미국으로 갈 수록 시간이 느려지는데 그러다보니 한국시간(KST) 11&#x2F;28 저녁 8시 쯤에 출발해서 라스베가스 현지시간(PST) 11&#x2F;28 저녁 6시 쯤에 도착하였는데 이것도 한 몫 한 것 같긴 하다.여행 가면 시간이 빨리간다는데 난 왜 이리 시간이 안 가는 거지?라는 생각이 들다가 아 맞다… 나 여행온 거 아니지… 라고 다시 정신을 차리곤 하였다.가장 큰 문제는 세미나에 집중하려해도 AWS 배경지식 부족 + 언어에서 오는 문제점으로 인해 세션에 집중할 수 없었다.그래도 회사에서 지원까지 받았고 나 대신 열심히 일하는 동료들도 있는데… 라는 생각으로 내일부터는 좀 더 세션을 이해해야겠다고 다짐하였다.그리고 너무 과하게 스케쥴을 잡다보니 피곤하고 시간에 쫓기듯 이동하다보니 점심도 제대로 못 먹고 세션을 들으러 가기도 하였다.그래서 좀 템포를 조절하여 세션을 들어야겠다고 생각하였다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"}]},{"title":"(Spring Boot) spring-boot-configuration-processor 활용하기","slug":"spring-boot-configuration-processor","date":"2021-11-21T14:43:06.000Z","updated":"2022-10-30T08:42:16.915Z","comments":true,"path":"2021/11/21/spring-boot-configuration-processor/","link":"","permalink":"https://perfectacle.github.io/2021/11/21/spring-boot-configuration-processor/","excerpt":"Configuration Metadatahttps://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html Spring Boot jars include metadata files that provide details of all supported configuration properties.The files are designed to let IDE developers offer contextual help and “code completion” as users are working with application.properties or application.yml files. Configuration Metadata는 IDE에서 yml 혹은 properties에서 사용하는 Configuration의 자동완성을 도와주는 메타데이터이다. (소스코드에는 영향을 1도 안 미친다.)","text":"Configuration Metadatahttps://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html Spring Boot jars include metadata files that provide details of all supported configuration properties.The files are designed to let IDE developers offer contextual help and “code completion” as users are working with application.properties or application.yml files. Configuration Metadata는 IDE에서 yml 혹은 properties에서 사용하는 Configuration의 자동완성을 도와주는 메타데이터이다. (소스코드에는 영향을 1도 안 미친다.) 커스텀 Configuration Metadata 정의 자동으로 Configuration Metadata 생성하기 (spring-boot-configuration-processor)https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#configuration-metadata.annotation-processor You can easily generate your own configuration metadata file from items annotated with @ConfigurationProperties by using the spring-boot-configuration-processor jar.The jar includes a Java annotation processor which is invoked as your project is compiled. @ConfigurationProperties 어노테이션이 붙은 클래스에 대한 Configuration Metadata File은 spring-boot-configuration-processor를 통해 생성할 수 있다고 한다. build.gradle.kts에 kapt 플러그인을 활성화시켜준다. (코틀린 컴파일러로 컴파일하기 때문에 자바로 작성한 어노테이션을 해석하지 못하기 때문) 1kotlin(&quot;kapt&quot;) version &quot;1.6.0&quot; build.gradle.kts에 아래 디펜던시들을 추가해준다. (멀티 모듈인 경우 모든 모듈에 일일이 추가하는 게 귀찮으니 루트의 build.gradle.kts에 추가해주는 것이 좋다.) 12annotationProcessor(&quot;org.springframework.boot:spring-boot-configuration-processor&quot;)kapt(&quot;org.springframework.boot:spring-boot-configuration-processor&quot;) 다만 몇 가지 한계점이 있는데 아래와 같다. @ConfigurationProperties에 대해서만 동작하기 때문에 @Value와 같이 단순하게 사용한 경우에는 해당 configuration에 대해서 metadata가 생성되지 않는다. properties나 yml에 정의만 해놓고 @ConfigurationProperties 클래스를 생성하지 않은 경우에는 해당 configuration에 대해서 metadata가 생성되지 않는다. properties나 yml의 위치하는 모듈과 @ConfigurationProperties 클래스가 위치하는 모듈이 다른 경우에는 해당 configuration에 대해서 metadata가 생성되지 않는다. 소스코드가 돌아가는데는 전혀 문제가 없지만 올바른 설계인지 고민을 한 번 해보는 것이 좋다.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"}]},{"title":"(Spring) 외부 API의 Response 객체를 만들 때 null을 주의하자","slug":"spring-web-response-deserialization-for-null","date":"2021-09-20T02:57:30.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2021/09/20/spring-web-response-deserialization-for-null/","link":"","permalink":"https://perfectacle.github.io/2021/09/20/spring-web-response-deserialization-for-null/","excerpt":"소스코드 외부 세계에서 내부 세계로 데이터를 전달하기 위해서는 미리 정해진 프로토콜 및 API를 통해 데이터를 주고받게 된다.일반적으로 우리가 많이 사용하는 Restful API(혹은 HTTP API)는 대부분 json의 형태로 데이터를 주고 받게 된다.그럼 json 문자열이 우리가 정의한 Response 객체로 매핑을 할 때 null을 어떻게 핸들링 해야할까에 집중해서 간단히 정리해보았다.해당 포스트와 연관성이 높은 (Spring) 외부에서 호출하는 Request 객체를 만들 때 null을 주의하자도 읽는 것을 추천한다. 코틀린코틀린은 nullable을 지원하다보니 소스코드에서 null에 대한 체크를 매번하지 않아도 돼서 매우 편하다.하지만 이건 우리 소스코드 내부의 사정이고 소스코드 외부에서 들어오는 데이터의 경우에는 단정지을 수 없다.그 단적인 예가 네트워크를 통해 들어오는 HTTP API의 응답이다. 1234class ResponseV1( val number: Int, val text: String) 이런 응답 객체가 있다고 할 때 과연 number와 text는 non-null을 100% 보장할 수 있을까??","text":"소스코드 외부 세계에서 내부 세계로 데이터를 전달하기 위해서는 미리 정해진 프로토콜 및 API를 통해 데이터를 주고받게 된다.일반적으로 우리가 많이 사용하는 Restful API(혹은 HTTP API)는 대부분 json의 형태로 데이터를 주고 받게 된다.그럼 json 문자열이 우리가 정의한 Response 객체로 매핑을 할 때 null을 어떻게 핸들링 해야할까에 집중해서 간단히 정리해보았다.해당 포스트와 연관성이 높은 (Spring) 외부에서 호출하는 Request 객체를 만들 때 null을 주의하자도 읽는 것을 추천한다. 코틀린코틀린은 nullable을 지원하다보니 소스코드에서 null에 대한 체크를 매번하지 않아도 돼서 매우 편하다.하지만 이건 우리 소스코드 내부의 사정이고 소스코드 외부에서 들어오는 데이터의 경우에는 단정지을 수 없다.그 단적인 예가 네트워크를 통해 들어오는 HTTP API의 응답이다. 1234class ResponseV1( val number: Int, val text: String) 이런 응답 객체가 있다고 할 때 과연 number와 text는 non-null을 100% 보장할 수 있을까?? 12345678910111213141516171819202122232425262728293031323334353637383940414243@SpringBootTestinternal class ResponseTest &#123; @Autowired private lateinit var restTemplateBuilder: RestTemplateBuilder private lateinit var restTemplate: RestTemplate private var init = false companion object &#123; val mockHttpServer = WireMockServer(wireMockConfig().dynamicPort()) @BeforeAll @JvmStatic internal fun beforeAll() &#123; mockHttpServer.start() &#125; @AfterAll @JvmStatic internal fun afterAll() &#123; mockHttpServer.stop() &#125; &#125; @BeforeEach internal fun setUp() &#123; if (init) &#123; return &#125; init = true restTemplate = restTemplateBuilder.rootUri(&quot;http://localhost:$&#123;mockHttpServer.port()&#125;&quot;).build() &#125; @Test fun `응답 객체 전송 시에 non-null 필드가 누락돼있으면 RestClientException을 던진다`() &#123; mockHttpServer.givenThat(WireMock.any(UrlPattern.ANY).willReturn(WireMock.okJson(&quot;&quot;&quot;&#123;&quot;number&quot;: 13&#125;&quot;&quot;&quot;))) val expected = HttpMessageNotReadableException::class.java val actual = assertThrows&lt;RestClientException&gt; &#123; restTemplate.getForObject(&quot;/&quot;, ResponseV1::class.java) &#125;.cause assertThat(actual).isInstanceOf(expected) &#125;&#125; 외부 API의 응답을 모킹하기 위해 wiremock을 사용하였다.만약 외부 API의 응답 중 text 필드가 오지 않았더라면 RestClientException(cause exception은 HttpMessageNotReadableException)을 던지게 된다. 그러면 아래와 같이 코드를 개선해볼 수 있다. 1234567class ResponseV2( number: Int?, text: String?) &#123; val number = number ?: 0 val text = text ?: &quot;&quot;&#125; 우선 생성자를 전부 nullable로 정의해서 객체의 성공을 보장하고, 멤버변수는 전부 기본값을 정의해서 non-null을 보장하였다. 123456789@Testfun `응답 객체 전송 시에 non-null 필드가 누락돼있으면 기본값이 할당된다`() &#123; mockHttpServer.givenThat(WireMock.any(UrlPattern.ANY).willReturn(WireMock.okJson(&quot;&quot;&quot;&#123;&quot;number&quot;: 13&#125;&quot;&quot;&quot;))) val expected = &quot;&quot; val actual = restTemplate.getForObject(&quot;/&quot;, ResponseV2::class.java)?.text assertThat(actual).isEqualTo(expected)&#125; 혹시나 Data Class를 꼭 사용해야한다면 아래와 같이도 할 수 있다. 12345678910data class ResponseV3( val number: Int, val text: String) &#123; @JsonCreator constructor(number: Int?, text: String?) : this( number = number ?: 0, text = text ?: &quot;&quot; )&#125; jackson은 기본 생성자를 리플렉션하여 객체를 생성하는데 기본 생성자가 없으니 객체 생성을 위해 사용할 생성자에 @JsonCreator 어노테이션을 달아주었다. 자바자바에서도 똑같이 null에 대한 검증을 모두 끝마친 깔끔한 response dto 객체를 원할 것이다. 12345678910public class Response &#123; public final int number; public final String text; @JsonCreator public Request(final Integer number, final String text) &#123; this.number = number == null ? 0 : number; this.text = text == null ? &quot;&quot; :text; &#125;&#125; 기본적으로 응답 객체를 수정하는 행위는 소스코드의 예측력을 떨어뜨리므로 불변객체로 만들고,불변객체이므로 getter를 사용하나 필드에 직접 접근하나 재할당하지 못한다는 사실은 똑같기 때문에 불필요하게 getter 메서드를 사용하지 않고, 접근이 필요한 필드의 경우에만 public 접근 지정자를 사용하여 직접 필드를 참조하도록 하였다.jackson은 기본 생성자를 리플렉션하여 객체를 생성하는데 기본 생성자가 없으니 객체 생성을 위해 사용할 생성자에 @JsonCreator 어노테이션을 달아주었다.또한 클라이언트로부터 어떤 요청이 들어올지 모르니 일단 생성자에서는 전부 null을 허용하고 기본값을 할당하였다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"Web","slug":"Web","permalink":"https://perfectacle.github.io/tags/Web/"}]},{"title":"(Spring) 외부에서 호출하는 Request 객체를 만들 때 null을 주의하자","slug":"spring-web-request-deserialization-for-null","date":"2021-09-20T02:04:28.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2021/09/20/spring-web-request-deserialization-for-null/","link":"","permalink":"https://perfectacle.github.io/2021/09/20/spring-web-request-deserialization-for-null/","excerpt":"소스코드 외부 세계에서 내부 세계로 데이터를 전달하기 위해서는 미리 정해진 프로토콜 및 API를 통해 데이터를 주고받게 된다.일반적으로 우리가 많이 사용하는 Restful API(혹은 HTTP API)는 대부분 json의 형태로 데이터를 주고 받게 된다.그럼 json 문자열이 우리가 정의한 Request 객체로 매핑을 할 때 null을 어떻게 핸들링 해야할까에 집중해서 간단히 정리해보았다.해당 포스트와 연관성이 높은 (Spring) 외부 API의 Response 객체를 만들 때 null을 주의하자도 읽는 것을 추천한다. 코틀린코틀린은 nullable을 지원하다보니 소스코드에서 null에 대한 체크를 매번하지 않아도 돼서 매우 편하다.하지만 이건 우리 소스코드 내부의 사정이고 소스코드 외부에서 들어오는 데이터의 경우에는 단정지을 수 없다.그 단적인 예가 네트워크를 통해 들어오는 HTTP API의 요청이다. 12345678910class RequestV1( val number: Int, val text: String)@RestControllerclass Controller &#123; @PostMapping fun api(@RequestBody request: RequestV1) &#123;&#125;&#125; 이런 요청 객체와 API가 있다고 할 때 과연 number와 text는 non-null을 100% 보장할 수 있을까??","text":"소스코드 외부 세계에서 내부 세계로 데이터를 전달하기 위해서는 미리 정해진 프로토콜 및 API를 통해 데이터를 주고받게 된다.일반적으로 우리가 많이 사용하는 Restful API(혹은 HTTP API)는 대부분 json의 형태로 데이터를 주고 받게 된다.그럼 json 문자열이 우리가 정의한 Request 객체로 매핑을 할 때 null을 어떻게 핸들링 해야할까에 집중해서 간단히 정리해보았다.해당 포스트와 연관성이 높은 (Spring) 외부 API의 Response 객체를 만들 때 null을 주의하자도 읽는 것을 추천한다. 코틀린코틀린은 nullable을 지원하다보니 소스코드에서 null에 대한 체크를 매번하지 않아도 돼서 매우 편하다.하지만 이건 우리 소스코드 내부의 사정이고 소스코드 외부에서 들어오는 데이터의 경우에는 단정지을 수 없다.그 단적인 예가 네트워크를 통해 들어오는 HTTP API의 요청이다. 12345678910class RequestV1( val number: Int, val text: String)@RestControllerclass Controller &#123; @PostMapping fun api(@RequestBody request: RequestV1) &#123;&#125;&#125; 이런 요청 객체와 API가 있다고 할 때 과연 number와 text는 non-null을 100% 보장할 수 있을까?? 1234567891011121314151617181920@WebMvcTest@AutoConfigureMockMvcinternal class ControllerTest &#123; @Autowired private lateinit var mockMvc: MockMvc @Test fun `요청 객체 전송 시에 non-null 필드를 누락하면 HttpMessageNotReadableException 예외를 던진다`() &#123; val expected = HttpMessageNotReadableException::class.java val actual = mockMvc.post(&quot;/&quot;) &#123; contentType = MediaType.APPLICATION_JSON content = &quot;&quot;&quot;&#123;&quot;number&quot;: 13&#125;&quot;&quot;&quot; &#125;.andExpect &#123; status &#123; isBadRequest() &#125; &#125;.andReturn().resolvedException assertThat(actual).isInstanceOf(expected) &#125;&#125; 클라이언트에서 http 요청을 보낼 때 충분히 필수 필드를 누락할 수 있고, 이 때 서버에서 HttpMessageNotReadableException 예외를 던지게 된다.org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot construct instance of ... problem: Parameter specified as non-null is null: method example.web.mvc.RequestV1.&lt;init&gt;, parameter text기본적으로 이 경우에는 DefaultHandlerExceptionResolver에서 예외를 핸들링하여 warn 로그를 찍게 된다.이런 경우에는 HttpMessageNotReadableException 보다는 MethodArgumentNotValidException 예외를 던지는 것이 더 적합해보인다. 그러면 아래와 같이 코드를 개선해볼 수 있다. 123456789101112131415class RequestV2( number: Int?, text: String?) &#123; @Min(1) val number = number ?: 0 @NotBlank val text = text ?: &quot;&quot;&#125;@RestControllerclass Controller &#123; @PostMapping fun api(@RequestBody @Valid request: RequestV2) &#123;&#125;&#125; 우선 생성자를 전부 nullable로 정의해서 객체의 성공을 보장하고, 멤버변수는 전부 기본값을 정의해서 non-null을 보장하였다.생성자의 인자를 기준으로 요청을 검증하는 게 아니라 이미 생성된 객체를 기준으로 검증을 하기 때문에 멤버변수에 할당된 기본값 기준으로 어노테이션을 설정해야한다. 123456789101112131415@Testfun `요청 객체 전송 시에 유효하지 않은 필드가 존재하면 MethodArgumentNotValidException 예외를 던진다`() &#123; val expected = MethodArgumentNotValidException::class.java val actual = mockMvc.post(&quot;/&quot;) &#123; contentType = MediaType.APPLICATION_JSON content = &quot;&quot;&quot;&#123;&quot;number&quot;: 13&#125;&quot;&quot;&quot; &#125;.andDo &#123; print() &#125;.andExpect &#123; status &#123; isBadRequest() &#125; // 응답으로 어떤 필드가 유효하지 않은지 추가하려면 @ExceptionHandler를 사용하여 MethodArgumentNotValidException를 핸들링 해야한다. content &#123; string(&quot;&quot;) &#125; &#125;.andReturn().resolvedException assertThat(actual).isInstanceOf(expected)&#125; 혹시나 Data Class를 꼭 사용해야한다면 아래와 같이도 할 수 있다. 123456789101112data class RequestV3( @field:Min(1) val number: Int, @field:NotBlank val text: String) &#123; @JsonCreator constructor(number: Int?, text: String?) : this( number = number ?: 0, text = text ?: &quot;&quot; )&#125; 생성자 함수가 아닌 멤버변수에 어노테이션을 설정하기 위해 @field라고 어노테이션 타겟을 명시했다.(참고: Annotation use-site targets)또한 jackson은 기본 생성자를 리플렉션하여 객체를 생성하는데 기본 생성자가 없으니 객체 생성을 위해 사용할 생성자에 @JsonCreator 어노테이션을 달아주었다. 자바자바에서도 똑같이 null에 대한 검증을 모두 끝마친 깔끔한 request dto 객체를 원할 것이다. 123456789101112public class Request &#123; @Min(1) public final int number; @NotNull public final String text; @JsonCreator public Request(final Integer number, final String text) &#123; this.number = number == null ? 0 : number; this.text = text == null ? &quot;&quot; :text; &#125;&#125; 기본적으로 요청 객체를 수정하는 행위는 소스코드의 예측력을 떨어뜨리므로 불변객체로 만들고,불변객체이므로 getter를 사용하나 필드에 직접 접근하나 재할당하지 못한다는 사실은 똑같기 때문에 불필요하게 getter 메서드를 사용하지 않고, 접근이 필요한 필드의 경우에만 public 접근 지정자를 사용하여 직접 필드를 참조하도록 하였다.jackson은 기본 생성자를 리플렉션하여 객체를 생성하는데 기본 생성자가 없으니 객체 생성을 위해 사용할 생성자에 @JsonCreator 어노테이션을 달아주었다.또한 클라이언트로부터 어떤 요청이 들어올지 모르니 일단 생성자에서는 전부 null을 허용하고 기본값을 할당하였다.생성된 요청 객체의 멤버변수에는 적절한 벨리데이션을 위한 어노테이션을 추가하면 된다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"Web","slug":"Web","permalink":"https://perfectacle.github.io/tags/Web/"}]},{"title":"(Java) Fail Fast Iterator","slug":"fail-fast-iterator","date":"2021-08-14T19:20:03.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2021/08/14/fail-fast-iterator/","link":"","permalink":"https://perfectacle.github.io/2021/08/14/fail-fast-iterator/","excerpt":"문제상황12345678private Map&lt;String, String&gt; mappings;public void clear(final CardCompanyCode cardCompanyCode) &#123; mappings.entrySet().forEach(e -&gt; &#123; if (e.getValue() != cardCompanyCode) return; mappings.remove(e.getKey()); &#125;);&#125; 맵에서 entrySet(key&#x2F;value 쌍)을 가져와 forEach 돌면서 특정 조건에 맞으면 맵에서 요소를 삭제했더니 한 번만 요소가 삭제되고나서 ConcurrentModificationException을 던졌다. 여기서 아래와 같은 의문점이 생겼다. 맵의 요소를 삭제하는 건데 왜 예외를 던질까? 왜 한 번만 요소 삭제에 성공하는 걸까? 하나의 쓰레드에서 작업했는데 왜 ConcurrentModificationException을 던진 걸까?","text":"문제상황12345678private Map&lt;String, String&gt; mappings;public void clear(final CardCompanyCode cardCompanyCode) &#123; mappings.entrySet().forEach(e -&gt; &#123; if (e.getValue() != cardCompanyCode) return; mappings.remove(e.getKey()); &#125;);&#125; 맵에서 entrySet(key&#x2F;value 쌍)을 가져와 forEach 돌면서 특정 조건에 맞으면 맵에서 요소를 삭제했더니 한 번만 요소가 삭제되고나서 ConcurrentModificationException을 던졌다. 여기서 아래와 같은 의문점이 생겼다. 맵의 요소를 삭제하는 건데 왜 예외를 던질까? 왜 한 번만 요소 삭제에 성공하는 걸까? 하나의 쓰레드에서 작업했는데 왜 ConcurrentModificationException을 던진 걸까? Fail Fast In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them. 위키피디아 Fail-fast에서 따온 건데, 실패 조건에 부합한다면 바로 후속 작업 같은 걸 멈추는 걸 fail-fast라고 부르는 것 같다.비슷하게 gradle에서 테스트 같은 태스크를 돌릴 때 fail-fast 옵션을 킬 수 있는데, 하나의 테스트라도 실패하면 그 뒤에 테스트들은 실행조차 하지 않고 테스트가 실패했다고 처리하는 방식이다.비슷한 맥락으로 runtime에서 터질 에러를 compile-time으로 땡겨와서 에러를 잡는 것도 Fail-fast 전략이라고도 부르는 것 같다. (자바에서는 not null 타입이 없어서 NullPointerException으로 runtime에 에러가 던져졌는데 코틀린에서는 not null 타입이 생기면서 null을 넘기면 compile-time에 에러가 생겨 좀 더 빠른 실패가 보장된다던지… 등등) Fail Fast Iterator실제 내가 사용했던 Map의 구현체인 LinkedHashMap의 javadoc을 보면 아래와 같이 나온다. The iterators returned by the iterator method of the collections returned by all of this class’s collection view methods are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator’s own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. this class(LinkedHashMap)의 collection view를 반환하는 메서드에 의해 반환된 컬렉션의 iterator 메서드에 의해 반환된 iterators는 fail-fast라고 한다. (자바의 Collections Framework에서 View에 대한 내용은 https://softwarecave.org/2014/03/19/views-in-java-collections-framework/ 를 참조 바람) mappings.entries.forEach여기서 말하는 collection view를 반환하는 methods는 위 예시에서 entries(내부적으로 자바의 entrySet 메서드 호출)를 의미하고, forEach 메서드 안에서 내부적으로 iterator 메서드를 호출하여 iterator를 반환받고 iterating 하고 있는 것이다. 만약 map(예시에서 LinkedHashMap)이 iterator 생성 이후 구조적으로 변경(put(add)&#x2F;remove 메서드를 통해 구조가 바뀌는 경우)되는 경우에는 iterator는 ConcurrentModificationException을 던진다.이를 통해 잠재적으로 동시에 Map이 수정되는 현상을 방지하며 빠르고, 깔끔하게 실패처리를 하고 있다고 한다. Map 입장에서는 이게 멀티쓰레드 환경에서 돈 건지 아닌지 모르고, 혹시나 모를 동시성 이슈에 대비해 구조가 바뀌면 바로 ConcurrentModificationException을 던지는 것 같다. 실제 LinkedHashMap의 구현체를 보면 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; removeNode 메서드의 맨 아랫 부분의 조건문을 보면 실제 삭제가 발생할 때 ++modCount를 통해 변경된 횟수를 늘리고 있다. 123456789101112131415161718192021222324252627282930313233343536public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;&#125;final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; // ...&#125;final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125;abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; // ...&#125; entrySet 메서드를 통해 반환되는 EntrySet의 iterator 메서드는 EntryIterator를 반환하고, EntryIterator가 상속받은 HashIterator는 fast-fail을 위해 생성자에서 Map(LinkedHashMap)의 modCount를 expectedModCount 변수에 저장하고 있다. 123456789101112131415161718192021final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125;abstract class HashIterator &#123; // ... final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; // ...&#125; EntryIterator의 next 메서드는 부모 클래스인 HashIterator의 nextNode() 메서드를 호출하는데 그 안에서 객체 생성 당시의 modCount(expectedModCount)와 현재 Map(LinkedHashMap)의 modCount를 비교해서 다르면 ConcurrentModificationException을 던지고 있는 것을 볼 수 있다.문제가 발생(할 가능성이 보이면)하면 후속작업을 하지 않고 바로 fail 처리(예외 던져버리기)를 해버리는 점에서 fail fast iterator라고 불리는 것 같다. 문제 해결그럼 다시 문제상황에서 어떻게 코드가 내부적으로 돌아갔을지 확인해보자. 123456public void clear(final CardCompanyCode cardCompanyCode) &#123; mappings.entrySet().forEach(e -&gt; &#123; if (e.getValue() != cardCompanyCode) return; mappings.remove(e.getKey()); &#125;);&#125; mappings.entrySet 메서드가 호출되고, EntrySet 타입을 반환받는다. forEach에서 반복문을 돌리기 위해 EntrySet의 iterator 메서드가 호출됨에 따라 EntryIterator를 반환받는다. EntryIterator의 부모인 HashIterator 생성자에서는 fail-fast를 위해 현재 Map의 modCount를 expectedModCount 변수에 저장한다. forEach 메서드 안에서는 iterator.hasNext()가 호출되고 true를 반환함에 따라 iterator.next() 메서드가 호출되고, 그 반환값은 it라는 변수에 저장된다. 조건문에 따라 Map의 remove 메서드가 호출되고 그에 따라 Map의 modCount가 1 증가한다. 또 다시 iterator.hasNext()가 호출되고 true를 반환함에 따라 iterator.next() 메서드를 호출한다. iterator.next()에서는 HashIterator의 nextNode() 메서드가 호출되고, 객체 생성 당시의 modCount(expectedModCount)와 현재 Map의 modCount가 다르기 때문에 ConcurrentModificationException을 던진다. 이 문제를 해결하기 위해서는 map.remove 메서드가 아닌 iterator.remove() 메서드를 사용해야한다. 1234567891011121314abstract class HashIterator &#123; // ... public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125;&#125; iterator.remove() 메서드 안에서도 실제로 removeNode(map.remove에서도 호출함) 메서드가 호출되지만, expectedModCount를 현재 modCount로 갱신하는 게 큰 차이점이다. 따라서 위 예시는 아래와 같이 바꾸면 해결된다. 12345678910public void clear(final CardCompanyCode cardCompanyCode) &#123; final Iterator&lt;Map.Entry&lt;String, CardCompanyCode&gt;&gt; iterator = mappings.entrySet().iterator(); while (iterator.hasNext()) &#123; final Map.Entry&lt;String, CardCompanyCode&gt; entry = iterator.next(); if (entry.getValue() != cardCompanyCode) return; iterator.remove(); &#125;&#125; Fail Safe Iterator (Non Fail Fast Iterator)Fail Safe Iterator라는 용어가 없지만 Fail Fast Iterator와 반대되는 개념이라고 보면 된다. 대표적으로 ConcurrentHashMap의 Collection View를 반환하는 메서드(entrySet, keySet, valueSet 등등)의 iterator 메서드가 생성하는 iterator가 있다. 123456789101112131415161718static final class EntryIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt; implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Node&lt;K,V&gt;[] tab, int index, int size, int limit, ConcurrentHashMap&lt;K,V&gt; map) &#123; super(tab, index, size, limit, map); &#125; public final Map.Entry&lt;K,V&gt; next() &#123; Node&lt;K,V&gt; p; if ((p = next) == null) throw new NoSuchElementException(); K k = p.key; V v = p.val; lastReturned = p; advance(); return new MapEntry&lt;K,V&gt;(k, v, map); &#125;&#125; ConcurrentHashMap의 entrySet 메서드의 반환타입인 EntrySetView의 iterator 메서드의 반환타입인 EntryIterator의 next 메서드를 보면 ConcurrentModificationException을 던지지 않는 것을 볼 수 있다.즉, fail fast iterator와 달리 새로운 요소가 추가&#x2F;삭제되더라도 끝까지 모든 요소를 순회하는 것이다. ConcurrentHashMap에서 요소가 추가&#x2F;제거되더라도 ConcurrentModificationException을 던지지 않는 이유는 ConcurrentHashMap은 추가&#x2F;삭제 메서드에 synchronized 키워드를 사용하여 락을 잡은 후 다른 쓰레드에서 건드리지 못하도록 하기에 동시성으로부터 안전하기 때문이다. 12345678910111213141516171819202122232425262728293031public V remove(Object key) &#123; return replaceNode(key, null, null);&#125;final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; // ... &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null;&#125; 즉, fail safe iterator는 요소가 추가&#x2F;삭제 되더라도 ConcurrentModificationException을 던지지 않고 모든 요소를 순회할 수 있으며 동시성 이슈로부터도 안전하다(Safe). 위와 같이 syncronized로 해결하는 케이스도 있지만, CopyOnWriteArrayList처럼 원본 collection을 카피한 후 카피한 collection으로부터 iterator를 생성하여 사용하는 fail safe iterator도 있다. (원본 collection과 생성된 iterator는 무관하기 때문에 ConcurrentModificationException을 던지지 않는다.)","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Iterator","slug":"Iterator","permalink":"https://perfectacle.github.io/tags/Iterator/"},{"name":"Collection","slug":"Collection","permalink":"https://perfectacle.github.io/tags/Collection/"}]},{"title":"(JPA) Readonly 트랜잭션은 Dirty Checking을 하지 않는다","slug":"readonly-transaction-doesnt-make-entity-snapshot","date":"2021-08-08T23:29:33.000Z","updated":"2022-10-30T08:42:16.887Z","comments":true,"path":"2021/08/08/readonly-transaction-doesnt-make-entity-snapshot/","link":"","permalink":"https://perfectacle.github.io/2021/08/08/readonly-transaction-doesnt-make-entity-snapshot/","excerpt":"3줄 요약 @Transaction(readOnly &#x3D; true)로 설정하면 select 할 당시 엔티티의 스냅샷을 만들지 않는다. (JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다에서 봤다 싶이 트랜잭션이 커밋될 때 flush를 하지 않는다. flush를 할 필요가 없기 때문에 Dirty Checking을 할 필요가 없고, 그에 따라서 엔티티의 스냅샷도 만들지 않는 것이다. 엔티티 구조이해를 편하게 돕기 위해 엔티티는 아래와 같은 구조를 가진다. 12345678910@Entity@Table(name = &quot;parents&quot;)public class Parent &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long no; @Column(name = &quot;helloName&quot;) private SomeType someType;&#125;","text":"3줄 요약 @Transaction(readOnly &#x3D; true)로 설정하면 select 할 당시 엔티티의 스냅샷을 만들지 않는다. (JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다에서 봤다 싶이 트랜잭션이 커밋될 때 flush를 하지 않는다. flush를 할 필요가 없기 때문에 Dirty Checking을 할 필요가 없고, 그에 따라서 엔티티의 스냅샷도 만들지 않는 것이다. 엔티티 구조이해를 편하게 돕기 위해 엔티티는 아래와 같은 구조를 가진다. 12345678910@Entity@Table(name = &quot;parents&quot;)public class Parent &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long no; @Column(name = &quot;helloName&quot;) private SomeType someType;&#125; 1234567public class SomeType &#123; private final String helloName; public SomeType(final String helloName) &#123; this.helloName = helloName; &#125;&#125; SomeType은 JPA에서 모르는 커스텀 타입이기 때문에 컨버터를 만들어주자. 123456789101112@Converter(autoApply = true)public class SomeAttributeConverter implements AttributeConverter&lt;SomeType, String&gt; &#123; @Override public String convertToDatabaseColumn(final SomeType attribute) &#123; return attribute.getHelloName(); &#125; @Override public SomeType convertToEntityAttribute(final String dbData) &#123; return new SomeType(dbData); &#125;&#125; 테스트 편의성을 위해 convertToEntityAttribute 메서드에 브레이크 포인트를 걸고 확인해보면 편하다. Readonly 트랜잭션이 아니면 스냅샷을 만든다 (엔티티를 딥카피한다)테스트를 위해 Repository에 Readonly 트랜잭션이 아닌 findBy 메서드를 만든다.(SimpleJpaRepositroy의 findById 메서드는 readonly 트랜잭션이기 때문에 커스텀 메서드를 만들었다.) 1234public interface ParentRepository extends JpaRepository&lt;Parent, Long&gt; &#123; @Transactional Parent findByNo(final long no);&#125; 그리고 findByNo를 호출하면서 SomeAttributeConverter.convertToEntityAttribute 메서드는 몇 번 호출되는지 보자. TwoPhaseLoad.initializeEntityFromEntityEntryLoadedState 메서드가 핵심이다. 12345678910111213141516171819if ( isReallyReadOnly ) &#123; //no need to take a snapshot - this is a //performance optimization, but not really //important, except for entities with huge //mutable property values persistenceContext.setEntryStatus( entityEntry, Status.READ_ONLY );&#125;else &#123; //take a snapshot TypeHelper.deepCopy( hydratedState, persister.getPropertyTypes(), persister.getPropertyUpdateability(), //after setting values to object hydratedState, session ); persistenceContext.setEntryStatus( entityEntry, Status.MANAGED );&#125; readonly 트랜잭션이면 성능최적화를 위해 스냅샷을 만들 필요가 없다고 하고 있고, 그게 아니면 스냅샷을 만들고 있고 그 안에서 딥카피가 수행되고 있다. 여기서 핵심은 트랜잭션을 생성하지 않더라도 스냅샷(딥카피)를 만든다는 것이다. 123public interface ParentRepository extends JpaRepository&lt;Parent, Long&gt; &#123; Parent findByNo(final long no);&#125; 위와 같이 트랜잭션을 생성하지 않더라도 리드온리 트랜잭션은 아니기 때문에 else 구문을 탄다. Readonly 트랜잭션이면 스냅샷을 만들지 않는다이번에는 readonly 트랜잭션을 사용하는 SimpleJpaRepository.findById 메서드를 사용하여 스냅샷(딥카피)을 만드는지 직접 확인해보자. 1234567891011121314151617181920212223@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepositoryImplementation&lt;T, ID&gt; &#123; // ... @Override public Optional&lt;T&gt; findById(ID id) &#123; Assert.notNull(id, ID_MUST_NOT_BE_NULL); Class&lt;T&gt; domainType = getDomainClass(); if (metadata == null) &#123; return Optional.ofNullable(em.find(domainType, id)); &#125; LockModeType type = metadata.getLockModeType(); Map&lt;String, Object&gt; hints = getQueryHints().withFetchGraphs(em).asMap(); return Optional.ofNullable(type == null ? em.find(domainType, id, hints) : em.find(domainType, id, type, hints)); &#125; // ...&#125; 위에서 보다싶이 SimpleJpaRepository는 타입에 readonly 트랜잭션이 적용돼있어서 해당 어노테이션을 오버라이딩 하지 않은 모든 메서드는 readonly 트랜잭션을 사용한다는 것을 알 수 있다. 이렇듯 JPA(하이버네이트)에서는 readonly 트랜잭션이면 성능최적화를 위해 엔티티의 스냅샷(딥카피)을 만들지 않는 걸 볼 수 있다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"}]},{"title":"(JPA) persist vs merge","slug":"entity-manager-persist-vs-merge","date":"2021-06-13T04:02:52.000Z","updated":"2022-10-30T08:42:16.403Z","comments":true,"path":"2021/06/13/entity-manager-persist-vs-merge/","link":"","permalink":"https://perfectacle.github.io/2021/06/13/entity-manager-persist-vs-merge/","excerpt":"들어가기에 앞서글을 정리하다 보니 너무 깊게 파고 정리한 거 같아 글이 너무 길어져서 아무도 읽지 않을 것 같아 정리부터 해보겠습니다. 엔티티 매니저의 persist 메서드는 리턴값이 없기 때문에 원본 객체를 수정하고, merge 메서드는 리턴값이 있기 때문에 새로운 객체를 반환합니다. JpaRepository.save 호출 시 엔티티의 식별자(@Id, @EmbeddedId 어노테이션이 붙은 컬럼 등등)가 붙은 필드의 타입이 primitive type이 아닐 때는 null이거나 숫자형일 때는 0이면 새로운 엔티티라고 판단하면서 persist 메서드가 호출되고, 그게 아니면 merge 메서드가 호출됩니다. JPQL 호출 시 FlushMode가 AUTO(하이버네이트 기본 FlushMode)라 하더라도 쿼리 지연 저장소에 JPQL에서 사용하는 테이블과 관련있는 쿼리가 저장돼있지 않다면 flush를 호출하지 않습니다. JPQL 호출 시 AutoFlushEvent가 발생하면서 flush 이전에 cascade가 먼저 이뤄지는데 이 때는 PersistEvent가 발생하면서 원본 엔티티를 변경합니다. JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하고, cascade가 발생하는데 이 때 해당 엔티티에 대해 MergeEvent가 또 발생하면서 Transient 상태인 경우에는 원본 엔티티를 카피하고 카피한 객체의 값을 수정하고 연관관계가 맺어진 엔티티에서는 레퍼런스도 카피 객체로 바꿔치기 하고 있습니다. JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하는데 cascade 이후에 DirtyChecking이나 Flush가 호출되지 않습니다. 모든 트랜잭션이 끝난 이후에 커밋 이전에 FlushMode가 MANUAL이 아니고, Managed Entity가 존재하면 FlushEvent를 발생시켜서 DirtyChecking 및 Flush를 하게 됩니다. 제목은 엔티티 매니저의 persist와 merge에 대해 개념을 설명할 것처럼 적어놨지만 이해를 돕기 위해, 흥미 유발을 위해 사내에서 겪었던 문제 과정을 서술하겠습니다. 문제 상황","text":"들어가기에 앞서글을 정리하다 보니 너무 깊게 파고 정리한 거 같아 글이 너무 길어져서 아무도 읽지 않을 것 같아 정리부터 해보겠습니다. 엔티티 매니저의 persist 메서드는 리턴값이 없기 때문에 원본 객체를 수정하고, merge 메서드는 리턴값이 있기 때문에 새로운 객체를 반환합니다. JpaRepository.save 호출 시 엔티티의 식별자(@Id, @EmbeddedId 어노테이션이 붙은 컬럼 등등)가 붙은 필드의 타입이 primitive type이 아닐 때는 null이거나 숫자형일 때는 0이면 새로운 엔티티라고 판단하면서 persist 메서드가 호출되고, 그게 아니면 merge 메서드가 호출됩니다. JPQL 호출 시 FlushMode가 AUTO(하이버네이트 기본 FlushMode)라 하더라도 쿼리 지연 저장소에 JPQL에서 사용하는 테이블과 관련있는 쿼리가 저장돼있지 않다면 flush를 호출하지 않습니다. JPQL 호출 시 AutoFlushEvent가 발생하면서 flush 이전에 cascade가 먼저 이뤄지는데 이 때는 PersistEvent가 발생하면서 원본 엔티티를 변경합니다. JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하고, cascade가 발생하는데 이 때 해당 엔티티에 대해 MergeEvent가 또 발생하면서 Transient 상태인 경우에는 원본 엔티티를 카피하고 카피한 객체의 값을 수정하고 연관관계가 맺어진 엔티티에서는 레퍼런스도 카피 객체로 바꿔치기 하고 있습니다. JpaRepository.save 호출 시 엔티티가 새로운 엔티티가 아니면 MergeEvent가 발생하는데 cascade 이후에 DirtyChecking이나 Flush가 호출되지 않습니다. 모든 트랜잭션이 끝난 이후에 커밋 이전에 FlushMode가 MANUAL이 아니고, Managed Entity가 존재하면 FlushEvent를 발생시켜서 DirtyChecking 및 Flush를 하게 됩니다. 제목은 엔티티 매니저의 persist와 merge에 대해 개념을 설명할 것처럼 적어놨지만 이해를 돕기 위해, 흥미 유발을 위해 사내에서 겪었던 문제 과정을 서술하겠습니다. 문제 상황1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Entity@Table(name = &quot;mother&quot;)class Mother &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long? = null private set @OneToMany(mappedBy = &quot;mother&quot;, cascade = [CascadeType.ALL]) private val children: MutableSet&lt;Child&gt; = mutableSetOf() // 산모 보호 차원에서 최근 출산일을 기록합니다. @Column(name = &quot;recent_childbirth&quot;) var recentChildbirth: ZonedDateTime? = null private set fun born(child: Child) &#123; children.add(child) child.bornFrom(this) recentChildbirth = ZonedDateTime.now(ZoneId.of(&quot;Asia/Seoul&quot;)) &#125;&#125;@Entity@Table(name = &quot;child&quot;)class Child private constructor( @ManyToOne(fetch = FetchType.LAZY) private var mother: Mother? = null, val birthday: LocalDate = LocalDate.now()) &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) var id: Long? = null private set fun bornFrom(mother: Mother) &#123; this.mother = mother &#125; companion object &#123; // 엄마 아빠 유전자의 조합으로 인해 아이를 생성합니다. fun create(father: Father, mother: Mother): Child &#123; return Child(...) &#125; &#125;&#125; 자식을 낳는 Mother 엔티티와 Child 엔티티가 1:N 양방향 관계 매핑이 돼있는 상황입니다.그리고 Mother의 모든 Cascade(영속성 전이) Action에 대해 children에게 전파가 되도록 하였습니다. 이제 산모는 출산 예정일이 다가와 산부인과에서 출산을 시작합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 산부인과 표현이 이게 맞는지 모르겠네용~@Componentclass ObGyn( private val motherRepository: MotherRepository, // 산부인과에서 영재 양성 기관과 호적 저장소를 알고 있는 기이한 현상이지만 예제를 위해서 참아주세요! private val talentedPersonTrainingSchool: TalentedPersonTrainingSchool, private val familyRegisterRepository: FamilyRegisterRepository) &#123; // @Transactional 어노테이션을 붙인 이유는 예제를 위해 영속성 컨텍스트를 강제로 넓히기 위함이지 다른 이유는 없습니다. @Transactional fun naturalDeliveryWith(father: Father) &#123; val mother = motherRepository.findByIdOrNull(father.wifeId) ?: throw MotherNotFoundException(&quot;병원에 산모가 없습니다.&quot;) val child = Child.create(father, mother) // 엄마가 아이를 낳습니다. mother.born(child) // 아이의 부모는 아이가 태어나자마자 영재라는 삘이 와서 바로 영재 양성 기관에 등록합니다. talentedPersonTrainingSchool.register(child) // 아이가 너무 마음에 들어 바로 호적에 올려버립니다. val familyRegister = familyRegisterRepository.findByFatherId(father.id) familyRegister?.add(child) if (familyRegister != null) &#123; familyRegisterRepository.save(familyRegister) &#125; // 산모의 최근 출산일도 변경되었고, 자식도 새롭게 생성되어서 child도 같이 저장해야할 것 같지만 // 산모 객체의 children 필드는 CascadeType이 ALL이기 때문에 따로 child 객체는 저장하지 않아도 됩니다. motherRepository.save(mother) &#125;&#125;@Componentclass TalentedPersonTrainingSchool( private val talentedPersonRepository: TalentedPersonRepository) &#123; fun register(child: Child) &#123; val talentedPerson = TalentedPerson(child.id) talentedPersonRepository.save(talentedPerson) &#125;&#125; 코드가 더럽긴 하지만, 일단 코드는 잘 돌아갈 것 같습니다만…TalentedPersonTrainingSchool의 register 메서드를 호출할 때 TalentedPerson 객체에 child.id 필드에 접근합니다. save를 하기 전에 엔티티의 ID를 사용하려고 해서 문제가 발생했으니 이제 save를 먼저 호출하면 될 것 같습니다. 1234567891011@Transactionalfun naturalDeliveryWith(father: Father) &#123; // ... // child 엔티티의 id를 사용하기 전에 먼저 save를 때려줍니다. motherRepository.save(mother) talentedPersonTrainingSchool.register(child) // ...&#125; save를 먼저 호출했음에도 불구하고, child의 id가 null입니다.하지만 mother.children[0]에 있는 child에는 id가 박혀있습니다!!또한 child와 mother.children[0]의 레퍼런스가 다른 걸 보아 다른 객체로 보이는군요!! JPA 알못인 저에게는 정말 이해할 수 없는 미스테리였습니다. 원인 분석먼저 쿼리 로그를 한 번 봐봅시다.save를 가장 나중에 호출한 케이스입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// motherRepository.findByIdOrNull(father.wifeId)Hibernate: select mother0_.id as id1_4_0_, mother0_.recent_childbirth as recent_c2_4_0_ from mother mother0_ where mother0_.id=?// mother.children의 FetchType이 eager가 아니기 때문에 실제 children을 사용할 때(mother.born(child) 메서드 안에서) lazy하게 쿼리를 날립니다.Hibernate: select children0_.mother_id as mother_i3_2_0_, children0_.id as id1_2_0_, children0_.id as id1_2_1_, children0_.birthday as birthday2_2_1_, children0_.mother_id as mother_i3_2_1_ from child children0_ where children0_.mother_id=?// familyRegisterRepository.findByFatherId(father.id)는 JPQL이기 때문에 쿼리 실행 이전에 flush를 호출(hibernate의 기본 FlushMode가 AUTO이상이고 기타 등등의 사유로 인해) 해야하는지 판단하는데// mother.born(child)에 의해 mother(Managed Entity)의 children의 child(Transient Entity)에 대해서는 insert 쿼리가 날아갔습니다.// 신기한 건 mother(Managed Entity)는 변경사항(recentChildbirth 필드)이 있는데도 update 쿼리가 실행되지 않았습니다.Hibernate: insert into child (id, birthday, mother_id) values (null, ?, ?)// familyRegisterRepository.findByFatherId(father.id)Hibernate: select familyregi0_.id as id1_3_, familyregi0_.fatherId as fatherid2_3_, familyregi0_.motherId as motherid3_3_ from family_register familyregi0_ where familyregi0_.fatherId=?// motherRepository.save(mother) 이후에 바로 호출된 게 아니라 naturalDeliveryWith 메서드를 마치고 TransactionInterceptor에서 커밋하기 전에 flush를 호출했습니다.Hibernate: update mother set recent_childbirth=? where id=? Child는 왜 insert 됐는가??너무 내용이 길어서 3 줄로 요약해보면 JPQL 호출 이전에 AutoFlushEvent를 발생시키고 이벤트 핸들러인 DefaultAutoFlushEventListener 안에서 flushMightBeNeeded 메서드를 호출하는데 하이버네이트의 기본 FlushMode가 AUTO이기 때문에 true를 반환합니다. 본격적으로 flush 호출 이전에 전처리 작업(AbstractFlushingEventListener 클래스의 prepareEntityFlushes 메서드 등등)에서 영속성 컨텍스트에 있는 엔티티들에 대해 cascade를 수행합니다. 이 때 영속성 컨텍스트에 있는 Mother 엔티티의 children 프로퍼티에 대해 cascade 되면서 insert 쿼리가 호출됐습니다. child가 insert 된 이유는 flush를 호출했기 때문이 아니라 flush 이전에 cascade를 했기 때문입니다. 우선 JPQL을 호출하기 전에 child의 insert는 호출됐는데 왜 mother의 update는 호출이 되지 않은 건지 너무나 궁금했습니다. 1234567891011121314/** * detect in-memory changes, determine if the changes are to tables * named in the query and, if so, complete execution the flush */protected boolean autoFlushIfRequired(Set querySpaces) throws HibernateException &#123; checkOpen(); if ( !isTransactionInProgress() ) &#123; // do not auto-flush while outside a transaction return false; &#125; AutoFlushEvent event = new AutoFlushEvent( querySpaces, this ); fastSessionServices.eventListenerGroup_AUTO_FLUSH.fireEventOnEachListener( event, AutoFlushEventListener::onAutoFlush ); return event.isFlushRequired();&#125; 그리고 그 안에는 AutoFlushEvent를 발생시키고 있습니다.DefaultAutoFlushEventListener의 onAutoFlush 메서드를 이벤트 리스너로 등록하고 있습니다. 123456789101112public void onAutoFlush(AutoFlushEvent event) throws HibernateException &#123; final EventSource source = event.getSession(); final SessionEventListenerManager eventListenerManager = source.getEventListenerManager(); try &#123; eventListenerManager.partialFlushStart(); if ( flushMightBeNeeded( source ) ) &#123; // ... &#125; // ... &#125;&#125; onAutoFlush 메서드에서는 flush가 필요한지 확인하고 있는데 12345678910111213141516171819202122protected void flushEverythingToExecutions(FlushEvent event) throws HibernateException &#123; LOG.trace( &quot;Flushing session&quot; ); EventSource session = event.getSession(); final PersistenceContext persistenceContext = session.getPersistenceContextInternal(); session.getInterceptor().preFlush( persistenceContext.managedEntitiesIterator() ); prepareEntityFlushes( session, persistenceContext ); // we could move this inside if we wanted to // tolerate collection initializations during // collection dirty checking: prepareCollectionFlushes( persistenceContext ); // now, any collections that are initialized // inside this block do not get updated - they // are ignored until the next flush persistenceContext.setFlushing( true ); try &#123; int entityCount = flushEntities( event, persistenceContext ); int collectionCount = flushCollections( session, persistenceContext ); flushEverythingToExecutions를 보면 prepareEntityFlushes, prepareCollectionFlushes를 통해 플러시 전처리를 하고,flushEntities, flushCollections 메서드를 통해 실제로 플러시를 하는 것 같습니다. 이제 prepareEntityFlushes 메서드를 딥다이브 해봅시다. 현재 영속성 컨텍스트에 엔티티는 Mother(#1) 엔티티 하나 뿐이고, flush 하기 전에 엔티티에 대해서 영속성 전이시키는 걸 볼 수 있습니다. 참고로 getCascadingAction()의 결과는 ACTION_PERSIST_ON_FLUSH입니다. Mother는 왜 update 되지 않았는가?이것도 내용이 길어서 3줄 요악 해보겠습니다. AbstractFlushingEventListener 클래스의 flushEntities 메서드에서는 flush 호출 이전에 영속성 컨텍스트에 있는 엔티티에 대해 Dirty Checking이 발생하고, 쿼리 지연 저장소(ActionQueue)에 EntityUpdateAction을 추가합니다. DefaultAutoFlushEventListener 클래스의 flushIsReallyNeeded 메서드에서는 하이버네이트의 기본 FlushMode가 ALWAYS가 아니고(하이버네이트 기본은 FlushMode.AUTO임), AutoFlushEvent의 querySpaces([family_register])가 쿼리 지연 저장소(ActionQueue)에 있는 액션(EntityUpdateAction)과 관련 없는 테이블(mother)이기 때문에 false를 반환합니다. 힘겹게 쿼리 지연 저장소에 다 밀어넣었건만 flushIsReallyNeeded가 false이면 결국 flush는 호출되지 않습니다. 결국 Mother의 변경내역은 쿼리 지연 저장소에 저장됐지만 현재 JPQL에서 사용하는 family_register와 상관 없는 테이블인 mother이므로 flush가 호출되지 않습니다. 이제 엔티티를 flush할 준비(prepareEntityFlushes 메서드)가 끝났으니 다음 부분(flushEntities 메서드)을 딥다이브 해봅시다. 1234567891011121314151617181920protected final boolean isUpdateNecessary(FlushEntityEvent event) throws HibernateException &#123; EntityPersister persister = event.getEntityEntry().getPersister(); Status status = event.getEntityEntry().getStatus(); if ( !event.isDirtyCheckPossible() ) &#123; return true; &#125; else &#123; int[] dirtyProperties = event.getDirtyProperties(); if ( dirtyProperties != null &amp;&amp; dirtyProperties.length != 0 ) &#123; return true; //TODO: suck into event class &#125; else &#123; return hasDirtyCollections( event, persister, status ); &#125; &#125;&#125; DefaultFlushEntityEventListener의 isUpdateNecessary 메서드에서 dirtyProperties 유무에 따라 업데이트가 필요한지 판단하고 있는데 하나가 있기 때문에 true를 반환합니다. 123456789101112131415161718192021public void onFlushEntity(FlushEntityEvent event) throws HibernateException &#123; final Object entity = event.getEntity(); final EntityEntry entry = event.getEntityEntry(); final EventSource session = event.getSession(); final EntityPersister persister = entry.getPersister(); final Status status = entry.getStatus(); final Type[] types = persister.getPropertyTypes(); final boolean mightBeDirty = entry.requiresDirtyCheck( entity ); final Object[] values = getValues( entity, entry, mightBeDirty, session ); event.setPropertyValues( values ); //TODO: avoid this for non-new instances where mightBeDirty==false boolean substitute = wrapCollections( session, persister, entity, entry.getId(), types, values ); if ( isUpdateNecessary( event, mightBeDirty ) ) &#123; substitute = scheduleUpdate( event ) || substitute; &#125; isUpdateNecessary가 true이기 때문에 scheduleUpdate 메서드가 호출되는데 이름만 봐도 바로 지연 저장소에 저장할 거 같은 메서드네요. 하지만 여기까지 왔다고 해서 flush가 정말로 되는 건 아닙니다. 12345678910111213public void onAutoFlush(AutoFlushEvent event) throws HibernateException &#123; final EventSource source = event.getSession(); final SessionEventListenerManager eventListenerManager = source.getEventListenerManager(); try &#123; eventListenerManager.partialFlushStart(); if ( flushMightBeNeeded( source ) ) &#123; // Need to get the number of collection removals before flushing to executions // (because flushing to executions can add collection removal actions to the action queue). final ActionQueue actionQueue = source.getActionQueue(); final int oldSize = actionQueue.numberOfCollectionRemovals(); flushEverythingToExecutions( event ); if ( flushIsReallyNeeded( event, source ) ) &#123; flushMightBeNeeded에서 ‘flush가 필요할지도 몰라’ 정도까지만 판단을 하고, flushIsReallyNeeded에서 ‘정말로 flush가 필요한가?’에 대한 검토를 또 하고 있네요.(지금까지 우리는 flushEverythingToExecutions에 대해 딥다이브를 마쳤습니다.) 해당 액션이 family_register 테이블과 관련이 있는지 확인하고 있습니다. 관련이 없기 때문에 false를 반환합니다. JPQL 호출 시 flush를 무조건 호출하는 줄 알았는데 쿼리 지연 저장소에 생긴 쿼리의 테이블과 관련이 있다는 사실도 참 신기하네요. (어찌보면 쿼리를 날릴 필요가 없으면 안 날리는 게 최적화 측면에서는 당연해보이긴 하네요.) motherRepository.save(mother)는 왜 아무런 쿼리도 호출하지 않는가?이것도 내용이 길어서 3줄 요악 해보겠습니다. mother가 새로운 엔티티는 아니기 때문에 entityManager.merge(mother)가 호출되고, Merge 이벤트를 발생시킵니다. Merge 이벤트의 핸들러인 DefaultMergeEventListener 클래스의 onMerge 메서드에서는 엔티티의 상태가 Persistent이므로 entityIsPersistent 메서드가 호출되는데 cascade는 이전(JPQL 호출 시)에 진작 끝냈기 때문에 아무런 쿼리가 호출되지 않습니다. 최상단 트랜잭션(obGyn.naturalDeliveryWith 메서드)이 끝나지 않아 commit을 호출하지 않았기 때문에 flush도 호출되지 않았습니다. 새로운 엔티티냐, 아니냐에 따라 persist vs merge 메서드를 호출하는데 123456789101112131415public boolean isNew(T entity) &#123; ID id = getId(entity); Class&lt;ID&gt; idType = getIdType(); if (!idType.isPrimitive()) &#123; return id == null; &#125; if (id instanceof Number) &#123; return ((Number) id).longValue() == 0L; &#125; throw new IllegalArgumentException(String.format(&quot;Unsupported primitive id type %s!&quot;, idType));&#125; AbstractEntityInformation 클래스의 isNew 메서드를 보면 primitive 타입이 아니면 null이거나 Number 타입이면 0인 경우에만 새로운 엔티티라고 취급하고 있습니다.근데 Mother는 id에 값이 있기 때문에 새로운 엔티티가 아니라서 EntityManager의 merge 메서드가 호출됩니다. 왜 부모 트랜잭션이 끝난 이후에 mother의 update 쿼리가 날아갔을까?여기도 3줄 요약해보겠습니다. 트랜잭션이 모두 끝나고 커밋하기 이전에 flush를 해야하는지 FlushMode를 확인합니다. FlushMode가 MANUAL이 아니기 때문에 엔티티매니저에 대해 FlushEvent가 발생합니다. FlushEvent가 발생하면 DirtyChecking 및 쿼리 지연 저장소에 저장한 후에 flush가 이루어집니다. motherRepository.save(mother)에서는 아무런 메서드가 날아가지 않고, 부모 트랜잭션(obGyn.naturalDeliveryWith 메서드)이 끝날 때 무슨 코드 때문에 쿼리를 호출하는 건지도 궁금해졌습니다. 12345678910111213public void flushBeforeTransactionCompletion() &#123; final boolean doFlush = isTransactionFlushable() &amp;&amp; getHibernateFlushMode() != FlushMode.MANUAL; try &#123; if ( doFlush ) &#123; managedFlush(); &#125; &#125; catch (RuntimeException re) &#123; throw ExceptionMapperStandardImpl.INSTANCE.mapManagedFlushFailure( &quot;error during managed flush&quot;, re, this ); &#125;&#125; 하이버네이트의 기본 FlushMode는 AUTO이기 때문에 doFlush가 true이고, managedFlush 메서드를 호출하게 됩니다. FlushEvent의 이벤트 리스너 안에서 Managed Entity가 존재하므로 if 문 안을 보면, flushEverythingToExecutions을 호출하는데 이 때 Dirty Checking과 쿼리 지연 저장소에 저장이 이루어집니다.그리고 performExecutions 안에서 실제 쿼리 지연 저장소에 있는 내용에 대해 flush가 호출됩니다. motherRepository.save(mother)를 먼저 수행했을 때 child의 레퍼런스는 왜 바뀌었을까?여기도 너무 길어서 4줄 요약해보자면 mother가 새로운 엔티티는 아니기 때문에 entityManager.merge(mother)가 호출되고, mother 엔티티에 대해 Merge 이벤트를 발생시킵니다. Merge 이벤트의 핸들러인 DefaultMergeEventListener 클래스의 onMerge 메서드에서는 Managed Entity에 대해서 cascade가 발생하는데 child 엔티티에 대해서도 Merge 이벤트를 발생시킵니다. DefaultMergeEventListener 클래스의 onMerge 메서드에서는 Transient 상태인 child 엔티티에 대해서 카피본을 뜨고 카피에다가만 id를 할당한 후에 MergeContext 캐시에 entity를 key로, copy를 value로 할당하고 있습니다. mother 엔티티의 Merge 이벤트에서는 cascade가 전부 끝난 이후에 프로퍼티에 값 재할당이 일어나는데 이 때 children을 전부 비우고 copy로 채워넣으면서 레퍼런스가 바뀌게 됩니다. 12345678910111213141516171819202122232425262728293031@Componentclass ObGyn( private val motherRepository: MotherRepository, // 산부인과에서 영재 양성 기관과 호적 저장소를 알고 있는 기이한 현상이지만 예제를 위해서 참아주세요! private val talentedPersonTrainingSchool: TalentedPersonTrainingSchool, private val familyRegisterRepository: FamilyRegisterRepository) &#123; // @Transactional 어노테이션을 붙인 이유는 예제를 위해 영속성 컨텍스트를 강제로 넓히기 위함이지 다른 이유는 없습니다. @Transactional fun naturalDeliveryWith(father: Father) &#123; val mother = motherRepository.findByIdOrNull(father.wifeId) ?: throw MotherNotFoundException(&quot;병원에 산모가 없습니다.&quot;) val child = Child.create(father, mother) // 엄마가 아이를 낳습니다. mother.born(child) // child의 id를 먼저 설정하고 사용하기 위해 save를 먼저 호출 motherRepository.save(mother) // 아이의 부모는 아이가 태어나자마자 영재라는 삘이 와서 바로 영재 양성 기관에 등록합니다. talentedPersonTrainingSchool.register(child) // 아이가 너무 마음에 들어 바로 호적에 올려버립니다. val familyRegister = familyRegisterRepository.findByFatherId(father.id) familyRegister?.add(child) if (familyRegister != null) &#123; familyRegisterRepository.save(familyRegister) &#125; &#125;&#125; 여기가 핵심입니다.이전에 JPQL 호출 시 AutoFlushEvent의 이벤트 리스너에서는 ACTION_PERSIST_ON_FLUSH CascadingActions의 cascade를 호출하면서 Child 엔티티에 대해 PersistEvent를 발생시켰는데,motherRepository.save 호출 시 MergeEvent의 이벤트 리스너에서는 ACTION_MERGE인 CascadingActions의 cascade를 호출하면서 Child 엔티티에 대해 MergeEvent를 발생시키고 있습니다.그럼 PersistEvent와 MergeEvent의 차이점을 알아봅시다. 또 결정적 차이가 여기서 나옵니다.PersistEvent의 이벤트 리스너인 DefaultPersistEventListener 클래스의 onPersist 메서드에서 호출하는 DefaultPersistEventListener 클래스의 entityIsTransient 메서드에서는 entity에 대해 카피를 뜬 적이 없습니다.하지만 MergeEvent의 이벤트 리스너인 DefaultMergeEventListener 클래스의 onMerge 메서드에서 호출하는 DefaultMergeEventListener 클래스의 entityIsTransient 메서드에서는 entity에 대해 카피를 뜨고 있습니다.카피 뜰 때 default constructor가 없으면 아마도 org.hibernate.InstantiationException: No default constructor for entity 요런 예외를 던지지 않을까 싶네요.기본 생성자를 호출했기 때문에 아직 값은 카피되지 않고 객체 생성까지만 된 상태입니다.그리고 copyCache라는 MergeContext에 entity를 key로, copy를 value로 해서 넣고 있습니다. 그리고 saveTransientEntity 메서드에서 실질적인 insert가 이루어지는데 entity를 넘기는 게 아니라 copy를 넘기고 있습니다. 이렇게 copy를 뜨고, copy에만 id를 할당하고, collection을 비운 후 copy로 채우기 때문에 외부 변수는 여전히 id가 null인 상태로 남게 됩니다. 여담으로 child가 Transient 상태이기 때문에 카피를 뜨고 카피로 레퍼런스를 바꾸고 했는데, 이미 Persistent 상태인 child였다면 카피를 뜨지 않아 레퍼런스를 바꾸지 않습니다. Persist vs Merge이제 진짜 하고 싶었던 핵심인 엔티티 매니저의 persist와 merge 메서드에 대해 이야기 해보겠습니다. 123456789101112131415161718192021222324252627282930313233public interface EntityManager &#123; /** * Make an instance managed and persistent. * @param entity entity instance * @throws EntityExistsException if the entity already exists. * (If the entity already exists, the &lt;code&gt;EntityExistsException&lt;/code&gt; may * be thrown when the persist operation is invoked, or the * &lt;code&gt;EntityExistsException&lt;/code&gt; or another &lt;code&gt;PersistenceException&lt;/code&gt; may be * thrown at flush or commit time.) * @throws IllegalArgumentException if the instance is not an * entity * @throws TransactionRequiredException if there is no transaction when * invoked on a container-managed entity manager of that is of type * &lt;code&gt;PersistenceContextType.TRANSACTION&lt;/code&gt; */ public void persist(Object entity); /** * Merge the state of the given entity into the * current persistence context. * @param entity entity instance * @return the managed instance that the state was merged to * @throws IllegalArgumentException if instance is not an * entity or is a removed entity * @throws TransactionRequiredException if there is no transaction when * invoked on a container-managed entity manager of that is of type * &lt;code&gt;PersistenceContextType.TRANSACTION&lt;/code&gt; */ public &lt;T&gt; T merge(T entity); // ...&#125; 별 건 없고, persist는 return 타입이 없고, merge는 있는 게 가장 큰 차이입니다.어디서 봤는데 return 타입이 없으면 원본 객체를 수정하고, return type이 있으면 새로운 객체를 반환하는 게 뭐 뭘 분리해서 좋은 패턴이다~라는 걸 본 거 같은데 아시는 분 있으면 댓글 남겨주시면 감사하겠습니다. 여튼 위에서 말했듯 그런 패턴을 지킨 걸로 보입니다.persists는 return 타입이 없는데 id는 할당해야하니 당연히 새로운 객체를 만들 수는 없고 원본 객체를 수정할테고,merge는 return 타입이 있는 걸로 보아 원본 객체는 수정하지 않고, id가 할당된 새 객체를 반환하는 걸로 보입니다. persist와 merge에 대해 이해하면 위에서 있었던 PersistEvent와 MergeEvent가 왜 그렇게 동작했는지 이해할 수 있게 됩니다.JPQL 호출 시 cascade가 이루어질 때는 PersistEvent가 발생하기 때문에 persist 메서드의 특성을 생각해보면 원본 객체에 id가 할당됐던 것이 당연한 게 됩니다.그리고 save 호출 시 cascade가 이루어질 때는 새로운 엔티티가 아니라서 MergeEvent가 발생했기 때문에 merge 메서드의 특성을 생각해보면 새로운 객체를 반환하고, 레퍼런스도 바꿔치는 게 당연한 게 됩니다. 그럼 persist와 merge에 대한 간단한 예제를 보시면 이해하시는 데 더 도움이 될 것 같습니다. 12345678910111213141516171819@Testfun `새로운 엔티티라면 persist가 호출되면서 원본 엔티티를 반환하고, 새로운 엔티티가 아니면 merge가 호출되면서 새로운 엔티티 객체를 반환한다`() &#123; val mother = Mother() val persistedMother = motherRepository.save(mother) persistedMother shouldBeSameInstanceAs mother val newMother = Mother(2L) val mergedNewMother = motherRepository.save(newMother) mergedNewMother.id shouldBe 2L mergedNewMother shouldNotBeSameInstanceAs newMother val mergedMergedNewMother = motherRepository.save(mergedNewMother) mergedMergedNewMother.id shouldBe 2L mergedMergedNewMother shouldNotBeSameInstanceAs mergedNewMother mergedMergedNewMother shouldNotBeSameInstanceAs newMother&#125; 푸념단순히 save 메서드의 위치를 바꿨다고 해서 이렇게까지 동작이 달라질 줄은 몰랐습니다.복잡한 연관관계(CascadeAction 등등)와 JPQL이 어느 타이밍에 호출되는데 엔티티는 현재 어떤 상태인지 등등을 고려해가면서 코드를 짜야하니 예측성이 너무 떨어지는 것 같습니다.엔티티를 객체-테이블 매핑 이상의 역할인 도메인(비즈니스 로직을 담은) 객체로 사용하고, 역할에 맞게 객체를 덜 쪼갰기 때문에 요런 문제가 발생하긴 했지만…이제 JPA가 그렇게 좋은지 모르겠네요… 예측성이 너무 떨어지고, 알아야할 게 너무 많은 거 같습니다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://perfectacle.github.io/tags/Spring-Data-JPA/"}]},{"title":"(JPA) 엔티티 매니저는 리퀘스트 당 하나만 생성되지 않을 수 있다.","slug":"entity-manager-lifecycle","date":"2021-05-24T04:44:56.000Z","updated":"2022-10-30T08:42:16.403Z","comments":true,"path":"2021/05/24/entity-manager-lifecycle/","link":"","permalink":"https://perfectacle.github.io/2021/05/24/entity-manager-lifecycle/","excerpt":"3줄 요약 OSIV가 꺼져있으면 트랜잭션이 시작될 때 엔티티 매니저가 생성되고, 트랜잭션이 끝날 때 엔티티 매니저를 종료한다. OSIV가 꺼져있고, 다른 트랜잭션이라면 엔티티 매니저가 공유되지 않기 때문에 엔티티 매니저의 1차 캐시도 서로 공유되지 않는다. OSIV가 켜져있으면 요청 당 엔티티 매니저는 한 번 생성되고, 뷰 렌더링이 끝날 때까지 엔티티 매니저는 종료되지 않고 트랜잭션이 다르더라도 1차 캐시가 공유된다. 들어가기에 앞서엔티티 매니저 팩토리는 생성 비용이 비싸서 대부분 어플리케이션 당 하나를 생성하는 편이고, 엔티티 매니저는 생성 비용이 비싸지 않아서 어플리케이션에서 여러 번 생성된다.하지만 엔티티 매니저는 쓰레드 세이프 하지 않기 때문에, 쓰레드 당 하나를 생성해야할 것 같고 Spring MVC는 리퀘스트 당 하나의 쓰레드가 할당되기 때문에 리퀘스트 당 하나의 엔티티 매니저가 생성될 것만 같은 기분이 든다.나 또한 그렇게 알고 있었는데 아래 코드를 통해 뭔가 의문이 생겼다. 1234567891011interface SomeRepository : JpaRepository&lt;SomeEntity, Long&gt;@Serviceclass SomeService( private val repository: SomeRepository) &#123; fun some() &#123; val someEntity = repository.findById(1L) val someEntity2 = repository.findById(1L) &#125;&#125;","text":"3줄 요약 OSIV가 꺼져있으면 트랜잭션이 시작될 때 엔티티 매니저가 생성되고, 트랜잭션이 끝날 때 엔티티 매니저를 종료한다. OSIV가 꺼져있고, 다른 트랜잭션이라면 엔티티 매니저가 공유되지 않기 때문에 엔티티 매니저의 1차 캐시도 서로 공유되지 않는다. OSIV가 켜져있으면 요청 당 엔티티 매니저는 한 번 생성되고, 뷰 렌더링이 끝날 때까지 엔티티 매니저는 종료되지 않고 트랜잭션이 다르더라도 1차 캐시가 공유된다. 들어가기에 앞서엔티티 매니저 팩토리는 생성 비용이 비싸서 대부분 어플리케이션 당 하나를 생성하는 편이고, 엔티티 매니저는 생성 비용이 비싸지 않아서 어플리케이션에서 여러 번 생성된다.하지만 엔티티 매니저는 쓰레드 세이프 하지 않기 때문에, 쓰레드 당 하나를 생성해야할 것 같고 Spring MVC는 리퀘스트 당 하나의 쓰레드가 할당되기 때문에 리퀘스트 당 하나의 엔티티 매니저가 생성될 것만 같은 기분이 든다.나 또한 그렇게 알고 있었는데 아래 코드를 통해 뭔가 의문이 생겼다. 1234567891011interface SomeRepository : JpaRepository&lt;SomeEntity, Long&gt;@Serviceclass SomeService( private val repository: SomeRepository) &#123; fun some() &#123; val someEntity = repository.findById(1L) val someEntity2 = repository.findById(1L) &#125;&#125; 위 코드를 보면 select 쿼리는 몇 번 날아갈 것 같은가??첫 라인에서는 엔티티 매니저의 1차 캐시에 아무것도 없어서 쿼리가 날아갈 것 같고, 두 번째 라인에서는 엔티티 매니저의 1차 캐시에 id가 1인 SomeEntity가 있을 것 같으니 쿼리가 안 날아갈 것 같지 않은가?답은 spring.jpa.open-in-view: false로 OSIV 설정이 꺼져있으면 두 번 날아가고, OSIV 설정을 따로 건드리지 않았다면 기본적으로 켜져있을테니 한 번만 날아가게 된다. 먼저 알아둬야할 사항은 JpaRepository 인터페이스의 기본 구현체인 SimpleJpaRepository에 대해 알아야한다.우리가 만든 인터페이스 SomeRepository도 결국 실행될 때는 객체화 돼야하는데 이 때 JpaRepository 구현체인 SimpleJpaRepository를 상속받아서 구현되기 때문이다. 1234567891011121314151617181920212223@Repository@Transactional(readOnly = true)public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepositoryImplementation&lt;T, ID&gt; &#123; // ... @Override public Optional&lt;T&gt; findById(ID id) &#123; Assert.notNull(id, ID_MUST_NOT_BE_NULL); Class&lt;T&gt; domainType = getDomainClass(); if (metadata == null) &#123; return Optional.ofNullable(em.find(domainType, id)); &#125; LockModeType type = metadata.getLockModeType(); Map&lt;String, Object&gt; hints = getQueryHints().withFetchGraphs(em).asMap(); return Optional.ofNullable(type == null ? em.find(domainType, id, hints) : em.find(domainType, id, type, hints)); &#125; // ...&#125; 우리가 만든 repository의 findById 메서드를 호출하면 기본적으로 SimpleJpaRepository의 findById 메서드를 호출하게 되고, readOnly 트랜잭션 안에서 실행된다고 보면 된다. OSIV가 꺼졌을 때엔티티 매니저 생성 TransactionInterceptor의 invoke 메서드에서 부모 클래스인 TransactionAspectSupport의 invokeWithinTransaction 메서드를 호출한다. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 createTransactionIfNecessary 메서드를 호출한다. createTransactionIfNecessary 메서드에서 AbstractPlatformTransactionManager의 getTransaction 메서드를 호출한다. AbstractPlatformTransactionManager의 getTransaction 메서드에서 JpaTransactionManager의 doGetTransaction 메서드를 호출한다. 123456789@Overrideprotected Object doGetTransaction() &#123; JpaTransactionObject txObject = new JpaTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()); // ...&#125; 엔티티 매니저 팩토리를 가져온 후에 TransactionSynchronizationManager의 getResource 메서드를 호출하고 있다. TransactionSynchronizationManager의 getResource 메서드에서 doGetResource 메서드를 호출하고 있다. 123456789101112131415161718@Nullableprivate static Object doGetResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.get(actualKey); // Transparently remove ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value;&#125; actualKey는 엔티티 매니저 팩토리이고, resources는 ThreadLocal Map 객체란 걸 알 수 있다. 12345public abstract class TransactionSynchronizationManager &#123; // ... private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;); // ... 하지만 해당 쓰레드에서는 한 번도 엔티티 매니저 팩토리를 키로 맵에 값을 넣은 적이 없기 때문에 null을 반환하게 된다. 다시 JpaTransactionManager의 doGetTransaction 메서드로 돌아와보자. 12345678910111213141516171819@Overrideprotected Object doGetTransaction() &#123; JpaTransactionObject txObject = new JpaTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()); if (emHolder != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found thread-bound EntityManager [&quot; + emHolder.getEntityManager() + &quot;] for JPA transaction&quot;); &#125; txObject.setEntityManagerHolder(emHolder, false); &#125; // ... return txObject;&#125; TransactionSynchronizationManager.getResource(obtainEntityManagerFactory())가 null을 반환하기 때문에 txObject는 entityManagerHolder를 초기화하지 못한다. 123456789public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // ... if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. return handleExistingTransaction(def, transaction, debugEnabled); &#125; // ...&#125; 다시 AbstractPlatformTransactionManager의 getTransaction 메서드로 돌아오면 JpaTransactionManager의 isExistingTransaction 메서드를 호출한다. JpaTransactionManager의 isExistingTransaction 메서드에서 JpaTransactionObject의 hasTransaction 매서드를 호출한다.123public boolean hasTransaction() &#123; return (this.entityManagerHolder != null &amp;&amp; this.entityManagerHolder.isTransactionActive());&#125; entityManagerHolder는 null이기 때문에 hasTransaction은 false이고 isExistingTransaction 메서드도 false이다. 다시 AbstractPlatformTransactionManager의 getTransaction 메서드로 돌아와보자. 12345678910111213141516171819202122232425@Overridepublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // ... // No existing transaction found -&gt; check propagation behavior to find out how to proceed. if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123; throw new IllegalTransactionStateException( &quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;); &#125; else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) &#123; logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def); &#125; try &#123; return startTransaction(def, transaction, debugEnabled, suspendedResources); &#125; catch (RuntimeException | Error ex) &#123; resume(null, suspendedResources); throw ex; &#125; &#125;&#125; @Transactional의 기본 propagation 설정은 PROPAGATION_REQUIRED이기 때문에 startTransaction 메서드를 호출한다. 123456789101112131415161718192021private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction, boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status;&#125;protected DefaultTransactionStatus newTransactionStatus( TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) &#123; boolean actualNewSynchronization = newSynchronization &amp;&amp; !TransactionSynchronizationManager.isSynchronizationActive(); return new DefaultTransactionStatus( transaction, newTransaction, actualNewSynchronization, definition.isReadOnly(), debug, suspendedResources);&#125; 새롭게 트랜잭션을 시작하는 것이기 때문에 TransactionStatus를 만들 때 newTransaction을 true로 만든다.그리고나서 JpaTransactionManager의 doBegin 메서드를 호출한다. 123456789101112131415161718192021222324protected void doBegin(Object transaction, TransactionDefinition definition) &#123; JpaTransactionObject txObject = (JpaTransactionObject) transaction; // ... try &#123; if (!txObject.hasEntityManagerHolder() || txObject.getEntityManagerHolder().isSynchronizedWithTransaction()) &#123; EntityManager newEm = createEntityManagerForTransaction(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Opened new EntityManager [&quot; + newEm + &quot;] for JPA transaction&quot;); &#125; txObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true); &#125; // ... // Bind the entity manager holder to the thread. if (txObject.isNewEntityManagerHolder()) &#123; TransactionSynchronizationManager.bindResource( obtainEntityManagerFactory(), txObject.getEntityManagerHolder()); &#125; // ... &#125; // ...&#125; 위에서 봤다싶이 EntityManagerHolder를 초기화하지 못했기 때문에 위 if문을 타고 createEntityManagerForTransaction 메서드를 호출하여 엔티티 매니저를 생성하고 JpaTransactionObject의 setEntityManagerHolder 메서드를 호출하고 있다. 123456public void setEntityManagerHolder( @Nullable EntityManagerHolder entityManagerHolder, boolean newEntityManagerHolder) &#123; this.entityManagerHolder = entityManagerHolder; this.newEntityManagerHolder = newEntityManagerHolder;&#125; 엔티티 매니저 홀더를 초기화하는 것과 더불어 새로운 엔티티 매니저 홀더라고 마킹까지 하고 있다.그리고 새로운 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true이고, TransactionSynchronizationManager의 bindResource 메서드를 호출하고 있다. 123456789101112131415161718192021222324252627282930/** * Bind the given resource for the given key to the current thread. * @param key the key to bind the value to (usually the resource factory) * @param value the value to bind (usually the active resource object) * @throws IllegalStateException if there is already a value bound to the thread * @see ResourceTransactionManager#getResourceFactory() */public static void bindResource(Object key, Object value) throws IllegalStateException &#123; Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key); Assert.notNull(value, &quot;Value must not be null&quot;); Map&lt;Object, Object&gt; map = resources.get(); // set ThreadLocal Map if none found if (map == null) &#123; map = new HashMap&lt;&gt;(); resources.set(map); &#125; Object oldValue = map.put(actualKey, value); // Transparently suppress a ResourceHolder that was marked as void... if (oldValue instanceof ResourceHolder &amp;&amp; ((ResourceHolder) oldValue).isVoid()) &#123; oldValue = null; &#125; if (oldValue != null) &#123; throw new IllegalStateException(&quot;Already value [&quot; + oldValue + &quot;] for key [&quot; + actualKey + &quot;] bound to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Bound value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] to thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125;&#125; 쓰레드 로컬 맵인 resources에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣고 있다. 이렇게 트랜잭션이 시작할 때 엔티티 매니저가 생성된다는 것을 알 수 있다. 엔티티 매니저 종료다시 TransactionAspectSupport의 invokeWithinTransaction 메서드로 돌아오자. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 commitTransactionAfterReturning 메서드를 호출하고 있다. commitTransactionAfterReturning 메서드에서 AbstractPlatformTransactionManager의 commit 메서드를 호출하고 있다. AbstractPlatformTransactionManager의 commit 메서드에서 processCommit 메서드를 호출하고 있다. processCommit 메서드에서 cleanupAfterCompletion 메서드를 호출하고 있다.12345678910private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123; status.setCompleted(); if (status.isNewSynchronization()) &#123; TransactionSynchronizationManager.clear(); &#125; if (status.isNewTransaction()) &#123; doCleanupAfterCompletion(status.getTransaction()); &#125; // ...&#125; 새롭게 만든 트랜잭션이기 때문에 status.isNewTransaction()은 true이고, JpaTransactionManager의 doCleanupAfterCompletion 메서드를 호출한다. 1234567891011protected void doCleanupAfterCompletion(Object transaction) &#123; JpaTransactionObject txObject = (JpaTransactionObject) transaction; // Remove the entity manager holder from the thread, if still there. // (Could have been removed by EntityManagerFactoryUtils in order // to replace it with an unsynchronized EntityManager). if (txObject.isNewEntityManagerHolder()) &#123; TransactionSynchronizationManager.unbindResourceIfPossible(obtainEntityManagerFactory()); &#125; // ...&#125; 엔티티 매니저 홀더를 설정할 때도 새 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true라서 TransactionSynchronizationManager의 unbindResourceIfPossible 메서드를 호출한다.그 다음에 doUnbindResource 메서드를 호출하고 있다. 1234567891011121314151617181920private static Object doUnbindResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; // Transparently suppress a ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; value = null; &#125; if (value != null &amp;&amp; logger.isTraceEnabled()) &#123; logger.trace(&quot;Removed value [&quot; + value + &quot;] for key [&quot; + actualKey + &quot;] from thread [&quot; + Thread.currentThread().getName() + &quot;]&quot;); &#125; return value;&#125; resources는 쓰레드 로컬 맵이고, 이전에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣었기 때문에 해당 키는 삭제된다. 그리고 다시 JpaTransactionManager의 doCleanupAfterCompletion 메서드를 마저 보자. 123456789101112131415protected void doCleanupAfterCompletion(Object transaction) &#123; JpaTransactionObject txObject = (JpaTransactionObject) transaction; // ... // Remove the entity manager holder from the thread. if (txObject.isNewEntityManagerHolder()) &#123; EntityManager em = txObject.getEntityManagerHolder().getEntityManager(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Closing JPA EntityManager [&quot; + em + &quot;] after transaction&quot;); &#125; EntityManagerFactoryUtils.closeEntityManager(em); &#125; else &#123; logger.debug(&quot;Not closing pre-bound JPA EntityManager after transaction&quot;); &#125;&#125; JpaTransactionObject을 만들 때 새로운 엔티티 매니저 홀더라고 마킹했기 때문에 txObject.isNewEntityManagerHolder()는 true이고, EntityManagerFactoryUtils의 closeEntityManager 메서드를 호출한다. 123456789101112131415161718/** * Close the given JPA EntityManager, * catching and logging any cleanup exceptions thrown. * @param em the JPA EntityManager to close (may be &#123;@code null&#125;) * @see javax.persistence.EntityManager#close() */public static void closeEntityManager(@Nullable EntityManager em) &#123; if (em != null) &#123; try &#123; if (em.isOpen()) &#123; em.close(); &#125; &#125; catch (Throwable ex) &#123; logger.error(&quot;Failed to release JPA EntityManager&quot;, ex); &#125; &#125;&#125; 이렇게 트랜잭션이 끝날 때 엔티티 매니저가 종료된다는 것을 알게 되었다. 부모 트랜잭션을 사용한다면…?만약 트랜잭션이 부모의 것을 사용하여 쭉 이어진다면 어떻게 될까…? 12345678910@Service@Transactionalclass SomeService( private val repository: SomeRepository) &#123; fun some() &#123; val someEntity = repository.findById(1L) val someEntity2 = repository.findById(1L) &#125;&#125; SimpleJpaRepository의 findById(자식)가 SomeService(부모)의 트랜잭션을 사용한다면 어떻게 될까…?먼저 SomeService 진입 시 새로운 트랜잭션이 생성(엔티티 매니저도 생성)되는 건 생략하고 그 이후 과정부터 지켜보자. TransactionInterceptor의 invoke 메서드에서 부모 클래스인 TransactionAspectSupport의 invokeWithinTransaction 메서드를 호출한다. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 createTransactionIfNecessary 메서드를 호출한다. createTransactionIfNecessary 메서드에서 AbstractPlatformTransactionManager의 getTransaction 메서드를 호출한다. AbstractPlatformTransactionManager의 getTransaction 메서드에서 JpaTransactionManager의 doGetTransaction 메서드를 호출한다.12345678910111213141516171819@Overrideprotected Object doGetTransaction() &#123; JpaTransactionObject txObject = new JpaTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()); if (emHolder != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found thread-bound EntityManager [&quot; + emHolder.getEntityManager() + &quot;] for JPA transaction&quot;); &#125; txObject.setEntityManagerHolder(emHolder, false); &#125; // ... return txObject;&#125; 이미 부모 트랜잭션에서 TransactionSynchronizationManager.bindResource 메서드를 호출했기 때문에 TransactionSynchronizationManager.getResource는 null이 아니다.따라서 txObject에 emHolder를 초기화할 수 있는데, 부모 트랜잭션에서 만들어둔 엔티티 매니저 홀더이기 때문에 새로운 엔티티 매니저 홀더가 아니라고 마킹한다. 123456789101112131415public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // Use defaults if no transaction definition given. TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults()); Object transaction = doGetTransaction(); boolean debugEnabled = logger.isDebugEnabled(); if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. return handleExistingTransaction(def, transaction, debugEnabled); &#125; // ...&#125; 다시 AbstractPlatformTransactionManager의 getTransaction 메서드으로 돌아오면 JpaTransactionManager의 isExistingTransaction 메서드를 호출한다. JpaTransactionManager의 isExistingTransaction 메서드에서 JpaTransactionObject의 hasTransaction 매서드를 호출한다.123public boolean hasTransaction() &#123; return (this.entityManagerHolder != null &amp;&amp; this.entityManagerHolder.isTransactionActive());&#125; 둘 다 true이기 때문에 hasTransaction도 true를 반환한다.결국 isExistingTransaction(transaction)도 true이기 때문에 handleExistingTransaction 메서드를 호출한다.123456789101112131415161718192021222324252627private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException &#123; // ... return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);&#125;protected final DefaultTransactionStatus prepareTransactionStatus( TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) &#123; DefaultTransactionStatus status = newTransactionStatus( definition, transaction, newTransaction, newSynchronization, debug, suspendedResources); prepareSynchronization(status, definition); return status;&#125;protected DefaultTransactionStatus newTransactionStatus( TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) &#123; boolean actualNewSynchronization = newSynchronization &amp;&amp; !TransactionSynchronizationManager.isSynchronizationActive(); return new DefaultTransactionStatus( transaction, newTransaction, actualNewSynchronization, definition.isReadOnly(), debug, suspendedResources);&#125; 새로운 트랜잭션이 아니라 부모 트랜잭션을 그대로 사용하는 것이기 때문에 newTransaction을 false로 마킹을 해서 TransactionStatus를 반환한다.결국 새로운 트랜잭션을 시작한 게 아니기 때문에 엔티티 매니저 홀더도 부모가 쓰던 걸 물려받았고, 그렇기 때문에 새롭게 엔티티 매니저를 생성하지 않았다.그럼 부모 트랜잭션부터 시작된 엔티티 매니저가 유지되기 때문에 엔티티 매니저의 1차 캐시도 유지된다고 볼 수 있다. 그럼 자식 트랜잭션이 종료될 때는 엔티티 매니저를 종료할까??다시 TransactionAspectSupport의 invokeWithinTransaction 메서드로 돌아오자. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 commitTransactionAfterReturning 메서드를 호출하고 있다. commitTransactionAfterReturning 메서드에서 AbstractPlatformTransactionManager의 commit 메서드를 호출하고 있다. AbstractPlatformTransactionManager의 commit 메서드에서 processCommit 메서드를 호출하고 있다. processCommit 메서드에서 cleanupAfterCompletion 메서드를 호출하고 있다.12345678910111213141516private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123; status.setCompleted(); if (status.isNewSynchronization()) &#123; TransactionSynchronizationManager.clear(); &#125; if (status.isNewTransaction()) &#123; doCleanupAfterCompletion(status.getTransaction()); &#125; if (status.getSuspendedResources() != null) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Resuming suspended transaction after completion of inner transaction&quot;); &#125; Object transaction = (status.hasTransaction() ? status.getTransaction() : null); resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources()); &#125;&#125; transaction이 새로운 트랜잭션이 아니기 때문에 JpaTransactionManager의 doCleanupAfterCompletion 메서드를 호출하고 있지 않다.해당 메서드 안에서 쓰레드 로컬 맵도 지우고, 엔티티 매니저도 종료하는 등의 작업을 하고 있는데 호출하지 않기 때문에 엔티티 매니저는 종료되지 않는다. 즉, 부모 트랜잭션이 종료되기 전까지 엔티티 매니저를 새롭게 생성하거나 종료하는 일이 발생하지 않기 때문에 엔티티 매니저가 유효하고, 1차 캐시도 공유된다는 걸 알 수 있다. (물론 부모 트랜잭션을 사용하지 않는 Propagation.REQUIRES_NEW를 사용한다면 부모 트랜잭션을 사용하지 않고 새로운 트랜잭션을 만들기 때문에 엔티티 매니저를 새롭게 생성하고 해당 트랜잭션이 종료될 때 엔티티 매니저도 같이 종료될 것이다.)트랜잭션 내에서만 1차 캐시의 성능 최적화를 맛 볼 수 있기 때문에 생각보다 1차 캐시의 hit rate가 낮을 것 같다. OSIV가 켜져있을 때Spring Boot의 Auto Configuration인 JpaWebConfiguration을 보면 아래와 같이 설정이 돼있다. 12345678910111213141516171819202122232425262728293031323334353637383940@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(WebMvcConfigurer.class)@ConditionalOnMissingBean(&#123; OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class &#125;)@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)@ConditionalOnProperty(prefix = &quot;spring.jpa&quot;, name = &quot;open-in-view&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)protected static class JpaWebConfiguration &#123; private static final Log logger = LogFactory.getLog(JpaWebConfiguration.class); private final JpaProperties jpaProperties; protected JpaWebConfiguration(JpaProperties jpaProperties) &#123; this.jpaProperties = jpaProperties; &#125; @Bean public OpenEntityManagerInViewInterceptor openEntityManagerInViewInterceptor() &#123; if (this.jpaProperties.getOpenInView() == null) &#123; logger.warn(&quot;spring.jpa.open-in-view is enabled by default. &quot; + &quot;Therefore, database queries may be performed during view &quot; + &quot;rendering. Explicitly configure spring.jpa.open-in-view to disable this warning&quot;); &#125; return new OpenEntityManagerInViewInterceptor(); &#125; @Bean public WebMvcConfigurer openEntityManagerInViewInterceptorConfigurer( OpenEntityManagerInViewInterceptor interceptor) &#123; return new WebMvcConfigurer() &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addWebRequestInterceptor(interceptor); &#125; &#125;; &#125;&#125; spring.jpa.open-in-view가 설정돼있지 않거나 true로 설정돼있으면 OpenEntityManagerInViewInterceptor가 적용된다. 12345678910111213141516171819202122232425262728293031323334353637383940public class OpenEntityManagerInViewInterceptor extends EntityManagerFactoryAccessor implements AsyncWebRequestInterceptor &#123; // ... @Override public void preHandle(WebRequest request) throws DataAccessException &#123; // ... EntityManagerFactory emf = obtainEntityManagerFactory(); if (TransactionSynchronizationManager.hasResource(emf)) &#123; // Do not modify the EntityManager: just mark the request accordingly. Integer count = (Integer) request.getAttribute(key, WebRequest.SCOPE_REQUEST); int newCount = (count != null ? count + 1 : 1); request.setAttribute(getParticipateAttributeName(), newCount, WebRequest.SCOPE_REQUEST); &#125; else &#123; logger.debug(&quot;Opening JPA EntityManager in OpenEntityManagerInViewInterceptor&quot;); try &#123; EntityManager em = createEntityManager(); EntityManagerHolder emHolder = new EntityManagerHolder(em); TransactionSynchronizationManager.bindResource(emf, emHolder); AsyncRequestInterceptor interceptor = new AsyncRequestInterceptor(emf, emHolder); asyncManager.registerCallableInterceptor(key, interceptor); asyncManager.registerDeferredResultInterceptor(key, interceptor); &#125; catch (PersistenceException ex) &#123; throw new DataAccessResourceFailureException(&quot;Could not create JPA EntityManager&quot;, ex); &#125; &#125; &#125; // ... @Override public void afterCompletion(WebRequest request, @Nullable Exception ex) throws DataAccessException &#123; if (!decrementParticipateCount(request)) &#123; EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.unbindResource(obtainEntityManagerFactory()); logger.debug(&quot;Closing JPA EntityManager in OpenEntityManagerInViewInterceptor&quot;); EntityManagerFactoryUtils.closeEntityManager(emHolder.getEntityManager()); &#125; &#125; // ...&#125; 요청이 들어오면 preHandle 메서드가 실행되는데 TransactionSynchronizationManager.hasResource(emf)는 아마 false가 반환될 것이다. (대부분 그럴 거 같은데 100%는 아닐 것이다.)TransactionSynchronizationManager 안의 쓰레드 로컬 맵(resources 변수)에 해당 키(emf)가 존재하는지 확인하는 메서드인데 아직 해당 키가 존재하지 않을 것이기 때문이다.그럼 else 문을 타서 새롭게 엔티티 매니저, 엔티티 매니저 홀더를 생성하고 TransactionSynchronizationManager의 bindResource 메서드에서 쓰레드 로컬 맵(resources 변수)에 엔티티 매니저 팩토리를 키로, 엔티티 매니저 홀더를 값으로 넣게 된다. 그리고 뷰 렌더링이 모두 끝나면 afterCompletion이 호출되는데 이 때 TransactionSynchronizationManager의 unbindResource 메서드에서 쓰레드 로컬 맵(resources 변수)에 할당된 키(엔티티 매니저 팩토리)도 제거하고 엔티티 매니저도 종료하는 걸 볼 수 있다. 그럼 인터셉터에서 엔티티 매니저를 생성한 이후에 또 생성하거나 미리 제거하는 일은 없는 걸까?? 엔티티 매니저 생성 TransactionInterceptor의 invoke 메서드에서 부모 클래스인 TransactionAspectSupport의 invokeWithinTransaction 메서드를 호출한다. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 createTransactionIfNecessary 메서드를 호출한다. createTransactionIfNecessary 메서드에서 AbstractPlatformTransactionManager의 getTransaction 메서드를 호출한다. AbstractPlatformTransactionManager의 getTransaction 메서드에서 JpaTransactionManager의 doGetTransaction 메서드를 호출한다.12345678910111213141516171819@Overrideprotected Object doGetTransaction() &#123; JpaTransactionObject txObject = new JpaTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()); if (emHolder != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found thread-bound EntityManager [&quot; + emHolder.getEntityManager() + &quot;] for JPA transaction&quot;); &#125; txObject.setEntityManagerHolder(emHolder, false); &#125; // ... return txObject;&#125; 이미 OpenEntityManagerInViewInterceptor에서 TransactionSynchronizationManager.bindResource 메서드를 호출했기 때문에 TransactionSynchronizationManager.getResource는 null이 아니다.따라서 txObject에 emHolder를 초기화할 수 있는데, OpenEntityManagerInViewInterceptor에서 만들어둔 엔티티 매니저 홀더이기 때문에 새로운 엔티티 매니저 홀더가 아니라고 마킹한다. 123456789101112131415public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // Use defaults if no transaction definition given. TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults()); Object transaction = doGetTransaction(); boolean debugEnabled = logger.isDebugEnabled(); if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. return handleExistingTransaction(def, transaction, debugEnabled); &#125; // ...&#125; 다시 AbstractPlatformTransactionManager의 getTransaction 메서드으로 돌아오면 JpaTransactionManager의 isExistingTransaction 메서드를 호출한다. JpaTransactionManager의 isExistingTransaction 메서드에서 JpaTransactionObject의 hasTransaction 매서드를 호출한다.123public boolean hasTransaction() &#123; return (this.entityManagerHolder != null &amp;&amp; this.entityManagerHolder.isTransactionActive());&#125; entityManagerHolder는 null이 아니지만 isTransactionActive가 false이기 때문에 hasTransaction은 false를 반환한다.결국 isExistingTransaction(transaction)은 false이기 때문에 handleExistingTransaction 메서드를 호출하지 않는다. 다시 AbstractPlatformTransactionManager의 getTransaction 메서드로 돌아와보자. 123456789101112131415161718192021222324@Overridepublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // ... // No existing transaction found -&gt; check propagation behavior to find out how to proceed. if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123; throw new IllegalTransactionStateException( &quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;); &#125; else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) &#123; logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def); &#125; try &#123; return startTransaction(def, transaction, debugEnabled, suspendedResources); &#125; catch (RuntimeException | Error ex) &#123; resume(null, suspendedResources); throw ex; &#125; &#125; @Transactional의 기본 propagation 설정은 PROPAGATION_REQUIRED이기 때문에 startTransaction 메서드를 호출한다. 123456789101112131415161718192021private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction, boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status;&#125;protected DefaultTransactionStatus newTransactionStatus( TransactionDefinition definition, @Nullable Object transaction, boolean newTransaction, boolean newSynchronization, boolean debug, @Nullable Object suspendedResources) &#123; boolean actualNewSynchronization = newSynchronization &amp;&amp; !TransactionSynchronizationManager.isSynchronizationActive(); return new DefaultTransactionStatus( transaction, newTransaction, actualNewSynchronization, definition.isReadOnly(), debug, suspendedResources);&#125; 새롭게 트랜잭션을 시작하는 것이기 때문에 TransactionStatus를 만들 때 newTransaction을 true로 만든다.그리고나서 JpaTransactionManager의 doBegin 메서드를 호출한다. 123456789101112131415161718192021222324protected void doBegin(Object transaction, TransactionDefinition definition) &#123; JpaTransactionObject txObject = (JpaTransactionObject) transaction; // ... try &#123; if (!txObject.hasEntityManagerHolder() || txObject.getEntityManagerHolder().isSynchronizedWithTransaction()) &#123; EntityManager newEm = createEntityManagerForTransaction(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Opened new EntityManager [&quot; + newEm + &quot;] for JPA transaction&quot;); &#125; txObject.setEntityManagerHolder(new EntityManagerHolder(newEm), true); &#125; // ... // Bind the entity manager holder to the thread. if (txObject.isNewEntityManagerHolder()) &#123; TransactionSynchronizationManager.bindResource( obtainEntityManagerFactory(), txObject.getEntityManagerHolder()); &#125; // ... &#125; // ...&#125; OpenEntityManagerInViewInterceptor에서 생성한 엔티티 매니저 홀더를 txObject에 초기화 했기 때문에 createEntityManagerForTransaction 메서드를 호출하지 않는다.즉, 새로운 트랜잭션은 맞지만 entity manager는 새롭게 생성하지 않고 OpenEntityManagerInViewInterceptor에서 생성한 엔티티 매니저를 그대로 사용하는 걸 알 수 있다. 엔티티 매니저 종료다시 TransactionAspectSupport의 invokeWithinTransaction 메서드로 돌아오자. TransactionAspectSupport의 invokeWithinTransaction 메서드에서 commitTransactionAfterReturning 메서드를 호출하고 있다. commitTransactionAfterReturning 메서드에서 AbstractPlatformTransactionManager의 commit 메서드를 호출하고 있다. AbstractPlatformTransactionManager의 commit 메서드에서 processCommit 메서드를 호출하고 있다. processCommit 메서드에서 cleanupAfterCompletion 메서드를 호출하고 있다.12345678910111213141516private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123; status.setCompleted(); if (status.isNewSynchronization()) &#123; TransactionSynchronizationManager.clear(); &#125; if (status.isNewTransaction()) &#123; doCleanupAfterCompletion(status.getTransaction()); &#125; if (status.getSuspendedResources() != null) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Resuming suspended transaction after completion of inner transaction&quot;); &#125; Object transaction = (status.hasTransaction() ? status.getTransaction() : null); resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources()); &#125;&#125; OpenEntityManagerInViewInterceptor를 탔다고 하더라도 새로운 트랜잭션이 시작된 것이기 때문에 status.isNewTransaction()은 true이고 JpaTransactionManager의 doCleanupAfterCompletion 메서드를 호출한다.12345678910111213141516171819202122protected void doCleanupAfterCompletion(Object transaction) &#123; JpaTransactionObject txObject = (JpaTransactionObject) transaction; // Remove the entity manager holder from the thread, if still there. // (Could have been removed by EntityManagerFactoryUtils in order // to replace it with an unsynchronized EntityManager). if (txObject.isNewEntityManagerHolder()) &#123; TransactionSynchronizationManager.unbindResourceIfPossible(obtainEntityManagerFactory()); &#125; // ... // Remove the entity manager holder from the thread. if (txObject.isNewEntityManagerHolder()) &#123; EntityManager em = txObject.getEntityManagerHolder().getEntityManager(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Closing JPA EntityManager [&quot; + em + &quot;] after transaction&quot;); &#125; EntityManagerFactoryUtils.closeEntityManager(em); &#125; else &#123; logger.debug(&quot;Not closing pre-bound JPA EntityManager after transaction&quot;); &#125;&#125; 엔티티 매니저 홀더는 새롭게 생성한 게 아니라 OpenEntityManagerInViewInterceptor에서 생성한 것이기 때문에 txObject.isNewEntityManagerHolder 메서드는 전부 false이다.따라서 엔티티 매니저는 종료되지 않고 계속 살아있게 된다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"}]},{"title":"(JPA) Readonly 트랜잭션은 트랜잭션을 시작하지만 flush를 하지 않는다.","slug":"readonly-transaction-begin-transaction","date":"2021-05-05T17:46:16.000Z","updated":"2022-10-30T08:42:16.887Z","comments":true,"path":"2021/05/05/readonly-transaction-begin-transaction/","link":"","permalink":"https://perfectacle.github.io/2021/05/05/readonly-transaction-begin-transaction/","excerpt":"3줄 요약 @Transaction(readOnly &#x3D; true)로 설정해도 트랜잭션은 시작된다. (transaction isolation level 보장) readOnly 트랜잭션도 시작한 트랜잭션을 종료시켜야하기 때문에 커밋도 한다. readOnly 트랜잭션의 Hibernate Session의 FlushMode는 Manual로 강제하기 때문에 트랜잭션을 커밋하기 전에 flush를 하지 않는다. (readOnly 보장) @Transaction(readOnly &#x3D; true)로 설정해도 트랜잭션은 시작된다.1234567891011121314151617public interface SomeEntityRepository extends JpaRepository&lt;Parent, Long&gt; &#123; @Transactional(readOnly = true) List&lt;Parent&gt; findByName(String name);&#125;@Servicepublic SomeService &#123; private final SomeEntityRepository repository; public SomeService(final SomeEntityRepository repository) &#123; this.repository = repository; &#125; public void test() &#123; repository.findByName(&quot;qwer&quot;); &#125;&#125;","text":"3줄 요약 @Transaction(readOnly &#x3D; true)로 설정해도 트랜잭션은 시작된다. (transaction isolation level 보장) readOnly 트랜잭션도 시작한 트랜잭션을 종료시켜야하기 때문에 커밋도 한다. readOnly 트랜잭션의 Hibernate Session의 FlushMode는 Manual로 강제하기 때문에 트랜잭션을 커밋하기 전에 flush를 하지 않는다. (readOnly 보장) @Transaction(readOnly &#x3D; true)로 설정해도 트랜잭션은 시작된다.1234567891011121314151617public interface SomeEntityRepository extends JpaRepository&lt;Parent, Long&gt; &#123; @Transactional(readOnly = true) List&lt;Parent&gt; findByName(String name);&#125;@Servicepublic SomeService &#123; private final SomeEntityRepository repository; public SomeService(final SomeEntityRepository repository) &#123; this.repository = repository; &#125; public void test() &#123; repository.findByName(&quot;qwer&quot;); &#125;&#125; repository의 구현체는 프록시 객체로써 인터페이스이기 때문에 jdk dynamic 프록시 객체가 생성이 된다.또한 TransactionInterceptor라는 Advisor를 가지고 있으며 TransactionInterceptor.invoke() TransactionAspectSupport.invokeWithinTransaction() TransactionAspectSupport.createTransactionIfNecessary() AbstractPlatformTransactionManager.getTransaction() AbstractPlatformTransactionManager.startTransaction() JpaTransactionManager.doBegin() HibernateJpaDialect.beginTransaction() TransactionImpl.begin() JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.begin() LogicalConnectionManagedImpl.begin() AbstractLogicalConnectionImplementor.begin() 위와 같은 메서드 호출을 통해서 실제로 트랜잭션을 시작하게 된다. @Transaction(readOnly &#x3D; true)에 의해 시작된 트랜잭션은 flush를 하지 않는다.HibernateJpaDialect.beginTransaction() 을 타고 보다보면 아래와 같은 흐름을 따라가게 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic Object beginTransaction(EntityManager entityManager, TransactionDefinition definition) throws PersistenceException, SQLException, TransactionException &#123; Session session = getSession(entityManager); if (definition.getTimeout() != TransactionDefinition.TIMEOUT_DEFAULT) &#123; session.getTransaction().setTimeout(definition.getTimeout()); &#125; boolean isolationLevelNeeded = (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT); Integer previousIsolationLevel = null; Connection preparedCon = null; if (isolationLevelNeeded || definition.isReadOnly()) &#123; if (this.prepareConnection) &#123; preparedCon = HibernateConnectionHandle.doGetConnection(session); previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(preparedCon, definition); &#125; else if (isolationLevelNeeded) &#123; throw new InvalidIsolationLevelException(getClass().getSimpleName() + &quot; does not support custom isolation levels since the &#x27;prepareConnection&#x27; flag is off.&quot;); &#125; &#125; // Standard JPA transaction begin call for full JPA context setup... entityManager.getTransaction().begin(); // Adapt flush mode and store previous isolation level, if any. FlushMode previousFlushMode = prepareFlushMode(session, definition.isReadOnly()); // ...&#125;@Nullableprotected FlushMode prepareFlushMode(Session session, boolean readOnly) throws PersistenceException &#123; FlushMode flushMode = (FlushMode) ReflectionUtils.invokeMethod(getFlushMode, session); Assert.state(flushMode != null, &quot;No FlushMode from Session&quot;); if (readOnly) &#123; // We should suppress flushing for a read-only transaction. if (!flushMode.equals(FlushMode.MANUAL)) &#123; session.setFlushMode(FlushMode.MANUAL); return flushMode; &#125; &#125; // ...&#125; Transaction의 설정이 readOnly &#x3D; true라면 Hibernate Session의 FlushMode를 MANUAL(명시적으로 EntityManager.flush() 메서드를 호출하기 전까지 flush 되지 않음)로 강제하고 있다. 그리고 나서 실질적인 로직이 끝난 이후에 TransactionAspectSupport.invokeWithinTransaction() 메서드에서 아래와 같은 호출 흐름을 가진다. 123456789101112131415161718192021222324252627282930313233343536@Nullableprotected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123; // ... if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123; // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null &amp;&amp; txAttr != null) &#123; retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status); &#125; &#125; commitTransactionAfterReturning(txInfo); return retVal; &#125; // ...&#125; invocation.proceedWithInvocation()에 의해 트랜잭션 내부 로직을 호출한다. TransactionAspectSupport.commitTransactionAfterReturning() AbstractPlatformTransactionManager.commit() AbstractPlatformTransactionManager.processCommit() JpaTransactionManager.doCommit() TransactionImpl.commit() JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.commit() JdbcResourceLocalTransactionCoordinatorImpl.beforeCompletionCallback() JdbcCoordinatorImpl.beforeTransactionCompletion() SessionImpl.beforeTransactionCompletion() SessionImpl.flushBeforeTransactionCompletion() SessionImpl.flushBeforeTransactionCompletion 코드를 보면 아래와 같다. 12345678910111213public void flushBeforeTransactionCompletion() &#123; final boolean doFlush = isTransactionFlushable() &amp;&amp; getHibernateFlushMode() != FlushMode.MANUAL; try &#123; if ( doFlush ) &#123; managedFlush(); &#125; &#125; catch (RuntimeException re) &#123; throw ExceptionMapperStandardImpl.INSTANCE.mapManagedFlushFailure( &quot;error during managed flush&quot;, re, this ); &#125;&#125; 위에서 readOnly이면 Hibernate Session의 Flush 모드를 MANUAL로 강제했기 때문에 getHibernateFlushMode()는 MANUAL이 나오기 때문에getHibernateFlushMode() != FlushMode.MANUAL는 false이기 때문에 doFlush는 false라서 managedFlush 메서드를 호출하지 않아서 실질적으로 flush가 호출되지 않는다. @Transaction(readOnly &#x3D; true)에 의해 시작된 트랜잭션도 종료를 해야하기 때문에 커밋을 한다.flush는 하지 않았지만 트랜잭션을 시작했기 때문에 트랜잭션을 종료해야 정상적으로 커넥션을 반환하게 된다.다시 JdbcResourceLocalTransactionCoordinatorImpl.TransactionDriverControlImpl.commit() 로 돌아오면 AbstractLogicalConnectionImplementor.commit() ProxyConnection.commit() Connection.commit() 위와 같은 메서드 호출을 통해 실제 DB 물리 커넥션에 commit을 날리기 때문에 위에서 시작한 트랜잭션을 종료하게 된다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"}]},{"title":"Netty 이벤트 핸들러 실행 순서","slug":"netty-event-handler-order","date":"2021-02-28T15:53:46.000Z","updated":"2022-10-30T08:42:16.871Z","comments":true,"path":"2021/02/28/netty-event-handler-order/","link":"","permalink":"https://perfectacle.github.io/2021/02/28/netty-event-handler-order/","excerpt":"Netty를 사용하다보면 채널 파이프라인에 여러 이벤트 핸들러를 추가하기 마련이다.그러다보니 순서가 중요할 때가 있다. 클라에서 보낸 데이터 중에 헤더를 파싱하고, 헤더에 따라 바디를 파싱하고, 바디를 토대로 뭔가를 또 처리해야하고… 이런 식으로 N 개의 이벤트 핸들러를 붙여야하고, 순서가 중요하다보니 어떤 순서대로 실행되는지가 궁금해졌다. Inbound Event Handler1234567891011121314151617181920class ExampleHandler1 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;1&quot;) ctx.fireChannelRead(msg) &#125;&#125;class ExampleHandler2 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;2&quot;) ctx.fireChannelRead(msg) &#125;&#125;class ExampleHandler3 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;3&quot;) ctx.fireChannelRead(msg) &#125;&#125;","text":"Netty를 사용하다보면 채널 파이프라인에 여러 이벤트 핸들러를 추가하기 마련이다.그러다보니 순서가 중요할 때가 있다. 클라에서 보낸 데이터 중에 헤더를 파싱하고, 헤더에 따라 바디를 파싱하고, 바디를 토대로 뭔가를 또 처리해야하고… 이런 식으로 N 개의 이벤트 핸들러를 붙여야하고, 순서가 중요하다보니 어떤 순서대로 실행되는지가 궁금해졌다. Inbound Event Handler1234567891011121314151617181920class ExampleHandler1 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;1&quot;) ctx.fireChannelRead(msg) &#125;&#125;class ExampleHandler2 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;2&quot;) ctx.fireChannelRead(msg) &#125;&#125;class ExampleHandler3 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;3&quot;) ctx.fireChannelRead(msg) &#125;&#125; 그리고 채널 파이프라인에 순서대로 등록해주자. 12345678910// ...object : ChannelInitializer&lt;Channel&gt;() &#123; override fun initChannel(ch: Channel) &#123; ch.pipeline() .addLast(ExampleHandler1()) .addLast(ExampleHandler2()) .addLast(ExampleHandler3()) &#125;&#125;// ... Outbound Event HandlerOutbound Event를 발생시키기 위해서는 Inbound Event Handler에서 Outbound Event를 한 번 발생시켜야하기 때문에 둘을 짬뽕시켜보았다. 1234567891011121314151617181920class InboundHandler1 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;1&quot;) ctx.write(msg) &#125;&#125;class OutboundHandler2 : ChannelOutboundHandlerAdapter() &#123; override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise) &#123; println(&quot;2&quot;) ctx.write(msg, promise) &#125;&#125;class OutboundHandler3 : ChannelOutboundHandlerAdapter() &#123; override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise) &#123; println(&quot;3&quot;) ctx.write(msg, promise) &#125;&#125; 그리고 채널 파이프라인에 순서대로 등록해보았다. 12345678object : ChannelInitializer&lt;Channel&gt;() &#123; override fun initChannel(ch: Channel) &#123; ch.pipeline() .addLast(InboundHandler1()) .addLast(OutboundHandler2()) .addLast(OutboundHandler3()) &#125;&#125; 하지만 1만 출력되고, 2와 3은 출력되지 않았다.답은 Outbound Event는 Top-down 순서로 실행되기 때문이다. 12345678object : ChannelInitializer&lt;Channel&gt;() &#123; override fun initChannel(ch: Channel) &#123; ch.pipeline() .addLast(OutboundHandler3()) .addLast(OutboundHandler2()) .addLast(InboundHandler1()) &#125;&#125; OutboundHandler2, OutboundHandler3 순서대로 실행돼서 1이 찍힌 후에 2와 3이 찍힌다. Duplex Event HandlerInbound&#x2F;Outbound Event를 모두 핸들링하는 Duplex Event Handler를 추가해서 실행 순서를 살펴보자. 1234567891011121314151617181920212223242526272829303132class InboundHandler1 : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;1&quot;) ctx.write(msg) &#125;&#125;class OutboundHandler2 : ChannelOutboundHandlerAdapter() &#123; override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise) &#123; println(&quot;2&quot;) ctx.write(msg, promise) &#125;&#125;class DuplexHandler3 : ChannelDuplexHandler() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(&quot;3 - read&quot;) ctx.fireChannelRead(msg) &#125; override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise) &#123; println(&quot;3 - write&quot;) ctx.write(msg, promise) &#125;&#125;class OutboundHandler4 : ChannelOutboundHandlerAdapter() &#123; override fun write(ctx: ChannelHandlerContext, msg: Any, promise: ChannelPromise) &#123; println(&quot;4&quot;) ctx.write(msg, promise) &#125;&#125; 채널 파이프라인에 추가해주자. 123456789object : ChannelInitializer&lt;Channel&gt;() &#123; override fun initChannel(ch: Channel) &#123; ch.pipeline() .addLast(OutboundHandler4()) .addLast(DuplexHandler3()) .addLast(OutboundHandler2()) .addLast(InboundHandler1()) &#125;&#125; Inbound Handler는 Bottom-up 순서대로 실행되기 때문에 먼저 등록된 DuplexHandler3의 3 - read 출력 그 후 등록된 InboundHandler1의 1 출력 Outbound Handler는 Top-down 순서대로 실행되기 때문에 OutboundHandler2의 2 출력 DuplexHandler3의 3 - write 출력 OutboundHandler4의 4 출력","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Netty","slug":"Note/Netty","permalink":"https://perfectacle.github.io/categories/Note/Netty/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://perfectacle.github.io/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"https://perfectacle.github.io/tags/Netty/"}]},{"title":"Netty ByteBuf","slug":"netty-byte-buf","date":"2021-02-28T14:34:23.000Z","updated":"2022-10-30T08:42:16.871Z","comments":true,"path":"2021/02/28/netty-byte-buf/","link":"","permalink":"https://perfectacle.github.io/2021/02/28/netty-byte-buf/","excerpt":"Netty는 왜 자바 표준인 NIO의 ByteBuffer를 사용하지 않는 걸까 이유를 몰랐는데 자바 네트워크 소녀 네티를 보고 이유를 알게되어 정리해봄.ByteBuffer와 ByteBuf의 세부사항 보다는 ByteBuffer는 어떤 문제점을 가지고 있고, ByteBuf는 그 문제점을 어떻게 해결했는지에 초점을 맞추어 정리함. ByteBuffer의 문제점Netty의 ByteBuf는 자바의 ByteBuffer가 가진 문제점들을 해결하기 위해 나왔다. 데이터 쓰기&#x2F;읽기 인덱스가 분리돼있지 않다1234567val byteBuffer = ByteBuffer.allocate(3) // 3바이트를 담을 수 있는 힙버퍼, 전부 0으로 초기화된다.println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]byteBuffer.put(1)println(byteBuffer) // java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]println(byteBuffer.get()) // 0","text":"Netty는 왜 자바 표준인 NIO의 ByteBuffer를 사용하지 않는 걸까 이유를 몰랐는데 자바 네트워크 소녀 네티를 보고 이유를 알게되어 정리해봄.ByteBuffer와 ByteBuf의 세부사항 보다는 ByteBuffer는 어떤 문제점을 가지고 있고, ByteBuf는 그 문제점을 어떻게 해결했는지에 초점을 맞추어 정리함. ByteBuffer의 문제점Netty의 ByteBuf는 자바의 ByteBuffer가 가진 문제점들을 해결하기 위해 나왔다. 데이터 쓰기&#x2F;읽기 인덱스가 분리돼있지 않다1234567val byteBuffer = ByteBuffer.allocate(3) // 3바이트를 담을 수 있는 힙버퍼, 전부 0으로 초기화된다.println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]byteBuffer.put(1)println(byteBuffer) // java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]println(byteBuffer.get()) // 0 3byte를 담을 수 있는 버퍼를 만들고, 첫 번째 버퍼에 1이라는 바이트를 넣었다.그리고나서 읽으려고 하는데 0이 나왔다.이유는 쓰기 인덱스와 읽기 인덱스를 pos라는 하나의 변수로 관리하고 있기 때문이다. 123456789val byteBuffer = ByteBuffer.allocate(3)println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]byteBuffer.put(1)println(byteBuffer) // java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]byteBuffer.flip() // 읽기 모드로 변경println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=1 cap=3]println(byteBuffer.get()) // 1 데이터를 쓰다가 읽으려면 flip을 써서 읽기 모드로 변경해서 pos를 0으로 초기화하고 lim을 현재 포지션인 1로 바꾼다.왜냐하면 데이터를 1byte 밖에 안 썼기 때문에 1 byte 밖에 못 읽기 때문이다.그럼 정말 flip은 읽기&#x2F;쓰기 모드 변환으로 생각해도 되는 걸까? 123456789101112val byteBuffer = ByteBuffer.allocate(3)println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=3 cap=3]byteBuffer.put(1)println(byteBuffer) // java.nio.HeapByteBuffer[pos=1 lim=3 cap=3]byteBuffer.flip() // 읽기 모드로 변경println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=1 cap=3]println(byteBuffer.get()) // 1byteBuffer.flip() // 쓰기 모드로 변경println(byteBuffer) // java.nio.HeapByteBuffer[pos=0 lim=1 cap=3] 나는 읽기 모드에서 다시 flip을 하면 lim은 3으로 늘어나고 pos는 다시 1으로 원복될 줄 알았는데 그게 아니었다. 123456789101112131415161718192021222324252627/** * Flips this buffer. The limit is set to the current position and then * the position is set to zero. If the mark is defined then it is * discarded. * * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke * this method to prepare for a sequence of channel-write or relative * &lt;i&gt;get&lt;/i&gt; operations. For example: * * &lt;blockquote&gt;&lt;pre&gt; * buf.put(magic); // Prepend header * in.read(buf); // Read data into rest of buffer * buf.flip(); // Flip buffer * out.write(buf); // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt; * * &lt;p&gt; This method is often used in conjunction with the &#123;@link * java.nio.ByteBuffer#compact compact&#125; method when transferring data from * one place to another. &lt;/p&gt; * * @return This buffer */public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 읽기&#x2F;쓰기 모드가 아니라 그냥 버퍼를 flip하는 거라고 한다. (flip이 뒤집다라는 뜻인데 limit을 현재 포지션으로 뒤집는다는 뜻으로 쓰인 건지는 잘 모르겠다.)limit을 바꾸지 않고 position만 바꾸고 싶다면 rewind() 메서드를 사용하거나 position(int newPosition) 메서드를 사용해야한다. 버퍼의 사이즈가 고정적이다limit이나 capacity를 넘어서면 버퍼의 사이즈가 늘어나는 게 아니라 BufferOverflowException 예외를 던진다. 1234567891011val byteBuffer = ByteBuffer.allocate(3) // pos: 0, lim: 3, cap: 3byteBuffer.put(1) // pos: 1, lim: 3, cap: 3byteBuffer.put(1) // pos: 2, lim: 3, cap: 3byteBuffer.put(1) // pos: 3, lim: 3, cap: 3assertThrows&lt;BufferOverflowException&gt; &#123; byteBuffer.put(1) &#125;val byteBuffer2 = ByteBuffer.allocate(3) // pos: 0, lim: 3, cap: 3byteBuffer2.put(1) // pos: 1, lim: 3, cap: 3byteBuffer2.flip() // pos: 0, lim: 1, cap: 3byteBuffer2.put(1) // pos: 1, lim: 1, cap: 3assertThrows&lt;BufferOverflowException&gt; &#123; byteBuffer2.put(1) &#125; 버퍼풀이 존재하지 않는다.버퍼풀이 존재하지 않기 때문에 버퍼의 생성 및 메모리 해제 작업이 빈번하여 GC도 자주 유발하게 된다.이런 단점을 보완하려면 객체 풀링을 제공하는 써드파티 라이브러리를 사용하여야한다. 네티의 ByteBuf네티의 ByteBuf는 위의 문제점들 외에 기타 장점들까지 가지고 있기 때문에 고성능에 유지보수하기 쉬운 코드를 지향한다.또한 네티를 쓰지 않더라도 netty-buffer를 의존성에 추가하고 ByteBuf만 사용하는 것도 가능하다. 읽기&#x2F;쓰기 인덱스의 분리ByteBuffer에서는 pos라는 인덱스로 읽기&#x2F;쓰기 인덱스를 공유하여 데이터를 쓰다가 읽으려면 flip, rewind, poistion 메서드를 통해 pos를 변경해주어야만 했다.그리고 flip은 개발자의 혼란을 초래하는 동작방식 때문에 버그를 유발하기도 쉽다. ByteBuf는 이런 단점을 보완하고자 읽기&#x2F;쓰기 인덱스를 분리하였다. 1234567891011121314val byteBuf = Unpooled.buffer(3)println(byteBuf) // ridx: 0, widx: 0, cap: 3byteBuf.readableBytes() shouldBe 0 // widx(0) - ridx(0) = 0byteBuf.writableBytes() shouldBe 3 // cap(3) - widx(0) = 3byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 1, cap: 3byteBuf.readableBytes() shouldBe 1 // widx(1) - ridx(0) = 1byteBuf.writableBytes() shouldBe 2 // cap(3) - widx(1) = 2byteBuf.readByte() shouldBe 1println(byteBuf) // ridx: 1, widx: 1, cap: 3byteBuf.readableBytes() shouldBe 0 // widx(1) - ridx(1) = 0byteBuf.writableBytes() shouldBe 2 // cap(3) - widx(1) = 2 버퍼의 사이즈가 가변적이다.123456789101112131415161718192021222324val byteBuf = Unpooled.buffer(3)println(byteBuf) // ridx: 0, widx: 0, cap: 3byteBuf.readableBytes() shouldBe 0 // widx(0) - ridx(0) = 0byteBuf.writableBytes() shouldBe 3 // cap(3) - widx(0) = 3byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 1, cap: 3byteBuf.readableBytes() shouldBe 1 // widx(1) - ridx(0) = 1byteBuf.writableBytes() shouldBe 2 // cap(3) - widx(1) = 2byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 2, cap: 3byteBuf.readableBytes() shouldBe 2 // widx(2) - ridx(0) = 2byteBuf.writableBytes() shouldBe 1 // cap(3) - widx(2) = 1byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 3, cap: 3byteBuf.readableBytes() shouldBe 3 // widx(3) - ridx(0) = 3byteBuf.writableBytes() shouldBe 0 // cap(3) - widx(3) = 0byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 4, cap: 64, 버퍼의 사이즈가 가변적으로 늘어났다.byteBuf.readableBytes() shouldBe 4 // widx(4) - ridx(0) = 3byteBuf.writableBytes() shouldBe 60 // cap(64) - widx(4) = 60 widx가 cap를 넘어가는 순간 버퍼의 사이즈가 늘어난다.또한 capacity 메서드를 사용하면 명시적인 버퍼의 사이즈를 지정할 수 있다. (기존 capcity보다 작아지면 기존 데이터는 잘릴 수 있다.)당연한 얘기지만 ridx가 widx를 벗어나면 예외를 던지는 건 똑같다. 123456789101112131415161718192021val byteBuf = Unpooled.buffer(3)println(byteBuf) // ridx: 0, widx: 0, cap: 3byteBuf.readableBytes() shouldBe 0 // widx(0) - ridx(0) = 0byteBuf.writableBytes() shouldBe 3 // cap(3) - widx(0) = 3byteBuf.writeByte(1)println(byteBuf) // ridx: 0, widx: 1, cap: 3byteBuf.readableBytes() shouldBe 1 // widx(1) - ridx(0) = 1byteBuf.writableBytes() shouldBe 2 // cap(3) - widx(1) = 2byteBuf.readByte() shouldBe 1println(byteBuf) // ridx: 1, widx: 1, cap: 3byteBuf.readableBytes() shouldBe 0 // widx(1) - ridx(1) = 0byteBuf.writableBytes() shouldBe 2 // cap(3) - widx(1) = 2val indexOutOfBoundsException = assertThrows&lt;IndexOutOfBoundsException&gt; &#123; byteBuf.readByte() &#125;indexOutOfBoundsException.printStackTrace()// java.lang.IndexOutOfBoundsException: readerIndex(1) + length(1) exceeds writerIndex(1): UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: 1, widx: 1, cap: 3)// at io.netty.buffer.AbstractByteBuf.checkReadableBytes0(AbstractByteBuf.java:1478)// at io.netty.buffer.AbstractByteBuf.readByte(AbstractByteBuf.java:732)// ... 버퍼풀을 지원한다풀을 사용하는 이유는 자원을 재활용하기 위함이다.그럼 버퍼를 왜 재사용할까? 바로 버퍼를 빈번히 메모리에 할당&#x2F;해제 함으로써 발생하는 GC 횟수를 줄이기 위함이다. 1234567// 버퍼풀을 사용하지 않는다.Unpooled.buffer()Unpooled.directBuffer() // direct가 붙은 놈은 힙메모리가 아닌 OS의 커널 영역에 바이트 버퍼를 생성함, 생성 시간은 좀 더 걸리지만 읽기/쓰기 성능이 더 좋다.// 버퍼풀을 사용한다.ByteBufAllocator.DEFAULT.heapBuffer()ByteBufAllocator.DEFAULT.directBuffer() Reference counted objectsNetty 4 버전 이후로 객체(버퍼)의 라이프사이클은 레퍼런스 카운트에 의해 관리되고 있다.만약 어플리케이션에서 더이상 해당 버퍼를 참조하지 않아도, 풀에 반납하지 않는다면 GC가 돌아도 해당 버퍼는 계속 메모리 상에 남아 메모리 누수를 유발한다. 버퍼를 풀에 반납하는 방법은 두 가지가 있다.(아래 나오는 예제는 예시일 뿐이지, channelRead 메서드에서만 반납해야한다거나 그런 규칙은 없다.) 채널에 버퍼를 기록한다.12345class EchoHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; ctx.write(msg) &#125;&#125; 명시적으로 반환한다.123456789101112131415161718192021222324class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; if (msg !is ByteBuf) return println(msg.refCnt()) // 1 ReferenceCountUtil.retain(msg) println(msg.refCnt()) // 2 ReferenceCountUtil.release(msg) println(msg.refCnt()) // 1 ReferenceCountUtil.release(msg) // 레퍼런스 카운트가 0이 되면서 풀에 반납됨. println(msg.refCnt()) // 0 // 풀에 반납된 객체를 사용하려고 하면 IllegalReferenceCountException 예외를 던진다. ReferenceCountUtil.release(msg) // io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1 // at io.netty.util.internal.ReferenceCountUpdater.toLiveRealRefCnt(ReferenceCountUpdater.java:74) // at io.netty.util.internal.ReferenceCountUpdater.release(ReferenceCountUpdater.java:138) // at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:100) // at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:88) // ... &#125;&#125; 반납 의무를 다음 이벤트 핸들러에게 미루기바이트버퍼를 다음 이벤트 핸들러에게 넘기지 않을 때는 해당 이벤트 핸들러에서 반납을 해야하지만, 만약 다음 이벤트 핸들러에게 넘긴다면 반납해서는 안 된다.왜냐하면 IllegalReferenceCountException이 발생하기 때문이다. 1234567891011121314151617class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; if (msg !is ByteBuf) return println(msg.refCnt()) // 1 ReferenceCountUtil.retain(msg) println(msg.refCnt()) // 2 ReferenceCountUtil.release(msg) println(msg.refCnt()) // 1 ReferenceCountUtil.release(msg) // 레퍼런스 카운트가 0이 되면서 풀에 반납됨. println(msg.refCnt()) // 0 ctx.fireChannelRead(msg) &#125;&#125; 위 이벤트 핸들러 이후 바이트 버퍼를 사용하는 핸들러에서 io.netty.util.IllegalReferenceCountException 예외가 발생한다. 1234567class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; ctx.write(msg) ctx.fireChannelRead(msg) &#125;&#125; 마찬가지로 채널에 버퍼를 기록하는 경우도 풀에 반납하기 때문에 io.netty.util.IllegalReferenceCountException 예외가 발생한다. 따라서 반납하지 않고 바이트버퍼를 사용만 하고 그대로 넘겨주면 된다. 1234567class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; // 바이트 버퍼 잘 사용하고 반납은 하지 않기 ctx.fireChannelRead(msg) &#125;&#125; 하지만 뒤에 이벤트 핸들러로 넘겨줄 때도 ridx, widx, capacity는 공유된다.동일한 채널에 동일한 이벤트 핸들러를 두 번 등록해보면 ridx가 바뀌는 걸 볼 수 있다. 12345678910class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; // 첫 번째 - ridx: 0, widx: 1000, cap: 2048 // 두 번째 - ridx: 1, widx: 1000, cap: 2048 println(msg) (msg as? ByteBuf)?.readByte() ctx.fireChannelRead(msg) &#125;&#125; 따라서 뒤의 이벤트 핸들러에 영향을 주지 않으려면 ByteBuf를 카피한 후에 카피한 ByteBuf를 사용한 후에 원본 ByteBuf를 다음 이벤트로 넘겨줘야한다. 1234567891011class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; println(msg) // 매번 고정적으로 ridx: 0, widx: 1000, cap: 2048 if (msg is ByteBuf) &#123; val copiedByteBuf = msg.copy() copiedByteBuf.readByte() &#125; ctx.fireChannelRead(msg) &#125;&#125; 버퍼풀 반납하기후속 이벤트 핸들러에게 바이트 버퍼를 넘기지 않는한 해당 이벤트 핸들러에서 버퍼풀에 반납하지 않으면 메모리 누수가 발생한다.따라서 채널에 기록하던, 반환하던 무조건 풀에 반납하지 않으면 안 된다. (트래픽이 적으면 서서히 메모리 누수가 발생하겠지만 트래픽이 많다면…) 123456789class ExampleHandler : ChannelInboundHandlerAdapter() &#123; override fun channelRead(ctx: ChannelHandlerContext, msg: Any) &#123; try &#123; // ... &#125; finally &#123; ReferenceCountUtil.safeRelease(msg) &#125; &#125;&#125; try로 묶지 않으면 예외 발생 시 메모리 누수가 발생할 수 있으므로 꼭 try로 묶은 후 finally에서 처리하도록 하자.그리고 try에서 혹시나 반납을 이미 해버렸고, 반납된 이후에 예외가 터지거나 할 수 있기 때문에 safeRelease(이미 반납됐어도 예외를 던지지 않음) 메서드를 사용하자.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Netty","slug":"Note/Netty","permalink":"https://perfectacle.github.io/categories/Note/Netty/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://perfectacle.github.io/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"https://perfectacle.github.io/tags/Netty/"}]},{"title":"Netty 이벤트 루프","slug":"netty-event-loop","date":"2021-02-28T01:32:12.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2021/02/28/netty-event-loop/","link":"","permalink":"https://perfectacle.github.io/2021/02/28/netty-event-loop/","excerpt":"이벤트 루프의 개념이 명확하지 않아 자바 네트워크 소녀 네티를 보고 정리해봄. 통상적으로 이벤트 기반 어플리케이션이 이벤트를 처리하는 방식은 아래 두 가지가 존재한다고 함. 이벤트 리스너와 이벤트 처리 쓰레드 방식브라우저에서 DOM에 클릭 이벤트를 어떻게 핸들링하는지 생각해보면 된다. 1document.querySelector(&#x27;body&#x27;).onclick = e =&gt; console.dir(e)","text":"이벤트 루프의 개념이 명확하지 않아 자바 네트워크 소녀 네티를 보고 정리해봄. 통상적으로 이벤트 기반 어플리케이션이 이벤트를 처리하는 방식은 아래 두 가지가 존재한다고 함. 이벤트 리스너와 이벤트 처리 쓰레드 방식브라우저에서 DOM에 클릭 이벤트를 어떻게 핸들링하는지 생각해보면 된다. 1document.querySelector(&#x27;body&#x27;).onclick = e =&gt; console.dir(e) 이벤트를 처리하는 로직을 가진 메서드(e =&gt; console.dir(e))를 대상 객체(document.querySelector(&#39;body&#39;))의 이벤트 리스너(onclick)에 등록하고,객체에 이벤트(click)가 발생했을 때 이벤트 처리 쓰레드에서 등록된 메서드를 수행하는 방식. 이런 처리 방식은 대부분 단일 쓰레드에서 이벤트를 처리한다. (js도 그래서 이벤트 리스너에서 병목이 발생하면 거의 stop the world에 걸린다고 보면 됨.) 이벤트 큐에 이벤트를 등록하고 이벤트 루프가 이벤트 큐에 접근하여 처리하는 방식 이벤트 루프는 쉽게 말해서 이벤트를 실행하기 위한 무한루프 스레드를 말한다. (이벤트가 올 때까지 해당 쓰레드가 block이 걸릴 수도 있고, 안 걸릴 수도 있고…)이벤트 루프 쓰레드는 무한 루프를 돌면서 이벤트 큐에 이벤트가 있나 없나? 계속 감시를 하고 이벤트가 존재하면 큐에서 꺼내서 이벤트를 처리한다. 단일 쓰레드와 다중 쓰레드 이벤트 루프단일 쓰레드 이벤트 루프 Node.js와 같이 단일 쓰레드에서 이벤트 루프를 처리하게 되면 이벤트의 처리 순서를 보장할 수 있는 장점이 존재한다.하지만 이벤트 처리 도중 병목이 걸리면 뒤에 있는 이벤트들도 전부 지연된다는 단점이 존재한다.이런 단점을 극복하고자 노드에서는 CPU 코어 갯수만큼 프로세스를 띄우기도 한다. 다중 쓰레드 이벤트 루프 다중 쓰레드 이벤트 루프는 여러 쓰레드에서 이벤트 루프를 처리하기 때문에 단일 쓰레드보다 더 효율적으로 이벤트를 처리할 수 있다는 장점이 존재한다.하지만 하나의 자원(이벤트 큐)에 대해 여러 쓰레드에서 경합을 하기 때문에 다른 쓰레드에서 대기하는 시간이 발생할 수 있다.또한 CPU 코어는 동시에 하나의 쓰레드만 실행할 수 있으므로 쓰레드가 CPU 코어 갯수를 초과하는 경우 아래와 같은 컨텍스트 스위칭 비용이 발생한다. 운영체제는 현재 쓰레드 상태가 대기(Waiting), 슬립(Sleep), 지연(Blocked)인 쓰레드 중 하나를 선택하여 실행(Run) 상태로 바꾼다. 이 때 쓰레드가 가진 스택 정보를 현재 코어의 레지스터로 복사(컨텍스트 스위칭)한다. 그리고 여러 쓰레드에서 하나의 이벤트 큐에 접근하므로 이벤트 처리에 대한 순서를 보장할 수 없다. 이벤트 큐는 하나, 이벤트 루프 쓰레드는 2개라고 가정. 이벤트 큐에 E1, E2, E3가 쌓여있음. 이벤트 루프 쓰레드 1에서 E1 처리 시작 이벤트 루프 쓰레드 2에서 E2 처리 시작 이벤트 루프 쓰레드 2에서 E2 처리 끝 이벤트 루프 쓰레드 2에서 E3 처리 시작 이벤트 루프 쓰레드 2에서 E3 처리 끝 이벤트 루프 쓰레드 1에서 E1 처리 끝 이벤트 처리 시작에 대한 순서는 보장할 수 있어도 순서가 상관있는 이벤트를 순차적으로 시작하고 끝내는 걸 할 수가 없다.만약 파일에서 InputStream을 열어 데이터를 읽어서(E1), 버퍼에 기록하고(E2), 스트림을 닫는다(E3)라고 하면 순서가 보장되지 않으면 데이터를 다 읽기도 전에 스트림이 닫혀버릴 수도 있다.이렇게 다중 쓰레드 이벤트 루프를 사용할 때는 순서를 보장하지 않아도 되는 이벤트에 대해서만 처리 로직을 작성하여야한다. 네티는 이런 단점을 보완하고자 이벤트 루프 쓰레드마다 이벤트 큐를 가지도록 하였다.이렇게 되면 여러 쓰레드가 하나의 자원(이벤트 큐)을 사용하고자 서로 경합을 벌이지 않아도 된다.그리고 이벤트 루프 쓰레드에 채널이 등록되고, 해당 채널에서 이벤트를 발생시키기 때문에 독립적인 이벤트 큐에 대해 하나의 이벤트 루프 쓰레드만 처리를 진행하므로 순서도 보장할 수 있다.그리고 Netty의 NioEventLoopGroup은 CPU 코어 갯수 * 2개의 이벤트 루프 쓰레드를 만들어서 컨텍스트 스위칭 비용도 최소화하였다.2배로 만드는 이유는 아마 한 쓰레드에서 병목이 발생하면(최대한 적어야겠지만) 다른 쓰레드에서 커버쳐주기 위함이 아닐까 싶다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Netty","slug":"Note/Netty","permalink":"https://perfectacle.github.io/categories/Note/Netty/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://perfectacle.github.io/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"https://perfectacle.github.io/tags/Netty/"}]},{"title":"Netty 용어사전","slug":"netty-glossary","date":"2021-02-28T00:32:51.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2021/02/28/netty-glossary/","link":"","permalink":"https://perfectacle.github.io/2021/02/28/netty-glossary/","excerpt":"Netty의 개념이 하도 익숙하지 않아 자바 네트워크 소녀 네티를 보고 용어를 정리해봄. Netty Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 네티는 비동기 이벤트 기반 네트워크 어플리케이션 프레임워크로써 유지보수를 고려한 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있다.즉, TCP 통신을 위해 무조건 Netty를 써야하는 건 아니지만 유지보수하기도 쉽고, 비동기 이벤트 기반이기 때문에 고성능도 보장하게 된다.Spring Integration 또한 TCP 통신을 지원한다. Spring Integration provides channel adapters for receiving and sending messages over internet protocols. Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.","text":"Netty의 개념이 하도 익숙하지 않아 자바 네트워크 소녀 네티를 보고 용어를 정리해봄. Netty Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 네티는 비동기 이벤트 기반 네트워크 어플리케이션 프레임워크로써 유지보수를 고려한 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있다.즉, TCP 통신을 위해 무조건 Netty를 써야하는 건 아니지만 유지보수하기도 쉽고, 비동기 이벤트 기반이기 때문에 고성능도 보장하게 된다.Spring Integration 또한 TCP 통신을 지원한다. Spring Integration provides channel adapters for receiving and sending messages over internet protocols. Both UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided. Bootstrap네티로 작성한 네트워크 어플리케이션의 동작 방식과 환경을 설정하는 도우미 클래스, 주로 클라이언트 어플리케이션에 사용된다.추상화가 잘 돼있어서 블로킹 모드에서 논블로킹 모드로 바꾸는 등의 설정이 매우 쉬우며 아래 설정이 가능하다. 전송 계층 (소켓 모드 및 I&#x2F;O 종류) 이벤트 루프 (단일 스레드, 다중 스레드) 채널 파이프라인 설정 소켓 주소와 포트 소켓 옵션 123456789101112131415161718192021fun main() &#123; // BootStrap val bootstrap = Bootstrap() // 이벤트 루프 (단일 스레드, 다중 스레드) val group: EventLoopGroup = NioEventLoopGroup() bootstrap .group(group) // 이벤트 루프 .channel(NioServerSocketChannel::class.java) // 전송 계층 (소켓 모드 및 I/O 종류) .option(ChannelOption.SO_BACKLOG, 100) // 채널 옵션 .handler(object : ChannelInitializer&lt;Channel&gt;() &#123; // 채널 데이터 가공 핸들러 override fun initChannel(ch: Channel) &#123; // 소켓 채널이 생성될 때(서버와 연결을 맺을 때) 실행됨 // 채널 파이프라인 설정 ch.pipeline().addLast(ReadTimeoutHandler(60, TimeUnit.SECONDS)) &#125; &#125;) // 서버의 주소와 포트 val f: ChannelFuture = bootstrap.connect(&quot;localhost&quot;, 8080)&#125; ServerBootstrapBootstrap 중에 서버의 설정을 돕기 위한 클래스, 주로 서버 어플리케이션에 사용된다.아래 설정이 가능하다. 전송 계층 (소켓 모드 및 I&#x2F;O 종류) 이벤트 루프 (단일 스레드, 다중 스레드) 서버 소켓 채널 이벤트 루프 소켓 채널 이벤트 루프 채널 파이프라인 설정 서버 소켓 채널 파이프라인 설정 소켓 채널 파이프라인 설정 소켓 주소와 포트 소켓 옵션 서버 소켓 채널은 특정 포트를 listen하고 있다가 해당 포트로 커넥션 요청이 들어오면 해당 커넥션을 요청한 클라이언트와 통신하기 위해 소켓 채널을 만든다.실질적인 통신은 소켓 채널에서 이루어진다. 1234567891011121314151617181920212223242526272829303132fun main() &#123; // ServerBootStrap val bootstrap = ServerBootstrap() // 이벤트 루프 (단일 스레드, 다중 스레드) val bossGroup: EventLoopGroup = NioEventLoopGroup() val workerGroup: EventLoopGroup = NioEventLoopGroup() bootstrap .group( bossGroup, // 서버 소켓 채널 이벤트 루프 workerGroup // 소켓 채널 이벤트 루프 ) .channel(NioServerSocketChannel::class.java) // 전송 계층 (소켓 모드 및 I/O 종류) .option(ChannelOption.SO_BACKLOG, 100) // 서버 소켓 채널 옵션 .childOption(ChannelOption.TCP_NODELAY, false) // 소켓 채널 옵션 .handler(object : ChannelInitializer&lt;Channel&gt;() &#123; // 서버 소켓 채널 override fun initChannel(ch: Channel) &#123; // 서버 소켓 채널 데이터 가공 핸들러 (서버 소켓 채널이 생성될 때(서버 소켓에 포트가 바인딩될 때) 실행됨) // 서버 소켓 채널 파이프라인 설정 ch.pipeline().addLast(ReadTimeoutHandler(60, TimeUnit.SECONDS)) &#125; &#125;) .childHandler(object : ChannelInitializer&lt;Channel&gt;() &#123; // 소켓 채널 override fun initChannel(ch: Channel) &#123; // 소켓 채널 데이터 가공 핸들러 (소켓 채널이 생성될 때(클라이언트와 연결을 맺을 때) 실행됨) // 소켓 채널 파이프라인 설정 ch.pipeline().addLast(ReadTimeoutHandler(60, TimeUnit.SECONDS)) &#125; &#125;) // 서버 소켓 채널 주소와 포트 val f: ChannelFuture = bootstrap.bind(123)&#125; EventLoopGroupEventLoop를 그룹핑한 것이다.여러 EventLoop가 존재하는데 그 중에 나는 NioEventLoopGroup를 주로 사용한다. 1public class NioEventLoopGroup extends MultithreadEventLoopGroup &#123; NioEventLoopGroup은 멀티쓰레드 환경의 이벤트 루프 그룹이다.또한 NioEventLoopGroup은 기본 생성자를 사용하면 CPU 코어 수 * 2개의 EventLoop가 생성된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class NioEventLoopGroup extends MultithreadEventLoopGroup &#123; public NioEventLoopGroup() &#123; this(0); &#125; // ... public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) &#123; super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject()); &#125;&#125;public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup &#123; private static final int DEFAULT_EVENT_LOOP_THREADS; static &#123; DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); // &lt;-- CPU 코어 갯수에 2를 곱하고 있다. &#125; protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); // &lt;-- 기본 생성자는 nThreads가 0이다. &#125;&#125;public final class NettyRuntime &#123; public static int availableProcessors() &#123; return holder.availableProcessors(); &#125; private static final AvailableProcessorsHolder holder = new AvailableProcessorsHolder(); static class AvailableProcessorsHolder &#123; private int availableProcessors; synchronized int availableProcessors() &#123; if (this.availableProcessors == 0) &#123; final int availableProcessors = SystemPropertyUtil.getInt( &quot;io.netty.availableProcessors&quot;, Runtime.getRuntime().availableProcessors() // &lt;-- 여기에서 CPU 코어 갯수를 반환함. ); setAvailableProcessors(availableProcessors); &#125; return this.availableProcessors; &#125; synchronized void setAvailableProcessors(final int availableProcessors) &#123; ObjectUtil.checkPositive(availableProcessors, &quot;availableProcessors&quot;); if (this.availableProcessors != 0) &#123; final String message = String.format( Locale.ROOT, &quot;availableProcessors is already set to [%d], rejecting [%d]&quot;, this.availableProcessors, availableProcessors ); throw new IllegalStateException(message); &#125; this.availableProcessors = availableProcessors; &#125; &#125;&#125; 이제 CPU 코어수 * 2개라는 건 알았으니까 정말로 그만큼의 NioEventLoop이 생성되는지 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup &#123; protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); // &lt;-- 기본 생성자는 nThreads가 0이다. &#125; protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) &#123; this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args); &#125; private final EventExecutor[] children; protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads)); &#125; if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; children = new EventExecutor[nThreads]; // 코어 갯수 * 2개의 배열 생성 for (int i = 0; i &lt; nThreads; i ++) &#123; // 코어 갯수 * 2개만큼 반복 boolean success = false; try &#123; children[i] = newChild(executor, args); // ... &#125; &#125; &#125;&#125;public class NioEventLoopGroup extends MultithreadEventLoopGroup &#123; @Override protected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; EventLoopTaskQueueFactory queueFactory = args.length == 4 ? (EventLoopTaskQueueFactory) args[3] : null; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2], queueFactory); &#125;&#125; EventLoopEventLoop는 이벤트가 올 때까지 무한 반복을 도는 쓰레드이다.EventLoopGroup에 따라 어떤 EventLoop가 생성될지 모르는데 나는 주로 NioEventLoopGroup을 사용하다보니 NioEventLoop를 파보았다. 123456789public final class NioEventLoop extends SingleThreadEventLoop &#123; @Override protected void run() &#123; int selectCnt = 0; for (; ; ) &#123; // 무한 반복 // ... &#125; &#125;&#125; NioEventLoop는 단일 쓰레드 이벤트 루프이다. (하나의 이벤트 루프에 하나의 쓰레드 할당)그럼 이벤트가 올 때까지 해당 쓰레드가 block되는 건 아닐까? 하는 의문이 들었다. 1234567891011121314151617181920212223242526public final class NioEventLoop extends SingleThreadEventLoop &#123; private final SelectorProvider provider; NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123; super(parent, executor, false, newTaskQueue(queueFactory), newTaskQueue(queueFactory), rejectedExecutionHandler); this.provider = ObjectUtil.checkNotNull(selectorProvider, &quot;selectorProvider&quot;); this.selectStrategy = ObjectUtil.checkNotNull(strategy, &quot;selectStrategy&quot;); final SelectorTuple selectorTuple = openSelector(); this.selector = selectorTuple.selector; this.unwrappedSelector = selectorTuple.unwrappedSelector; &#125; private final IntSupplier selectNowSupplier = new IntSupplier() &#123; @Override public int get() throws Exception &#123; return selectNow(); &#125; &#125;; int selectNow() throws IOException &#123; return selector.selectNow(); &#125;&#125; selector는 io.netty.channel.nio.SelectedSelectionKeySetSelector 클래스이다.그리고 그 안에 delegate는 KQueueSelectorImpl이다.JRE마다 SelectorImpl은 달라질 수 있다. 1234567891011Windows sun.nio.ch.WindowsSelectorImplMac OS sun.nio.ch.KQueueSelectorImplLinux sun.nio.ch.EPollSelectorImplSolarissun.nio.ch.PollSelectorImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263final class SelectedSelectionKeySetSelector extends Selector &#123; private final SelectedSelectionKeySet selectionKeys; private final Selector delegate; @Override public int selectNow() throws IOException &#123; selectionKeys.reset(); return delegate.selectNow(); &#125;&#125;public abstract class SelectorImpl extends AbstractSelector&#123; public int selectNow() throws IOException &#123; return lockAndDoSelect(0); &#125; private int lockAndDoSelect(long timeout) throws IOException &#123; synchronized (this) &#123; if (!isOpen()) throw new ClosedSelectorException(); synchronized (publicKeys) &#123; synchronized (publicSelectedKeys) &#123; return doSelect(timeout); &#125; &#125; &#125; &#125;&#125;class KQueueSelectorImpl extends SelectorImpl &#123; protected int doSelect(long var1) throws IOException &#123; boolean var3 = false; if (this.closed) &#123; throw new ClosedSelectorException(); &#125; else &#123; this.processDeregisterQueue(); int var7; try &#123; this.begin(); var7 = this.kqueueWrapper.poll(var1); &#125; finally &#123; this.end(); &#125; this.processDeregisterQueue(); return this.updateSelectedKeys(var7); &#125; &#125;&#125;class KQueueArrayWrapper &#123; int poll(long var1) &#123; this.updateRegistrations(); // var1은 timeout에서 넘어온 0이므로 블락시키지 않고 바로 다음 구문으로 간다. int var3 = this.kevent0(this.kq, this.keventArrayAddress, 128, var1); return var3; &#125; private native int kevent0(int var1, long var2, int var4, long var5);&#125; selectNow 메서드는 KQueue의 timeout에 0을 넘기기 때문에 기다리지 않는다. ByteBuf자바의 바이트 버퍼 클래스(java.nio.ByteBuffer)와 유사하지만 더 나은 성능과 편의성을 가진 Netty의 버퍼 클래스 Channel일반적인 소켓 프로그래밍에서 말하는 소켓과 같다고 보면 된다고 함. Channel Pipeline네티의 채널과 이벤트 핸들러 사이에서 연결 통로 역할을 수행.채널에서 발생한 이벤트가 채널 파이프라인을 타고 흘러가고, 이벤트 핸들러는 이벤트를 수신한 후에 본인이 처리해야하는 이벤트인지 판단하고 처리한다. EventInbound Event연결 상대방이 어떤 동작을 취했을 때 발생함 channelRegistered - 채널이 이벤트 루프에 등록되었을 때 발생서버 소켓 채널의 channelRegistered 이벤트는 서버 소켓 채널이 생성됐을 때 발생하고, 클라이언트 소켓 채널의 channelRegistered 이벤트는 새로운 클라이언트가 서버에 접속하며 클라이언트 소켓 채널이 생성될 때 발생한다. channelActive - channelRegistered 이후에 발생채널이 생성되고 이벤트 루프에 등록된 이후에 네티 API를 사용하여 입출력을 수행할 상태가 되었음을 알려주는 이벤트 channelRead - 데이터가 수신될 때마다 발생하는 이벤트 channelReadComplete - 데이터 수신이 완료됐을 때 발생하는 이벤트channelRead 이벤트는 채널에 데이터가 있을 때 발생하고, channelReadComplete는 채널의 데이터를 다 읽어서 더 이상 데이터가 없을 때 발생한다. channelInactive - 채널이 비활성화되었을 때 발생 channelUnregistered - 채널이 이벤트 루프에 제거되었을 대 발생 Outbound Event프로그래머가 요청한 동작에 해당하는 이벤트 bind - 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생 connect - 클라이언트 소켓 채널이 서버에 연결되었을 때 발생 disconnect - 클라이언트 소켓 채널의 연결이 끊어졌을 때 발생 close - 클라이언트 소켓 채널의 연결이 닫혔을 때 발생 write - 소켓 채널에 데이터가 기록되었을 때 발생 flush - 소켓 채널에 flush 메서드가 호출되었을 때 발생 Event Handler이벤트가 발생했을 때 이벤트를 처리하는 역할을 담당한다.크게 이벤트 유형에 따라 ChannelInboundHandler, ChannelOutboundHandler 인터페이스로 나눌 수 있다. ChannelHandlerContext채널에 대한 입출력 처리 및 채널 파이프라인에 대한 상호작용을 도와주는 인터페이스ChannelHandlerContext의 writeAndFlush 메서드로 채널에 데이터를 기록하거나 close 메서드로 채널의 연결을 종료할 수 있다.또한 ChannelHandlerContext는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메서드를 제공하기 때문에 채널 파이프라인을 수정할 수 있다. 12345bootstrap.handler(object : ChannelInitializer&lt;Channel&gt;() &#123; override fun initChannel(ch: Channel) &#123; ch.pipeline().addLast(ReadTimeoutHandler(60, TimeUnit.SECONDS)) &#125; &#125;) Codec보통 동영상 압축 알고리즘을 코덱이라 부름. 원본 -&gt; 인코딩(압축) -&gt; 압축된 동영상 파일 압축된 동영상 파일 -&gt; 디코딩 (압축 해제) -&gt; 원본 파일 Encoder (Outbound Event Handler)송신 데이터 -&gt; 인코더 (데이터 변환 알고리즘) -&gt; 소켓 채널 Decoder (Inbound Event Handler)소켓 채널 -&gt; 디코더 (데이터 변환 알고리즘) -&gt; 수신 데이터","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Netty","slug":"Note/Netty","permalink":"https://perfectacle.github.io/categories/Note/Netty/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://perfectacle.github.io/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"https://perfectacle.github.io/tags/Netty/"}]},{"title":"(Spring Boot) SimpleClientHttpRequestFactory와 Connection Pool","slug":"simple-client-http-request-factory-connection-pool","date":"2021-02-14T13:04:05.000Z","updated":"2022-10-30T08:42:16.903Z","comments":true,"path":"2021/02/14/simple-client-http-request-factory-connection-pool/","link":"","permalink":"https://perfectacle.github.io/2021/02/14/simple-client-http-request-factory-connection-pool/","excerpt":"N줄 요약SimpleClientHttpRequestFactory(RestTemplate을 기본생성자로 만들었을 때 사용하는)를 사용하더라도 내부에서 KeepAliveCache를 사용하여 커넥션 풀을 관리한다.기본적으로 KeepAliveKey(protocol, host, port) 당 5개의 풀을 가지며 시스템 프로퍼티 http.maxConnections를 할당해주면 늘릴 수 있다.커넥션 풀을 초과하면 커넥션은 바로 종료되며, 커넥션 풀 내의 커넥션은 매번 연결을 맺고 끊는 게 아니라 재사용 된다.당연하게도 서버에서 Keep-Alive를 사용하지 않으면 매번 커넥션이 종료된다.그럼에도 불구하고 SimpleClientHttpRequestFactory는 다음의 단점이 있기 때문에 토이 프로젝트가 아닌 이상 HttpComponentsClientHttpRequestFactory 같은 다른 구현체를 사용해야할 것 같다. http.maxConnections라는 시스템 프로퍼티를 설정해야하는데 설정을 위해 자주 사용하던 properties(yml)에는 설정할 수 없다보니 다른 방법으로 설정을 해줘야하고, 그러다 보면 설정을 파악하려면 한 군데(properties 또는 yml)만 집중해서는 파악할 수 없는 내용도 있다보니 실수할 여지가 발생할 수 있다. KeepAliveCache가 static 변수이다보니 서로 다른 SimpleClientHttpRequestFactory여도 동일한 커넥션 풀을 참조한다. route(프로토콜, 호스트, 포트) 별 커넥션 풀은 설정할 수 있지만 토탈 커넥션 풀은 제한이 없다. SimpleClientHttpRequestFactory가 뭐지??RestTemplate의 기본 생성자를 사용하면 ClientHttpRequestFactory를 별도로 초기화하지 않으므로 기본값인 SimpleClientHttpRequestFactory를 사용한다.","text":"N줄 요약SimpleClientHttpRequestFactory(RestTemplate을 기본생성자로 만들었을 때 사용하는)를 사용하더라도 내부에서 KeepAliveCache를 사용하여 커넥션 풀을 관리한다.기본적으로 KeepAliveKey(protocol, host, port) 당 5개의 풀을 가지며 시스템 프로퍼티 http.maxConnections를 할당해주면 늘릴 수 있다.커넥션 풀을 초과하면 커넥션은 바로 종료되며, 커넥션 풀 내의 커넥션은 매번 연결을 맺고 끊는 게 아니라 재사용 된다.당연하게도 서버에서 Keep-Alive를 사용하지 않으면 매번 커넥션이 종료된다.그럼에도 불구하고 SimpleClientHttpRequestFactory는 다음의 단점이 있기 때문에 토이 프로젝트가 아닌 이상 HttpComponentsClientHttpRequestFactory 같은 다른 구현체를 사용해야할 것 같다. http.maxConnections라는 시스템 프로퍼티를 설정해야하는데 설정을 위해 자주 사용하던 properties(yml)에는 설정할 수 없다보니 다른 방법으로 설정을 해줘야하고, 그러다 보면 설정을 파악하려면 한 군데(properties 또는 yml)만 집중해서는 파악할 수 없는 내용도 있다보니 실수할 여지가 발생할 수 있다. KeepAliveCache가 static 변수이다보니 서로 다른 SimpleClientHttpRequestFactory여도 동일한 커넥션 풀을 참조한다. route(프로토콜, 호스트, 포트) 별 커넥션 풀은 설정할 수 있지만 토탈 커넥션 풀은 제한이 없다. SimpleClientHttpRequestFactory가 뭐지??RestTemplate의 기본 생성자를 사용하면 ClientHttpRequestFactory를 별도로 초기화하지 않으므로 기본값인 SimpleClientHttpRequestFactory를 사용한다. 1public class RestTemplate extends InterceptingHttpAccessor implements RestOperations &#123; 1public abstract class InterceptingHttpAccessor extends HttpAccessor &#123; 123456public abstract class HttpAccessor &#123; /** Logger available to subclasses. */ protected final Log logger = HttpLogging.forLogName(getClass()); private ClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory(); ClientHttpRequest의 javadoc을 보면 아래와 같이 나와있다. Represents a client-side HTTP request. Created via an implementation of the ClientHttpRequestFactory. A ClientHttpRequest can be executed, receiving a ClientHttpResponse which can be read from. ClientHttpRequest는 클라이언트 측면의 HttpRequest이며, ClientHttpRequestFactory 구현체에 의해 생성된다.ClientHttpRequest는 실행될 수 있으머, ClientHttpResponse를 받아서 읽을 수 있다.대충 해석해보면 그냥 팩토리로 request 만들어서 서버로 전송하고 응답받을 수 있다는 내용 같다. HTTP 통신을 사용할 때 사용하다보니 SimpleClientHttpRequestFactory에는 기본적인 타임아웃을 설정할 수 있다. 1234567891011121314151617public class SimpleClientHttpRequestFactory implements ClientHttpRequestFactory, AsyncClientHttpRequestFactory &#123; private static final int DEFAULT_CHUNK_SIZE = 4096; @Nullable private Proxy proxy; private boolean bufferRequestBody = true; private int chunkSize = DEFAULT_CHUNK_SIZE; private int connectTimeout = -1; private int readTimeout = -1; // ...&#125; 그리고 ClientHttpRequestFactory는 RestTemplate을 이용하여 통신할 때 사용된다. 12345678910111213141516171819202122232425262728293031323334353637public class RestTemplate extends InterceptingHttpAccessor implements RestOperations &#123; // ... @Override @Nullable public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables); &#125; // ... @Override @Nullable public &lt;T&gt; T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables) throws RestClientException &#123; URI expanded = getUriTemplateHandler().expand(url, uriVariables); return doExecute(expanded, method, requestCallback, responseExtractor); &#125; // ... @Nullable protected &lt;T&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor) throws RestClientException &#123; Assert.notNull(url, &quot;URI is required&quot;); Assert.notNull(method, &quot;HttpMethod is required&quot;); ClientHttpResponse response = null; try &#123; ClientHttpRequest request = createRequest(url, method); if (requestCallback != null) &#123; requestCallback.doWithRequest(request); &#125; response = request.execute(); // ... &#125; // ...&#125; doExecute에서 호출하는 createRequest는 HttpAccessor에 있는 메서드이다. 1234567891011121314151617181920public abstract class HttpAccessor &#123; // ... /** * Create a new &#123;@link ClientHttpRequest&#125; via this template&#x27;s &#123;@link ClientHttpRequestFactory&#125;. * @param url the URL to connect to * @param method the HTTP method to execute (GET, POST, etc) * @return the created request * @throws IOException in case of I/O errors * @see #getRequestFactory() * @see ClientHttpRequestFactory#createRequest(URI, HttpMethod) */ protected ClientHttpRequest createRequest(URI url, HttpMethod method) throws IOException &#123; ClientHttpRequest request = getRequestFactory().createRequest(url, method); initialize(request); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;HTTP &quot; + method.name() + &quot; &quot; + url); &#125; return request; &#125;&#125; 그리고 SimpleClientHttpRequestFactory의 createRequest 메서드를 보면 요청을 보내기 위해 HttpURLConnection을 사용한다는 사실을 알 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * &#123;@link ClientHttpRequestFactory&#125; implementation that uses standard JDK facilities. * * @author Arjen Poutsma * @author Juergen Hoeller * @since 3.0 * @see java.net.HttpURLConnection * @see HttpComponentsClientHttpRequestFactory */@SuppressWarnings(&quot;deprecation&quot;)public class SimpleClientHttpRequestFactory implements ClientHttpRequestFactory, AsyncClientHttpRequestFactory &#123; // ... @Override public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException &#123; HttpURLConnection connection = openConnection(uri.toURL(), this.proxy); prepareConnection(connection, httpMethod.name()); if (this.bufferRequestBody) &#123; return new SimpleBufferingClientHttpRequest(connection, this.outputStreaming); &#125; else &#123; return new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming); &#125; &#125; // ... /** * Opens and returns a connection to the given URL. * &lt;p&gt;The default implementation uses the given &#123;@linkplain #setProxy(java.net.Proxy) proxy&#125; - * if any - to open a connection. * @param url the URL to open a connection to * @param proxy the proxy to use, may be &#123;@code null&#125; * @return the opened connection * @throws IOException in case of I/O errors */ protected HttpURLConnection openConnection(URL url, @Nullable Proxy proxy) throws IOException &#123; URLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection()); if (!(urlConnection instanceof HttpURLConnection)) &#123; throw new IllegalStateException( &quot;HttpURLConnection required for [&quot; + url + &quot;] but got: &quot; + urlConnection); &#125; return (HttpURLConnection) urlConnection; &#125; // ...&#125; SimpleClientHttpRequestFactory는 정말로 커넥션 풀을 사용하지 않을까?내 머릿 속 어딘가에서는 SimpleClientHttpRequestFactory는 커넥션 풀을 사용하지 않는다고 기억을 하고 있다.이 말 뜻은 매번 커넥션을 맺고 끊는다는 것인데 Keep-Alive 메커니즘을 전혀 따르지 않는 것으로 보였다. 정말 이 말이 사실일까 싶어서 테스트를 해보았다.우선 로컬에 간단한 서버를 띄워야하니 컨트롤러를 추가하자. 12345@RestControllerclass Controller &#123; @GetMapping fun a() &#123;&#125;&#125; 이제 SimpleClientHttpRequestFactory를 사용하는 테스트를 작성해보자. 12345678910111213141516171819202122232425262728@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)class RestTemplateConnectionPoolTest( @LocalServerPort private val port: Int) &#123; @Test fun `총 12개의 요청을 두 번에 끊어서 동시에 6개씩 전송`() &#123; val threadCount = 6 val threadPool = Executors.newFixedThreadPool(threadCount) val futures = mutableListOf&lt;CompletableFuture&lt;String?&gt;&gt;() val restTemplate = RestTemplate() val total = threadCount * 2 for (i in 1..total) &#123; futures.add(CompletableFuture.supplyAsync( // 와이어샤크의 패킷 캡쳐를 위해 일부러 private IP를 직접 박음 &#123; restTemplate.getForObject(&quot;http://192.168.0.144:$&#123;port&#125;&quot;, String::class.java) &#125;, threadPool )) &#125; futures.forEach &#123; it.join() &#125; // spring-boot-starter-web 모듈의 기본 내장 서버인 embedded tomcat의 // 기본 Keep-Alive 헤더의 timeout 파라미터 값인 60초 이후에 커넥션이 끊기는지 확인하기 위해 서버 종료를 딜레이 시킴. Thread.sleep(70_000) &#125;&#125; 와이어샤크를 통해 패킷 캡쳐를 해보니 6개의 커넥션이 동시에 맺혀지고 있다. 커넥션 풀을 사용하지 않는다면 모든 커넥션이 종료돼야하는데 하나의 커넥션만 종료되고 있다.가장 처음 응답을 받은 소켓(50322 포트)이 닫혔다.그리고 다음에 또 6개의 요청을 보내야하는데 커넥션이 하나 모자르므로 소켓(50324 포트)을 하나 더 열어서 커넥션을 맺었다. 위와 동일하게 50324 포트는 응답을 받자마자 바로 커넥션이 끊겼다.그리고 나머지 5개의 커넥션은 Keep-Alive의 timeout 파라미터인 60초 이후에 커넥션이 끊기기 시작했다. SimpleClientHttpRequestFactory와 커넥션 풀위 테스트를 토대로 SimpleClientHttpRequestFactory가 커넥션 풀을 사용은 하는 것 같은데 최대 5개가 아닐까 의심이 들었다. 그래서 다시 한 번 RestTemplate의 getForObject 메서드에 브레이크 포인트를 걸고 쫓아가보았다. 123456789101112131415161718192021222324252627282930313233343536public class RestTemplate extends InterceptingHttpAccessor implements RestOperations &#123; // ... @Override @Nullable public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables); &#125; // ... @Override @Nullable public &lt;T&gt; T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables) throws RestClientException &#123; URI expanded = getUriTemplateHandler().expand(url, uriVariables); return doExecute(expanded, method, requestCallback, responseExtractor); &#125; // ... @Nullable protected &lt;T&gt; T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor&lt;T&gt; responseExtractor) throws RestClientException &#123; Assert.notNull(url, &quot;URI is required&quot;); Assert.notNull(method, &quot;HttpMethod is required&quot;); ClientHttpResponse response = null; try &#123; ClientHttpRequest request = createRequest(url, method); if (requestCallback != null) &#123; requestCallback.doWithRequest(request); &#125; response = request.execute(); // ... &#125;&#125; request는 SimpleClientHttpRequestFactory에 의해 생성됐기 때문에 HttpURLConnection을 가지고 있다.그리고 request.execute()를 쭉 타고가보자. 1234567891011public abstract class AbstractClientHttpRequest implements ClientHttpRequest &#123; // ... @Override public final ClientHttpResponse execute() throws IOException &#123; assertNotExecuted(); ClientHttpResponse result = executeInternal(this.headers); this.executed = true; return result; &#125; // ...&#125; 1234567891011121314abstract class AbstractBufferingClientHttpRequest extends AbstractClientHttpRequest &#123; // ... @Override protected ClientHttpResponse executeInternal(HttpHeaders headers) throws IOException &#123; byte[] bytes = this.bufferedOutput.toByteArray(); if (headers.getContentLength() &lt; 0) &#123; headers.setContentLength(bytes.length); &#125; ClientHttpResponse result = executeInternal(headers, bytes); this.bufferedOutput = new ByteArrayOutputStream(0); return result; &#125; // ...&#125; 123456789101112131415161718192021222324final class SimpleBufferingClientHttpRequest extends AbstractBufferingClientHttpRequest &#123; // ... @Override protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException &#123; addHeaders(this.connection, headers); // JDK &lt;1.8 doesn&#x27;t support getOutputStream with HTTP DELETE if (getMethod() == HttpMethod.DELETE &amp;&amp; bufferedOutput.length == 0) &#123; this.connection.setDoOutput(false); &#125; if (this.connection.getDoOutput() &amp;&amp; this.outputStreaming) &#123; this.connection.setFixedLengthStreamingMode(bufferedOutput.length); &#125; this.connection.connect(); if (this.connection.getDoOutput()) &#123; FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream()); &#125; else &#123; // Immediately trigger the request in a no-output scenario as well this.connection.getResponseCode(); &#125; return new SimpleClientHttpResponse(this.connection); &#125; // ...&#125; this.connection.connect()에서 실제 커넥션을 맺는데 한번 들어가보자. 12345678910111213141516171819202122232425262728public class HttpURLConnection extends java.net.HttpURLConnection &#123; // ... public void connect() throws IOException &#123; synchronized (this) &#123; connecting = true; &#125; plainConnect(); &#125; // ... protected void plainConnect() throws IOException &#123; // ... plainConnect0(); // ... &#125; // ... protected void plainConnect0() throws IOException &#123; // ... http = getNewHttpClient(url, p, connectTimeout, false); // ... &#125; // ... // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout) throws IOException &#123; return HttpClient.New(url, p, connectTimeout, this); &#125; // ...&#125; 이제 HttpClient 클래스를 봐보자. 12345678910111213141516171819202122232425262728293031public class HttpClient extends NetworkClient &#123; /* where we cache currently open, persistent connections */ protected static KeepAliveCache kac = new KeepAliveCache(); // ... public static HttpClient New(URL url, Proxy p, int to, HttpURLConnection httpuc) throws IOException &#123; return New(url, p, to, true, httpuc); &#125; // ... public static HttpClient New(URL url, Proxy p, int to, boolean useCache, HttpURLConnection httpuc) throws IOException &#123; if (p == null) &#123; p = Proxy.NO_PROXY; &#125; HttpClient ret = null; /* see if one&#x27;s already around */ if (useCache) &#123; ret = kac.get(url, null); // ... &#125; if (ret == null) &#123; ret = new HttpClient(url, p, to); &#125; else &#123; // ... &#125; return ret; &#125; // ...&#125; kac.get(url, null) - KeepAliveCache에 이미 커넥션이 존재하는지 확인하고 없으면 새로운 커넥션을 맺고 있다.protected static KeepAliveCache kac = new KeepAliveCache();에서 보다싶이 KeepAliveCache는 static 변수이다보니 어플리케이션 전역에서 공유되는 자원이다. (즉, 서로 다른 SimpleClientHttpRequestFactory를 가진 RestTemplate이라도 커넥션 풀을 공유한다는 소리다.)캐시에 이미 맺어진 커넥션이 캐시에 존재한다면 그걸 사용하고, 아니면 다시 tcp 커넥션을 맺는다.이제 KeepAliveCache가 어떻게 생겨먹었는지 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class KeepAliveCache extends HashMap&lt;KeepAliveKey, ClientVector&gt; implements Runnable &#123; // ... public synchronized HttpClient get(URL url, Object obj) &#123; KeepAliveKey key = new KeepAliveKey(url, obj); ClientVector v = super.get(key); if (v == null) &#123; // nothing in cache yet return null; &#125; return v.get(); &#125; // ...&#125;class KeepAliveKey &#123; private String protocol = null; private String host = null; private int port = 0; private Object obj = null; // additional key, such as socketfactory /** * Constructor * * @param url the URL containing the protocol, host and port information */ public KeepAliveKey(URL url, Object obj) &#123; this.protocol = url.getProtocol(); this.host = url.getHost(); this.port = url.getPort(); this.obj = obj; &#125; /** * Determine whether or not two objects of this type are equal */ @Override public boolean equals(Object obj) &#123; if ((obj instanceof KeepAliveKey) == false) return false; KeepAliveKey kae = (KeepAliveKey)obj; return host.equals(kae.host) &amp;&amp; (port == kae.port) &amp;&amp; protocol.equals(kae.protocol) &amp;&amp; this.obj == kae.obj; &#125; /** * The hashCode() for this object is the string hashCode() of * concatenation of the protocol, host name and port. */ @Override public int hashCode() &#123; String str = protocol+host+port; return this.obj == null? str.hashCode() : str.hashCode() + this.obj.hashCode(); &#125;&#125;class ClientVector extends java.util.Stack&lt;KeepAliveEntry&gt; &#123; // ... synchronized HttpClient get() &#123; if (empty()) &#123; return null; &#125; else &#123; // Loop until we find a connection that has not timed out HttpClient hc = null; long currentTime = System.currentTimeMillis(); do &#123; KeepAliveEntry e = pop(); if ((currentTime - e.idleStartTime) &gt; nap) &#123; e.hc.closeServer(); &#125; else &#123; hc = e.hc; &#125; &#125; while ((hc== null) &amp;&amp; (!empty())); return hc; &#125; &#125; // ...&#125;class KeepAliveEntry &#123; HttpClient hc; long idleStartTime; KeepAliveEntry(HttpClient hc, long idleStartTime) &#123; this.hc = hc; this.idleStartTime = idleStartTime; &#125;&#125; KeepAliveCache를 보면 KeepAliveKey(프로토콜, 호스트, 포트)를 키로 가지고 있고, ClientVector(Stack을 상속받음)에 실제 커넥션(KeepAliveEntry)들이 들어있다.그리고 스택에서 하나씩 커넥션을 꺼내오고 있다. 그럼 언제 KeepAliveCache에 put 할까?? 123456789101112131415161718192021222324final class SimpleBufferingClientHttpRequest extends AbstractBufferingClientHttpRequest &#123; // ... @Override protected ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException &#123; addHeaders(this.connection, headers); // JDK &lt;1.8 doesn&#x27;t support getOutputStream with HTTP DELETE if (getMethod() == HttpMethod.DELETE &amp;&amp; bufferedOutput.length == 0) &#123; this.connection.setDoOutput(false); &#125; if (this.connection.getDoOutput() &amp;&amp; this.outputStreaming) &#123; this.connection.setFixedLengthStreamingMode(bufferedOutput.length); &#125; this.connection.connect(); if (this.connection.getDoOutput()) &#123; FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream()); &#125; else &#123; // Immediately trigger the request in a no-output scenario as well this.connection.getResponseCode(); &#125; return new SimpleClientHttpResponse(this.connection); &#125; // ...&#125; 커넥션을 모두 끝마치고 this.connection.getResponseCode() 쪽을 주목해보자. 12345678910111213141516171819202122232425abstract public class HttpURLConnection extends URLConnection &#123; // ... public int getResponseCode() throws IOException &#123; /* * We&#x27;re got the response code already */ if (responseCode != -1) &#123; return responseCode; &#125; /* * Ensure that we have connected to the server. Record * exception as we need to re-throw it if there isn&#x27;t * a status line. */ Exception exc = null; try &#123; getInputStream(); &#125; catch (Exception e) &#123; exc = e; &#125; // ... &#125; // ...&#125; 1234567891011121314151617181920public class HttpURLConnection extends java.net.HttpURLConnection &#123; // ... protected HttpClient http; // ... @Override public synchronized InputStream getInputStream() throws IOException &#123; // ... return getInputStream0(); // ... &#125; // ... private synchronized InputStream getInputStream0() throws IOException &#123; // ... http.parseHTTP(responses, pi, this); // ... http.finished(); // ... &#125; // ...&#125; 먼저 parseHTTP부터 봐보자 (응답의 헤더를 파싱한다) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class HttpClient extends NetworkClient &#123; // ... volatile boolean keepingAlive = false; /* this is a keep-alive connection */ volatile boolean disableKeepAlive;/* keep-alive has been disabled for this connection - this will be used when recomputing the value of keepingAlive */ int keepAliveConnections = -1; /* number of keep-alives left */ /**Idle timeout value, in milliseconds. Zero means infinity, * iff keepingAlive=true. * Unfortunately, we can&#x27;t always believe this one. If I&#x27;m connected * through a Netscape proxy to a server that sent me a keep-alive * time of 15 sec, the proxy unilaterally terminates my connection * after 5 sec. So we have to hard code our effective timeout to * 4 sec for the case where we&#x27;re using a proxy. *SIGH* */ int keepAliveTimeout = 0; // ... /** Parse the first line of the HTTP request. It usually looks something like: &quot;HTTP/1.0 &lt;number&gt; comment\\r\\n&quot;. */ public boolean parseHTTP(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc) throws IOException &#123; /* If &quot;HTTP/*&quot; is found in the beginning, return true. Let * HttpURLConnection parse the mime header itself. * * If this isn&#x27;t valid HTTP, then we don&#x27;t try to parse a header * out of the beginning of the response into the responses, * and instead just queue up the output stream to it&#x27;s very beginning. * This seems most reasonable, and is what the NN browser does. */ try &#123; serverInput = serverSocket.getInputStream(); if (capture != null) &#123; serverInput = new HttpCaptureInputStream(serverInput, capture); &#125; serverInput = new BufferedInputStream(serverInput); return (parseHTTPHeader(responses, pi, httpuc)); &#125; // ... &#125; // ... private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc) throws IOException &#123; /* If &quot;HTTP/*&quot; is found in the beginning, return true. Let * HttpURLConnection parse the mime header itself. * * If this isn&#x27;t valid HTTP, then we don&#x27;t try to parse a header * out of the beginning of the response into the responses, * and instead just queue up the output stream to it&#x27;s very beginning. * This seems most reasonable, and is what the NN browser does. */ keepAliveConnections = -1; keepAliveTimeout = 0; // ... HeaderParser p = new HeaderParser(responses.findValue(&quot;Keep-Alive&quot;)); /* default should be larger in case of proxy */ keepAliveConnections = p.findInt(&quot;max&quot;, usingProxy?50:5); keepAliveTimeout = p.findInt(&quot;timeout&quot;, usingProxy?60:5); // ... &#125; // ...&#125; Keep-Alive 헤더를 파싱해서 max(커넥션 재활용 가능 횟수), timeout(응답 이후 커넥션 유지 기간) 파라미터의 값을 가져오고 있는데 proxy를 쓰지 않는다는 가정하에 둘 다 기본값이 5이다.그리고 이번에는 finished 메서드를 봐보자. 123456789101112131415161718192021222324252627282930313233343536373839public class HttpClient extends NetworkClient &#123; // ... /* return it to the cache as still usable, if: * 1) It&#x27;s keeping alive, AND * 2) It still has some connections left, AND * 3) It hasn&#x27;t had a error (PrintStream.checkError()) * 4) It hasn&#x27;t timed out * * If this client is not keepingAlive, it should have been * removed from the cache in the parseHeaders() method. */ public void finished() &#123; if (reuse) /* will be reused */ return; keepAliveConnections--; poster = null; if (keepAliveConnections &gt; 0 &amp;&amp; isKeepingAlive() &amp;&amp; !(serverOutput.checkError())) &#123; /* This connection is keepingAlive &amp;&amp; still valid. * Return it to the cache. */ putInKeepAliveCache(); &#125; else &#123; closeServer(); &#125; &#125; // ... protected synchronized void putInKeepAliveCache() &#123; if (inCache) &#123; assert false : &quot;Duplicate put to keep alive cache&quot;; return; &#125; inCache = true; kac.put(url, null, this); &#125; // ...&#125; keepAliveConnections(max 파라미터)에서 하나 까고 커넥션 재사용 횟수가 아직 남아있다면 KeepAliveCache에 집어넣고 있다. 1234567891011121314151617181920212223242526272829303132333435363738public class KeepAliveCache extends HashMap&lt;KeepAliveKey, ClientVector&gt; implements Runnable &#123; // ... /** * Register this URL and HttpClient (that supports keep-alive) with the cache * @param url The URL contains info about the host and port * @param http The HttpClient to be cached */ public synchronized void put(final URL url, Object obj, HttpClient http) &#123; // ... KeepAliveKey key = new KeepAliveKey(url, obj); ClientVector v = super.get(key); if (v == null) &#123; int keepAliveTimeout = http.getKeepAliveTimeout(); v = new ClientVector(keepAliveTimeout &gt; 0? keepAliveTimeout*1000 : LIFETIME); v.put(http); super.put(key, v); &#125; else &#123; v.put(http); &#125; &#125;&#125;class ClientVector extends java.util.Stack&lt;KeepAliveEntry&gt; &#123; // ... /* return a still valid, unused HttpClient */ synchronized void put(HttpClient h) &#123; if (size() &gt;= KeepAliveCache.getMaxConnections()) &#123; h.closeServer(); // otherwise the connection remains in limbo &#125; else &#123; push(new KeepAliveEntry(h, System.currentTimeMillis())); &#125; &#125; // ...&#125; ClientVector(커넥션 풀)의 사이즈가 KeepAliveCache의 maxConnections보다 작지 않으면 커넥션을 바로 끊고 있다.그게 아니면 커넥션 풀에 여유가 있다는 거니 밀어넣고 있다. 12345678910111213141516171819202122232425public class KeepAliveCache extends HashMap&lt;KeepAliveKey, ClientVector&gt; implements Runnable &#123; private static final long serialVersionUID = -2937172892064557949L; /* maximum # keep-alive connections to maintain at once * This should be 2 by the HTTP spec, but because we don&#x27;t support pipe-lining * a larger value is more appropriate. So we now set a default of 5, and the value * refers to the number of idle connections per destination (in the cache) only. * It can be reset by setting system property &quot;http.maxConnections&quot;. */ static final int MAX_CONNECTIONS = 5; static int result = -1; static int getMaxConnections() &#123; if (result == -1) &#123; result = java.security.AccessController.doPrivileged( new sun.security.action.GetIntegerAction(&quot;http.maxConnections&quot;, MAX_CONNECTIONS)) .intValue(); if (result &lt;= 0) result = MAX_CONNECTIONS; &#125; return result; &#125;&#125; 커넥션 풀의 최대 사이즈는 기본값이 5이고, http.maxConnections이라는 시스템 프로퍼티를 사용한다는 것을 알 수 있다. 결론사실 맨 상단에 있는 N줄 요약이 결론이나 다름없다.다만 왜 커넥션이 5개가 넘어가면 커넥션을 바로 끊었는지, route(프로토콜, 호스트, 포트)가 다르다면 커넥션이 5개가 넘어가도 왜 커넥션이 유지되었는지 알게 되어 좋았다.하지만 SimpleClientHttpRequestFactory는 다양한 단점 때문에 실무에서 쓸만한 수준이 아닌데 괜히 깊게 판 것 같아서 시간이 좀 아깝다는 생각도 많이 들었다. (앞으로 좀 쓸 데 없어보이면 적당히만 파보고 더 가치있는 것을 딥하게 파야겠다.)","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://perfectacle.github.io/tags/RestTemplate/"}]},{"title":"Spring Boot Test에서 Test Configuration 감지하기","slug":"detecting-test-configuration-in-spring-boot-test","date":"2020-12-27T03:00:37.000Z","updated":"2022-10-30T08:42:16.375Z","comments":true,"path":"2020/12/27/detecting-test-configuration-in-spring-boot-test/","link":"","permalink":"https://perfectacle.github.io/2020/12/27/detecting-test-configuration-in-spring-boot-test/","excerpt":"Spring Boot Reference의 Testing - Detecting Test Configuration 파트를 보면 다음과 같은 내용이 나온다. If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes&#x3D;…​) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test.When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one.The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration. Detecting Test Configuration을 위해서 스프링에 친숙하다면 @ContextConfiguration이나 Nested @Configuration이 필요하다고 하고,Spring Boot를 사용하면 @*Test(@SpringBootTest, @WebMvcTest, @DataJpaTest, etc.)에서 별다른 설정을 하지 않았다면 primary configuration을 찾아나간다고 한다. N줄 요약글이 길어지다보니 아무도 안 볼 거 같고, 집중을 하고 소스코드를 따라가면서 읽어야해서 우선 먼저 요약을 적어놓는다.","text":"Spring Boot Reference의 Testing - Detecting Test Configuration 파트를 보면 다음과 같은 내용이 나온다. If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes&#x3D;…​) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test.When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one.The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration. Detecting Test Configuration을 위해서 스프링에 친숙하다면 @ContextConfiguration이나 Nested @Configuration이 필요하다고 하고,Spring Boot를 사용하면 @*Test(@SpringBootTest, @WebMvcTest, @DataJpaTest, etc.)에서 별다른 설정을 하지 않았다면 primary configuration을 찾아나간다고 한다. N줄 요약글이 길어지다보니 아무도 안 볼 거 같고, 집중을 하고 소스코드를 따라가면서 읽어야해서 우선 먼저 요약을 적어놓는다. TestContext를 로딩하기 위한 Test Configuaration은 다음과 같은 우선순위를 가진다. @ContextConfiguration 또는 @ContextHierarchy(여러 @ContextConfiguration을 포함) Nested @Configuration @SpringBootConfiguration (@SpringBootApplication 어노테이션이 @SpringBootConfiguration 어노테이션을 포함하고 있음) Nested @TestConfiguration 1, 2, 3 중 하나는 필수이며 셋 중에 하나만 적용된다.Nested @TestConfiguration은 @ContextConfiguration을 사용했을 때는 적용되지 않고, Nested @Configuration이나 @SpringBootConfiguration에 추가로 적용된다고 보면 된다.Nested @Configuration은 여러 개 만들어도 전부 적용되고, Nested @TestConfiguration도 여러 개 만들어도 전부 추가로 적용된다. @ContextConfigurationSpring 3.1에 추가된 기능으로 해당 블로그를 보면 아래와 같이 나와있다. At its core, the TestContext framework allows you to annotate test classes with @ContextConfiguration to specify which configuration files to use to load the ApplicationContext for your test. @ContextConfiguration 어노테이션에 기술한 configuration file들이 ApplicationContext에 로딩되는 걸 TestContext framework에서 해준다는 내용이다.그럼 @ContextConfiguration에 기술할 수 있는 configuration file에는 무엇이 있을까?ContextConfiguration Javadoc을 보면 다음과 같이 나와있다. Component Classes The term component class can refer to any of the following. -A class annotated with @Configuration -A component (i.e., a class annotated with @Component, @Service, @Repository, etc.) -A JSR-330 compliant class that is annotated with javax.inject annotations -Any class that contains @Bean-methods -Any other class that is intended to be registered as a Spring component (i.e., a Spring bean in the ApplicationContext), potentially taking advantage of automatic autowiring of a single constructor without the use of Spring annotations 빈에 관련된 설정(@Configuration) 파일이나 빈에 등록될 수 있는 어노테이션(@Component, @Service, @Repository 등등)은 기본적으로 기술할 수 있다고 보면 된다. 테스트 코드를 통해 간단히 확인해보자우선 src&#x2F;main에 인터페이스를 하나 만들자. 1interface SomeInterface 그리고 src&#x2F;test에 구현체를 하나 만들어주자. 1class SomeInterfaceInContextConfiguration : SomeInterface 이제 테스트 클래스를 작성해서 @ContextConfiguration의 간단한 동작을 검증해보자.참고로 Spring Boot 2.1.x 미만에서는 @ExtendWith(SpringExtension::class)를 추가해줘야한다.또한 Spring Boot 2.2.x 미만에서는 @TestConstructor 어노테이션이 없기 때문에 생성자 안의 파라미터 마다 @Autowired 어노테이션을 추가해줘야한다.그리고 JUnit 4에서는 Field Injection 밖에 지원하지 않기 때문에 Constructor Injection을 사용하려면 JUnit 5를 사용해야한다. 1234567891011@SpringBootTest@ContextConfiguration(classes = [SomeInterfaceInContextConfiguration::class])@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)internal class ContextConfigurationTest2( private val someInterface: SomeInterface) &#123; @Test internal fun `@ContextConfiguration에 기술된 Component Classes들이 Test Configuration으로 사용된다`() &#123; assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::class.java) &#125;&#125; 실제 어떻게 동작하는지 하나씩 찾아나가보자.@SpringBootTest 어노테이션을 보면 그 안에 @ExtendWith(SpringExtension.class) 어노테이션이 포함돼있다.또한 @BootstrapWith 어노테이션을 통해 어떤 클래스를 통해 Spring TestContext Framework를 부트스트랩할 지 명시하고 있다. 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@BootstrapWith(SpringBootTestContextBootstrapper.class)@ExtendWith(SpringExtension.class)public @interface SpringBootTest &#123; 그리고 SpringExtension 클래스의 beforeAll 메서드를 보면 testContextManager를 가져오고 있다. 1234@Overridepublic void beforeAll(ExtensionContext context) throws Exception &#123; getTestContextManager(context).beforeTestClass();&#125; 그리고 그 안에서 TestContextManager를 초기화하고 있다. 123456private static TestContextManager getTestContextManager(ExtensionContext context) &#123; Assert.notNull(context, &quot;ExtensionContext must not be null&quot;); Class&lt;?&gt; testClass = context.getRequiredTestClass(); Store store = getStore(context); return store.getOrComputeIfAbsent(testClass, TestContextManager::new, TestContextManager.class);&#125; TestContextManager 생성자에서는 TestContextBootstrapper를 resolving하고 있다. 123public TestContextManager(Class&lt;?&gt; testClass) &#123; this(BootstrapUtils.resolveTestContextBootstrapper(BootstrapUtils.createBootstrapContext(testClass)));&#125; BootstrapUtils.resolveTestContextBootstrapper 메서드 안에서는 resolveExplicitTestContextBootstrapper 메서드를 호출하고 있다. 123456static TestContextBootstrapper resolveTestContextBootstrapper(BootstrapContext bootstrapContext) &#123; Class&lt;?&gt; testClass = bootstrapContext.getTestClass(); Class&lt;?&gt; clazz = null; try &#123; clazz = resolveExplicitTestContextBootstrapper(testClass); resolveExplicitTestContextBootstrapper 메서드를 보면 testClass에 달려있는 BootstrapWith 어노테이션을 사용하는 걸 볼 수 있다. 1234567891011121314151617181920212223242526private static Class&lt;?&gt; resolveExplicitTestContextBootstrapper(Class&lt;?&gt; testClass) &#123; Set&lt;BootstrapWith&gt; annotations = new LinkedHashSet&lt;&gt;(); AnnotationDescriptor&lt;BootstrapWith&gt; descriptor = TestContextAnnotationUtils.findAnnotationDescriptor(testClass, BootstrapWith.class); while (descriptor != null) &#123; annotations.addAll(descriptor.findAllLocalMergedAnnotations()); descriptor = descriptor.next(); &#125; if (annotations.isEmpty()) &#123; return null; &#125; if (annotations.size() == 1) &#123; return annotations.iterator().next().value(); &#125; // Allow directly-present annotation to override annotations that are meta-present. BootstrapWith bootstrapWith = testClass.getDeclaredAnnotation(BootstrapWith.class); if (bootstrapWith != null) &#123; return bootstrapWith.value(); &#125; throw new IllegalStateException(String.format( &quot;Configuration error: found multiple declarations of @BootstrapWith for test class [%s]: %s&quot;, testClass.getName(), annotations));&#125; testClass에 BootstrapWith 어노테이션을 찾는다. 없으면 null을 반환한다. 하나만 있으면 어노테이션의 value에 기술된 TestContextBootstrapper 클래스를 반환한다. 두 개 이상이면 테스트 클래스에 직접적으로 기술된 BootstrapWith 어노테이션을 찾는다. 있으면 value에 기술된 TestContextBootstrapper 클래스를 반환한다. 없으면 우선순위 충돌로 인해 multiple @BootstrapWith 어노테이션을 발견했다는 에러를 반환한다. 우리는 @SpringBootTest 어노테이션에 있는 @BootstrapWith(SpringBootTestContextBootstrapper.class) 하나만 기술돼있기 때문에 SpringBootTestContextBootstrapper가 반환된다 이제 testContextBootstrapper를 구했으면 인자로 넘겨서 TestContextManager를 초기화 하고 있는데 TestContextManager 생성자 안에서는 testContext를 만들고 있다. 1234public TestContextManager(TestContextBootstrapper testContextBootstrapper) &#123; this.testContext = testContextBootstrapper.buildTestContext(); registerTestExecutionListeners(testContextBootstrapper.getTestExecutionListeners());&#125; 그리고 메서드를 쭉쭉 타고 들어가다보면 AbstractTestContextBootstrapper 클래스의 buildMergedContextConfiguration 메서드에서 ContextConfiguration 어노테이션 유무를 판단하고 처리하고 있다. 123456789101112131415161718public final MergedContextConfiguration buildMergedContextConfiguration() &#123; Class&lt;?&gt; testClass = getBootstrapContext().getTestClass(); CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate = getCacheAwareContextLoaderDelegate(); if (TestContextAnnotationUtils.findAnnotationDescriptorForTypes( testClass, ContextConfiguration.class, ContextHierarchy.class) == null) &#123; return buildDefaultMergedContextConfiguration(testClass, cacheAwareContextLoaderDelegate); &#125; if (TestContextAnnotationUtils.findAnnotationDescriptor(testClass, ContextHierarchy.class) != null) &#123; // ... &#125; else &#123; return buildMergedContextConfiguration(testClass, ContextLoaderUtils.resolveContextConfigurationAttributes(testClass), null, cacheAwareContextLoaderDelegate, true); &#125;&#125; testClass에 ContextConfiguration 어노테이션이나 ContextHierarchy 어노테이션이 포함됐는지 확인한다. 포함됐으면 ContextHierarchy 어노테이션이 포함됐는지 확인 후에 처리한 걸 반환한다. ContextConfiguration 어노테이션이 포함됐는지 확인 후에 처리한 걸 반환한다. 3번에 의해 동작이 되는 거라고 보면 된다.@ContextHierarchy 어노테이션은 @ContextConfiguration을 배열로 가지는 어노테이션으로 여러 @ContextConfiguration이 필요할 때 사용하면 된다. Nested @Configuration우선 동작하는 코드를 간단히 살펴보자.src&#x2F;test에 인터페이스의 구현체를 하나 더 추가해보자. 1class SomeInterfaceInNestedConfiguration : SomeInterface 그리고 테스트 코드를 통해 검증해보자 12345678910111213141516@SpringBootTest@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)internal class NestedConfigurationTest( private val someInterface: SomeInterface) &#123; @Configuration internal class Config &#123; @Bean fun someInterface() = SomeInterfaceInNestedConfiguration() &#125; @Test internal fun `@ContextConfiguration 어노테이션 다음으로는 Nested @Configuration 클래스가 Test Configuration으로 사용된다`() &#123; assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInNestedConfiguration::class.java) &#125;&#125; 이제 실제로 어떻게 동작하는지 또 알아보자.기본적으로 위에 설정한 동작방식 그대로를 쫓아가다가 분기문에서 갈라진다고 보면 된다.AbstractTestContextBootstrapper 클래스의 buildMergedContextConfiguration 메서드에서 ContextConfiguration 어노테이션 유무를 판단하고 있는 걸 위에서 살펴보았다. 12345678910public final MergedContextConfiguration buildMergedContextConfiguration() &#123; Class&lt;?&gt; testClass = getBootstrapContext().getTestClass(); CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate = getCacheAwareContextLoaderDelegate(); if (TestContextAnnotationUtils.findAnnotationDescriptorForTypes( testClass, ContextConfiguration.class, ContextHierarchy.class) == null) &#123; return buildDefaultMergedContextConfiguration(testClass, cacheAwareContextLoaderDelegate); &#125; // ...&#125; 우리 클래스에서는 해당 어노테이션이 없기 때문에 buildDefaultMergedContextConfiguration 메서드를 쭉쭉 타고 보면 buildMergedContextConfiguration 메서드까지 가게 된다. 1234567891011121314151617181920212223private MergedContextConfiguration buildMergedContextConfiguration(Class&lt;?&gt; testClass, List&lt;ContextConfigurationAttributes&gt; configAttributesList, @Nullable MergedContextConfiguration parentConfig, CacheAwareContextLoaderDelegate cacheAwareContextLoaderDelegate, boolean requireLocationsClassesOrInitializers) &#123; Assert.notEmpty(configAttributesList, &quot;ContextConfigurationAttributes list must not be null or empty&quot;); // @BootstrapWith(SpringBootTestContextBootstrapper.class)에 의해 SpringBootTestContextBootstrapper의 getDefaultContextLoaderClass 메서드를 호출하여 // SpringBootContextLoader가 resolving 됨 ContextLoader contextLoader = resolveContextLoader(testClass, configAttributesList); List&lt;String&gt; locations = new ArrayList&lt;&gt;(); List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;(); List&lt;Class&lt;?&gt;&gt; initializers = new ArrayList&lt;&gt;(); for (ContextConfigurationAttributes configAttributes : configAttributesList) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(String.format(&quot;Processing locations and classes for context configuration attributes %s&quot;, configAttributes)); &#125; if (contextLoader instanceof SmartContextLoader) &#123; // SpringBootContextLoader는 SmartContextLoader의 구현체이다 SmartContextLoader smartContextLoader = (SmartContextLoader) contextLoader; smartContextLoader.processContextConfiguration(configAttributes); 그리고 SpringBootContextLoader의 processContextConfiguration 메서드를 보면 detectDefaultConfigurationClasses를 호출하고 있다.(우리의 테스트 코드에서는 resource가 비어있는데 그거까지 이 포스트에서 다루기에는 너무 방대해져서 생략했다.) 12345678@Overridepublic void processContextConfiguration(ContextConfigurationAttributes configAttributes) &#123; super.processContextConfiguration(configAttributes); if (!configAttributes.hasResources()) &#123; Class&lt;?&gt;[] defaultConfigClasses = detectDefaultConfigurationClasses(configAttributes.getDeclaringClass()); configAttributes.setClasses(defaultConfigClasses); &#125;&#125; 메서드를 또 쭉쭉 타고 들어가다 보면 AnnotationConfigContextLoaderUtils 클래스의 detectDefaultConfigurationClasses 메서드를 호출하고 있다. 1234567891011121314public static Class&lt;?&gt;[] detectDefaultConfigurationClasses(Class&lt;?&gt; declaringClass) &#123; Assert.notNull(declaringClass, &quot;Declaring class must not be null&quot;); List&lt;Class&lt;?&gt;&gt; configClasses = new ArrayList&lt;&gt;(); for (Class&lt;?&gt; candidate : declaringClass.getDeclaredClasses()) &#123; if (isDefaultConfigurationClassCandidate(candidate)) &#123; configClasses.add(candidate); &#125; // .. &#125; // .. return ClassUtils.toClassArray(configClasses);&#125; 그리고 그 안에는 testClass(declaringClass)에 getDeclaredClasses 메서드를 호출하고 있다.해당 메서드는 클래스에 정의된 클래스 객체를 반환하는 메서드라고 보면 된다.따라서 Nested class들을 전부 반환하게 되는데 이 class 들을 for-loop 돌면서 isDefaultConfigurationClassCandidate 메서드를 호출해서 DefaultConfigurationClassCandidate라면 추가한 후에 반환하고 있다. isDefaultConfigurationClassCandidate 메서드를 보면 static이면서 private이 아니고, final이 아닌 클래스인데 @Configuration 어노테이션이 붙어있는지 판단하고 있다. 1234private static boolean isDefaultConfigurationClassCandidate(@Nullable Class&lt;?&gt; clazz) &#123; return (clazz != null &amp;&amp; isStaticNonPrivateAndNonFinal(clazz) &amp;&amp; AnnotatedElementUtils.hasAnnotation(clazz, Configuration.class));&#125; 이렇게 Nested @Configuration 클래스를 추가했으면 그 다음에 또 메서드를 쭉쭉 타고 들어가다보면 SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드를 호출하고 있다. 1234567protected Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123; Class&lt;?&gt;[] classes = mergedConfig.getClasses(); if (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123; return classes; &#125; // ...&#125; 그리고 containsNonTestComponent 메서드에서는 Nested @Configuration classes 중에 @TestConfiguration 어노테이션이 붙지 않은 클래스가 하나라도 존재하면 Nested @Configuration classes들을 merge 하여 Test Configuration으로 사용하고 있다.즉 Nested @Configuration 클래스가 2개여도 두 @Configuration을 하나로 머지하여 사용한다고 보면 된다. 123456789private boolean containsNonTestComponent(Class&lt;?&gt;[] classes) &#123; for (Class&lt;?&gt; candidate : classes) &#123; if (!MergedAnnotations.from(candidate, SearchStrategy.INHERITED_ANNOTATIONS) .isPresent(TestConfiguration.class)) &#123; return true; &#125; &#125; return false;&#125; @SpringBootConfiguration스프링 부트의 primary configuration은 @SpringBootConfiguration이다.하지만 @SpringBootConfiguration을 직접 사용하는 경우는 아직까지 보지 못했고 @SpringBootApplication을 사용하면 그 안에 포함돼있다. 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; src&#x2F;main에 @SpringBootApplication 클래스를 하나 추가해주자. 12@SpringBootApplicationclass DemoApplication 그리고 SomeInterface의 구현체도 하나 작성해주자 1class SomeInterfaceInConfiguration : SomeInterface 해당 클래스를 빈으로 등록해줄 Config 클래스도 작성하자. 12345@Configurationclass SomeInterfaceConfig &#123; @Bean fun someInterface() = SomeInterfaceInConfiguration()&#125; 그리고 테스트를 통해 해당 빈이 주입되는지 검증해보자. 12345678910@SpringBootTest@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)internal class SpringBootConfigurationTest( private val someInterface: SomeInterface) &#123; @Test internal fun `테스트용 설정이 없으면 기본적으로 @SpringBootApplication 클래스가 Test Configuration으로 사용된다`() &#123; assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInConfiguration::class.java) &#125;&#125; 이제 실제로 왜 이렇게 동작하는지 알아보자.위에 살펴봤던 것과 같이 SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드를 호출하고 있다.그리고 Nested @Configuration 클래스가 하나라도 존재하는지 containsNonTestComponent 메서드를 통해 검증했었다.하지만 이번에는 하나도 설정한 게 없으므로 그 아래에 있는 부분을 탄다. 123456789101112protected Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123; Class&lt;?&gt;[] classes = mergedConfig.getClasses(); if (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123; return classes; &#125; Class&lt;?&gt; found = new AnnotatedClassFinder(SpringBootConfiguration.class) .findFromClass(mergedConfig.getTestClass()); Assert.state(found != null, &quot;Unable to find a @SpringBootConfiguration, you need to use &quot; + &quot;@ContextConfiguration or @SpringBootTest(classes=...) with your test&quot;); logger.info(&quot;Found @SpringBootConfiguration &quot; + found.getName() + &quot; for test &quot; + mergedConfig.getTestClass()); return merge(found, classes);&#125; nested @Configuration 클래스를 가져온다. nested @TestConfiguration이 아닌 nested @Configuration 클래스가 하나라도 존재한다면 nested @Configuration(nested @TestConfiguration 포함) 클래스들을 반환한다. @SpringBootConfiguration 어노테이션이 붙은 클래스를 가져온다. 3에서 클래스를 찾지 못했다면 @SpringBootConfiguration이 붙은 클래스를 찾지 못하여 @ContextConfiguration이나 @SpringBootTest에 component classes를 명시하라고 에러를 뱉는다. 3에서 찾은 클래스와 nested @Configuration 클래스를 머지한다. 이렇게 nested @Configuration 클래스가 없다면 디폴트로 @SpringBootConfiguration이 붙은 @SpringBootApplication이 붙은 클래스가 Test Configuration으로 사용된다고 보면 된다. Nested @TestConfigurationSpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드를 보면 containsNonTestComponent 메서드를 호출하고 있다.즉, Nested @TestConfiguration이 아닌 Nested @Configuration 클래스가 하나라도 존재하는지 찾는 것인데…Nested @TestConfiguration 클래스는 어떤 역할을 하는 걸까?? src&#x2F;test에 SomeInterface의 구현체를 하나 더 추가해보자 1class SomeInterfaceInNestedTestConfiguration : SomeInterface 그리고 해당 빈이 주입되도록 Nested @TestConfiguration을 사용하여 테스트를 작성해보자. 12345678910111213141516171819202122@SpringBootTest@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)class NestedTestConfigurationTest( private val someInterface: SomeInterface, private val someInterface2: SomeInterface,) &#123; @TestConfiguration internal class Config &#123; @Bean fun someInterface2() = SomeInterfaceInNestedTestConfiguration() &#125; @Test internal fun `@SpringBootConfiguration에 의해 src에 있는 @Configuration 클래스에 있는 빈이 주입된다`() &#123; assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInConfiguration::class.java) &#125; @Test internal fun `@SpringBootConfiguration에 없는 건 @TestConfiguration 클래스에 있는 빈이 주입된다`() &#123; assertThat(someInterface2).isExactlyInstanceOf(SomeInterfaceInNestedTestConfiguration::class.java) &#125;&#125; 실제로 src&#x2F;main에 있는 @Configuration도 주입되고, Nested @TestConfiguration도 주입된 걸 볼 수 있다.Nested @TestConfiguration의 용도는 원래 Configuration(@SpringBootConfigurtion 또는 Nested @Configuration)에 추가적으로 설정할 Configuration을 위해 사용한다고 보면 된다. 위에 살펴봤던 것과 같이 SpringBootTestContextBootstrapper 클래스의 getOrFindConfigurationClasses 메서드를 호출하고 있다.그리고 Nested @Configuration 클래스가 하나라도 존재하는지 containsNonTestComponent 메서드를 통해 검증했었다.이번에는 Nested @TestConfiguration 클래스를 설정했으므로 그 관점에서 바라보자. 123456789101112protected Class&lt;?&gt;[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) &#123; Class&lt;?&gt;[] classes = mergedConfig.getClasses(); if (containsNonTestComponent(classes) || mergedConfig.hasLocations()) &#123; return classes; &#125; Class&lt;?&gt; found = new AnnotatedClassFinder(SpringBootConfiguration.class) .findFromClass(mergedConfig.getTestClass()); Assert.state(found != null, &quot;Unable to find a @SpringBootConfiguration, you need to use &quot; + &quot;@ContextConfiguration or @SpringBootTest(classes=...) with your test&quot;); logger.info(&quot;Found @SpringBootConfiguration &quot; + found.getName() + &quot; for test &quot; + mergedConfig.getTestClass()); return merge(found, classes);&#125; nested @Configuration 클래스를 가져온다. nested @TestConfiguration이 아닌 nested @Configuration 클래스가 하나라도 존재한다면 nested @Configuration(nested @TestConfiguration 포함) 클래스들을 반환한다. @SpringBootConfiguration 어노테이션이 붙은 클래스를 가져온다. 3에서 클래스를 찾지 못했다면 @SpringBootConfiguration이 붙은 클래스를 찾지 못하여 @ContextConfiguration이나 @SpringBootTest에 component classes를 명시하라고 에러를 뱉는다. 3에서 찾은 클래스와 nested @Configuration 클래스를 머지한다. @TestConfiguration 어노테이션이 @Configuration을 포함하고 있으므로 mergedConfig.getClasses()에서는 Nested @Configuration과 Nested @TestConfiguration 클래스가 나온다고 보면 된다. 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@TestComponentpublic @interface TestConfiguration &#123; 그리고 우리는 Nested @Configuration 클래스는 하나도 없으므로 containsNonTestComponent(classes)에서 false를 뱉고그 아래에서 Class&lt;?&gt; found = new AnnotatedClassFinder(SpringBootConfiguration.class).findFromClass(mergedConfig.getTestClass());로 찾아온 @SpringBootApplication 클래스와 Nested @TestConfiguration 클래스가 머지된다고 보면 된다.실제로 merge() 메서드에서는 두 Configuration들을 머지하고 있다. 123456private Class&lt;?&gt;[] merge(Class&lt;?&gt; head, Class&lt;?&gt;[] existing) &#123; Class&lt;?&gt;[] result = new Class&lt;?&gt;[existing.length + 1]; result[0] = head; System.arraycopy(existing, 0, result, 1, existing.length); return result;&#125; 참고로 @ContextConfiguration을 사용할 때는 Nested @Configuration&#x2F;@TestConfiuration이 먹히지 않는다. (물론 @SpringBootConfiguration도 씹힌다.) 12345678910111213141516171819202122232425262728293031323334353637@SpringBootTest@ContextConfiguration(classes = [SomeInterfaceInContextConfiguration::class])@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)internal class ContextConfigurationTest( private val someInterface: SomeInterface, private val someInterface2: SomeInterface, private val someInterface3: SomeInterface,) &#123; @Configuration internal class NestConfiguration &#123; @Bean fun someInterface2() = SomeInterfaceInNestedConfiguration() &#125; @TestConfiguration internal class NestedTestConfiguration &#123; @Bean fun someInterface3() = SomeInterfaceInNestedTestConfiguration() &#125; @Test internal fun `@ContextConfiguration에 기술된 Component Classes들이 Test Configuration으로 사용된다`() &#123; assertThat(someInterface).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::class.java) &#125; @Test internal fun `@ContextConfiguratio을 적용했으면 Nested @Configuration은 무시된다`() &#123; assertThat(someInterface2).isNotExactlyInstanceOf(SomeInterfaceInNestedConfiguration::class.java) assertThat(someInterface2).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::class.java) &#125; @Test internal fun `@ContextConfiguratio을 적용했으면 Nested @TestConfiguration은 무시된다`() &#123; assertThat(someInterface3).isNotExactlyInstanceOf(SomeInterfaceInNestedTestConfiguration::class.java) assertThat(someInterface3).isExactlyInstanceOf(SomeInterfaceInContextConfiguration::class.java) &#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"JUnit","slug":"JUnit","permalink":"https://perfectacle.github.io/tags/JUnit/"},{"name":"Test","slug":"Test","permalink":"https://perfectacle.github.io/tags/Test/"}]},{"title":"IntelliJ (Spring Boot) vs Gradle (bootRun)에서 클래스패스의 차이점","slug":"intellij-vs-gradle-in-classpath","date":"2020-12-26T16:56:41.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2020/12/26/intellij-vs-gradle-in-classpath/","link":"","permalink":"https://perfectacle.github.io/2020/12/26/intellij-vs-gradle-in-classpath/","excerpt":"123dependencies &#123; compileOnly(&quot;org.springframework.boot:spring-boot-starter-web:2.4.0&quot;)&#125; runtime classpath에는 추가되지 않아서 원래는 java.lang.ClassNotFoundException이 나야 정상이다.하지만 IntelliJ의 Spring Boot Configuration으로 실행하면 실행이 잘만 된다. 실제로 classpath를 찍어보면 아래와 같이 spring-boot-starter-web을 포함하고 있다.","text":"123dependencies &#123; compileOnly(&quot;org.springframework.boot:spring-boot-starter-web:2.4.0&quot;)&#125; runtime classpath에는 추가되지 않아서 원래는 java.lang.ClassNotFoundException이 나야 정상이다.하지만 IntelliJ의 Spring Boot Configuration으로 실행하면 실행이 잘만 된다. 실제로 classpath를 찍어보면 아래와 같이 spring-boot-starter-web을 포함하고 있다. 12345fun main(args: Array&lt;String&gt;) &#123; val property = System.getProperty(&quot;java.class.path&quot;) println(property) runApplication&lt;DemoApplication&gt;(*args)&#125; 1234567/Users/perfectacle/IdeaProjects/demo/build/classes/kotlin/main:/Users/perfectacle/IdeaProjects/demo/build/resources/main:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk8/1.4.10/998caa30623f73223194a8b657abd2baec4880ea/kotlin-stdlib-jdk8-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-web/2.4.0/4bdd422c370d1d66ffc12ecafdecc70cad406367/spring-boot-starter-web-2.4.0.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.4.10/30e46450b0bb3dbf43898d2f461be4a942784780/kotlin-stdlib-jdk7-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.10/ea29e063d2bbe695be13e9d044dcfb0c7add398e/kotlin-stdlib-1.4.10.jar:... 하지만 spring boot gradle plugin을 사용하여 bootRun Task를 실행하면 클래스패스가 아래와 같이 spring-boot-starter-web을 포함하고 있지 않는다. 12345678/Users/perfectacle/IdeaProjects/demo/build/classes/java/main:/Users/perfectacle/IdeaProjects/demo/build/classes/kotlin/main:/Users/perfectacle/IdeaProjects/demo/build/resources/main:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk8/1.4.10/998caa30623f73223194a8b657abd2baec4880ea/kotlin-stdlib-jdk8-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jdk7/1.4.10/30e46450b0bb3dbf43898d2f461be4a942784780/kotlin-stdlib-jdk7-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.10/ea29e063d2bbe695be13e9d044dcfb0c7add398e/kotlin-stdlib-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-common/1.4.10/6229be3465805c99db1142ad75e6c6ddeac0b04c/kotlin-stdlib-common-1.4.10.jar:/Users/perfectacle/.gradle/caches/modules-2/files-2.1/org.jetbrains/annotations/13.0/919f0dfe192fb4e063e7dacadee7f8bb9a2672a9/annotations-13.0.jar 실제 build된 jar 파일을 실행했을 때는 classpath 내에 spring-boot-starter-web jar 파일이 없기 때문에 서버가 뜨지도 않기 때문에 bootRun task의 클래스패스가 더 리얼월드에 가깝다.따라서 인텔리제이에서 돌려봤을 때 서버 뜬다고 신나하면 안 되고 gradle의 bootRun task까지 돌려봐야 가장 정확할 것 같다. (test code도 마찬가지일 듯??)","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"https://perfectacle.github.io/tags/IntelliJ/"},{"name":"Gradle","slug":"Gradle","permalink":"https://perfectacle.github.io/tags/Gradle/"}]},{"title":"Spring Boot + JUnit에서 의존성 주입하기","slug":"dependency-injection-in-junit","date":"2020-12-25T02:55:29.000Z","updated":"2022-10-30T08:42:16.375Z","comments":true,"path":"2020/12/25/dependency-injection-in-junit/","link":"","permalink":"https://perfectacle.github.io/2020/12/25/dependency-injection-in-junit/","excerpt":"JUnt 4Field Injection 밖에 되지 않음.Spring Boot 2.2.0부터 JUnit 5가 기본으로 탑재되기 시작했고,Spring Boot 2.4.0부터는 아예 JUnit 4 의존성이 제거됐기 때문에 JUnit 4의 사용은 하지 말아야한다. 12345678@RunWith(SpringRunner::class)@SpringBootTestclass SomeTest &#123; @Autowired private lateinit var a: SomeComponent @Test fun contextLoad() &#123;&#125;&#125; JUnit 5JUnit 5의 @ExtendedWith 어노테이션을 이용하면 테스트 전&#x2F;후로 다양한 일을 할 수 있다.@ExtendedWith 어노테이션은 어노테이션에 명시한 Extension들을 실행하는 역할 뿐이 하지 않는다.","text":"JUnt 4Field Injection 밖에 되지 않음.Spring Boot 2.2.0부터 JUnit 5가 기본으로 탑재되기 시작했고,Spring Boot 2.4.0부터는 아예 JUnit 4 의존성이 제거됐기 때문에 JUnit 4의 사용은 하지 말아야한다. 12345678@RunWith(SpringRunner::class)@SpringBootTestclass SomeTest &#123; @Autowired private lateinit var a: SomeComponent @Test fun contextLoad() &#123;&#125;&#125; JUnit 5JUnit 5의 @ExtendedWith 어노테이션을 이용하면 테스트 전&#x2F;후로 다양한 일을 할 수 있다.@ExtendedWith 어노테이션은 어노테이션에 명시한 Extension들을 실행하는 역할 뿐이 하지 않는다. 1234567@Repeatable(Extensions.class)public @interface ExtendWith &#123; /** * An array of one or more &#123;@link Extension&#125; classes to register. */ Class&lt;? extends Extension&gt;[] value()&#125; AfterEachCallback과 같은 다양한 Extension 인터페이스들을 직접 개발자가 구현하고 본인이 원하는 Extension만 넣으면 되는 구조다.이렇게 함으로써 전&#x2F;후 처리 해야되는 내용들은 Extnsion을 통해 직접 구현하고 @ExtendedWith에 기술함으로써 개발자가 좀 더 테스트에 집중할 수 있게 만들어준다. @SpringBootTest처럼 어플리케이션 컨텍스트를 로딩해야하는 테스트를 작성할 때 컨텍스트 로딩하는 코드를 직접 테스트 코드에 삽입하지 않고,여러 Extension을 구현한 SpringExtension을 사용하여 문제를 해결할 수 있다.또한 SpringExtension을 사용하면 Constructor Injection도 지원하는데 SpringExtension이 ParameterResolver Extension을 구현했기 때문이다. 123public class SpringExtension implements BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor, BeforeEachCallback, AfterEachCallback, BeforeTestExecutionCallback, AfterTestExecutionCallback, ParameterResolver &#123; ParameterResolver defines the API for Extensions that wish to dynamically resolve arguments for parameters at runtime. If a constructor for a test class or a @Test, @BeforeEach, @AfterEach, @BeforeAll, or @AfterAll method declares a parameter, an argument for the parameter must be resolved at runtime by a ParameterResolver. ParameterResolver는 두 개의 API를 가지고 있는데 해당 파라미터의 리졸빙을 지원하는지를 판단하는 supportsParameter 메서드와 실제 리졸빙을 하는 resolveParameter 메서드가 있다. Spring Boot 2.0.x (Spring 5.0.x)Spring Boot 2.0.x는 Spring 5.0.x를 사용하기 때문에 Spring Test 5.0.x의 SpringExtension 클래스를 보면 당연히 ParameterResolver Extension을 구현하였다.supportsParameter 메서드 로직 중에 @Autowired 어노테이션이 포함돼있는지를 판단하여 지원 여부를 구분하고 123456789@Overridepublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) &#123; Parameter parameter = parameterContext.getParameter(); int index = parameterContext.getIndex(); Executable executable = parameter.getDeclaringExecutable(); return (executable instanceof Constructor &amp;&amp; AnnotatedElementUtils.hasAnnotation(executable, Autowired.class)) || ParameterAutowireUtils.isAutowirable(parameter, index);&#125; resolveParameter 메서드에서는 ParameterAutowireUtils.resolveDependency 메서드를 호출하여 실제 리졸빙을 수행하고 있다. 123456789@Override@Nullablepublic Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) &#123; Parameter parameter = parameterContext.getParameter(); int index = parameterContext.getIndex(); Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass(); ApplicationContext applicationContext = getApplicationContext(extensionContext); return ParameterAutowireUtils.resolveDependency(parameter, index, testClass, applicationContext);&#125; 그리고 Spring Boot Test 2.0.x에서는 @SpringBootTest 어노테이션에 @ExtendedWith(SpringExtension.class)가 포함돼있지 않다. 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@BootstrapWith(SpringBootTestContextBootstrapper.class)public @interface SpringBootTest &#123; 따라서 @ExtendedWith(SpringExtension.class)를 무조건 명시해주어야 어플리케이션 컨텍스트가 정상적으로 로딩된다. 123456789@ExtendedWith(SpringExtension::class)@SpringBootTestclass SomeTest( @Autowired private val a: SomeComponent) &#123; @Test fun contextLoad() &#123;&#125;&#125; Spring Boot 2.1.x (Spring 5.1.x)Spring Boot 2.1.x는 Spring 5.1.x를 사용하기 때문에 Spring Test 5.1.x의 SpringExtension 클래스의 supportsParameter 메서드를 보면 Autowired 어노테이션이 있는지 비교하는 부분은 똑같아서 큰 변화가 없다.하지만 Spring Boot Test 2.1.x에서는 @SpringBootTest 어노테이션에 @ExtendedWith(SpringExtension.class)가 포함됐다. 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@BootstrapWith(SpringBootTestContextBootstrapper.class)@ExtendWith(SpringExtension.class)public @interface SpringBootTest &#123; 이는 어플리케이션 컨텍스트를 로딩하는 다른 테스트 @WebMvcTest, @DataJpaTest, @JsonTest 등등과 같은 Slice Test 류에도 동일하게 적용되었다.따라서 테스트를 작성할 때 @ExtendWith가 생략 가능해졌다. 12345678@SpringBootTestclass SomeTest( @Autowired private val a: SomeComponent) &#123; @Test fun contextLoad() &#123;&#125;&#125; Spring Boot 2.2.x (Spring 5.2x)Spring Boot 2.2.x는 Spring 5.2.x를 사용하기 때문에 Spring Test 5.2.x의 SpringExtension 클래스를 보면 supportsParameter 메서드의 로직이 달라져있다. 123456789@Overridepublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) &#123; Parameter parameter = parameterContext.getParameter(); Executable executable = parameter.getDeclaringExecutable(); Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass(); return (TestConstructorUtils.isAutowirableConstructor(executable, testClass) || ApplicationContext.class.isAssignableFrom(parameter.getType()) || ParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));&#125; 단순히 @Autowired 어노테이션이 있는지 검사하는 게 아니라 TestConstructorUtils.isAutowirableConstructor 메서드를 호출하는 것으로 변하였다. 해당 메서드를 계속 추적하다보면 아래 메서드를 만나게 된다. 12345678910111213141516171819202122232425262728293031public static boolean isAutowirableConstructor(Constructor&lt;?&gt; constructor, Class&lt;?&gt; testClass) &#123; // Is the constructor annotated with @Autowired? if (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) &#123; return true; &#125; AutowireMode autowireMode = null; // Is the test class annotated with @TestConstructor? TestConstructor testConstructor = AnnotatedElementUtils.findMergedAnnotation(testClass, TestConstructor.class); if (testConstructor != null) &#123; autowireMode = testConstructor.autowireMode(); &#125; else &#123; // Custom global default? String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME); if (value != null) &#123; try &#123; autowireMode = AutowireMode.valueOf(value.trim().toUpperCase()); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(String.format(&quot;Failed to parse autowire mode &#x27;%s&#x27; for property &#x27;%s&#x27;: %s&quot;, value, TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME, ex.getMessage())); &#125; &#125; &#125; &#125; return (autowireMode == AutowireMode.ALL);&#125; @Autowired 어노테이션이 달려있으면 true를 반환한다. autowireMode 변수를 선언하고, null로 초기화한다. @TestConstructor 어노테이션이 달려있는지 확인한다. 달려있으면 해당 어노테이션의 autowireMode 프로퍼티를 autowireMode 변수에 할단한다. 달려있지 않으면 아래 분기를 탄다. 클래스 패스에 있는 spring.properties 파일에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다. 프로퍼티를 AutowireMode enum으로 변환해보고 성공하면 autowireMode 변수에 할당한다. autowireMode 변수가 AutowireMode.ALL과 같으면 true, 다르면 false를 반환한다. @TestConstructor 어노테이션을 통한 @Autowired 어노테이션 생략테스트 별로 설정이 다를 때 테스트 마다 @TestConstructor를 달고 안 달고 설정할 수 있다.spring.properties에 spring.test.constructor.autowire.mode&#x3D;all로 설정하지 않는 이상 @TestConstructor(autowireMode &#x3D; TestConstructor.AutowireMode.NONE)이 기본 값처럼 동작하기 때문에 전역적으로 ALL로 설정한 게 아닌 이상 AutowireMode.NONE은 굳이 사용할 필요가 없다. 12345678@SpringBootTest@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)class SomeTest( private val a: SomeComponent) &#123; @Test fun contextLoad() &#123;&#125;&#125; spring.properties 파일을 통한 @Autowired 어노테이션 생략TestConstructorUtils.isAutowirableConstructor 메서드에서 전역으로 설정된 값을 가져오기 위해 이런 부분이 있었다. 12public @interface TestConstructor &#123; String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME); 그리고 TestConstructor에는 TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME이 있다. 1String TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME = &quot;spring.test.constructor.autowire.mode&quot;; SpringProperties 클래스의 getProperty 메서드를 보면 localProperties 변수로부터 프로퍼티를 가져오고 있다. 1234@Nullablepublic static String getProperty(String key) &#123; String value = localProperties.getProperty(key); if (value == null) &#123; 그리고 localProperties는 static final 변수라서 다시 재할당 되지 않고, static 초기화 블럭에 의해 어떻게 초기화 되는지 봐보면 12345678910111213141516171819202122232425private static final String PROPERTIES_RESOURCE_LOCATION = &quot;spring.properties&quot;;private static final Properties localProperties = new Properties();static &#123; try &#123; ClassLoader cl = SpringProperties.class.getClassLoader(); URL url = (cl != null ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) : ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION)); if (url != null) &#123; logger.debug(&quot;Found &#x27;spring.properties&#x27; file in local classpath&quot;); InputStream is = url.openStream(); try &#123; localProperties.load(is); &#125; finally &#123; is.close(); &#125; &#125; &#125; catch (IOException ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Could not load &#x27;spring.properties&#x27; file from local classpath: &quot; + ex); &#125; &#125;&#125; PROPERTIES_RESOURCE_LOCATION 변수에 있는 리소스를 읽어들여서 localProperties에 로딩하는 걸 볼 수 있다.PROPERTIES_RESOURCE_LOCATION 변수도 static final 변수이기 때문에 무조건 classpath 내에 존재하는 spring.properties라는 파일로부터 읽어들인다는 사실을 알 수 있다. Gradle의 java plugin을 사용하면 기본적으로 src&#x2F;main&#x2F;resources나 src&#x2F;test&#x2F;resources를 classpath에 등록해준다.하지만 spring boot를 사용하기 위해 필수적으로 적용하는 Spring Boot Gradle Plugin을 사용하면 Spring Boot 2.0.0.RELEASE 이후부터는 기본적으로 java 플러그인이 적용되기 때문에 따로 적용할 필요가 없다. A typical Spring Boot project will apply the groovy, java, or org.jetbrains.kotlin.jvm plugin and the io.spring.dependency-management plugin as a minimum. 이 설정은 테스트용 설정이기 때문에 src/test/resources에 spring.properties 파일을 만들고 아래와 같이 프로퍼티를 설정하면 된다. 1spring.test.constructor.autowire.mode=all 위와 같이 전역에 공통적으로 autowireMode를 설정하고 나면 테스트 코드에서 @TestConstructor 어노테이션을 사용하지 않아도 @Autowired 어노테이션 없이 생성자를 통한 의존성 주입을 받을 수 있다 1234567@SpringBootTestclass SomeTest( private val a: SomeComponent) &#123; @Test fun contextLoad() &#123;&#125;&#125; Spring Boot 2.3.x (Spring 5.2.x)Spring Boot 2.3.x는 Spring 5.2.x를 사용하는데 Spring Boot 2.2.x와 동일한 스프링 버전을 사용했기 때문인지 Junit 5에서 Dependency Injection을 위한 변화는 없었다. Spring Boot 2.4.x (Spring 5.3.2)Spring Boot 2.4.x는 Spring 5.3.x를 사용하기 때문에 Spring Test 5.3.x의 SpringExtension 클래스를 보면 supportsParameter 메서드의 로직이 달라져있다. 1234567891011@Overridepublic boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) &#123; Parameter parameter = parameterContext.getParameter(); Executable executable = parameter.getDeclaringExecutable(); Class&lt;?&gt; testClass = extensionContext.getRequiredTestClass(); PropertyProvider junitPropertyProvider = propertyName -&gt; extensionContext.getConfigurationParameter(propertyName).orElse(null); return (TestConstructorUtils.isAutowirableConstructor(executable, testClass, junitPropertyProvider) || ApplicationContext.class.isAssignableFrom(parameter.getType()) || ParameterResolutionDelegate.isAutowirable(parameter, parameterContext.getIndex()));&#125; 이번엔 TestConstructorUtils.isAutowirableConstructor 메서드에 junitPropertyProvider까지 넘기고 있다.그리고 해당 메서드를 계속 타고 들어가면 아래와 같이 로직이 바뀌어있는 걸 볼 수 있다. 1234567891011121314151617181920212223242526272829public static boolean isAutowirableConstructor(Constructor&lt;?&gt; constructor, Class&lt;?&gt; testClass,@Nullable PropertyProvider fallbackPropertyProvider) &#123; // Is the constructor annotated with @Autowired? if (AnnotatedElementUtils.hasAnnotation(constructor, Autowired.class)) &#123; return true; &#125; AutowireMode autowireMode = null; // Is the test class annotated with @TestConstructor? TestConstructor testConstructor = TestContextAnnotationUtils.findMergedAnnotation(testClass, TestConstructor.class); if (testConstructor != null) &#123; autowireMode = testConstructor.autowireMode(); &#125; else &#123; // Custom global default from SpringProperties? String value = SpringProperties.getProperty(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME); autowireMode = AutowireMode.from(value); // Use fallback provider? if (autowireMode == null &amp;&amp; fallbackPropertyProvider != null) &#123; value = fallbackPropertyProvider.get(TestConstructor.TEST_CONSTRUCTOR_AUTOWIRE_MODE_PROPERTY_NAME); autowireMode = AutowireMode.from(value); &#125; &#125; return (autowireMode == AutowireMode.ALL);&#125; @Autowired 어노테이션이 달려있으면 true를 반환한다. autowireMode 변수를 선언하고, null로 초기화한다. @TestConstructor 어노테이션이 달려있는지 확인한다. 달려있으면 해당 어노테이션의 autowireMode 프로퍼티를 autowireMode 변수에 할단한다. 달려있지 않으면 아래 분기를 탄다. 클래스 패스에 있는 spring.properties 파일에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다. 가져온 프로퍼티를 AutowireMode enum으로 변환해서 autowireMode 변수에 할당한다. AutowireMode enum으로 변환에 실패했는데 fallbackPropertyProvider(junitPropertyProvider)가 존재하면 아래 분기를 탄다. junitPropertyProvider에서 spring.test.constructor.autowire.mode 프로퍼티를 가져온다. 프로퍼티를 AutowireMode enum으로 변환해서 autowireMode 변수에 할당한다. autowireMode 변수가 AutowireMode.ALL과 같으면 true, 다르면 false를 반환한다. junitPropertyProvider로부터 읽어오는 부분이 추가된 건데 추가하는 방법은 스프링 공식 문서에 나와있다. Changing the default test constructor autowire modeThe default test constructor autowire mode can be changed by setting the spring.test.constructor.autowire.mode JVM system property to all.Alternatively, the default mode may be set via the SpringProperties mechanism.As of Spring Framework 5.3, the default mode may also be configured as a JUnit Platform configuration parameter. JUnit Platform configuration parameter를 설정하는 방법은 JUnit 공식문서에 나와있고, junit-platform.properties 파일을 만들어서 클래스패스에 추가하면 적용이 된다. The JUnit Platform configuration file: a file named junit-platform.properties in the root of the class path that follows the syntax rules for a Java Properties file. spring.properties는 테스트 전용 설정파일이 아닌데 반해 junit-platform.properties 파일은 테스트 전용 설정파일이기 때문에 우리가 설정하려는 값은 테스트 전용 값이라서 junit-platform.properties에 있는 게 더 좋다고 볼 수 있다. /src/test/resources에 junit-platform.properties 파일을 만들어주자.자바 표준 API인 Properties 문법을 따른다고 하니 아래와 같이 적어주면 된다. 1spring.test.constructor.autowire.mode=all 위와 같이 전역에 공통적으로 autowireMode를 설정하고 나면 테스트 코드에서 @TestConstructor 어노테이션을 사용하지 않아도 @Autowired 어노테이션 없이 생성자를 통한 의존성 주입을 받을 수 있다. 1234567@SpringBootTestclass SomeTest( private val a: SomeComponent) &#123; @Test fun contextLoad() &#123;&#125;&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"JUnit","slug":"JUnit","permalink":"https://perfectacle.github.io/tags/JUnit/"}]},{"title":"spring.properties 파일을 읽어들이는 원리","slug":"spring-properties-file","date":"2020-12-25T00:51:17.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2020/12/25/spring-properties-file/","link":"","permalink":"https://perfectacle.github.io/2020/12/25/spring-properties-file/","excerpt":"SpringProperties 클래스1234567891011121314151617181920212223242526272829303132333435363738394041// ...import java.util.Properties;// ...public final class SpringProperties &#123; private static final String PROPERTIES_RESOURCE_LOCATION = &quot;spring.properties&quot;; private static final Properties localProperties = new Properties(); static &#123; try &#123; ClassLoader cl = SpringProperties.class.getClassLoader(); URL url = (cl != null ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) : ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION)); if (url != null) &#123; try (InputStream is = url.openStream()) &#123; localProperties.load(is); &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(&quot;Could not load &#x27;spring.properties&#x27; file from local classpath: &quot; + ex); &#125; &#125; // ... @Nullable public static String getProperty(String key) &#123; String value = localProperties.getProperty(key); if (value == null) &#123; try &#123; value = System.getProperty(key); &#125; catch (Throwable ex) &#123; System.err.println(&quot;Could not retrieve system property &#x27;&quot; + key + &quot;&#x27;: &quot; + ex); &#125; &#125; return value; &#125; // ...&#125; PROPERTIES_RESOURCE_LOCATION(spring.properties) 파일을 읽어서 InputStream에 넣고 localProperties.load(is)를 통해 Properties에 위에서 읽어들인 InputStream을 load 하고 나중에 필요할 때 키 값을 통해 프로퍼티를 불러오고 있다. localProperties는 Properties라는 자바 표준 API를 사용하고 있기 때문에 저 spring.properties에는 어떻게 키와 프로퍼티를 구성하는지 알아보자. Properties","text":"SpringProperties 클래스1234567891011121314151617181920212223242526272829303132333435363738394041// ...import java.util.Properties;// ...public final class SpringProperties &#123; private static final String PROPERTIES_RESOURCE_LOCATION = &quot;spring.properties&quot;; private static final Properties localProperties = new Properties(); static &#123; try &#123; ClassLoader cl = SpringProperties.class.getClassLoader(); URL url = (cl != null ? cl.getResource(PROPERTIES_RESOURCE_LOCATION) : ClassLoader.getSystemResource(PROPERTIES_RESOURCE_LOCATION)); if (url != null) &#123; try (InputStream is = url.openStream()) &#123; localProperties.load(is); &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(&quot;Could not load &#x27;spring.properties&#x27; file from local classpath: &quot; + ex); &#125; &#125; // ... @Nullable public static String getProperty(String key) &#123; String value = localProperties.getProperty(key); if (value == null) &#123; try &#123; value = System.getProperty(key); &#125; catch (Throwable ex) &#123; System.err.println(&quot;Could not retrieve system property &#x27;&quot; + key + &quot;&#x27;: &quot; + ex); &#125; &#125; return value; &#125; // ...&#125; PROPERTIES_RESOURCE_LOCATION(spring.properties) 파일을 읽어서 InputStream에 넣고 localProperties.load(is)를 통해 Properties에 위에서 읽어들인 InputStream을 load 하고 나중에 필요할 때 키 값을 통해 프로퍼티를 불러오고 있다. localProperties는 Properties라는 자바 표준 API를 사용하고 있기 때문에 저 spring.properties에는 어떻게 키와 프로퍼티를 구성하는지 알아보자. Properties The Properties class represents a persistent set of properties.The Properties can be saved to a stream or loaded from a stream.Each key and its corresponding value in the property list is a string. 프로퍼티들을 모아놓은 타입이고, 키와 밸류의 쌍으로 이루어졌다고 보면 된다.그리고 stream으로부터 load 될 수 있다고 하니 InputStream에서 로드되는 API부터 봐보자. load(InputStream inStream) public void load(InputStream inStream) throws IOException Reads a property list (key and element pairs) from the input byte stream.The input stream is in a simple line-oriented format as specified in load(Reader) and is assumed to use the ISO 8859-1 character encoding;that is each byte is one Latin1 character. Characters not in Latin1, and certain special characters, are represented in keys and elements using Unicode escapes as defined in section 3.3 of The Java™ Language Specification. 일단 ISO 8859-1은 문자열 관련 인코딩 표준인데 영어&#x2F;숫자나 기본적인 특수문자(공백, 느낌표 등등)들만 지원한다고 생각하면 편하다.또한 line-oriented format이기 때문에 한 줄 마다 key and element pair가 구성이 된다.한 줄이 어떤 식으로 구성되는지는 load(Reader reader) 메서드를 참고하면 된다. load(Reader reader) public void load(Reader reader) throws IOException…As an example, each of the following three lines specifies the key “Truth” and the associated element value “Beauty”:Truth &#x3D; Beauty Truth:Beauty Truth :Beauty =이나 :로 key&#x2F;element를 구분짓고, 앞 뒤에 굳이 공백은 전부 생략해주는 것으로 보인다.일반적으로 보던 application.properties와 큰 차이 없는 것으로 보이므로 원래 사용하던 데로 쓰면 될 거 같다.","categories":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"}]},{"title":"(TDD) 클래스의 명시적인 타입 검사를 제거하는 방법","slug":"how-to-remove-instanceof","date":"2020-06-11T17:30:48.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2020/06/11/how-to-remove-instanceof/","link":"","permalink":"https://perfectacle.github.io/2020/06/11/how-to-remove-instanceof/","excerpt":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 해당 포스트는 프랑(CHF, 스위스 통화)을 달러($)로 변환하는 간단한 테스트를 작성하는 것부터 시작한다. 프랑에서 달러로 변환하기아래와 같은 간단한 코드들을 이번 예제에서 사용해보자.","text":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 해당 포스트는 프랑(CHF, 스위스 통화)을 달러($)로 변환하는 간단한 테스트를 작성하는 것부터 시작한다. 프랑에서 달러로 변환하기아래와 같은 간단한 코드들을 이번 예제에서 사용해보자. 123456789101112131415161718192021abstract class Money( val amount: Long, val currency: String) &#123; companion object &#123; fun dollar(amount: Long): Money = Dollar(amount) fun franc(amount: Long): Money = Franc(amount) &#125; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Money if (amount != other.amount) return false if (currency != other.currency) return false return true &#125;&#125; 1class Dollar(amount: Long): Money(amount, &quot;USD&quot;) 1class Franc(amount: Long): Money(amount, &quot;CHF&quot;) 프랑(스위스 통화)과 달러의 환율은 2:1이라고 가정했을 때 프랑으로부터 달러를 얻는 테스트는 다음과 같이 작성할 수 있다. 1234567891011121314class MoneyTest &#123; @Test fun `10CHF = $5`() &#123; // Given val tenFrancs = Money.franc(10) val expected = Money.dollar(5) // When val actual = tenFrancs.ofDollars() // Then actual shouldBe expected &#125;&#125; 컴파일이 되도록 소스코드를 수정해보자. 12345678910abstract class Money( val amount: Long, val currency: String) &#123; // ... fun ofDollars(): Dollar &#123; TODO(&quot;Not yet implemented&quot;) &#125; // ...&#125; 우선 컴파일은 가능해졌고 테스트를 돌리면 깨진다. (Red 단계)이제 테스트를 성공시켜 보자. 123fun ofDollars(): Dollar &#123; return Dollar(5)&#125; 상수를 반환하게 하여 테스트를 통과하게 했지만 이번엔 달러에서 달러를 반환하는 테스트를 작성해서 일반화 시켜 나가보자. 123456789101112@Testfun `$10 = $10`() &#123; // Given val tenBucks = Money.dollar(10) val expected = Money.dollar(10) // When val actual = tenBucks.ofDollars() // Then actual shouldBe expected&#125; 위 테스트는 깨진다.그럼 테스트를 통과할 수 있게 끔 ofDollars 메서드 구현을 상수에서 일반화시켜보자. 1234567fun ofDollars(): Dollar &#123; return when (this) &#123; is Dollar -&gt; this is Franc -&gt; Dollar(this.amount / 2) else -&gt; throw UnsupportedOperationException(&quot;Unsupported Currency&quot;) &#125;&#125; 테스트는 전부 통과하지만, 통화가 늘어나면 저렇게 타입 검사하는 코드를 계속 추가해야하고, 실수로 타입 검사를 빼먹으면 예외를 만나게 될 것이다.이런 고통으로부터 벗어나려면 어떻게 해야할까…? 다형성을 이용하여 타입검사 제거하기명시적으로 타입검사를 제거하기 위해서는 **다형성(Polymorphism)**을 이용하면 된다. 12345678abstract class Money( val amount: Long, val currency: String) &#123; // ... abstract fun ofDollars(): Dollar // ...&#125; 12345class Dollar(amount: Long): Money(amount, &quot;USD&quot;) &#123; override fun ofDollars(): Dollar &#123; return this &#125;&#125; 12345class Franc(amount: Long): Money(amount, &quot;CHF&quot;) &#123; override fun ofDollars(): Dollar &#123; return Dollar(this.amount / 2) &#125;&#125; Money에서 ofDollars 메서드를 추상메서드로 바꿨을 때 나타나는 장점은 세 가지가 있다. 유저가 미지원 통화 오류를 만날 일이 사라졌다.이전에는 각 통화에 대한 분기를 추가하지 않는 실수를 할 수 있었고 그렇게 되면 예외를 만나게 됐는데 지금은 각 하위 클래스에서 구현을 하지 않으면 컴파일 조차 되지 않는다.컴파일 자체가 되지 않기 때문에 실수한 상태로 배포가 불가능하고, 적어도 유저가 장애를 경험할 일은 없다. 단일 책임 원칙을 준수하게 됐다. (해당 클래스가 변경돼야하는 사유는 해당 통화의 환율이 변경됐을 때 뿐이다.)기존 Money 클래스에 구현돼있을 때는 ofDollars 메서드에서 Money가 Dollar인 경우, Franc인 경우, 그 외의 통화인 경우를 전부 커버하고 있었다.그러다보니 Franc의 환율이 변경되도 Money를 수정해야하고, 그 외의 통화가 추가돼도 Money를 수정하다보니 Money의 소스가 비대해질 가능성이 있다보니 이해&#x2F;수정하기도 힘들고, Franc의 환율을 수정했는데 다른 통화가 영향을 받을 수 있는 상황이었다.하지만 지금은 Franc의 환율이 변경되면 Franc만 수정하면 되고, Franc만 수정했으므로 그 변경의 여파가 다른 통화로 번지지 않기 때문에 수정할 때 더 안심할 수 있다. 타입검사가 제거됐다.외부에서는 Money란 사실만 알고 있고, 실제 구체 타입에 따라서 알아서 메서드를 실행한다.자바&#x2F;코틀린에서는 언어 수준에서 다형성을 지원하기 때문에 분기를 마구 태우던 부분을 제거할 수 있었고 코드가 좀 더 단순해졌다. 하지만 이로 인한 단점은 아래 두 가지가 있다. Dollar 클래스에 별로 하는 일도 없는 껍데기 메서드가 추가됐다.Dollar에서 구현한 ofDollars 메서드는 자기 자신(this)를 리턴한다.외부에서 분기를 없애기 위해서 다형성을 사용하다 보니 별로 하는 일도 없어보이는 듯한 메서드가 추가됐다.다형성을 위해서 이런 껍데기 같은 메서드들은 어쩔 수 없이 추가돼야하는 것 같다. 실제 코드를 파악하려면 Money 클래스와 각 하위 클래스들을 파악해야한다.원래 분기를 태울 때는 Money 클래스만 봐도 돼서 코드가 한 눈에 들어왔다.하지만 지금은 하위 클래스에서 그 책임을 분할해서 지고 있다보니 각 하위 클래스들을 전부 봐야 모든 소스를 이해하게 되는 것이다.다형성을 너무 많이 활용하다보면 소스코드를 확인하기 위해서 엄청 많은 클래스들을 봐야할 수도 있다.이건 얼마나 추상화할 것인지, 적절한 밸런스를 가져가야할 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Study","slug":"Note/Study","permalink":"https://perfectacle.github.io/categories/Note/Study/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://perfectacle.github.io/tags/TDD/"}]},{"title":"(TDD) 하위 클래스를 제거하기 쉽게 만드는 방법","slug":"how-to-make-subclasses-easy-to-remove","date":"2020-06-11T16:03:32.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2020/06/11/how-to-make-subclasses-easy-to-remove/","link":"","permalink":"https://perfectacle.github.io/2020/06/11/how-to-make-subclasses-easy-to-remove/","excerpt":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.해당 포스트는 클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법에서 제거하지 못한 중복인 plus 메서드를 제거하는 것으로 시작한다.(기본적으로 코틀린, JUnit5, kotest를 사용했다)기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 마치며를 보면 된다. 각 하위 클래스에 있는 plus 메서드 제거하기기본적으로 소스 코드는 아래와 같다.","text":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.해당 포스트는 클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법에서 제거하지 못한 중복인 plus 메서드를 제거하는 것으로 시작한다.(기본적으로 코틀린, JUnit5, kotest를 사용했다)기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 마치며를 보면 된다. 각 하위 클래스에 있는 plus 메서드 제거하기기본적으로 소스 코드는 아래와 같다. 1234567891011121314abstract class Money(val amount: Long) &#123; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Money if (amount != other.amount) return false return true &#125; abstract operator fun plus(money: Money): Money&#125; 12345class Dollar(amount: Long): Money(amount) &#123; override operator fun plus(money: Money): Money &#123; return Dollar(this.amount + money.amount) &#125;&#125; 12345class Franc(amount: Long): Money(amount) &#123; override operator fun plus(money: Money): Money &#123; return Franc(this.amount + money.amount) &#125;&#125; 문제는 메서드에서는 구체 클래스인 Dollar나 Franc 밖에 반환하지 못하는데 공통된 구체 클래스를 반환하게 해야 중복(plus 메서드)을 제거할 수 있다.그럼 공통된 부모 클래스인 Money 클래스를 구체 클래스로 바꿔보고 Money 클래스를 리턴하게 끔 수정해보자. 12345678910111213141516171819open class Money(private val amount: Long) &#123; companion object &#123; fun dollar(amount: Long): Money = Dollar(amount) fun franc(amount: Long): Money = Franc(amount) &#125; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (other !is Money) return false if (amount != other.amount) return false return true &#125; operator fun plus(money: Money): Money &#123; return Money(this.amount + money.amount) &#125;&#125; 이제 plus 메서드를 각 하위 클래스에서 제거해보자. 1class Dollar(amount: Long): Money(amount) 1class Franc(amount: Long): Money(amount) 모든 테스트를 돌려보면 통과하고 이제 Dollar와 Franc 클래스는 딱히 하는 일이 없어보이므로 삭제해도 될 거 같다는 생각이 든다.과연 그럴까…?? 통화(currency) 추가하기Dollar와 Franc 클래스는 그 자체만으로 Currency(통화) 정보를 포함하는 클래스인데 Money 클래스는 그러지 못한다.이게 정말 문제가 되는 건지 테스트를 통해 검증해보자. 123456789class MoneyTest &#123; @Test fun `$5 != 5CHF`() &#123; val amount = 5 val dollars = Money.dollar(amount) val francs = Money.franc(amount) dollars shouldNotBe francs &#125;&#125; 흠… 테스트는 잘 통과한다.하지만 위 팩토리 메서드들은 Dollar와 Franc과 같은 하위 클래스를 반환하므로 문제가 안 생긴 것일 수도 있으니 Money를 반환하는 plus 메서드에 대해서도 검증을 추가해보자. 1234567@Testfun `$5 + $5 != 5CHF + 5CHF`() &#123; val amount = 5 val tenBucks = Money.dollar(amount) + Money.dollar(amount) val tenFrancs = Money.franc(amount) + Money.franc(amount) tenBucks shouldNotBe tenFrancs&#125; 우리가 예상했던 대로 위 테스트는 실패한다.따라서 Money 클래스에 currency 필드를 추가해보자. 123456789101112131415161718192021open class Money( private val amount: Long, private val currency: String) &#123; // ... override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Money if (amount != other.amount) return false if (currency != other.currency) return false return true &#125; operator fun plus(money: Money): Money &#123; return Money(this.amount + money.amount, this.currency) &#125;&#125; 바뀐 생성자를 각 하위 클래스에 적용해주자. 1class Dollar(amount: Long): Money(amount, &quot;&quot;) 1class Franc(amount: Long): Money(amount, &quot;&quot;) 우선 Red 단계를 보기 위해 재빠르게 구현만 해주자.그리고 테스트를 돌려보면 여전히 $5 + $5 != 5CHF + 5CHF에서 실패한다.그럼 Green을 보기 위해 알맞은 currency를 할당해주자. 1class Dollar(amount: Long): Money(amount, &quot;USD&quot;) 1class Franc(amount: Long): Money(amount, &quot;CHF&quot;) 이제 MoneyTest는 Green을 볼 수 있지만 다른 Test를 돌려보면 테스트가 깨진다.DollarTest와 FrancTest의 test addition 테스트가 아래와 같은 사유로 깨진다.org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Dollar@1b919693&gt; but was:&lt;com.example.demo.Money@7fb4f2a9&gt;org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Franc@12591ac8&gt; but was:&lt;com.example.demo.Money@5a7fe64f&gt; 문제는 factory method에서는 하위 클래스인 Dollar&#x2F;Franc을 반환하고, plus 메서드에서는 부모 클래스인 Money를 반환하기 때문이다.이제 테스트를 통과하게 끔 factory method에서도 Money를 반환하게 끔 수정해보자. 1234567891011open class Money( private val amount: Long, private val currency: String) &#123; // ... companion object &#123; fun dollar(amount: Long): Money = Money(amount, &quot;USD&quot;) fun franc(amount: Long): Money = Money(amount, &quot;CHF&quot;) &#125; // ...&#125; 이제 모든 테스트가 통과하게 된다.이제 Money가 가지고 있던 통화 문제도 해결했고, 하위 클래스인 Dollar와 Franc 클래스를 사용하는 곳은 완전히 사라졌다.위 두 클래스를 제거하고 이제 Money 클래스를 상속받는 클래스가 사라졌으므로 클래스를 상속받지 못하게 open 키워드를 제거해서 final 클래스로 만들어버리자. 123456class Money( private val amount: Long, private val currency: String) &#123; // ...&#125; 마치며만약 클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법에서처럼 하위 클래스에 직접적인 접근을 제거하지 않았으면 중복을 제거한 후에 하위 클래스를 제거할 때 애를 먹었을 것이다.해당 클래스들을 사용하는 부분(테스트 코드)에서 Dollar&#x2F;Franc 생성자로 생성하는 부분을 전부 찾아서 Money 생성자로 바꿨을 것이다.하지만 하위 클래스에 직접적인 접근하는 부분을 전부 제거하고 Money 내부에서만 직접적인 접근을 하도록 두었기 때문에 Money 클래스만 수정함으로써 하위 클래스를 제거하기가 훨씬 수월했다.그리고 문제점에 대해 인식을 하고 먼저 테스트로 작성해뒀기 때문에 어떤 부분을 구현해야할 지 좀 더 명확했다.또한 자동화 된 테스트들을 작성해두다 보니 내가 수정한 부분이 어디까지 영향을 미쳤는지, 코드를 안전하게 수정한 건 지 확인할 수 있어서 안심하고 코드를 작성할 수 있었다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Study","slug":"Note/Study","permalink":"https://perfectacle.github.io/categories/Note/Study/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://perfectacle.github.io/tags/TDD/"}]},{"title":"(TDD) 클라이언트에 영향 없이 상속 구조를 마음껏 고칠 수 있는 방법","slug":"change-inheritance-hierarchy-without-affecting-client","date":"2020-06-09T18:21:29.000Z","updated":"2022-10-30T08:42:16.191Z","comments":true,"path":"2020/06/09/change-inheritance-hierarchy-without-affecting-client/","link":"","permalink":"https://perfectacle.github.io/2020/06/09/change-inheritance-hierarchy-without-affecting-client/","excerpt":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.해당 포스트도 위 두가지 통화에 대해 덧셈 연산을 테스트 하는 작은 코드로 시작한다.(기본적으로 코틀린, JUnit5, kotest를 사용했다)기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 하위 클래스의 직접적인 참조 줄이기를 보면 된다. Dollar 클래스 구현하기123456789101112131415class DollarTest &#123; @Test fun `$5 + $2 = $7`() &#123; // Given val five = Dollar(5) val two = Dollar(2) // When val actual = five + two // Then val expected = Dollar(7) actual shouldBe expected &#125;&#125;","text":"TDD By Example 책을 보다가 감명 받은 부분을 정리해봤다.기본적으로 아래 4가지 원칙을 따라 진행한다. Red - 실패하는 작은 테스트를 작성(최초에는 컴파일 조차 되지 않음) Green - 빨리 테스트가 통과하게 끔 수정(이를 위해선 어떠한 죄악도 용서됨) Refactoring - 모든 중복을 제거(2번에서 수행한 죄악들을 청산) 책에서는 달러($)와 프랑(CHF, 스위스 통화)의 연산에 대한 조그만 테스트를 시작으로 두 통화 사이의 중복을 제거해나갔다.해당 포스트도 위 두가지 통화에 대해 덧셈 연산을 테스트 하는 작은 코드로 시작한다.(기본적으로 코틀린, JUnit5, kotest를 사용했다)기본적인 내용은 내가 감명깊게 느낀 부분을 설명하기 위해 TDD로 진행해나가는 과정이고 실제 이 포스트의 핵심은 하위 클래스의 직접적인 참조 줄이기를 보면 된다. Dollar 클래스 구현하기123456789101112131415class DollarTest &#123; @Test fun `$5 + $2 = $7`() &#123; // Given val five = Dollar(5) val two = Dollar(2) // When val actual = five + two // Then val expected = Dollar(7) actual shouldBe expected &#125;&#125; 이제 위 코드가 실패하게 끔 컴파일이 되도록 클래스를 만들어주자. (컴파일만 되게 끔 아주 빠르게 만들면 된다) 12345class Dollar(amount: Long) &#123; operator fun plus(dollar: Dollar): Dollar &#123; TODO(&quot;Not yet implemented&quot;) &#125;&#125; 아주 빠르게 만들다보니 아래와 같은 죄악을 저질렀다. 생성자의 매개변수인 amount를 멤버변수로 할당하지 않았다. plus 메서드 내부를 TODO로 비워뒀다. 하지만 우리에겐 실패하는 테스트를 돌려보는 게 제일 중요기 때문에 위와 같은 죄악은 전혀 중요치 않다. 아무 생각없이 IDE의 도움을 받아서 우선 가장 빠르게 컴파일이 되도록 만든 후에 테스트를 돌려보면 당연히 테스트는 실패한다.kotlin.NotImplementedError: An operation is not implemented: Not yet implemented 우선 첫 번째 단계인 Red를 만족하였다.그럼 다음 단게인 Green 단계를 만족시키기 위해 테스트를 성공 시키는 강력범죄를 저지르러 가자. 123456789class Dollar(amount: Long) &#123; override fun equals(other: Any?): Boolean &#123; return true &#125; operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(0) &#125;&#125; 테스트를 돌려보면 테스트가 통과했다는 Green 표시를 보게 된다.우리는 테스트를 가장 빠르게 통과시키기 위해 가짜로 구현하기 기법을 사용했다.가짜로 구현하기는 우선 상수를 반환시켜서 테스트를 통과시키고 단계적으로 변수를 사용하도록 점진시켜나가는 과정이다. 우선 하나의 테스트만 가지고는 제대로 구현했는지 검증이 안 되므로 plus 메서드의 결과가 일치하지 않는 것에 대한 테스트도 작성해보자. 12345678910111213@Testfun `$5 + $2 != $10`() &#123; // Given val five = Dollar(5) val two = Dollar(2) // When val actual = five + two // Then val notExpected = Dollar(10) actual shouldNotBe notExpected&#125; Dollar 클래스의 equals 메서드는 무조건 true를 반환하므로 테스트는 성공하지 못한다.equality를 비교하려면 해당 클래스의 내부 상태를 검사하는 값 객체(Value Object) 패턴을 사용해야한다. 12345678910111213141516class Dollar(private val amount: Long) &#123; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Dollar if (amount != other.amount) return false return true &#125; operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(0) &#125;&#125; 우선 값 객체로 사용하기 위해 amount를 멤버 변수로 할당하고, IDE의 도움을 받아 equals 메서드를 제대로 구현했다.테스트를 돌려보면 $5 + $2 != $10은 통과하는데 $5 + $2 = $7은 plus 메서드를 제대로 구현하지 않았기 때문에 실패한다.이제 $5 + $2 = $7 메서드를 통과시키도록 plus 메서드의 구현부를 바꿔보자. 123operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(7)&#125; 테스트가 통과되는 가장 빠른 길을 택하기 위해 상수를 사용하는 죄악을 저질렀다.우선 테스트는 잘 통과된다.하지만 하나의 테스트 셋만 가지고는 제대로 구현했는지 검증이 안 되므로 JUnit5의 Dynamic Test를 이용하여 검증해보자. 123456789101112131415161718@TestFactoryfun `test addition`() = listOf( Pair(5, 2), Pair(6, 3)).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$$&#123;augendAmount&#125; + $$&#123;addendAmount&#125; = $$&#123;augendAmount + addendAmount&#125;&quot;) &#123; // Given val augend = Dollar(augendAmount) val addend = Dollar(addendAmount) // When val actual = augend + addend // Then val expected = Dollar(augendAmount + addendAmount) actual shouldBe expected &#125;&#125; $6 + 3 &#x3D; $9 테스트에서 실패한다.org.opentest4j.AssertionFailedError: expected:&lt;9&gt; but was:&lt;7&gt; plus 메서드의 반환값을 Dollar(7)이라는 상수를 박았기 때문에 실패했다.따라서 7이라는 상수를 변수로 변환시켜보면 아래와 같이 중복을 제거할 수 있다. 123operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(this.amount + dollar.amount)&#125; 이제 테스트를 돌려보면 모든 테스트가 통과한다.그냥 상수에서 변수로 바꾼 것 뿐인데 어느 부분이 중복이었길래 중복이 제거됐다고 하는지 의아해 할 수 있다.우리의 뇌가 너무 똑똑해서 머릿 속에서 연산이 순식간에 일어나서 중복이 아니라고 생각할 수 있는데 찬찬히 해체해보면 중복이 보인다. 123operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(7)&#125; 우선 상수를 사용하던 코드로 돌아가서 Dollar(7) 부분을 좀 더 집중해서 보면 우리 머릿 속에서 엄청 빠른 연산이 일어나서 7이란 값이 나온 거지 사실은 연산을 거치기 전에는 아래와 같다. 123operator fun plus(dollar: Dollar): Dollar &#123; return Dollar(5 + 2)&#125; 바로 테스트의 val expected = Dollar(augendAmount + addendAmount) 부분(augendAmount + addendAmount)과 중복되는 걸 볼 수 있다.따라서 우리는 Dollar 클래스의 amount 필드와 plus 메서드의 매개변수의 필드인 dollar.amount를 사용하여 중복을 제거했다.하나의 특별한 사례($5 + $2 = $7)에서만 동작하게 끔 상수(7)를 박았다가 다른 여러 사례($6 + $3 = $9 등)에 대해서도 작동할 수 있도록 변수(this.amount + dollar.amount)를 사용하여 일반화 시킴으로써 중복을 제거한 것이다.이렇게 성공하는 테스트를 먼저 작성해놓고 보면(일부는 실패했지만) 테스트의 수정없이(퍼블릭 API의 변경 없이) 소스코드의 수정이 매우 자유로워진다.즉, 테스트만 깨지지 않으면 되기 때문에 리팩토링하기 매우 좋은 환경이 제공된다. Franc 클래스 구현하기Franc 클래스도 Dollar 클래스와 내용이 별반 다를 게 없으므로 우선 테스트를 복붙해주자. (어떻게 구현할지 명확해지면 좀 더 보폭을 넓혀도 된다.) 12345678910111213141516171819202122232425262728293031323334class FrancTest &#123; @TestFactory fun `test addition`() = listOf( Pair(5, 2), Pair(6, 3) ).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$&#123;augendAmount&#125;CHF + $&#123;addendAmount&#125;CHF = $&#123;augendAmount + addendAmount&#125;CHF&quot;) &#123; // Given val augend = Franc(augendAmount) val addend = Franc(addendAmount) // When val actual = augend + addend // Then val expected = Franc(augendAmount + addendAmount) actual shouldBe expected &#125; &#125; @Test fun `5CHF + 2CHF != 10CHF`() &#123; // Given val five = Franc(5) val two = Franc(2) // When val actual = five + two // Then val notExpected = Franc(10) actual shouldNotBe notExpected &#125;&#125; 이제 컴파일이 되도록 하면 되는데 우리는 어떻게 구현해야할지 Dollar 클래스의 테스트를 작성하면서 명확해졌으므로 Dollar 클래스의 구현체도 복붙하자. 12345678910111213141516class Franc(private val amount: Long) &#123; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Franc if (amount != other.amount) return false return true &#125; operator fun plus(franc: Franc): Franc &#123; return Franc(this.amount + franc.amount) &#125;&#125; 컴파일이 가능해짐과 동시에 모든 테스트가 성공한다.모든 부분을 Dollar 테스트를 통해 검증했던 부분을 그대로 복붙한 것이므로 딱히 손 볼 곳이 없다. Dollar&#x2F;Franc 중복 제거하기우선 두 클래스의 plus&#x2F;equals 메서드를 보면 반환 타입만 다르거나 타입 캐스팅하는 부분만 다를 뿐, 로직은 동일하다.이 로직의 중복을 제거하려면 어떻게 해야할까?가장 빠르게 떠오른 방법은 두 클래스의 중복을 묶어줄(?) 상위 클래스가 있으면 될 거 같다. 우선 DollarTest에서 Money 타입을 사용하도록 아래와 같이 수정해보자. 12345678910111213141516171819202122232425262728293031323334class DollarTest &#123; @TestFactory fun `test addition`() = listOf( Pair(5, 2), Pair(6, 3) ).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$$&#123;augendAmount&#125; + $$&#123;addendAmount&#125; = $$&#123;augendAmount + addendAmount&#125;&quot;) &#123; // Given val augend: Money = Dollar(augendAmount) val addend: Money = Dollar(addendAmount) // When val actual: Money = augend + addend // Then val expected: Money = Dollar(augendAmount + addendAmount) actual shouldBe expected &#125; &#125; @Test fun `$5 + $2 != $10`() &#123; // Given val five: Money = Dollar(5) val two: Money = Dollar(2) // When val actual: Money = five + two // Then val notExpected: Money = Dollar(10) actual shouldNotBe notExpected &#125;&#125; 상속은 죄악이라고 하니까 우선 Money 인터페이스로 빼서 컴파일 되게 구현해보자. 1234interface Money &#123; val amount: Long operator fun plus(money: Money): Money&#125; 그 다음엔 Dollar 클래스가 Money 인터페이스를 구현하게 끔 수정해보자 12345678910111213141516class Dollar(override val amount: Long): Money &#123; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Dollar if (amount != other.amount) return false return true &#125; override operator fun plus(money: Money): Money &#123; return Dollar(this.amount + money.amount) &#125;&#125; 우선 테스트가 통과하긴 하는데… 이렇게 해선 plus&#x2F;equals 메서드를 Dollar 클래스에서 제거할 수 없다. (Franc 클래스에서도 마찬가지일 것이다.)인터페이스의 plus&#x2F;equals 메서드를 디폴트 메서드로 빼면 되긴 하는데 개인적으로 인터페이스의 취지에 적합하지 않다고 판단하여 적당히 타협하여 인터페이스를 추상 클래스로 변경해보자. 12345678910111213141516abstract class Money(private val amount: Long) &#123; override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Money if (amount != other.amount) return false return true &#125; operator fun plus(money: Money): Money &#123; return Dollar(this.amount + money.amount) &#125;&#125; Dollar 클래스를 Money 인터페이스 구현에서 추상 클래스 상속으로 변경해주자. 1class Dollar(amount: Long): Money(amount) 오! 모든 테스트가 통과하고 드디어 Dollar 클래스에서 plus&#x2F;equals 메서드를 제거했고, Dollar 클래스만 봤을 때 딱히 하는 일이 없어 보인다.뭔가 냄새…가 나지만 아직은 좀 참고, Franc 메서드의 plus&#x2F;equals도 제거해보자.우선은 FrancTest에서 Franc 대신에 Money를 사용하게 끔 수정해보자. 12345678910111213141516171819202122232425262728293031323334class FrancTest &#123; @TestFactory fun `test addition`() = listOf( Pair(5, 2), Pair(6, 3) ).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$&#123;augendAmount&#125;CHF + $&#123;addendAmount&#125;CHF = $&#123;augendAmount + addendAmount&#125;CHF&quot;) &#123; // Given val augend: Money = Franc(augendAmount) val addend: Money = Franc(addendAmount) // When val actual: Money = augend + addend // Then val expected: Money = Franc(augendAmount + addendAmount) actual shouldBe expected &#125; &#125; @Test fun `5CHF + 2CHF != 10CHF`() &#123; // Given val five: Money = Franc(5) val two: Money = Franc(2) // When val actual: Money = five + two // Then val notExpected: Money = Franc(10) actual shouldNotBe notExpected &#125;&#125; 이제 Franc 클래스가 Money 추상 클래스를 상속하도록 수정하자. 1class Franc(amount: Long): Money(amount) 오! 드디어 Franc에서도 plus&#x2F;equals 메서드를 제거했다.하지만 테스트를 돌려보면 test addition 테스트가 깨진다.org.opentest4j.AssertionFailedError: expected:&lt;com.example.demo.Franc@3e08ff24&gt; but was:&lt;com.example.demo.Dollar@70ed52de&gt; Money 클래스의 plus 메서드가 Dollar 구체 클래스를 반환하기 때문에 발생하는 문제다.일단 테스트가 깨졌기 때문에 한 발짝 물러서서 Dollar, Franc, Money 클래스와 테스트 코드를 전부 롤백하고 다시 보폭을 줄여보자. 하위 클래스의 직접적인 참조 줄이기책 88P에는 아래와 같이 나와있다. 하위 클래스에 대한 직접적인 참조가 적어진다면 하위 클래스를 제거하기 위해 한 발짝 더 다가섰다고 할 수 있겠다. DollarTest 클래스에서 Money의 하위 클래스인 Dollar 클래스에 직접적으로 접근하는 부분은 생성자를 통해 객체를 생성하는 부분과 plus 메서드의 반환타입이다.생성자는 팩토리 메서드를 통해 직접 참조를 제거하면 되고, plus 메서드의 반환타입은 Money를 반환하게 끔 수정하면 된다. 12345678910111213141516171819202122232425262728293031323334class DollarTest &#123; @TestFactory fun `test addition`() = listOf( Pair(5, 2), Pair(6, 3) ).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$$&#123;augendAmount&#125; + $$&#123;addendAmount&#125; = $$&#123;augendAmount + addendAmount&#125;&quot;) &#123; // Given val augend: Money = Money.dollar(augendAmount) val addend: Money = Money.dollar(addendAmount) // When val actual: Money = augend + addend // Then val expected: Money = Money.dollar(augendAmount + addendAmount) actual shouldBe expected &#125; &#125; @Test fun `$5 + $2 != $10`() &#123; // Given val five: Money = Money.dollar(5) val two: Money = Money.dollar(2) // When val actual: Money = five + two // Then val notExpected: Money = Money.dollar(10) actual shouldNotBe notExpected &#125;&#125; 이제 컴파일이 되도록 수정해보자. 12345678910abstract class Money &#123; companion object &#123; fun dollar(amount: Long): Money = Dollar(amount) &#125; // 팩토리 메서드가 부모 클래스 타입을 리턴하도록 변경하였으므로 부모 클래스 API에 plus 메서드가 추가돼야한다. // Money 클래스에서 plus 메서드를 구현하면 Dollar/Franc 구체 클래스 중 하나를 선택해야하는데 // 그러면 Dollar나 Franc의 equals 메서드에 대한 테스트가 깨져버리므로 우선 자식 클래스에게 위임해두자. abstract operator fun plus(money: Money): Money&#125; Money에 Dollar 객체를 생성하는 static factory method를 추가했고 plus 추상 메서드도 추가했다.다시 Dollar에서 Money를 상속 받게 끔 하자. 1234567class Dollar(private val amount: Long): Money() &#123; // ... override operator fun plus(money: Money): Money &#123; return Dollar(this.amount + money.amount) &#125; // ..&#125; 테스트를 돌리면 성공한다. 이번에는 FrancTest에서 Franc(Money의 하위클래스)에 대한 참조를 없애보자. 12345678910111213141516171819202122232425262728293031323334class FrancTest &#123; @TestFactory fun `test addition`() = listOf( Pair(5, 2), Pair(6, 3) ).map &#123; (augendAmount, addendAmount) -&gt; dynamicTest(&quot;$&#123;augendAmount&#125;CHF + $&#123;addendAmount&#125;CHF = $&#123;augendAmount + addendAmount&#125;CHF&quot;) &#123; // Given val augend: Money = Money.franc(augendAmount) val addend: Money = Money.franc(addendAmount) // When val actual: Money = augend + addend // Then val expected: Money = Money.franc(augendAmount + addendAmount) actual shouldBe expected &#125; &#125; @Test fun `5CHF + 2CHF != 10CHF`() &#123; // Given val five: Money = Money.franc(5) val two: Money = Money.franc(2) // When val actual: Money = five + two // Then val notExpected: Money = Money.franc(10) actual shouldNotBe notExpected &#125;&#125; 이제 컴파일이 되도록 수정해보자. 1234567891011abstract class Money &#123; companion object &#123; fun dollar(amount: Long): Money = Dollar(amount) fun franc(amount: Long): Money = Franc(amount) &#125; // 팩토리 메서드가 부모 클래스 타입을 리턴하도록 변경하였으므로 부모 클래스 API에 plus 메서드가 추가돼야한다. // Money 클래스에서 plus 메서드를 구현하면 Dollar/Franc 구체 클래스 중 하나를 선택해야하는데 // 그러면 Dollar나 Franc의 equals 메서드에 대한 테스트가 깨져버리므로 우선 자식 클래스에게 위임해두자. abstract operator fun plus(money: Money): Money&#125; Money에 Franc 객체를 생성하는 static factory method를 추가했고 다시 Franc에서 Money를 상속 받게 끔 하자. 1234567class Franc(private val amount: Long): Money() &#123; // ... override operator fun plus(money: Money): Money &#123; return Franc(this.amount + money.amount) &#125; // ..&#125; 이제 모든 테스트가 통과한다.외부에서 바라봤을 때는 객체의 생성이 직접적인 생성자를 통한 생성에서 외부 클래스의 static factory method를 통한 생성으로 바뀌었고, plus 메서드의 반환 타입이 부모 클래스로 바뀌었을 뿐이다.이것이 무엇을 의미하는지는 책 90P에 나온다. 어떤 클라이언트(현재 우리 예제에서는 테스트) 코드도 Dollar(또는 Franc)라는 이름의 하위 클래스가 있다는 사실을 알지 못한다.하위 클래스의 존재를 **테스트에서 분리(decoupling)**함으로써 어떤 모델 코드에도 영향을 주지 않고 상속 구조를 마음대로 변경할 수 있게 됐다. 외부에서는 Money 클래스 밖에 모르므로 상속 구조가 마음껏 바뀌어도 끽해봐야 Money 타입이기 때문에 클라이언트 측에는 전혀 영향을 미치지 않는 것이다.하위 클래스의 직접 참조를 제거한 것만으로 하위 클래스 제거에 큰 한 걸음을 나간 것이나 마찬가지다.여기서 멈추지 말고 각 하위 클래스에 있는 equals 메서드를 부모 클래스로 올려서 하위 클래스에서 제거해보자. 1234567891011121314abstract class Money(val amount: Long) &#123; // ... override fun equals(other: Any?): Boolean &#123; if (this === other) return true if (javaClass != other?.javaClass) return false other as Money if (amount != other.amount) return false return true &#125; // ...&#125; 이제 각 하위 클래스에서 컴파일이 되도록 수정하고, equals 메서드도 제거해보자. 12345class Dollar(amount: Long): Money(amount) &#123; override operator fun plus(money: Money): Money &#123; return Dollar(this.amount + money.amount) &#125;&#125; 12345class Franc(amount: Long): Money(amount) &#123; override operator fun plus(money: Money): Money &#123; return Franc(this.amount + money.amount) &#125;&#125; 다시 모든 테스트를 돌려보면 전부 통과한다. 마치며하위 클래스에 대한 직접적인 참조를 제거하면 외부(클라이언트)에 영향 없이 상속 구조를 마음껏 수정할 수 있다는 사실에 큰 감명을 받았다.plus 메서드까지 제거하는 방법을 보기 위해서는 하위 클래스를 제거하기 쉽게 만드는 방법을 보자.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Study","slug":"Note/Study","permalink":"https://perfectacle.github.io/categories/Note/Study/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://perfectacle.github.io/tags/TDD/"}]},{"title":"(Hexo) NexT 테마에서 '더 읽어보기'를 설정하는 방법","slug":"how-to-set-read-more-in-next-theme","date":"2020-05-31T12:15:21.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2020/05/31/how-to-set-read-more-in-next-theme/","link":"","permalink":"https://perfectacle.github.io/2020/05/31/how-to-set-read-more-in-next-theme/","excerpt":"","text":"themes/next/_config.yml을 보면 아래와 같이 기본적으로 ‘더 읽어보기’가 세팅돼있다. 123456789# Automatically excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt section.read_more_btn: true 하지만 NexT Theme 7.6.0 이상의 버전에서는 위와 같이 설정이 돼있어도 ‘더 읽어보기’가 나오지 않는다.이럴 때는 hexo-excerpt 플러그인을 설치해주면 해결된다. &amp;#x1f389;https://github.com/theme-next/hexo-theme-next/issues/1245#issuecomment-558486354 If you are using NexT 7.6.0 and later, please install the plugin: https://github.com/chekun/hexo-excerpt","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://perfectacle.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://perfectacle.github.io/tags/Theme/"},{"name":"NexT","slug":"NexT","permalink":"https://perfectacle.github.io/tags/NexT/"}]},{"title":"공인인증서","slug":"korean-certification","date":"2020-01-24T15:52:03.000Z","updated":"2022-10-30T08:42:16.735Z","comments":true,"path":"2020/01/24/korean-certification/","link":"","permalink":"https://perfectacle.github.io/2020/01/24/korean-certification/","excerpt":"인증서는 왜 쓸까A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.인증서는 A라는 사람이라는 것을 보증해주는 문서라고 보면 된다.따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 **인증된 기관(CA, Certificate Authority)**으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다. 우리가 알고 있는 TLS 인증서(https 도메인마다 발라져있는) 같은 경우에도 이런 절차를 거쳐 발급된다.그리고 이런 인증서들은 **X.509(공개키 인증서 포맷의 표준)**라는 표준을 준수한다.","text":"인증서는 왜 쓸까A가 데이터를 보냈는데 이게 진짜 A가 보낸 건지 아닌지를 검증할 수가 없다.인증서는 A라는 사람이라는 것을 보증해주는 문서라고 보면 된다.따라서 A한테 메세지가 올 때 A의 인증서가 오지 않는다면 A라고 취급을 하지 않으면 된다.하지만 개나소나 인증서를 발급할 수 있으면 A 행세를 아무나 낼테니까 **인증된 기관(CA, Certificate Authority)**으로부터 적절한 절차를 거쳐 인증서를 발급받을 수 있다. 우리가 알고 있는 TLS 인증서(https 도메인마다 발라져있는) 같은 경우에도 이런 절차를 거쳐 발급된다.그리고 이런 인증서들은 **X.509(공개키 인증서 포맷의 표준)**라는 표준을 준수한다. 공인인증서는 왜 나왔을까인터넷 뱅킹이나 온라인 쇼핑몰 등등을 이용하기 위해서는 보안이 취약해서는 안되며 이를 위해서 인증서 사용은 필수이다. https://news.joins.com/article/521864하지만 과거에는 미국의 수출 금지법에 의해 미국을 제외한 나라에서는 브라우저에서 56bit 길이 이하의 약한 암호화 방식 밖에 사용할 수 없었다. 따라서 국내에서 직접 암호화 알고리즘인 SEED(128bit 길이, 2009년부터는 256bit 길이도 제공)를 개발하고,해당 알고리즘을 사용하는 공인인증서도 만들게 되었다. 하지만 국제 표준 암호 알고리즘도 아니고 국내에서만 인증된 CA에서 발급한 인증서이다보니 웹 브라우저에서 사용할 수 없었다.따라서 당시 국내 점유율이 압도적인 IE에서 사용이 가능한 ActiveX라는 기술을 사용하여 공인인증서를 사용할 수 있게 만들었다. 과거에는 어쩔 수 없는 선택일 수 밖에 없었을 것 같은데 브라우저에서 해당 제약이 사라진 요즘같은 시대에비표준 기술을 위해 ActiveX나 설치형 프로그램을 잔뜩 깔아야하는 건 아마 여러 이해관계가 얽혀있기 때문이 아닐까 싶다.(그 때문에 사용자만 엄청 고생하는 ㅠㅠ…) 공인인증서 구조 MacOS는 &#x2F;Users&#x2F;사용자이름&#x2F;Library&#x2F;Preferences&#x2F;NPKI,Windows 10는 C:\\Users\\사용자이름\\AppData\\LocalLow\\NPKI에 위치하고 있다. 공인인증서(*.der, *.cer 등등)와 개인키(*.key)파일로 이루어져있다.아니면 공인인증서와 개인키 파일이 합쳐진 형태(*.p12, *.pfx 등등)로 이루어진 경우도 있다.공인인증서와 개인키 파일이 합쳐진 형태는 PKCS#12(Public Key Cryptography Standards, 공개키 암호화 표준의 12번째 표준)을 준수하고 있다.PKCS#12는 다수의 X.509 인증서 + 개인키 묶음을 하나의 파일로 저장하기 위한 표준이다. 공인인증서*.cer(Canonical Encoding Rules) 또는 *.der(Distinguished Encoding Representation)과 같은 확장자를 가지며 바이너리 형태로 인코딩 돼있다. 공인인증서는 X.509 V3을 따른다.또한 공인인증서 소유자의 공개키 + CA(Certificate Authority, 발행기관) 정보 및 전자서명 + 사용목적 + 유효기간 등등이 저장돼있다. 위 인증서는 은행에서 사용 중인 공인인증서인데 은행에 대한 정보는 1도 없다.아마 은행은 CA가 아니기 때문에 CA에게 대신 발급 요청(CSR, Certificate Signing Request)을 하고 발급받은 인증서를 개인에게 전달해주는 시스템 같다.아마 보안모듈은 공인인증서를 전달받으면 해당 CA로부터 발급된 인증서가 맞는지 검증까지 해주는 것 같다.(TLS 인증서였다면 이런 행위는 브라우저가 알아서 해주겠지만…)CA(인증서 발급 기관, Certificate Authority)에게 인증서 발급을 요청할 때 요청자의 공개키를 함께 보낸다.그러면 CA는 서명(CA의 개인키로 암호화)한 인증서를 발급해준다.그리고 인증서 안에는 인증서 발급 요청자의 공개키가 포함돼있고, 어떤 용도의 인증서인지,어느 기관(CA, Certificate Authority)에서 발급한 건지 등등의 정보가 포함돼있다. 또한 공인인증서는 국내에서만 사용하는 인증서이기 때문에 OS 레벨에서는 해당 인증서가 신뢰된 CA로부터 발급받은 인증서인지 알 수가 없다.(그냥 은행이나 공공기관 등등을 믿고 쓰는 수 밖에…) 비밀키 (*.key) 전자서명인증관리센터에 보면 PKCS#5와 PKCS#8 형식이라고 나와있다. In cryptography, PKCS #8 is a standard syntax for storing private key information. The PKCS #8 private key may be encrypted with a passphrase using the PKCS #5 standards, which supports multiple ciphers. PKCS#8(Private-Key Information Syntax Standard)이 뭔지 찾아보니 위키피디아에서는 개인키 저장을 위한 문법 표준이라고 하고 있다.웬만한 개인키는 다 이 형식을 따르는 것 같다.여기서 말하는 passphrase는 사용자가 공인인증서를 만들 때 입력한 비밀번호를 의미한다. 이번엔 PKCS#5(Password-Based Cryptography Standard)가 뭔지 찾아보니 패스워드를 깨먹기 어렵게 하기 위한 표준 같아 보였다.그 안에는 Key Derivation Functions라는 게 있는데 패스워드 + salt + 이터레이션 카운트(해당 함수를 몇 번 이터레이션 돌릴지) 등등을 인자로 받아서 추가 연산을 진행하는 함수인데,패스워드를 빠르게 계산하기 어렵게 해서 해커가 공격을 빠르게 하지 못하게 막기 위해 사용하는 함수 같다.이런 Key Derivation Function을 커스텀하게 구현해도 되지만 좀 더 검증되고 표준에 등재된PBKDF1과 PBKDF2가 있는데 공인인증서는 두 가지 방식을 모두 지원한다. 그리고 공인인증서의 개인키는 SEED 알고리즘으로 암호화해서 저장돼있다고 하니 개인키를 얻어오려면 복호화를 해야한다. ASN.1(Abstract Syntax Notation One)X.509 인증서의 데이터 구조는 ASN.1 표기법에 의해 표기된다.따라서 디코딩해보면 더 많은 정보를 얻어낼 수 있는데 온라인에서 디코딩을 할 수 있다. https://lapo.it/asn1js에 들어가서 공인인증서나 개인키 파일을 Base64로 인코딩한 텍스트를 입력한 후에 decode 버튼을 누르면 더 자세한 정보를 볼 수 있다. 개인키 파일을 디코딩해보면 어떤 암호화 알고리즘을 사용했는지, 어떤 KDF(Key Derivation Function)를 사용했는지 나온다.object identifer를 http://oid-info.com/get/1.2.410.200004.1.4에서 검색하면 더 자세한 정보가 나온다. 또한 SEED 알고리즘 규격 문서를 보면 OID에 따라서 초기 벡터 값을 어떻게 세팅해야하는지 나온다. ActiveX로 깔은 모듈(delfino, Xecure 등등)에서는 무슨 일을 할까…? 그 안에서 공인인증서도 가져오고, 개인키 파일을 복호화 해서 개인키를 획득하기도 하고…여러가지 행위들을 한다. PKCS #7(Cryptographic Message Syntax)이 뭔지 찾아보니 전자서명에 대한 표준 같아 보였다.실제로 어떤 카드사의 경우에는 PKCS7 방식으로 전자서명 하는 모듈을 쓰는 곳도 있다. 근데 PKCS7에 보낸 데이터를 보니 Base64 인코딩 된 스트링이고 이 데이터는 전자서명한 데이터는 아니고,ASN.1 Decoder로 보니 내 공인인증서였다.내 공인인증서를 보냄으로써 내가 맞는지 검증하는 것 같다.하지만 공개키 인증서는 기본적으로 여기저기 공유가 돼도 문제 없도록 만들었다.따라서 저 공인인증서를 내가 전달한 건지, 남이 전달한 건지 서버는 알 길이 없다. 식별번호를 이용한 본인확인 기술규격을 보면 다음과 같은 부분이 나와있다.VID = h(h(IDN, R) VID: 가상식별번호 h( ) : 해쉬 함수 IDN : 식별번호 식별번호 : 전자서명법 시행규칙 제13조의2에 의한 주민등록번호, 사업자등록번호 및 고유번호 R: 비트열 난수본 규격에서는 적어도 160비트 이상의 안전한 임의의 난수를 생성하여 사용해야한다. 난수는 가상 식별번호를 생성하는데 사용되며 가상 식별번호와 함께 공인인증기관에 전달되어 공인인증기관이 식별번호를 검증하는데 사용된다.국민은행 측에 보낸 VID_RANDOM 값을 Base64 디코딩해보면 20바이트(160비트)의 데이터가 나온다. 따라서 보안 모듈에서는 다음과 같은 행동이 일어났다. 공인인증서 목록을 불러온다. 비밀번호를 입력받아서 개인키를 복호화한다. 복호화한 개인키에서 R값을 가져온다. js에서 보안모듈(127.0.0.1)과 통신을 해서 R값과 공인인증서 값을 받아와서 국민은행 사이트에게 ajax로 요청을 보낸다. 해당 유저의 공인인증서와 R값이 맞다면 로그인을 성공시킨다. 모듈마다 어떻게 인증 절차를 거치는지 다 다르다.어떤 모듈은 PKCS7 방식으로 전자서명한 데이터를 보내는 모듈도 있고, 어떤 모듈은 추출한 R 값을 한 번 더 암호화 해서 보내는 곳도 있고,어떤 곳은 Base64 인코딩이 아닌 Hex 인코딩을 사용하는 곳도 있다.하지만 같은 모듈을 사용하는 은행&#x2F;카드사가 있다면 비슷한 방식을 통해 로그인 과정이 이뤄진다.(하나를 뚫으면 여러 벤더사를 함께 뚫을 수 있게 된다.) 참조 링크 https://www.letmecompile.com/certificate-file-format-extensions-comparison/ https://indienote.tistory.com/272 https://indienote.tistory.com/273 https://www.slideshare.net/ied206/4th-inc0gnito https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0https://unius.tistory.com/entry/%EC%A0%84%EC%9E%90%EC%84%9C%EB%AA%85-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0 https://news.joins.com/article/521864 SEED 암호 알고리즘 규격 전자서명 인증서 프로파일 규격","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"삽질","slug":"Note/삽질","permalink":"https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"}],"tags":[{"name":"보안","slug":"보안","permalink":"https://perfectacle.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"공인인증서","slug":"공인인증서","permalink":"https://perfectacle.github.io/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%84%9C/"}]},{"title":"AES 256 CBC + PBKDF2","slug":"aes","date":"2019-11-24T09:59:51.000Z","updated":"2022-10-30T08:42:16.131Z","comments":true,"path":"2019/11/24/aes/","link":"","permalink":"https://perfectacle.github.io/2019/11/24/aes/","excerpt":"막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다. 양방향&#x2F;단방향 암호화양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.양방향 암호화 알고리즘에는 DES(보안에 취약), AES, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다. 단방향 암호화는 암호화만 가능하고 복호화는 불가능하다는 소리다.비밀번호와 같이 암호화 한 값들끼리 단순히 비교만 하면 되고, 복호화 할 필요가 없는 정보들은 단방향 암호화 해야한다.혹시나 키와 DB가 털려도 복호화가 불가능하기 때문에 암호화된 값만 알 수 있지 원본 비밀번호는 알 수 없기 때문에 양방향 암호화 보다는 좀 더 안전하다.이런 특성 때문에 비밀번호 찾기 대신에 비밀번호 재설정 기능 밖에 지원 할 수 없다. (비밀번호 찾기를 지원해주는 사이트는 보안이 매우 안 좋은 사이트이다.)단방향 암호화 알고리즘에는 해시 알고리즘이 사용되며 SHA256, SHA512, MD5(무작위 대입 공격에 약함) 등등이 있다.","text":"막연하게 양방향 암호화 하면 당연스레 AES를 떠올리고, 제대로 모른 채로 사용했다.이제부터라도 조금은 알고 써야겠다는 생각이 들어서 살짝 정리해봤다. 양방향&#x2F;단방향 암호화양방향 암호화는 암호화 및 복호화가 가능하다는 소리다.휴대폰 번호 등등 민감한 개인정보는 암호화 해서 저장해야하는데 고객 정보를 식별하기 위해선 복호화도 가능해야한다.혹시나 키와 DB가 털린다면 복호화가 가능하므로 적어도 개인정보는 마스킹 한 후에 암호화해서 저장해야한다.양방향 암호화 알고리즘에는 DES(보안에 취약), AES, SEED(국내에서 개발, 공인인증서에 사용됨) 등등이 있다. 단방향 암호화는 암호화만 가능하고 복호화는 불가능하다는 소리다.비밀번호와 같이 암호화 한 값들끼리 단순히 비교만 하면 되고, 복호화 할 필요가 없는 정보들은 단방향 암호화 해야한다.혹시나 키와 DB가 털려도 복호화가 불가능하기 때문에 암호화된 값만 알 수 있지 원본 비밀번호는 알 수 없기 때문에 양방향 암호화 보다는 좀 더 안전하다.이런 특성 때문에 비밀번호 찾기 대신에 비밀번호 재설정 기능 밖에 지원 할 수 없다. (비밀번호 찾기를 지원해주는 사이트는 보안이 매우 안 좋은 사이트이다.)단방향 암호화 알고리즘에는 해시 알고리즘이 사용되며 SHA256, SHA512, MD5(무작위 대입 공격에 약함) 등등이 있다. AES (Advanced Encryption Standard)DES 암호화 방식에 결함이 발견되어 그 이후에 미국에서 열린 암호화 공모전에서 채택된 알고리즘이다.대칭키 방식이라 암호화 및 복호화에 사용되는 키 값이 동일하다.서버에서 사용되는 AES의 키는 대부분 파일로 저장돼있다기 보다는 키 값에 사용될 값을 어디 비밀스러운 공간에 저장해뒀다가 불러오는 예제가 대다수이다.소스코드나 config 파일에 문자열을 하드코딩 해뒀다가 사용하는 곳도 있지만 깃헙 등등이 털리면 답이 없기 때문에 정말 비밀스런 공간에 저장했다가 불러와야한다.(정말 비밀스러운 공간에 잘 저장해뒀다가 불러오는 방법은 자세히는 모르겠다.) AES128 vs AES192 vs AES256키 값의 길이에 따라 AES128(128 bit &#x3D;&#x3D; 16 byte), AES192(192 bit &#x3D;&#x3D; 24 byte), **AES256(256 bit &#x3D;&#x3D; 32 byte)**으로 나뉜다.키 값이 길면 길수록 무작위 대입 공격에 유리하다는 장점이 있다.예를 들면 AES128은 2¹²⁸번 시도해서 공격에 성공한다면 AES256은 2²⁵⁶번 시도해야 성공할 수 있다. 하지만 이것 외에 또 다른 차이점이 있는데, 암호화에는 Round라는 게 존재한다.예를 들면 1Round에는 bit-rotation을 진행하고, 2Round에는 1Round에서 나온 걸 XOR 연산하고, 뭐 이런 식으로 각 Round 별로 암호화에 필요한 연산을 진행하게 된다.AES128은 10Round, AES192는 12Round, AES256은 14Round에 걸쳐 암호화를 진행한다. 따라서 AES256은 키 값이 길어서 무작위 대입에도 유리하고, 암호화에 진행되는 Round도 많다보니 다른 방식에 비해 더 우수한 알고리즘이다.물론 컴퓨팅 파워를 더 쓰긴 하겠지만, 요즘 서버 스펙에는 큰 무리는 되지 않는다.오히려 불필요하게 빠르면 무작위 대입 공격에 더 불리해질 뿐이다. (유저 입장에서는 ms 단위의 차이는 체감도 하지 못할 수준일 것이다.) Block CipherAES는 128 bit(16 byte)라는 고정된 블럭 단위로 암호화를 수행한다.이는 키 값의 길이와는 전혀 무관하다.하지만 AES는 128 bit까지만 암호화 할 수 있으므로 128 bit가 넘어가는 데이터를 암호화하기 위해 Block Cipher Mode(EBC, CBC 등등)를 선택해야한다.즉 256 bit의 평문을 암호화 할 때 두 개의 128 bit로 쪼개서 각각 암호화를 수행하게 된다. 또한 128 bit의 블럭으로 쪼개기 때문에 128 bit 보다 작은 블럭이 나올 수 있는데 이런 블럭은 뒤에 값을 붙여주는데 이 값을 padding이라고 부른다.이따 나올 예제에서 사용하는 패딩의 종류를 보면 PKCS#5 padding을 사용하고 있다.하지만 PKCS#5 padding은 8 byte 블럭에 대한 패딩인데 왜 PKCS#5 padding을 사용하는지 의문을 가지게 된다.스택오버플로우의 한 댓글을 살펴보면레거시의 잔재인 것 같고, 내부적으로는 PKCS#7 padding으로 변환되는 것 같다.PKCS#7 padding은 1~255 byte의 block에 대한 패딩을 만들어내는 방식이다.소스 코드에서 PKCS#5 padding을 사용하는 것처럼 보이는 게 싫다면 Bouncy Castle을 사용해야한다.Bouncy Castle 없이 PKCS#7 padding을 사용하려고 하면 java.security.NoSuchAlgorithmException 예외를 만나게 될 것이다. EBC (Electronic Codebook)짧게 말하면 실무에서는 절대 사용하면 안 되는 Mode이다. 이미지 출처: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB) EBC는 각 블럭을 독립적으로 암&#x2F;복호화한다.독립적으로 암호화하기 때문에 병렬로 암&#x2F;복호화 할 수 있기 때문에 속도 측면에서 장점을 가진다.또한 키값만 설정하면 되기 때문에 사용하기 쉽다는 장점도 가지고 있다. 123456789101112131415161718192021222324252627282930313233// 키 길이는 256 bit(32 byte)이다.private const val KEY_LENGTH = 32// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)private val KEY = &quot;a&quot;.repeat(KEY_LENGTH)object AES256ECB &#123; private val secretKeySpec = try &#123; SecretKeySpec(KEY.toByteArray(), &quot;AES&quot;) &#125; catch (e: Exception) &#123; println(&quot;Error while generating key: $e&quot;) null &#125; fun encrypt(plainText: String): ByteArray? = try &#123; // 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다. val cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5PADDING&quot;) cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec) cipher.doFinal(plainText.toByteArray()) &#125; catch (e: Exception) &#123; println(&quot;Error while encrypting: $e&quot;) null &#125; fun decrypt(cipherText: ByteArray?): String? = try &#123; // 각각 알고리즘/Block Cipher Mode/Padding 메카니즘이다. val cipher = Cipher.getInstance(&quot;AES/ECB/PKC55PADDING&quot;) cipher.init(Cipher.DECRYPT_MODE, secretKeySpec) String(cipher.doFinal(cipherText)) &#125; catch (e: Exception) &#123; println(&quot;Error while decrypting: $e&quot;) null &#125;&#125; 123456789101112131415161718private const val PLAIN_TEXT = &quot;a&quot;internal class AES256ECBTest &#123; @Test internal fun testEncrypt() &#123; // 0 ~ 127 bit까지는 한 블럭 안에 담긴다. val encrypted = AES256ECB.encrypt(&quot;&quot;) assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE) &#125; @Test internal fun testDecrypt() &#123; val encrypted = AES256ECB.encrypt(PLAIN_TEXT) val decrypted = AES256ECB.decrypt(encrypted) assertThat(PLAIN_TEXT).isEqualTo(decrypted) &#125;&#125; 하지만 각 블럭이 독립적으로 암호화 되기 때문에 더 빨리 공격당하기 쉽고(병렬로 암&#x2F;복호화 시도), 아래와 같은 결함을 가진다. 12345678910111213141516171819202122232425262728293031323334private const val PLAIN_TEXT = &quot;a&quot;private const val BLOCK_SIZE = 16private const val DUPLICATED_COUNT = 5internal class AES256ECBTest &#123; @Test internal fun `반복된 문자열을 암호화 하면 반복된 암호문 블럭이 나온다`() &#123; // 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다. val encrypted = AES256ECB.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT)) val encryptedBlocks = mutableListOf( encrypted?.copyOfRange(BLOCK_SIZE, BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf() ) for (i in 1 until DUPLICATED_COUNT) &#123; val firstBlock = encryptedBlocks.first() val currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf() if (firstBlock.contentEquals(currentBlock)) continue encryptedBlocks.add(currentBlock) &#125; // 암호문에 들어간 반복된 문자열들을 추론 가능해짐. assertThat(encryptedBlocks.size).isEqualTo(1) &#125; @Test internal fun `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`() &#123; val encrypted = AES256ECB.encrypt(PLAIN_TEXT) val encrypted2 = AES256ECB.encrypt(PLAIN_TEXT) // 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다. assertThat(encrypted).isEqualTo(encrypted2) &#125;&#125; 위와 같은 보안적 결함 때문에 1 ~ 127 bit의 데이터를 암호화 할 때만 사용해야한다고 하던데,그런 거 따질 시간에 그냥 안전한 CBC 모드를 무조건 쓰는 걸 권장한다. CBC (Cipher Block Chaining)예제를 찾다보면 가장 많이 보이는 Mode인 것 같다. 이미지 출처: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC) IV(Initialization vector)라는 처음보는 값이 사용된다.vector는 힘과 방향을 가진다 라고 학교에서 배웠었는데 여기서 어떤 의미로 vector가 쓰인 건지는 잘 모르겠다… 첫 블럭의 암호문 결과가 다음 블럭에도 쓰이기 때문에 암호화 할 때 병렬로 처리하지 못한다.하지만 복호화 할 때는 복호화 한 블럭이 그 다음 블럭에 사용되는 게 아니기 때문에 병렬로 처리할 수 있다.이런 부분에 있어서 무작위 대입 공격에 EBC 보다는 더 유리하지 않을까 싶다. 간단하게 예제를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738// 키 길이는 256 bit(32 byte)이다.private const val KEY_LENGTH = 32// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)private val KEY = &quot;a&quot;.repeat(KEY_LENGTH)// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.private const val BLOCK_SIZE = 16// 16 바이트가 아닌 경우에는 java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 16 bytes long 오류가 나온다.private val IV = &quot;a&quot;.repeat(BLOCK_SIZE)object AES256CBC &#123; private val ivParameterSpec = IvParameterSpec(IV.toByteArray()) private val secretKeySpec = try &#123; SecretKeySpec(KEY.toByteArray(), &quot;AES&quot;) &#125; catch (e: Exception) &#123; println(&quot;Error while generating key: $e&quot;) null &#125; fun encrypt(plainText: String): ByteArray? = try &#123; val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec) cipher.doFinal(plainText.toByteArray()) &#125; catch (e: Exception) &#123; println(&quot;Error while encrypting: $e&quot;) null &#125; fun decrypt(cipherText: ByteArray?): String? = try &#123; val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec) String(cipher.doFinal(cipherText)) &#125; catch (e: Exception) &#123; println(&quot;Error while decrypting: $e&quot;) null &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940private const val PLAIN_TEXT = &quot;a&quot;private const val BLOCK_SIZE = 16private const val DUPLICATED_COUNT = 5internal class AES256CBCTest &#123; @Test internal fun testEncrypt() &#123; // 0 ~ 127 bit까지는 한 블럭 안에 담긴다. val encrypted = AES256CBC.encrypt(&quot;&quot;) assertThat(encrypted?.size).isEqualTo(BLOCK_SIZE) &#125; @Test internal fun testDecrypt() &#123; val encrypted = AES256CBC.encrypt(PLAIN_TEXT) val decrypted = AES256CBC.decrypt(encrypted) assertThat(PLAIN_TEXT).isEqualTo(decrypted) &#125; @Test internal fun `반복된 문자열을 암호화 해도 각 블럭은 다른 암호문 형태로 나온다`() &#123; // 좀 더 깔끔한 예제를 만들기 위해 패딩 값이 없게 끔 각 블럭을 꽉꽉 채워 암호화 시도한다. val encrypted = AES256CBC.encrypt(PLAIN_TEXT.repeat(BLOCK_SIZE * DUPLICATED_COUNT)) val encryptedBlocks = mutableListOf( encrypted?.copyOfRange(0, BLOCK_SIZE) ?: byteArrayOf() ) for (i in 1 until DUPLICATED_COUNT) &#123; val firstBlock = encryptedBlocks.first() val currentBlock = encrypted?.copyOfRange(i * BLOCK_SIZE, i * BLOCK_SIZE + BLOCK_SIZE) ?: byteArrayOf() if (firstBlock.contentEquals(currentBlock)) continue encryptedBlocks.add(currentBlock) &#125; // 암호문에 들어간 반복된 문자열들이 추론 불가능하다. assertThat(encryptedBlocks.size).isEqualTo(DUPLICATED_COUNT) &#125;&#125; 하지만 아래 결함은 여전히 가지고 있다. 1234567891011121314private const val BLOCK_SIZE = 16private const val DUPLICATED_COUNT = 5private const val PLAIN_TEXT = &quot;a&quot;internal class AES256CBCTest &#123; @Test internal fun `똑같은 평문을 암호화 하면 똑같은 암호문이 나온다`() &#123; val encrypted = AES256CBC.encrypt(PLAIN_TEXT) val encrypted2 = AES256CBC.encrypt(PLAIN_TEXT) // 딕셔너리를 만들어두면 어느 정도 암호문의 평문 데이터 추론이 가능해진다. assertThat(encrypted).isEqualTo(encrypted2) &#125;&#125; 똑같은 평문을 암호화 하면 똑같은 암호문이 나온다는 문제는 IV값이 매번 고정이기 때문에 발생하는 문제이다.IV 값을 암호화 할 때마다 랜덤하게 생성해주면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 키 길이는 256 bit(32 byte)이다.private const val KEY_LENGTH = 32// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)private val KEY = &quot;a&quot;.repeat(KEY_LENGTH)// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.private const val BLOCK_SIZE = 16object AES256CBC &#123; private val secretKeySpec = try &#123; SecretKeySpec(KEY.toByteArray(), &quot;AES&quot;) &#125; catch (e: Exception) &#123; println(&quot;Error while generating key: $e&quot;) null &#125; fun encrypt(plainText: String): ByteArray? = try &#123; // Generate Random IV val iv = ByteArray(BLOCK_SIZE) SecureRandom.getInstanceStrong().nextBytes(iv) val ivParameterSpec = IvParameterSpec(iv) val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec) val encrypted = cipher.doFinal(plainText.toByteArray()) // Combine Random IV and Encrypted Data iv + encrypted &#125; catch (e: Exception) &#123; println(&quot;Error while encrypting: $e&quot;) null &#125; fun decrypt(cipherText: ByteArray?): String? = try &#123; // Extract IV and Encrypted Data. val iv = cipherText?.copyOfRange(0, BLOCK_SIZE) val ivParameterSpec = IvParameterSpec(iv) val encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size) val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec) String(cipher.doFinal(encrypted)) &#125; catch (e: Exception) &#123; println(&quot;Error while decrypting: $e&quot;) null &#125;&#125; 암호화 할 때 매번 랜덤한 IV 값을 생성하고,복호화 할 때는 랜덤한 IV 값을 알 수 없기 때문에 암호문 첫 16바이트는 랜덤하게 생성한 IV 값을 붙여서 리턴해야한다. 1234567891011@Testinternal fun `똑같은 평문을 암호화 하면 다른 암호문이 나온다`() &#123; val encrypted = AES256CBC.encrypt(PLAIN_TEXT) val encrypted2 = AES256CBC.encrypt(PLAIN_TEXT) assertThat(encrypted).isNotEqualTo(encrypted2) val decrypted = AES256CBC.decrypt(encrypted) assertThat(decrypted).isEqualTo(PLAIN_TEXT) val decrypted2 = AES256CBC.decrypt(encrypted2) assertThat(decrypted2).isEqualTo(PLAIN_TEXT)&#125; 그리고 문자열의 길이에 따라서 암호문의 길이가 달라지기 때문에 평문의 길이가 유추 가능하다라는 것도 문제라고 생각했는데Java AES Encryption with salt을 보면비밀번호와 달리 조금은 덜 민감한 정보를 암호화하는 것이기 때문인지 크게 중요치 않다고 여기는 것 같다.애초에 AES의 목적이 고정된 길이를 리턴하는 해시 함수가 아니기 때문에도 그런 것 같다. PBKDF2 (Password-Based Key Derivation Function)마지막으로 그러면 안 되겠지만 만약에 키 값이 털렸다고 치자.하지만 키 값을 그대로 사용한 게 아니라 키 값을 다시 암호화 해서 사용했다면 어느 정도 안심할 수 있다.이 때 사용할 키 값은 복호화 할 때도 사용할 키 값이기 때문에 항상 고정된 값을 리턴하는 암호화 알고리즘이어야 한다. 이를 해소하기 위한 방법이 Key Derivation Function이다.Key Derivation Function은 키 값도 늘려버리고, 암호화 횟수도 여러 번 돌려서 암호화를 수행하는데 시간이 오래 걸린다.(하지만 AES는 키값이 128, 192, 256bit로 고정적이라서 키 값을 늘려버리진 않는다.)그렇다고 해서 암호화 하는데 몇 초씩이나 걸리는 건 아니지만 해커가 일 초에 수십억 번 공격할 수 있는 걸 수천 번 정도 수준으로 줄여준다.수천 번이라고 하니까 그래도 엄청 많아 보이지만 수십억 번에 비하면 새발의 피다.또한 해시돼서 나오는 값이라 복호화도 불가능하다. 그럼 예제를 살펴보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 키 길이는 256 bit(32 byte)이다.private const val KEY_LENGTH = 32// 1바이트 문자열이 아닌 경우에는 java.security.InvalidKeyException: Invalid AES key length 오류가 난다. (ex: 한글 등등)private val KEY = &quot;a&quot;.repeat(KEY_LENGTH)// 첫 블럭과 XOR 연산을 해야되기 때문에 iv의 길이는 블럭 사이즈인 16 byte이다.private const val BLOCK_SIZE = 16// PBKDF2에 적용할 값들이다.private const val SALT = &quot;&#123;,*jbU787l@BcG:L]Oos/?s7EwMo:i/%No2z)sP@ut@=cydO9&amp;@Xa137-ZHkke&quot;private const val ITERATION_COUNT = 1024// 키 값이 256 bit이기 때문에 해시 돌린 digest 길이도 256 bit여야 한다.private const val DIGEST_BIT_LENGTH = 256object AES256CBC &#123; private val secretKeySpec = try &#123; val factory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;) val spec = PBEKeySpec(KEY.toCharArray(), SALT.toByteArray(), ITERATION_COUNT, DIGEST_BIT_LENGTH) SecretKeySpec(factory.generateSecret(spec).encoded, &quot;AES&quot;) &#125; catch (e: Exception) &#123; println(&quot;Error while generating key: $e&quot;) null &#125; fun encrypt(plainText: String): ByteArray? = try &#123; // Generate Random IV val iv = ByteArray(BLOCK_SIZE) val secureRandom = SecureRandom.getInstanceStrong() secureRandom.nextBytes(iv) val ivParameterSpec = IvParameterSpec(iv) val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec) val encrypted = cipher.doFinal(plainText.toByteArray()) // Combine Random IV and Encrypted Data iv + encrypted &#125; catch (e: Exception) &#123; println(&quot;Error while encrypting: $e&quot;) null &#125; fun decrypt(cipherText: ByteArray?): String? = try &#123; // Extract IV and Encrypted Data. val iv = cipherText?.copyOfRange(0, BLOCK_SIZE) val ivParameterSpec = IvParameterSpec(iv) val encrypted = cipherText?.copyOfRange(BLOCK_SIZE, cipherText.size) val cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5PADDING&quot;) cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec) String(cipher.doFinal(encrypted)) &#125; catch (e: Exception) &#123; println(&quot;Error while decrypting: $e&quot;) null &#125;&#125; 123456789101112131415internal class AES256CBCTest &#123; @Test internal fun testEncrypt() &#123; val encrypted = AES256CBC.encrypt(&quot;&quot;) assertThat(encrypted).isNotEmpty() &#125; @Test internal fun testDecrypt() &#123; val encrypted = AES256CBC.encrypt(PLAIN_TEXT) val decrypted = AES256CBC.decrypt(encrypted) assertThat(PLAIN_TEXT).isEqualTo(decrypted) &#125;&#125; 참고자료 Block cipher mode of operation Security Best Practices: Symmetric Encryption with AES in Java and Android initialization vector (IV) What are the practical differences between 256-bit, 192-bit, and 128-bit AES encryption? What is the difference between PKCS#5 padding and PKCS#7 padding Java AES Encryption Decryption Example AES Encryption and Decryption in Java(CBC Mode) Java AES CBC encryption example Java AES Encryption with salt","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Dev","slug":"Note/Dev","permalink":"https://perfectacle.github.io/categories/Note/Dev/"}],"tags":[{"name":"암호화","slug":"암호화","permalink":"https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94/"},{"name":"AES","slug":"AES","permalink":"https://perfectacle.github.io/tags/AES/"}]},{"title":"(Kotlin) Request에서 Nullable? Non-Null?","slug":"kotlin-request-nullable-non-null","date":"2019-09-18T01:23:39.000Z","updated":"2022-10-30T08:42:16.743Z","comments":true,"path":"2019/09/18/kotlin-request-nullable-non-null/","link":"","permalink":"https://perfectacle.github.io/2019/09/18/kotlin-request-nullable-non-null/","excerpt":"코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)통제할 수 없는 부분은 클라이언트로부터 받는 Request이다. 그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다. 기본값을 사용하자.1234567class DTO(val name: String? = null)@RestControllerclass Controller &#123; @PostMapping fun test(@RequestBody dto: DTO) &#123;&#125;&#125; 위와 같을 때 request body의 name에 아무런 내용도 입력하지 않으면 name에 기본값 null이 잘 세팅된다.기본값이 전부 존재하면 default constructor가 생성돼서 객체를 손쉽게 생성할 수 있다보니 테스트 할 때 용이하다.","text":"코틀린의 장점을 하나 꼽자면 Non-null 타입을 지원한다는 것이다.모든 곳에 null을 없앨 수 있는데(100% 순수 코틀린 코드로만 짠다면)통제할 수 없는 부분은 클라이언트로부터 받는 Request이다. 그래서 Request에는 어떤 타입을 써야할지 삽질을 해봤다. 기본값을 사용하자.1234567class DTO(val name: String? = null)@RestControllerclass Controller &#123; @PostMapping fun test(@RequestBody dto: DTO) &#123;&#125;&#125; 위와 같을 때 request body의 name에 아무런 내용도 입력하지 않으면 name에 기본값 null이 잘 세팅된다.기본값이 전부 존재하면 default constructor가 생성돼서 객체를 손쉽게 생성할 수 있다보니 테스트 할 때 용이하다. 무조건 nullable 타입을 사용하자.1234567class DTO(val name: String = &quot;123&quot;)@RestControllerclass Controller &#123; @PostMapping fun test(@RequestBody dto: DTO) &#123;&#125;&#125; 위와 같을 때 클라이언트에서 의도적으로 &#123;&quot;name&quot;: null&#125;을 보내는 순간failed for JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type라는 오류와 함께 400 에러를 뱉는다. (타입에 관련된 에러임)따라서 nullable 타입을 사용하자. Header와 Parameter의 default value는 어노테이션에 있는 설정을 쓴다.12345@RestControllerclass Controller &#123; @GetMapping fun test(@RequestHeader(required = false, defaultValue = &quot;11&quot;) test: Int?) &#123;&#125;&#125; 이 때 헤더에 아무런 값도 보내지 않으면 11이 세팅된다.하지만 아래와 같이 변수에 기본값을 세팅했다면 null이 세팅된다. 12345@RestControllerclass Controller &#123; @GetMapping fun test(@RequestHeader(required = false) test: Int? = 11) &#123;&#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Kotlin","slug":"Note/Kotlin","permalink":"https://perfectacle.github.io/categories/Note/Kotlin/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://perfectacle.github.io/tags/Kotlin/"}]},{"title":"(Kotlin) De/Serialize DTO 뽀개서 뿌셔버리기","slug":"kotlin-de-serialize-dto","date":"2019-09-16T00:30:06.000Z","updated":"2022-10-30T08:42:16.743Z","comments":true,"path":"2019/09/16/kotlin-de-serialize-dto/","link":"","permalink":"https://perfectacle.github.io/2019/09/16/kotlin-de-serialize-dto/","excerpt":"연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.모든 설명은 JSON으로 request와 response를 주고받는 HTTP API 기반으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다. 용어 설명간단하게 용어들을 집고 넘어가자. DTO(Data Transfer Object)데이터를 전송하는데 사용하는 객체","text":"연차 대비 너무너무 느린 개발 속도를 향상시키기 위해 나만의 Cheetsheet를 하나씩 만들어야겠다.처음 접하는 코틀린 환경에서 자바에서는 좀 할만했던 DTO의 (De)Serialize 관련해서 적어보았다.모든 설명은 JSON으로 request와 response를 주고받는 HTTP API 기반으로 진행하기 때문에 엄밀히 따지면 부정확한 내용들이 많다. 용어 설명간단하게 용어들을 집고 넘어가자. DTO(Data Transfer Object)데이터를 전송하는데 사용하는 객체 쉽게 말해서 HTTP API에서 사용하는 JSON 타입 등등의 Request Body와 Response Body를 떠올리면 된다.자바스크립트에서는 JSON이 자바스크립트의 Object 리터럴과 매우 유사해서 파싱하는데 크게 무리가 없지만,JVM 진영에서는 꽤나 큰 이슈이다. (잘 몰라서 삽질을 하는 계기가 된다.) Deserialize쉽게 말하면 JSON 형태의 Request Body를 코틀린 등등의 Object로 파싱하는 작업을 의미한다.Setter에 해당 로직이 들어간다. Request Body는 클라이언트가 서버로 던지는 내용이다.따라서 서버의 권한 밖이기 때문에 Kotlin이 non-null type을 지원한들 아래와 같은 문제를 마주치게 된다. non-null tpye이고, default value가 없는데 client에서 필드를 넘겨주지 않으면 (&#123;&#125;) non-null tpye이고, default value가 있는데 client에서 null을 넘기면 (&#123;&quot;field&quot;: null&#125;) 위와 같은 경우에 아래 오류와 마주치게 된다. (컴파일 타임에 클라이언트가 어떻게 던질지 모르므로 런타임 에러로 발생한다.)JSON property name due to missing (therefore NULL) value for creator parameter name which is a non-nullable type 따라서 클라이언트가 우리 말을 잘 듣는다는 보장이 없으므로 Request Body DTO의 필드들은 nullable type으로 지정해주자! Serialize쉽게 말하면 코틀린 등등의 Object를 JSON 형태의 Response Body로 파싱하는 작업을 의미한다.Getter에 해당 로직이 들어간다. 기본적인 형태가장 기본적인 형태들의 DTO를 파싱해보자. Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 똑같은 경우12345678/** * deserialize from (request body) * &#123;name: &quot;name&quot;&#125; * * serialize to (response body) * &#123;name: &quot;name&quot;&#125; * */class DTO(val name: String?) 코틀린의 필드명과는 다른 경우12345678/** * deserialize from (request body) * &#123;n: &quot;name&quot;&#125; * * serialize to (response body) * &#123;n: &quot;name&quot;&#125; * */class DTO(@JsonProperty(&quot;n&quot;) val name: String?) Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 필드명이 다른 경우dto field name: namerequest body’s key: nresponse body’s key: name 123456789101112/** * deserialize from (request body) * &#123;n: &quot;name&quot;&#125; * * serialize to (response body) * &#123;name: &quot;name&quot;&#125; * */class DTO(name: String?) &#123; var name = name @JsonProperty(access = JsonProperty.Access.READ_ONLY) get @JsonProperty(value = &quot;n&quot;, access = JsonProperty.Access.WRITE_ONLY) set&#125; dto field name: namerequest body’s key: nameresponse body’s key: n 123456789101112/** * deserialize from (request body) * &#123;name: &quot;name&quot;&#125; * * serialize to (response body) * &#123;n: &quot;name&quot;&#125; * */class DTO(name: String?) &#123; var name = name @JsonProperty(value = &quot;n&quot;, access = JsonProperty.Access.READ_ONLY) get @JsonProperty(access = JsonProperty.Access.WRITE_ONLY) set&#125; dto field name: namerequest body’s key: namesresponse body’s key: n 123456789101112/** * deserialize from (request body) * &#123;name: &quot;name&quot;&#125; * * serialize to (response body) * &#123;n: &quot;name&quot;&#125; * */class DTO(name: String?) &#123; var name = name @JsonProperty(value = &quot;n&quot;, access = JsonProperty.Access.READ_ONLY) get @JsonProperty(value = &quot;names&quot;, access = JsonProperty.Access.WRITE_ONLY) set&#125; LocalDateTime 3형제 다루기보기 좋은 포맷으로 serialize하려면 jackson-modules-java8을 디펜던시에 추가해줘야한다. LocalDate, LocalTime, LocalDateTime 3형제를 다뤄보자.모든 클라이언트가 ISO 8601을 따라서 Request Body를 만들어서 주면 좋겠지만 그렇지 않은 경우가 많기 때문에 직접 파싱해야할 경우가 있다. 기본 파싱 규칙 (ISO 8601)123456789101112/** * deserialize from (request body) * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125; * * serialize to (response body) * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125; * */class DTO( val date: LocalDate?, val time: LocalTime?, val dateTime: LocalDateTime?) Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우123456789101112/** * deserialize from (request body) * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125; * * serialize to (response body) * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125; * */class DTO( @JsonFormat(pattern = &quot;yyyy/MM/dd&quot;) val date: LocalDate?, @JsonFormat(pattern = &quot;HH시 mm분 ss초&quot;) val time: LocalTime?, @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초&quot;) val dateTime: LocalDateTime?) Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우12345678910111213141516171819202122/** * deserialize from (request body) * &#123;&quot;date&quot;: &quot;2019/08/08&quot;, &quot;time&quot;: &quot;19시 21분 33초&quot;, &quot;dateTime&quot;: &quot;2019/08/08 19시 21분 33초&quot;&#125; * * serialize to (response body) * &#123;&quot;date&quot;: &quot;2019-08-08&quot;, &quot;time&quot;: &quot;19:21:33&quot;, &quot;dateTime&quot;: &quot;2019-08-08T19:21:33&quot;&#125; * */class DTO( date: LocalDate?, time: LocalTime?, dateTime: LocalDateTime?) &#123; var date = date @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) get @JsonFormat(pattern = &quot;yyyy/MM/dd&quot;) set var time = time @JsonFormat(pattern = &quot;HH:mm:ss&quot;) get @JsonFormat(pattern = &quot;HH시 mm분 ss초&quot;) set var dateTime = dateTime @JsonFormat(pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&quot;) get @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초&quot;) set&#125; 세계 시간 다루기보기 좋은 포맷으로 serialize하려면 jackson-modules-java8을 디펜던시에 추가해줘야한다. Local 시리즈는 타임존이 없다.저 시간&#x2F;날짜가 영국 기준인지, 한국 기준인지 모른다.생일과 같이 타임존에 관계를 받지 않는 시간&#x2F;날짜에 사용해야한다. 스포츠 중계와 같이 전세계에서 동시에 진행되는 경우에는 타임존이 필수다.그럼 타임존을 가지고 있는 OffsetDateTime, ZonedDateTime, Instant를 다뤄보자. OffsetDateTime은 Timezone만 가지고 있는 반면, ZonedDateTime은 Timezone + Zone의 특성(Summer Time 여부 등등)도 가지고 있다.Instant는 Unix Timestamp를 다룰 때 용이하다. application.yaml에 아래 설정을 넣지 않으면 Deserialize해서 다루는 DTO 객체와 Response Body에 Timezone이 UTC로 고정된다. 1234spring: jackson: deserialization: adjust_dates_to_context_time_zone: false 기본 파싱 규칙 (ISO 8601)123456789101112/** * deserialize from (request body) * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00[Asia/Seoul]&quot;, &quot;unixTime&quot;: 1568558972&#125; * * serialize to (response body) * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;unixTime&quot;: &quot;2019-09-15T14:49:32Z&quot;&#125; * */class DTO( val offsetDateTime: OffsetDateTime?, val zonedDateTime: ZonedDateTime?, val unixTime: Instant?) Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 동일한 파싱 규칙을 사용하는 경우123456789101112/** * deserialize from (request body) * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]&quot;, &quot;unixTime&quot;: 1568558972&#125; * * serialize to (response body) * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [KST]&quot;, &quot;unixTime&quot;: &quot;2019-09-15T14:49:32Z&quot;&#125; * */class DTO( @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;) val offsetDateTime: OffsetDateTime?, @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초 XXX &#x27;[&#x27;z&#x27;]&#x27;&quot;) val zonedDateTime: ZonedDateTime?, val unixTime: Instant?) Request Body를 Deserialize 할 때와 Response Body를 Serialize 할 때 다른 파싱 규칙을 사용하는 경우1234567891011121314151617181920212223/** * deserialize from (request body) * &#123;&quot;offsetDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00 [Asia/Seoul]&quot;, &quot;unixTime&quot;: &quot;2019/08/08 19시 21분 33초 +09:00&quot;&#125; * * serialize to (response body) * &#123;&quot;offsetDateTime&quot;: &quot;2019-08-08T19:21:33+09:00&quot;, &quot;zonedDateTime&quot;: &quot;2019-08-08T19:21:33+09:00[KST]&quot;, &quot;unixTime&quot;: 1565259693&#125; * */class ZonedDateTimeDTO3( offsetDateTime: OffsetDateTime?, zonedDateTime: ZonedDateTime?, unixTime: Instant?) &#123; var offsetDateTime = offsetDateTime @JsonFormat(pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ssXXX&quot;) get @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;) set var zonedDateTime = zonedDateTime @JsonFormat(pattern = &quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ssXXX&#x27;[&#x27;z&#x27;]&#x27;&quot;) get @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초 XXX &#x27;[&#x27;z&#x27;]&#x27;&quot;) set var unixTime = unixTime @JsonFormat(pattern = &quot;yyyy/MM/dd HH시 mm분 ss초 XXX&quot;) set fun getUnixTime() = unixTime?.epochSecond&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Kotlin","slug":"Note/Kotlin","permalink":"https://perfectacle.github.io/categories/Note/Kotlin/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://perfectacle.github.io/tags/Kotlin/"}]},{"title":"자산과 부채, 그리고 현금흐름과 자본이득","slug":"assets-debts-cash-flow-and-captial-gains","date":"2019-08-24T15:03:12.000Z","updated":"2022-10-30T08:42:16.131Z","comments":true,"path":"2019/08/24/assets-debts-cash-flow-and-captial-gains/","link":"","permalink":"https://perfectacle.github.io/2019/08/24/assets-debts-cash-flow-and-captial-gains/","excerpt":"돈으로부터 자유로워지려면 어떻게 해야할까?월급을 얼마를 받던 상관없이 내가 원하는 삶을 살 수는 없을까?지금은 내가 일을 해서 돈을 벌지만, 내가 일을 못하게 되면 어떤 삶을 살아야할까?그렇다면 평생 일을 할 수 있다면, 죽을 때까지 계속해서 일을 해야하는 걸까? 사람마다 일과 삶(Working &amp; Life), 그리고 돈에 대한 가치가 다 다르겠지만 내 스스로 기준을 정하고 내가 원하는 삶으로 이끌어나가기 위해서 책을 읽은 내용을 토대로 좀 정리해봤다. 자산과 부채로버트 기요사키의 부자 아빠, 가난한 아빠에서는 다음과 같이 설명하고 있다. 자산은 내 지갑에 돈을 넣어주고, 부채는 내 지갑에서 돈을 꺼내간다.","text":"돈으로부터 자유로워지려면 어떻게 해야할까?월급을 얼마를 받던 상관없이 내가 원하는 삶을 살 수는 없을까?지금은 내가 일을 해서 돈을 벌지만, 내가 일을 못하게 되면 어떤 삶을 살아야할까?그렇다면 평생 일을 할 수 있다면, 죽을 때까지 계속해서 일을 해야하는 걸까? 사람마다 일과 삶(Working &amp; Life), 그리고 돈에 대한 가치가 다 다르겠지만 내 스스로 기준을 정하고 내가 원하는 삶으로 이끌어나가기 위해서 책을 읽은 내용을 토대로 좀 정리해봤다. 자산과 부채로버트 기요사키의 부자 아빠, 가난한 아빠에서는 다음과 같이 설명하고 있다. 자산은 내 지갑에 돈을 넣어주고, 부채는 내 지갑에서 돈을 꺼내간다. 자산로버트 기요사키의 앞으로 10년, 돈의 배반이 시작된다에서는 자산을 아래 4종류로 분류하고 있다. 기업세계적인 기업들(MS, Google, Apple, Facebook, etc.) 뿐만 아니라 기본적으로 기업은 이익을 창출하는 집단이다 부동산월&#x2F;전세를 놓던, 싸게 사서 더 비싸게 팔던, 건물을 지어서 팔던, 부동산을 통해서도 수익을 낼 수 있다. 금융자산주식, 펀드, 채권 등등을 통해 수익을 낼 수 있다. 상품(원자재)금, 은 등등의 상품을 통해서도 수익을 낼 수 있다. (물론 금, 은의 가격이 떨어지기도 한다.)금과 은의 가격이 등락하는 이유는 미국이 달러의 금본위제도를 폐지하면서 돈이 인쇄 가능한 종이 쪼가리(수준으로 전락)에 불과하기 때문이다. 부채 일반적으로 생각하는 빚(은행이나 각종 방법으로 빌린 돈) 말고도 다양한 종류의 부채가 존재한다. 자동차많은 사람들이 자동차를 산다.자동차는 많은 편리함을 주는 반면에 자산과 부채 관점에서 보면 부채에 불과하다.자동차를 구매해서 운전하는 순간 자동차의 가치(금액)은 곤두박질 치고, 기름값과 각종 유지비용은 내 지갑에서 돈을 꺼내가는 부채이다. 집부동산은 자산이 될 수도, 부채가 될 수도 있다.집은 오래되면 수리해야하고, 각종 세금도 있고, 주택담보대출 등등의 부채에 대한 이자 또한 내 지갑에서 돈을 꺼내가는 부채이다.많은 사람들이 평생 내 집 마련을 위해 일하고, 이를 자산으로 여기는데 현금흐름을 창출해내지 못하는 이상 집은 부채에 불과하다. 시간이 지나면 가격이 떨어지는 각종 사치품(시계, 옷, 가방 등등)시간이 흘러가면 흘러갈 수록 가치가 올라간다면 부채는 아니겠지만, 그렇지 않은 경우에는 부채다.이를 사기 위해 내 지갑에서 돈을 꺼냈는데 이 사치품들은 지나면 지날 수록 가치가 떨어지기 때문이다.심지어 이런 사치품들을 사기 위해 할부나 빚을 냈다면 상황은 더더욱 심각하다. 이 외에도 상당히 많은데 내가 어떻게 설명해야할 지 모르겠다. 좋은 부채그렇다고 해서 부채가 무조건 나쁘다는 건 아니다.부채를 통해 자산을 만들어낼 수 있다면 좋은 부채다.만약에 은행에서 연 금리 5%로 대출을 받았는데 그 대출금으로 연 6%의 수익률을 낸다면 그 부채는 좋은 부채다. 부채 없이 성공한 부자는 없을 것이고, 현재 부자들도 대부분 부채가 있을 것이다.만약 현재 부채가 없는 부자라면, 부채가 있었다면 더 큰 부자도 될 수 있었을 것이다.왜냐면 좋은 부채는 자산을 만들어주는데, 자금이 크면 클 수록 큰 자산을 만들어 낼 수 있고, 자금 조달 수단 중 하나에 부채가 포함되기 때문이다. 만약 대출받은 100원과 내 돈 100원으로 수익을 내고 있었다고 쳐보자. (수익을 내고 있다는 말은 대출 원리금 상환을 한 후에도 수익이 남는 구조를 뜻한다.)내가 투자한 100원을 전부 회수한 이후부터는 내 자본금은 하나도 들이지 않고 수익을 내기 시작하는 것이다.이렇게 내 자본금은 하나도 들어가지 않고, 수익을 내는 구조를 무한수익이라고 하며, 이렇게 무한 수익을 낼 수 있게 끔 해주는 부채가 가장 좋은 부채가 아닐까 싶다. 나쁜 부채자산을 만들어내지 못하는 부채는 전부 나쁜 부채이다. (학자금 대출이 전형적인 경우가 아닐까 싶다.)똑같은 자동차라도 가정집에서 그냥 몰면 돈잡아 먹는 부채에 불과하고, 그 자동차로 택시 운전 등등을 통해 현금 흐름을 창출해낸다면 자산이 될 수 있다.따라서 그 자동차를 구입하기 위해 받은 대출금 마저도 용도에 따라서 좋은 부채가 될지, 나쁜 부채가 될지가 결정된다. 대부분의 가계 부채는 나쁜 부채일 것이다.내 지갑에서 돈을 꺼내가는 반면에 돈을 채워넣어주지는 않을 것이기 때문이다.그렇기 때문에 나는 지갑에 돈을 채워넣기 위해서 더욱 열심히 일해야할 것이다. 계속해서… 평생…은 일하지 못하기 때문에 문제가 발생한다.따라서 은퇴 후에는 각종 연금(국민연금, 퇴직연금, 연금저축보험 등등)에 의존하게 된다. 하지만 국민 연금의 경우에는 합법적인 폰지 사기라는 생각이 든다. (물론 틀렸을 가능성도 크다.)폰지 사기는 사기꾼 찰스 폰지의 이름에서 따왔는데 사기의 절차는 다음과 같다. 투자자 A에게 수익을 약속해서 폰지는 투자금을 받는다. 투자자 B에게 수익을 약속해서 폰지는 투자금을 받는다. 폰지는 투자자 A에게 수익금을 준다. 이 폰지 사기의 맹점은 더이상 투자자가 나타나지 않는 이상 수익금은 발생하지 않는다.이 폰지 사기를 한 번 국민 연금에 빗대어서 생각해보자. 부모님에게 물가 상승률 대비 수익을 약속해서 정부는 국민연금을 걷는다. 나에게 물가 상승률 대비 수익을 약속해서 정부는 국민연금을 걷는다. 정부는 부모님에게 연금을 준다. 저출산, 고령화 시대에 더이상 새롭게 연금을 내줄 사람이 줄어드는 이상 연금은 바닥나거나 젊은이들이 더 많이 부담해야할 것이다.정부에서 과연 물가 상승률 대비해서 계속해서 수익을 내고 있을까?그렇다면 다행인데 만약 그렇지 않다면 나는 합법적인 폰지 사기와 다를 바 없다고 생각하고 문제가 심각하다고 본다. 정상적으로 국민연금이 운영됐다는 전제 하에도 예상 수령액을 보면 불우한 내 노후가 눈 앞에 아른거렸다.그러다보니 각종 은행 및 보험사 등에서 연금성 저축이나 보험을 권유한다.하지만 황소장의 부동산팩폭의 한의사 교수님 그리고 보험 영상을 보면서 꼼꼼히 검토해보고 가입해야한다.영상 내용을 간단히 요약하자면 70년대에 연금 보험을 들었는데 그 때 기준으로 쌀 두 가마니를 살 수 있는 돈을 저축했는데, 은퇴 후에 연금을 받아보니 점심 한 끼 사먹을 수 있는 돈을 돌려받았다는 얘기이다.모든 연금성 저축 상품들이 이렇지 않겠지만 정말 꼼꼼히 검토해보고 가입해야한다.과거의 100원과 현재의 100원의 가치는 다르다.또한 현재 1000원을 가지고 있어도 과거의 100원만도 못하게 되는 경우도 허다하다.인플레이션(feat. 물가 상승률)에 대한 내용은 포스트에 작성해 뒀으니 꼭 이해해야하는 내용 중 하나이다. 현금흐름과 자본이득 자신이 가진 부동산 자산에서 나오는 전&#x2F;월세가 이 경우에 해당한다. (수익형) 부동산 가격이 오르거나, 금&#x2F;은 등의 가격이 오르거나, 주가가 오르는 등이 자본이득이다.대부분 투기꾼들이 저가에 사서 거품을 잔뜩 끼게 한 다음에 고가에 팔아 치우곤 한다. (시세 차익형)이게 과연 거품인지 아닌지를 보는 눈이 있어야 개미들이 피해보지 않을 것이다. 자본이득 같은 경우에는 미래를 예측하는 눈이 있지 않는 이상은 도박에 불과할 것이다.이를 위해서 리스크를 관리하고 회피하는 능력이 있지 않아야할까 싶다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"경제","slug":"기타/경제","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"}],"tags":[{"name":"경제","slug":"경제","permalink":"https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"자본주의","slug":"자본주의","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"},{"name":"재테크","slug":"재테크","permalink":"https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"},{"name":"자산","slug":"자산","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%82%B0/"},{"name":"부채","slug":"부채","permalink":"https://perfectacle.github.io/tags/%EB%B6%80%EC%B1%84/"},{"name":"현금흐름","slug":"현금흐름","permalink":"https://perfectacle.github.io/tags/%ED%98%84%EA%B8%88%ED%9D%90%EB%A6%84/"}]},{"title":"야놀자를 떠나며... (feat. 레저큐)","slug":"exit-yanolja-feat-leisureq","date":"2019-08-23T08:16:36.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2019/08/23/exit-yanolja-feat-leisureq/","link":"","permalink":"https://perfectacle.github.io/2019/08/23/exit-yanolja-feat-leisureq/","excerpt":"오늘은 야놀자 서류상 퇴사일이다. (오늘까지 남은 연차를 사용했다.)총 세 번의 이직 시도 끝에 성공할 수 있었다.여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다. 왜 퇴사를 결심했나야놀자는 탄력 근무제(연장 근무를 했다면 다른 날 단축 근무 가능), 식비 지원, 분기별 야놀자 포인트 지급, 전용 사옥 등등의 좋은 복지들이 있다.또한 Tech야, 놀자란 세미나를 할 정도로 탄탄한 개발문화와 유니콘 기업이 되는 등 굉장히 유망한 회사다.그럼에도 불구하고 내가 퇴사를 결심한 계기를 크게 두 가지다. 가장 큰 요인은 개발에 집중하지 못하는 환경이었다.레저큐에서 야놀자로 조직이 이동되면서(완전히 퇴사 후 입사 처리되었다. 레저큐는 야놀자의 계열사인데 일부만 야놀자로 조직 이동이 된 상태다.) 레저큐의 인프라 쪽을 한 번 쭉 털고 가야하는 이슈가 있었다.평상시에 인프라에 관심이 많았던 내가 해당 업무를 맡게 되었고, 끝까지 털지 못하고 퇴사하게 되었다. (이후에는 시스템 엔지니어 쪽 팀에서 도와줄 예정인 걸로 알고 있다.)개발이 하고 싶었지만, 점점 인프라 쪽 업무의 비중이 높아지면서 내 정체성을 의심하기 시작했다.나는 서버 개발자인가? 아니면 시스템 엔지니어인가…?물론 인프라 쪽도 알면 좋지만, 아직까지는 개발이 더 마렵다는 생각이 들었다. 연봉대부분의 이직 사유 중 하나일 것이다.물론 나보다 열악한 근무 환경 속에서도 안 좋은 대우를 받으시는 분들도 있을 거다.하지만 사람의 욕심은 끝이 없어서 자꾸만 위를 올려다 보게 되었다.네임밸류 기업에서 시작을 한 게 아니기 때문에 첫 시작 자체가 높지 않았던 탓도 있었던 것 같다. (그렇다고 그렇게 낮은 편도 아니었다.)","text":"오늘은 야놀자 서류상 퇴사일이다. (오늘까지 남은 연차를 사용했다.)총 세 번의 이직 시도 끝에 성공할 수 있었다.여태까지 신입으로만 이직(프론트엔드 신입(5개월 재직) -&gt; 백엔드 중고 신입)했고, 지인 추천을 통해서만 면접을 봤는데이번 이직에서는 지인 추천도 있었지만, 내 힘으로 스스로 지원해서 합격까지 한 케이스도 많아서 굉장히 뿌듯한 경험이었다.나와 같은 2~3년 차 주니어 분에게 도움이 됐으면 하는 바람, 개인적으로 회고를 하고 싶어서 정리를 해봤다. 왜 퇴사를 결심했나야놀자는 탄력 근무제(연장 근무를 했다면 다른 날 단축 근무 가능), 식비 지원, 분기별 야놀자 포인트 지급, 전용 사옥 등등의 좋은 복지들이 있다.또한 Tech야, 놀자란 세미나를 할 정도로 탄탄한 개발문화와 유니콘 기업이 되는 등 굉장히 유망한 회사다.그럼에도 불구하고 내가 퇴사를 결심한 계기를 크게 두 가지다. 가장 큰 요인은 개발에 집중하지 못하는 환경이었다.레저큐에서 야놀자로 조직이 이동되면서(완전히 퇴사 후 입사 처리되었다. 레저큐는 야놀자의 계열사인데 일부만 야놀자로 조직 이동이 된 상태다.) 레저큐의 인프라 쪽을 한 번 쭉 털고 가야하는 이슈가 있었다.평상시에 인프라에 관심이 많았던 내가 해당 업무를 맡게 되었고, 끝까지 털지 못하고 퇴사하게 되었다. (이후에는 시스템 엔지니어 쪽 팀에서 도와줄 예정인 걸로 알고 있다.)개발이 하고 싶었지만, 점점 인프라 쪽 업무의 비중이 높아지면서 내 정체성을 의심하기 시작했다.나는 서버 개발자인가? 아니면 시스템 엔지니어인가…?물론 인프라 쪽도 알면 좋지만, 아직까지는 개발이 더 마렵다는 생각이 들었다. 연봉대부분의 이직 사유 중 하나일 것이다.물론 나보다 열악한 근무 환경 속에서도 안 좋은 대우를 받으시는 분들도 있을 거다.하지만 사람의 욕심은 끝이 없어서 자꾸만 위를 올려다 보게 되었다.네임밸류 기업에서 시작을 한 게 아니기 때문에 첫 시작 자체가 높지 않았던 탓도 있었던 것 같다. (그렇다고 그렇게 낮은 편도 아니었다.) 그 외에도 있긴 하지만, 너무 개인적인 일이기도 하고 크게 공감을 얻을만한 내용이 아니어서 적지 않았다. 세 번의 이직 시도작년에 두 번, 올해 한 번의 이직을 시도했다.공교롭게도 이직 시도할 쯤이 연봉 협상 시기와 비슷한 경우가 많았다.그만큼 연봉 인상에 대한 갈증도 어느정도 있었던 것 같다. 첫 번째 시도, 오피지지오피지지는 게임 랭킹&#x2F;플레이 분석 등등을 해주는 서비스를 제공해주는 회사이다.우리나라 보다 외국 유저가 많은만큼 글로벌 경험도 해볼 수 있고, 또 트래픽도 굉장히 많은 걸로 알고 있다.면접을 보러 건물 앞을 서성이자 프로게이머 면접 왔냐고 물어봤다.프로게이머 구단을 꾸리고 있을 정도로 게임에 대한 열정을 엿볼 수 있었다. 우선 면접 중에 가장 신선했던 것은 자신있는 코드를 가져와서 직접 리뷰를 한다는 점이다.물론 코드를 제출하는 게 아니라 개인 노트북을 들고 가서 직접 코드를 돌리진 않고 IDE를 띄워놓고 하나하나 리뷰했다.외부 사람에게 코드리뷰를 한 적은 처음이었고, 내 코드에 어떤 개선사항들이 있는지, 앞으로 어떻게 해결해나가야할지 등등에 대해서 피드백을 알 수 있어서 좋았다.그 이후에는 기술적인 질문들을 받았는데 이 때 제대로 대답을 하지 못했다.단골 질문들도 나왔는데 평상시 그런 내용들은 물라도 일하는데 문제가 없었던 터라 공부를 미루고 있었다.또한 면접 전에 반짝 공부해서 가기에는 회사에게 미안했다.내 원래 모습이 아닌 거짓된 모습을 보여주는 것 같기 때문에 회사에게도, 나에게도 좋지 않다고 판단을 했다.그 이후에는 인사? 면접까지 바로 이루어졌다. (이건 뭐 다른 기업들이랑 크게 다르지 않았던 것 같아서 적을만한 게 없다.)그리고 면접이 끝나고 나서도 해당 질문들을 정리하고 공부했어야 했는데 게으르게도 정리하지 않았다. 결과는 불합격이었다.내 추측에 의하면 내가 답변을 제대로 못했기 때문이라기 보다는 성향이 맞지 않았던 것 같았다.당시에는 빨대를 꼽을나를 빠르게 성장시켜 줄 사수나 환경에 대해 갈망하고 있었다.시간이 흘렀지만 나는 그대로인 것 같았다.그러다보니 나를 바꿀 생각을 안 하고, 주변 환경을 바꿔서 쉽게 쉽게 가려고 했던 것 같다.면접 때도 그런 태도를 계속 내비췄던 것 같은데 당시 오피지지는 그렇게 막 챙겨주고 가르쳐 줄 상황이 아니었기 때문이 아닐까 생각을 한다. 두 번째 시도, 쿠팡쿠팡은 이커머스 사업을 하는 회사이다.프론트엔드 스터디 강의를 해주신 두 분께서 쿠팡 출신이기 때문에 쿠팡에 대해 굉장히 기대가 크고 벽도 높다고 생각했다.경력이 적었던 터라 내부 추천으로 들어가기에는 무리가 있어보였고 신입으로 지원하게 되었다. 운 좋게 서류를 통과하고 코딩 테스트를 볼 차례가 되었다.카카오 블라인드 채용 코딩 테스트 문제를 봤을 때 이걸 다 푼 사람이 있나 싶을 정도였다.그 중에 1&#x2F;5도 못 맞출만큼 평상시에 알고리듬에 관한 공부를 하지 않았다.그러다보니 거의 벼락치기 수준으로 코딩 테스트를 준비했다. 결과는 불합격이었다.개인적인 기준에는 너무 어려웠다.초반 1~2 문제는 시간이 좀 걸렸고, 풀었던 문제들도 나이스하지 못하게 풀었다.뒤로 가면 갈 수록 도저히 실무에서 겪어보지 못한 복잡성이었다.지금 다시 풀라고 해도 못 붙는다. 이렇게 나에게 코딩 테스트는 넘사벽 급의 존재가 되었다.이 때부터라도 알고리듬 공부를 열심히 했어야했는데 또 게으름 탓에 알고리듬 공부도 딱히 하지 않으며 시간만 흘러갔다. 세 번째 시도세 번째 시도부터는 올해에 시도하기 시작했다.그리고 처음으로 공격적으로 동시에 여러 곳을 면접봤다.일주일에 면접을 5번 본 적도 있고, 심지어 오전에 한 개, 오후에 한 개 이렇게 본 날도 있었다.떨어지기도 많이 떨어졌고, 붙기도 많이 붙었다. 탈락한 기업 스노우스노우는 스마트폰의 카메라 필터나 영상과 관련된 앱을 만드는 회사이다.비개발자인 친구들도 많이 사용하는 앱이라 스노우 지원했다고 자랑도 했다.하지만 서류부터 광탈했다. 카카오뱅크카카오뱅크는 국내 최초로 온라인 100% 은행이다. (오프라인 은행 지점이 없다.)평상시에 크게 사용하진 않지만(역시 사람은 익숙한 것을 바꾸기가 정말 힘들다.) 그래도 간편함과 혁신적인 부분에 있어서는 정말 좋게 생각하고 있었다.스노우의 전례가 있기 때문에 이번엔 친구들에게 설레발을 떨지 않았다.서류를 열심히 작성해서 제출했지만 역시나 서류에서 탈락했다.지원동기를 적어내는 칸에 거짓말을 치지 않는 이상 나를 어필하는 능력이 부족했다.금융 쪽은 아예 경험이 없기 때문에 뭐라 적을 내용이 없었는데 그런 경험이 없기 때문에 떨어졌던 게 아닐까 싶다. 카카오카카오는 카카오톡이라는 메신저로 성장하여 다음 포털까지 인수한 회사이다.월간 카카오를 통해 도전했고, 한 달에 한 번씩 볼 수 있기 때문에 크게 부담 가지지 않고 지원했다.서류까지는 어찌저찌 통과했지만, 역시나 코딩 테스트에서 탈락했다.&amp;nbsp;하지만 카카오는 나에게 용기를 불어넣어준 아주 고마운 회사이다.회사마다, 팀마다 다르겠지만 내가 여태까지 봐왔던 코딩 테스트(카카오 블라인드 채용, 쿠팡 신입)와 비교해보면 난이도가 너무 낮았다. (그렇다고 발로 풀어도 될 정도까진 아니고…)아마도 신입은 경력이 없다보니 증명할 게 코딩 테스트 말고는 없어서 좀 빡세게 냈던 게 아닐까 싶다.따라서 경력은 프로젝트 이력 등등을 통해 증명할 수 있으니 다소 코딩 테스트의 비중을 좀 낮춘 게 아닐까 싶다.실제로 내가 본 다른 기업의 코딩 테스트는 전부 카카오의 코딩 테스트와 비슷한 수준이었다. 네오펙트네오펙트는 의료 재활 솔루션 회사이다.생소한 도메인이기도 하고, 서버 개발자가 뭐 할일이 크게 있나… 싶을 정도였는데의료 재활 기기와 앱을 연동해서 재활을 쉽고 재미있게 도와주는데 이 때 앱에서 사용할 API 서버를 개발하는 업무의 담당자를 뽑고 있었다. 서류까지는 무사통과 되고, 그 이후에 코딩 테스트를 봤는데 신기하게 SQL, 자바스크립트(DOM 지식이 필요한) 문제들이 나왔다.솔직히 다른 코딩 테스트들은 어떤 문제는 ‘이 회사는 실무에서 이정도 복잡성을 다루면서 이런 문제를 내나?’ 싶은 수준의 문제도 많았는데 네오펙트는 참 실용적인 문제들만 나와서 좋았다.(그만큼 내가 준비가 덜 됐기 때문에 그렇게 느꼈을지도 모르겠다.) 코딩 테스트 통과 후에 주말에 두 명의 면접관과 함께 행아웃으로 라이브 코딩 면접도 보았다. (손코딩은 아니고 IDE를 사용해서 풀었다.)라이브 코딩이기 때문에 구글링을 하면 안 되는 줄 알고 초반에 좀 뻘뻘대다가 해도 된다는 소리를 듣고 정말 실용적으로 면접보는 것 같아서 좋았다.문제 자체는 Easy 레벨이었는데 초반에 너무 성급하게 문제를 푸는 바람에 이해를 잘못해서 시간을 정말 많이 날렸다.어찌저찌 문제를 풀고 코드를 제출했다.너무 덜렁대는 성격을 보여준 것 같아 불안했는데 어찌저찌 통과했다. 마지막으로 기술 면접과 인사 면접을 하루에 몰아서 보았다.오피지지 이후로 첫 번째 기술 면접이기 때문에 오피지지에서 대답하지 못했던 부분들은 많이 공부해둔 상태였다. (실무를 통해 경험하다보니 자연스레 공부한 내용들도 있었고…)하지만 자바 관련된 질문들, 스프링 관련된 질문들은 전혀 하지 않았다.오로지 내가 진행한 프로젝트 이력에 대해서만 물어봤다. (그 이외의 질문도 좀 있긴 했지만)이후에 면접관에게 왜 그런 내용은 물어보지 않았냐고 여쭙자 ‘자신들이 질문한 것만으로 어느 정도 검증이 되기도 하고, 그런 걸 물어봐도 뻔한 대답이 돌아오기 때문에 제대로 검증이 안되기 때문’이라고 말했던 것 같다. (정확히는 기억이…) 결과는 합격이었다.처음으로 합격한 회사라 기분이 정말 좋았다.하지만 집에 돌아가는 순간 입사하지 않기로 마음 먹었다.거리가 너무 멀기도 하고, 교통편이 좋지 않아서 집에 가면서 마음이 많이 돌아섰다.하지만 굉장히 실용적인 부분만 검증한 것 같아서 굉장히 좋은 면접 경험이었다. 네이버 파이낸셜(분사 예정)네이버 파이낸셜은 네이버 페이라는 간편 결제 서비스를 개발하는 핀테크 회사이다. (아직은 네이버 소속)네이버 파이낸셜은 미래에셋에서 5000억을 투자(예정)받을 정도로 미래에 촉망받는 회사이다.나는 간편결제라면 대부분 네이버 페이 밖에 안 쓰고, 굉장히 편리하게 사용하고 있는 서비스이기 때문에 지원했다. (네이버라는 네임밸류도 한 몫 했다.) 신기하게 코딩 테스트는 보지 않고 서류를 합격하였다.대신 면접장에서 화이트보드에 손코딩(정확한 문법까지 작성하진 않아도 됨)과 A4 용지에 출력된 문제들을 푸는 걸로 코딩 테스트를 대체했다.내가 경력이 짧다는 이유로 이런 과정도 있었는데 경력이 많은 경우에는 이마저도 스킵하지 않을까 싶었다.1차 면접에서는 역시나 프로젝트 위주의 질문을 많이 받았다.면접이 끝난 후에 선물을 받았는데 2019년이 절반 이상 흘러갔는데 캘린더가 선물에 포함된 건 조금 아쉬웠다. 1주가 흐른 후에 합격 메일을 통보 받고, 2차 면접 날짜를 잡았다.2차는 기술 심층 면접이었다.1차에서 물어보지 않았던 부분들에 대해서 질문을 많이 받았다.초반에는 인프라 쪽 질문을 많이 받았고, 면접관 분도 개발자 불러다놓고 너무 인프라 쪽 얘기만 한 것 같다고 말씀하셨다.많은 질문들이 나의 추측으로 밖에 답변할 수 없을 정도로 내 지식이 크게 부족했다.그 때마다 면접관 분들은 정답을 원하는 게 아니라 그냥 알고 있는 그 대로 한 번 얘기해보라고 다독여주셨다.그래서인지 면접이 끝날 때 쯤에는 몸에 산소 공급이 부족한 느낌이 들 정도로 얘기를 많이 했고, 머리에서 김이 나는 것 같았다. 또 1주가 흐른 후에 합격 메일을 통보 받고, 마지막 3차 임원진 면접 날짜를 잡았다.임원진이기 때문에 비개발직군이 들어오지 않을까 싶었는데, 내가 하는 말을 전부 이해하시는 걸 보아 개발자이거나 개발자 출신 같아 보였다.그리고 블로그 하는 걸 굉장히 높게 평가해주셨고, 면접을 보는 내내 긍정적인 신호를 받았다. 결과는 합격이다.개인적으로 1차에서는 프로젝트 위주로, 2차에서는 기술 위주로 평가를 받아서 다방면에서 고루고루 평가를 제대로 받았단 느낌이 들었다.하지만 3차까지 면접과정이 있다보니 역시 몸과 마음이 시간이 지나면 지날 수록 지침을 느꼈다.1차와 2차는 하루에 몰아서 봤으면 어땠을까… 싶기도 하다. (그러면 내가 지쳐 쓰러졌을 지도 모르겠지만…) 밸런스 히어로밸런스 히어로는 인도에서 무선통신요금을 효율적으로 관리하는 솔루션 등등을 제공해주는 앱(트루 밸런스)을 개발한 핀테크 기업이다.처음에 채용 담당자로부터 카카오톡으로 연락이 왔다. (주변 지인을 통해서 내 번호를 알았다고 한다.)나는 인터넷에 핸드폰 번호를 공개한 적이 없어서 맨 처음엔 스팸인가 싶어서 무시했지만 내 주제에 오히려 굴러들어온 기회를 걷어차버리는 것 같아서 먼저 채용 담당자를 만났다. 처음에는 별 생각없이 만났는데 정말 흥미로운 서비스 같았다.일단 인도 인구가 13억 명이나 되고, 인도는 현재 개발이 크게 되지 않았고,매달 1,000만명이 스마트폰을 신규가입하고, 인터넷이란 환경을 스마트폰으로 처음 접하는 세대가 대부분이라는 점이 굉장히 흥미로웠다.그러다 보니 비싼 아이폰은 거의 쓰지 않고, 또 대부분이 스마트폰으로 인터넷을 접했기 때문에 프론트엔드 개발자 보다는 안드로이드 개발자가 클라이언트 쪽 주력이란 사실도 흥미로웠다.그리고 서비스를 개발하는 입장에서 인도 현지에 무조건 방문한다는 사실을 듣고 설렘 반, 두려움 반이었다. 바로 그 날 저녁에 이력서를 보내고, 시간이 흘러 서류는 통과하고 코딩테스트를 봤다.다른 코딩 테스트와 비슷한 수준이었는데 샘플로 등록된 테스트 코드가 많지 않았다.그래서 내가 테스트 코드를 등록해서 돌려봤는데 내가 등록한 테스트 코드는 잘 통과했다.그래서 바로 제출을 했는데 말하기 창피한 수준의 점수가 나와서 한숨을 푹푹 쉬어가며 떨어졌다고 생각했는데 웬걸 합격 메일이 날아왔다. 1차로 기술면접을 봤는데 그 날 처음 위워크를 방문해봤는데 상당히 시설이 좋아서 일하는 분위기 보다는 노는 분위기가 났다.그리고 건물은 높은데 엘레베이터가 두 대 뿐이 없어서 엘레베이터 전쟁도 어느 정도 예상되었다.네오펙트는 프로젝트 이력만 물어봤던 것에 비해서 밸런스 히어로는 기본적인 기술 관련된 질문도 좀 했다. (JVM 메모리 구조나 GC 같은…)그리고 내가 진행한 배포 서버 구축 프로젝트에 대해서 내가 CI&#x2F;CD 서버 구축이라고 적어놨는데 사실 단순히 배포 서버만 만든 건데 해당 단어의 의미를 정확히 모르고 사용했다는 것도 피드백을 해주셨다. 1차 면접에 대한 결과는 그날 저녁에 바로 와서 여기 사람이 그렇게 급한가… 싶었다.(아니면 내가 그만큼 뽑고 싶은 인재인가…란 생각도 들긴 했지만 아직 김칫국 마시기엔 일렀기 때문에 애써 자기 최면을 했다.)2차 면접은 1차에서 기술에 대한 걸 봤기 때문에 전형적인 임원진 면접으로 알고 있었는데 테크 리더 분께서 들어오셔서 기술 심층 면접을 보았다.블로그에 대해 얘기를 하다가 심도있게 작성한 글을 얘기하다보니 직접 심도있게 적은 글을 골라보라 하고 그에 대해 설명도 부탁하셨다.그렇게까지 디테일하게 블로그에 대해서 물어본 적은 처음이었다.그리고 해시맵이나 GC의 구조 등등에 대해서 좀 더 심도있게 질문해주셨는데 처음엔 내가 답변을 제대로 못하자 문제를 해결할 수 있게 끔 질문을 유도해주셨다. 결과는 합격이다.코딩테스트까지는 일반적인 속도였지만, 그 이후부터는 굉장히 빠르게 채용이 진행되고 결과도 빨리 알려줘서 좋았다. 비바 리퍼블리카비바 리퍼블리카는 간편 송금 서비스로 시작한 토스란 앱을 만들고, 토스로 이름이 더 많이 알려진 핀테크 스타트업이다.토스하면 복지라던지, 여러가지 무성한 소문 때문에 굉장히 높은 벽으로 인식하고 있었다. 토스는 다른 회사와 달리 코딩 테스트를 일절 보지 않았다. (손코딩도 마찬가지로)이유를 물어보니 코딩 테스트로 역량 검증이 힘들다고 했던 걸로 기억한다. 서류 넣자마자 다음날 연락이 와서 그 다음주에 바로 1차 기술 면접 날짜를 잡았다.다른 곳과 마찬가지로 대부분 프로젝트 관련된 질문이었고, 다른 데서는 인프라 쪽 얘기를 많이 했는데 여기선 서버 개발 쪽 얘기를 많이 했다.내가 MSA 경험이 없고 대용량의 트래픽을 받아본 경험이 없다보니 그에 대한 답변을 못하자 계속해서 답변을 유도할 수 있는 질문을 해주셨다. 그리고 그 다음날 바로 합격 전화가 와서 또 그 주에 2차 문화 면접 날짜를 잡았다.임원진 면접도 아니고, 문화 면접이기 때문에 어떻게 준비를 해야할지 막막해서 지인에게 조언을 구했다.지인은 아래와 같이 조언해주었다. 인생의 목표를 설정해라. 인생의 목표와 회사의 목표를 봐라. 공통점을 찾아라. 공통점이 없다면, 혹은 현저히 적다면 과감히 포기해라. 나는 거짓말을 쳐서라도 들어가고 싶은 곳은 들어가야하나 싶었는데 그 분은 장기적으로 봤을 때는 회사나 본인 둘 다에게 손해라고 말씀해주셨다.누구나 해줄 수 있는 말이지만 나에겐 굉장히 영향력이 큰 분이라 위 조언을 토대로 아래와 같이 행동해보았다. 인생의 목표를 정한다. 내 인생의 목표를 이루려면 뭘 해야할까? 회사가 내 인생의 목표를 이루는데 도움이 될까? 된다면 어떤 부분에서 어떤 도움을 받을 수 있을까? 위와 같은 고민을 하자 토스에는 내 인생의 목표를 이뤄줄만한 점이 있기 때문에 그걸 토대로 면접을 준비했다.이 시간은 불과 3시간도 채 걸리지 않았다.배민의 2차 면접을 위해 1주일 간 배민다움 책을 읽은 것에 비하면(1주일 내내 읽은 건 아니지만)굉장히 단시간 내에 2차 면접 준비를 마쳤고, 확신 또한 있었다. 2차 면접은 위에 고민한 내용을 토대로 정리해서 답변을 했고, 나를 당홯하게 만드는 질문이나 내용들이 어느 정도 있었지만 확신을 갖고 있었기 때문에 이상한 답변을 한 것 같진 않다.그리고 토스가 어떻게 일하는지, 정말 기업 문화가 어떤 문화인지 알 수 있게 해주는 면접이었다. 결과는 합격했는데 바로 그 날 저녁에 알려주었다. (저녁에도 열심히 일하는 무서운 사람들…)다른것보다도 내가 여태껏 경험해본 모든 채용과정을 통틀어 제일 빨랐다.모든 과정이 1주일 내로 다 끝났다.개인적으로 이런 부분도 구직자를 배려해주는 한 부분인 것 같다고 느꼈다. 우아한 형제들우아한 형제들은 배달의 민족(줄여서 배민), 배민찬, 배민 라이더스 등등의 서비스를 만든 회사로 오히려 배민이란 이름으로 더 잘 알려져있다.우아한 형제들을 처음 지원할 때는 굉장히 망설였다.월간 카카오와 달리 한 달에 한 번 지원할 수 있는 제도가 아니기 때문에 재도전하기까지 쿨타임(기간)이 어느정도 있기 때문이었다.하지만 개발이 하고 싶다는 강한 욕구와 기술 블로그와 다양한 세미나 등등을 통해 개발 문화가 탄탄한 게 눈에 보였기 때문에 고민 끝에 지원했다. 이력서 양식에서부터 신경을 많이 쓴 티가 났다. (내가 쓴 이력서를 재활용하지 못해서 좀 귀찮았지만…)일반적인 회사의 지원동기 같은 건 물어보지 않았고(아마도 없었던 걸로 기억한다.),배민의 B급 감성과 잘 맞는 사람을 찾는 것인지 노래와 시를 인용해서 작성하는 내용도 있었는데 평상시 가사 보다는 비트 위주의 음악을 듣다보니 해당 내용을 그냥 무시하고 적었다. 1주일 정도가 흘러 코딩 테스트 메일이 와서 서류는 합격인 줄 알았는데 코딩 테스트까지가 서류 전형이었다.문제는 크게 어렵진 않았는데 복잡도(리스트가 엄청 크다거나) 부분에서 타임아웃이 발생했다.시간이 없는 관계로 제출을 하긴 했는데 계속해서 마음에 걸렸지만 어쩔 수 없었다. 또 1주일 정도가 흘러 코딩 테스트는 합격 메일이 오고, 그로부터 또 1주 후에 이제 1차 기술 면접을 보게 되었다.이번 기술 면접 때도 자바나 스프링 같은 기본적인 기술보다는 프로젝트 이력 위주로 물어보았다.내가 인프라 쪽 얘기를 굉장히 많이 하자 내 정체성(본인은 인프라 쪽이냐, 개발 쪽이냐)을 여쭤보고 내가 개발이라고 답하자 안심하는 듯 했다.면접 분위기도 딱딱하지 않고 자연스럽게 풀어주어서 좋았다.코딩 테스트에 관한 건 내 코딩 습관(메서드를 쪼개거나 변수 앞에 final을 붙이는 등등)에 대해서만 물어보았다.면접 중간중간 공부 열심히 했다는 칭찬도 들었는데 이 때부터 자신감이 엄청 붙기 시작해서 면접이 끝나고 붙었다는 자신이 생겼다.한편으론 면접을 못봤다고 생각했을 때도 붙은 경험이 있기 때문에 반대로 되는 게 아닐까, 나 혼자 헛소리 하다 온 게 아닐까 걱정이 됐다.면접이 끝나고 배민의 B급 감성이 가득 담긴 선물을 주는데 면접 때 뭘 받아본 적은 처음이어서 기분이 되게 좋았다. 그로부터 1주일 정도가 흘러 1차 합격 메일이 오고, 2차 임원진 면접을 그로부터 1주 후에 보았다.면접 보기 하루 전날에 스타벅스 기프트콘을 주는 것 또한 면접자를 배려해준다는 걸 크게 느낄 수 있었다.정말정말 들어가고 싶은 회사이기 때문에 배민다움이란 책도 읽었다.개인적으로 배민에 들어갈 생각이 없더라도 꼭 한 번 읽어보길 권한다.한 기업의 역사와 어떤 마인드를 가지고, 또 어떻게 충성도 높은 고객을, 그런 문화들을 만들어냈는지 엿볼 수 있는 기회이다.책을 본 덕분에 면접은 괜찮게 봤다는 느낌이 들었다. 그로부터 1주일 정도가 흘러 최종 합격 메일이 왔다.면접자를 배려하는 점은 굉장히 좋은 경험이었지만 길었던 면접 과정에 몸과 마음이 많이 지친 것 같았다. 나는 어떻게 합격할 수 있었을까?자만이 아니라 내 주관적인 판단 하에 어떤 이유 때문에 생각지도 못한 기업들에 합격할 수 있었는지 고민해봤다.하나하나 나열해서 과거로 올라가자면 끝이 없을테니 적당히 추려보았다. 연차대비 다양한 경험나는 다음과 같은 경험을 해보았다. 프로젝트 세팅(Gradle, JDK, 기술 스택) 서버 세팅(AWS의 VPC, Subnet, Routing Table, NAT Gateway, EC2, ELB, EB, Security Group, Route 53, RDS, ElastiCache 등등을 처음부터 끝까지 만들어보았다.) 성능 개선(지도보기 API 응답 15MB -&gt; 2MB로 줄임, 응답 속도를 22초에서 0.5초로 단축) 기존 로직을 수정할 때 먼저 기존 로직을 손대지 않고 성공하는 테스트 코드를 작성한 후에 로직을 개선하면서 테스트가 실패하지 않게 끔 하며 리팩토링 Dogfooding(외부에 제공할 서비스를 사내에서 미리 적용해봄) 용으로 진행한 프로젝트에서 Spring WebMVC를 사용해도 됨에도 불구하고 먼저 Webflux를 제안해주셔서 Webflux에 대한 간단한 이해도 및 장단점 인프라 경험 자동화된 배포 서버 구축 및 배포 방식 통일(Jenkins, Ansible) 서버 환경 통일(Docker) 모니터링 시스템 구축(Prometheus, Exporter, Grafana) Scale In&#x2F;Out에 대비하여 유동적으로 서비스 디스커버리(Consul) 위와 같은 경험은 주니어에게 AWS에 대한 제한을 걸지 않았던 환경(각자 DevOps로 일하는 문화)과 독자적으로 프로젝트를 진행할 수 있었던 환경,지속적으로 AWS 쪽에 관심을 표하니 인프라 쪽 업무도 맡을 수 있게 된 환경이 나에게 주어졌기 때문에 경험할 수 있었다.한마디로 복이 참 많았다. 블로그이번 면접에서 블로그에 대해 얘기가 나오지 않은 적이 거의 없었던 것 같다.먼저 언급을 해주거나, 블로그 글 재밌게 잘 봤다고 얘기해주거나, 블로그에 나온 내용 중에 궁금한 점을 물어보거나 할 정도였으니 말이다. 3년 전, 처음 블로그 시작은 개발자로 취직하기 전에 이력서에 한 줄이라도 더 적어보고 싶은 마음에, 스타 개발자가 되고 싶은 마음에 시작했다.하지만 이제 블로그에 정리를 하지 않으면 이해도가 많이 줄어드는 것 같고, 정리를 해놓으면 마음이 좀 안심되는 지경에 이르렀다. (그럼에도 불구하고 게으를 땐 여전히 잘 안 쓴다 ㅠㅠ…)또한 블로그를 해서 손해본 적은 없었던 것 같다. (앞으로는 말조심 해야할 일이 더 많을 것 같다.)따라서 뭐가 됐던 블로그에 조금씩 남기다 보면 하나의 밑거름이 되지 않을까 싶다. (광고 수익으로 돈까스를 공짜로 먹으려는 심산도 있긴 하다.) 자신감뭔소리냐 싶을 수 있겠지만, 합격하는 곳이 생기고 심지어 칭찬해주거나 면접 잘 봤다고 얘기해주는 면접관도 있다보니그 이후에 보는 면접에서는 더 잘 대답한 것 같았다.심지어 준비를 덜 했는데도 잘 본 기업도 있었다. 물어볼 게 비슷해보였고, 그에 대해 나는 준비됐다라고 자신감을 가지기 시작하니 두렵지 않았다.그전에는 ‘어떻게 내가 감히, 나는 아직 부족해’라는 생각으로 의기소침해하며 제대로 대답도 못하거나 이직 시도할 생각 조차도 하지 못했다.하지만 이런 자신감을 가지고 나니 남은 면접들이 전부 수월하게 잘 풀렸다. 이력서지인의 조언을 받아 전형적인 국문 이력서에서 프로젝트 중심의 정보들만 남긴 이력서로 탈바꿈했다.전형적인 국문 이력서(사진, 성별, 나이, 주소, 학력, 성장배경 등등)는 기술 중심의 회사라면 그닥 궁금해할 거 같지 않았다.‘개발자가 개발만 잘하면 되지, 뭐가 중요하냐’라는 생각에 수정을 했는데 매우 잘 한 것 같다. 마치며최종적으로 이직하기로 한 회사가 있긴 하지만, 수습 3개월이라는 큰 관문이 남아있기 때문에 공개하기엔 이른 것 같다.연말 쯤에는 속시원히 어떤 회사 다닌다고 말할 수 있지 않을까 싶다. 이번 면접 때 느낀 점은 회사에서 원하는 인재는 다 비슷한 것 같았다. (문화만 좀 다를 뿐이지)결국엔 잘하는 사람을 원한다. (내가 잘한다고 막 자만하거나 그런 건 아니다.)적어도 현재 잘하지 않더라도 열심히 해서 미래 잠재 능력을 보는 것도 같았다. (아마도 나는 이 축에 속하는 것 같고 이건 연차가 적은 주니어까지만 먹힐 것 같다.)대부분이 엄청 기술적인 부분보다는 프로젝트 중심으로 많이 물어봤다. (전부 자사 서비스 회사를 가서 그런 경험이 중시된 부분도 있겠지만)결국 프로젝트 경험을 쌓아야하기 때문에 개인적인 토이 프로젝트나 오픈 소스 쪽 경험을 쌓아보는 것도 좋은 것 같다. 또한 거짓말 칠만한, 가식적인 질문들(직장 상사의 부당한 지시에 어떻게 대응할 것인지 등등)이 없었고, 나의 솔직한 대답(지원 동기)가 좋게 작용했다.유튜브나 블로그에 저런 것 관련해서 어떻게 답변해야하는지, 면접관이 듣고싶어하는 답은 정해져있다 뭐 이런 내용을 어느 정도 봤었는데 그렇게까지 나 자신을 속이고 싶지 않았다. (덜 간절했던 건지도 모르겠지만…)지원 동기에 대해서 어떤 회사에는 ‘잘하는 사람이 있어서 그 사람 보고 지원했습니다’, 또 어떤 회사에는 ‘평상시에 자주 사용하는 서비스인데 제가 만들고 남들이 쓰는 거 보면 뿌듯할 거 같아서’,또 다른 회사에는 ‘대용량 트래픽에 대한 경험이 없다보니 그런 경험 하고 싶어서’ 이렇게 말했다.인터넷에서 말하는 ‘그 회사여야만 하는 이유’, ‘다른 회사에도 써먹을 수 있는 이유면 안 된다’라는 내용에 완전 위배했다.만약 내가 자신이 없었다면, 준비가 덜 됐더라면 저런 내용들로 나 자신을 숨기고 포장했을 거다.하지만 나는 기술로 승부하는 개발자이기 때문에 숨김없는 나의 기술 실력으로 승부했는데 좋게 작용한 것 같고, 전부 기술 중심의 회사이기 때문에 먹힌 전략 같았다. 그리고 이번 이직을 통해서 개발자 측면에서도 많은 성장을 했지만, 한 사람 측면에서도 엄청난 성장을 했다.열심히 하고, 잘 한다고 이직 해보라는 권유를 주변으로부터 종종 받았다.하지만 그럴 때일 수록 ‘카프카도 잘 모르는데, 레디스도 잘 모르는데, MSA로 서버 구성도 안 해봤는데, 알고리듬이나 자료구조도 잘 모르는데, 객체지향도 잘 모르는데, 스프링도 잘 모르는데’ 이런 생각이 자꾸만 들었다.그래서 ‘조금만 더 준비하고 봐야지’란 생각으로 계속 공부만 해왔다. (사실 경력 중에 공부 안 하고 인생 낭비한 세월이 절반은 된 것 같다. 물론 공부한 하면서 살진 못하겠지만…)하지만 이번 이직을 통해 내가 합격하지 못할 곳이라고 생각한 기업들에 많이 떨어지기도 했지만 합격도 많이 했다.그러다보니 내가 생각한 나보다 나는 좀 더 가치가 있는 사람이구나라는 걸 깨닫게 되었다.그동안 내 가치를 내 스스로 깎아내리고, 제대로 판단하지 못하고 시간을 많이 낭비했다는 생각도 들었다.어떻게 보면 자만일지 모르겠지만 정도 차이는 있더라도 내 가치를 내 스스로 판단하지 못한 건 사실이었다. (물론 지금도 정확히 판단하진 못하지만…)그러다보니 말이나 행동할 때 자신감이 붙다보니 계속해서 좋은 결과가 있었던 것 같다. 이런 사실은 주변에서 천년 만년 말해줘도 죽었다 깨어나도 깨닫지 못한다.본인이 직접 깨달아야한다. (물론 그만한 준비를 해왔다는 전제 하에…)하지만 시간은 계속해서 흘러가기 때문에 최대한 빨리 깨달아야한다.당신의 가치를 계속해서 깎아내리는 일이 없길 바란다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"퇴사","slug":"퇴사","permalink":"https://perfectacle.github.io/tags/%ED%87%B4%EC%82%AC/"},{"name":"이직","slug":"이직","permalink":"https://perfectacle.github.io/tags/%EC%9D%B4%EC%A7%81/"},{"name":"면접","slug":"면접","permalink":"https://perfectacle.github.io/tags/%EB%A9%B4%EC%A0%91/"}]},{"title":"(Hexo) NexT 테마","slug":"hexo-theme-next","date":"2019-08-22T15:38:15.000Z","updated":"2022-10-30T08:42:16.647Z","comments":true,"path":"2019/08/22/hexo-theme-next/","link":"","permalink":"https://perfectacle.github.io/2019/08/22/hexo-theme-next/","excerpt":"Static Page Blog 테마 선정Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다. 나는 이전에 Hueman 테마를 살짝 커스터마이징해서 사용했다.검색이나 카테고리, 메뉴 등등의 기능은 좋았지만 디자인이 좀 구려보였다.다소 아쉽긴 했지만 블로그의 본질은 글쓰기이기 때문에 좀 더 가치있는 일에 집중을 하고 싶어서 큰 불만없이 사용하고 있었다.","text":"Static Page Blog 테마 선정Static Page로 만들어진 블로그들은 테마가 굉장히 중요하다.네이버나 티스토리에는 있는 기본적인 기능들이 없는 테마들이 상당히 많다. (검색, 카테고리, 태그, 페이지네이션 등등)따라서 디자인만 보고 골랐다가 커스터마이징하느라 시간을 날리기 십상이기 때문에 디자인과 기능 사이에 어느정도 절충안을 가지고 골라야한다. 나는 이전에 Hueman 테마를 살짝 커스터마이징해서 사용했다.검색이나 카테고리, 메뉴 등등의 기능은 좋았지만 디자인이 좀 구려보였다.다소 아쉽긴 했지만 블로그의 본질은 글쓰기이기 때문에 좀 더 가치있는 일에 집중을 하고 싶어서 큰 불만없이 사용하고 있었다. 하지만 욕심이 생겨서 구글 애드센스를 통해 조그만 수익이라도 창출해보고 싶었다.그러나 번번히 정책에 부합하지 않는다는 답변만 받았다.그러다보니 ‘애드센스 다느라 뻘짓할 시간에 공부해서 연봉 올리는 게 더 낫겠다’는 판단이 들었다. 왜 NexT 테마로 바꾸는가?하지만 인간의 욕심은 끝이 없고, 주변에서 ‘왜 애드센스 안 다냐, 다른 사람들은 쉽게 통과됐다’라는 소리가 들리길래 다시 욕심이 생겼다.애드센스 말고 다른 광고 플랫폼도 있지만 ‘질떨어지는 광고가 노출되면 어떡하나, 광고가 너무 과해서 사람들의 발길이 끊기면 어떡하나’ 이런 걱정들이 들었다.그렇다고 해서 애드센스가 통과 잘 되는 다른 플랫폼으로 갈아타고 싶진 않았고, 내가 테마를 커스터마이징하면서 뭔가 웹표준이나 접근성에 위배되는 등등의 잘못을 저지르지 않을까 싶었다.따라서 애드센스가 통과된 적이 있고, 사람들이 많이 사용하는 테마를 최대한 커스터마이징하지 않으려고 하다보니 NexT란 테마를 발견하게 되었다. 우선 카테고리, 메뉴, 태그, 검색 등등의 기능은 이전 Hueman 테마와 동일하다.하지만 디자인이 깔끔하고 테마 안에서도 Muse, Mist, Pisces, Gemini와 같은 테마들이 존재한다. (나는 Pisces 테마를 택했다.)또한 사이드바에 목차가 나오는 것도 좋고, 예전에는 블로그 홈에 썸네일이 없으면 좀 보기가 안 좋았는데 이 테마는 굳이 썸네일이 없어도 돼서 썸네일을 고르는데 들었던 시간을 단축시킬 수도 있다.문서도 굉장히 잘 되있고, 한국어도 잘 지원한다.또한 북마크 기능(다음에 해당 페이지 재방문시 스크롤 위치 기억), PJAX (AJAX와 pushState를 이용하여 페이지를 처음부터 로딩하는 게 아니라 필요한 컨텐츠만 로딩), 각종 Analytics, 댓글 등등의 플러그인의 사용이 가능하다.그리고 유지보수도 굉장히 활발히 이루어지고 있다. 테마를 바꾸고 만 하루만에 바로 통과되었다.기존 테마를 내 맘대로 커스터마이징 하면서 뭔가 잘못 건드린 모양이다.주 1회 매콤 치즈 돈까스를 실현하기 위해 블로그를 열심히 해야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://perfectacle.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://perfectacle.github.io/tags/Theme/"},{"name":"NexT","slug":"NexT","permalink":"https://perfectacle.github.io/tags/NexT/"}]},{"title":"왜 한국은 미국 금리에 의존적일까?","slug":"why-korea-depends-on-interest-rate-us","date":"2019-08-15T10:14:29.000Z","updated":"2022-10-30T08:42:17.023Z","comments":true,"path":"2019/08/15/why-korea-depends-on-interest-rate-us/","link":"","permalink":"https://perfectacle.github.io/2019/08/15/why-korea-depends-on-interest-rate-us/","excerpt":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다와돌디 님의 금리, 돈은 가짜다 - 저축만 해서 망하는 이유 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다. 왜 한국은 한국 금리에만 의존할 수 없는 걸까?그 이유는 바로 무역 때문이다.대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.대부분 외국에서 수입에 의존하기 때문이다.이렇게 수출&#x2F;수입을 할 때 쓰는 돈이 기축통화인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다. 기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유기축통화는 국제거래에 통용되는 결제 수단으로서 가장 의미있는 돈이 기축통화인데, 현재 기축통화는 미국의 달러($)이다.","text":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다와돌디 님의 금리, 돈은 가짜다 - 저축만 해서 망하는 이유 영상을 보면 좀 더 많은 인사이트를 쌓을 수 있다. 왜 한국은 한국 금리에만 의존할 수 없는 걸까?그 이유는 바로 무역 때문이다.대부분의 나라가 무역을 하기 때문에 그 나라의 금리에만 의존할 순 없을 것이다.더군다나 우리 나라는 자원(석유, 나무, 철광석 등등)이 거의 없다.대부분 외국에서 수입에 의존하기 때문이다.이렇게 수출&#x2F;수입을 할 때 쓰는 돈이 기축통화인데 우리나라의 통화는 기축통화가 아니기 때문에 우리나라의 금리에만 의존할 수가 없는 거다. 기축통화 - 우리가 미국 금리에 의존할 수 밖에 없는 이유기축통화는 국제거래에 통용되는 결제 수단으로서 가장 의미있는 돈이 기축통화인데, 현재 기축통화는 미국의 달러($)이다. 그럼 어떻게 달러가 기축통화가 되었을까?현재 미국이 경제대국이지만 과거에는 영국이 경제대국이었다.그래서 2차 세계 대전 이전에는 영국의 파운드(£)가 기축통화였다.하지만 2차 세계 대전 당시에 영국은 전쟁 자금을 마련하기 위해 미국으로부터 많은 돈을 빌렸고,그 돈을 갚기 위해 영국은 많은 금을 미국에 지불하게 된다.대부분 금을 제일 많이 가지고 있는 국가가 패권을 가지게 되고, 그로 인해 미국이 패권을 가지게 됨으로써 1944년 미국 브레튼우즈 협정에서 달러가 기축통화가 되었다. 달러의 의미돈은 빚이다에서 말했다 싶이 금은 들고다니기 불편하므로 대부분의 사람이 금고에 금을 맡기고, 금 보관증으로 거래를 하기 시작했다.기축통화가 된 달러도 마찬가지였다.35 달러를 가져오면 금 1oz로 교환해주겠다고 1944년 미국 브레튼우즈 협정에서 정해졌다. (이를 금 본위제 또는 금 태환제라고 부른다.) 즉, 달러는 금 보관증으로써 작용하기 시작했다. 하지만 그 이후에 베트남 전쟁으로 달러의 가치가 하락하기 시작했다.달러의 가치가 하락했다는 것은 수요&#x2F;공급 법칙에 의해 달러의 공급이 많아졌음을 의미한다.즉, 공급이 많아졌다는 것은 중앙은행에서 달러를 많이 찍어냈음을 의미한다.왜냐하면 전쟁을 하려면 많은 돈이 필요하기 때문이다.그만한 금이 없음에도 불구하고 미국은 자신의 금고 안에 금이 얼마나 들어있는지는 미국 자신 밖에 모르기 때문에 없는 금을 교환해준다고 교환증(달러)을 마구 찍어댄 게 아닐까 싶다. 그래서 미국에 수출을 해서 달러를 벌어들인 각국은 달러의 가치를 점점 의심하기 시작한다.그 결과 많은 국가가 달러(금 보관증)를 금으로 바꾸기 시작한다.엎친데 덮친격으로 미국은 무역 적자(수출액 &lt; 수입액)였기 때문에 금은 점점 더 미국 밖으로 유출되기 시작한다. 역사적으로 금을 가장 많이 가진 국가가 패권을 쥐기 때문에 금의 유출이 두려웠던 미국은 1971년 닉슨 대통령에 의해 금 본위제(달러를 금으로 교환)를 폐지하도록 한다.왜냐하면 돈은 종이 쪼가리에 불과하기 때문에 중앙은행에서 찍어대기만 하면 되지만, 금은 실물이기 때문에 돈보다 생성(혹은 확보)해내기가 훨씬 어려웠기 때문이다.물론 폐지할 때도 영구적으로 폐지한다고 하면 달러(금 보관증)를 소유한 나라의 반발이 심할 것이므로 미국의 경제가 살아날 때까지 임시 방편으로 폐지하는 것처럼 얘기했지만 그 이후 금 본위제는 부활하지 않고 있다. 이제 달러는 금으로부터 자유로워졌고, 단순히 종이 쪼가리에 불과하게 된다.즉, 금의 보유량과 상관없이 이제 마구잡이로 찍어댈 수 있게 됐다. 미국의 조폐공사또한 달러의 조폐공사인 미국의 중앙은행(FRB, Federal Reserve Bank)은 한국과 달리 정부가 운영하는 기관이 아닌 민간은행이다.따라서 민간은행에 의해 돈이 생산되다보니 완전 그들의 손아귀에 막강한 권력이 있는 것이다.미국 정부마저도 중앙은행에 이자를 내고 돈을 대출받고 있다. 어찌보면 굉장히 웃긴 일인데, 미국에서도 화폐 발행권을 민간은행에서 정부로 옮기려는 시도는 있었다.케네디 대통령이 암살당한 해인 1963년 6월에 대통령령 11110호(화폐의 발행권을 정부로 가져온다는 내용)에 서명했다.그로부터 5개월 후인 11월에 케네디 대통령은 암살 당하고, 그 이후 대통령을 맡게 된 존슨 대통령은 대통령령 11110호에 서명한 것을 취소했다.음모론에 불과할지 모르겠지만, 그만큼 미국의 중앙은행이 가진 권력이 막강했기 때문에 이런 사태가 벌어졌다라는 루머도 있다. 이렇게 달러는 종이 쪼가리에 불과하고(완전 종이 쪼가리까지는 아니고, 미국에 대한 신뢰도로써 사용되는 게 아닐까 싶다.), 그 달러 마저도 정부가 아닌 민간은행에서 발행하기 때문에미국에 대한 의존도를 낮추자는 차원에서 다른 기축통화를 지정하자는 얘기도 있었지만 그만한 경제 규모를 가진 큰 나라가 없기 때문에 계속해서 달러가 기축통화로서 자리잡고 있는 게 아닐까 싶다. 한국 금리는 미국 금리에 의존한다.왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)에서 말했다 싶이 돈도 수요&#x2F;공급 원칙을 따른다.또한 금리(돈을 빌려주는 대가, 이자)에도 마찬가지로 수요&#x2F;공급 원칙이 적용된다. 돈을 빌리려는 사람이 많으면 공급 부족에 의해 금리는 올라간다.경기가 좋으면 사람들은 많은 돈을 사용할테고, 그로 인해 돈도 빌려서 여기저기 사업도 번창하고, 투자도 많이 할 것이다.이렇게 경기가 좋으면 금리는 올라가게 돼있다. 돈을 빌리려는 사람이 적으면 공급 과잉에 의해 금리는 내려간다.경기가 안 좋으면 사람들의 소비 심리는 위축되고, 그로 인해 기업의 매출은 줄어들고, 기업은 매출이 줄어들었으니 인건비 절감의 목적으로 정리해고를 하고, 또 정리해고 당한 사람들은 돈을 벌지 못하니 소비 심리는 위축되고…이런 사이클이 계속해서 반복된다.정부 입장에서는 사람들이 소비를 하지 않으니 세금이 덜 걷히게 되니 돈을 쓰게 끔 만들어야한다.돈이 있어야 쓰게 되는데 사람들은 돈이 없다보니 적은 금리로 대출해주는 것이다.하지만 그럼에도 불구하고 사람들이 금리가 비싸다고 생각되면 돈을 많이 빌리지 않을테니 사람들이 돈을 많이 빌릴 때까지 계속해서 금리를 내린다.0%까지 내리면 누구나 돈을 빌리고 갚지 않으면 되기 때문에 0.1%까지 낮추는 것으로 알고 있다. 이렇게 경기가 안 좋아지면 금리는 내려가고, 그러다 다시 경기가 좋아지면 금리를 올리고, 이런 싸이클이 계속해서 반복된다. 하지만 이는 한 나라의 금리만 바라봤을 때의 얘기이고, 다른 나라의 금리까지 끼어들게 되면 상황은 좀 복잡해진다. 은행명 이자 자본 A 3% 건장 B 1% 부실 당신이라면 어느 은행에 예금할 것인가? 이성적으로 판단해보면 당연히 A 은행에 맡길 것이다.그럼 이 은행명을 국가로 바꿔보자. 국가 이자 자본 미국 3% 건장 한국 1% 부실 대부분 한국보다 미국이 훨씬 튼튼한 나라라고 생각한다.더군다나 금리마저 높다면??당장 한국에 투자했던 사람은 한국에 투자한 돈을 빼서 다시 미국에 투자할 것이다.따라서 이런 자본의 유출을 막기 위해 경기의 상황과는 별개로 울며 겨자먹기로 금리를 조금씩 올려서 미국보다 금리를 높게 만들 수도 있을 것이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"경제","slug":"기타/경제","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"}],"tags":[{"name":"경제","slug":"경제","permalink":"https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"자본주의","slug":"자본주의","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"},{"name":"재테크","slug":"재테크","permalink":"https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"},{"name":"금리","slug":"금리","permalink":"https://perfectacle.github.io/tags/%EA%B8%88%EB%A6%AC/"},{"name":"기축통화","slug":"기축통화","permalink":"https://perfectacle.github.io/tags/%EA%B8%B0%EC%B6%95%ED%86%B5%ED%99%94/"}]},{"title":"왜 중앙은행은 화폐를 발행하는가? (feat. 인플레이션, 디플레이션)","slug":"why-central-banks-creates-money","date":"2019-08-15T01:56:31.000Z","updated":"2022-10-30T08:42:17.019Z","comments":true,"path":"2019/08/15/why-central-banks-creates-money/","link":"","permalink":"https://perfectacle.github.io/2019/08/15/why-central-banks-creates-money/","excerpt":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다를 보고 나면 더 많은 인사이트를 얻을 수 있다. 물가는 왜 상승하는가? (feat. 인플레이션) 수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다.","text":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다를 보고 나면 더 많은 인사이트를 얻을 수 있다. 물가는 왜 상승하는가? (feat. 인플레이션) 수요가 늘어나거나 공급이 줄어들면 가격이 올라간다.(공급 부족)예를 들면 참외 농사가 흉년이 일어나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 5개로 확 줄어들은 상황이거나,어느날 참외가 암을 치료해준다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1000명으로 늘어난 상황이다. 수요가 줄어들거나 공급이 늘어나면 가격은 줄어든다.(공급 과잉)예를 들면 참외 농사가 풍년이 나서 참외를 먹고 싶은 사람은 전과 같이 10명으로 고정적인데 참외의 갯수가 1000개로 확 늘어난 상황이거나,어느날 참외를 먹으면 암에 걸린다는 소문이 돌아 참외는 100개가 있는데 참외를 사려는 사람이 1명으로 줄어들은 상황이다. 이렇게 특정 물건에 대해서 수요와 공급의 원칙에 의해 물가가 상승&#x2F;하락하곤 한다.하지만 이건 특정 물건에만 국한되는 게 아니라 돈에도 적용되는 원칙이다. 돈의 공급이 늘어나는 방법에는 두 가지 방법이 있다. 중앙은행에서는 화폐를 발행할 수 있다.돈을 찍어내는데 당연히 공급이 늘어날 것이다. 일반 시중에 있는 은행들(중앙은행도 마찬가지)은 빚을 생성(대출로 인해)해서 그 이자로 인해 이익을 창출한다.은행은 대출해 줄 수록 이자를 많이 받을 수 있고, 그러면 그럴 수록 통화량은 증가한다.즉, 새로운 빚이 생성됨과 동시에 새로운 돈이 생성되는 것이다. 위와 같은 방법으로 인해 돈이 많아졌으니 돈에 대한 공급이 과잉 현상이 발생한다.즉, 돈의 가치가 하락한다. 돈의 가치가 하락했는데 참외의 수요&#x2F;공급 상황은 동일하다고 해보자.그럼 더 많은 돈을 지불해야 참외 한 개를 살 수 있게 된다.이렇게 통화량의 증가로 인해 화폐가치가 하락하고, 물가가 오르는 경제 현상을 인플레이션(통화팽창)이라고 한다. 우리나라 경제를 보면 꾸준하게 통화량도 증가했고, 그와 비슷한 추세로 물가도 같이 상승했음을 알 수 있다. 중앙은행중앙은행(우리나라의 중앙은행은 한국은행이다.)은 아래 권한들을 통해 통화량을 조절한다. 이자율 통제이자율을 통제(올리고 내림)함으로써 어떻게 통화량을 조절할 수 있다는 걸까? 우선 경기가 안 좋다고 쳐보자.그럼 사람들의 지갑은 무거워 질 것이고, 더더욱 경기는 안 좋아질 것이다.이 때 사람들이 소비를 하게 끔 만드는 방법은 무엇일까?바로 통화량을 늘려 사람들이 돈을 더 많이 가지게 끔 하면 돈을 많이 쓰게 될 것이다.그러면 통화량을 늘려야하는데 이자율만 내려도 통화량은 자연스레 늘어난다.이자율이 내려가면 사람들은 싼 이자에 돈을 빌릴 수 있으니 더 대출을 많이 하게 된다.그럼 대출을 함으로써 새로운 돈이 생성되는 것이다. (통화량 증가) 반대로 경기가 좋다고 쳐보자.경기가 좋으니 사람들의 지갑은 빵빵할 것이고, 이자율이 조금 높아져도 지갑이 빵빵하니 어느정도 납득할 것이다.하지만 대부분의 사람들이 이자율이 높아지면 내야할 이자가 많기 때문에 전보다는 돈을 많이 빌리지 않게 된다.또한 이자율이 비싸졌으니 비싼 이자를 감당하기 힘들어서 하루 빨리 빚을 갚으려고 할 것이다.이럼으로써 빚은 적게 생성되거나 줄어들게 되다보니 통화량은 줄게 돼있다. 화폐 발행말 그대로 돈을 찍어내는 것이다.이자율 통제는 통화량을 늘릴 수도, 줄일 수도 있지만 화폐 발행은 통화량을 줄일 순 없다. 또한 양적 완화(quntitative easing)라는 단어도 있는데 이 단어의 뜻은 중앙은행이 화폐를 찍어 통화량을 늘림으로써 경기방어와 신용경색(금융기관에서 돈이 제대로 공급되지 않아 기업들이 어려움을 겪는 현상)을 해소하는 정책이라고 한다.양적 완화는 이자율을 낮췄음에도 불구하고 경기가 회복되지 않는 등 효과가 없을 때 시행한다. 중앙은행은 왜 화폐를 발행할까?우선 경기가 안 좋아서 시중에 돈을 많이 풀려고라고 생각할 수 있다.하지만 이것보다 더 근본적인 무서운 이유가 존재한다.그것은 대출에는 이자 시스템이 존재하는데, 대출받은 돈 자체가 이자를 발생시키지 않기 때문이다. 중앙은행에서 여태까지 화폐를 100원만 발행했다고 쳐보자.(통화량 100원) 100원을 A라는 사람에게 이자 10원과 함께 빌려줬다. (여기서 지급 준비율은 무시한다.)(통화량: 100원, A의 자본: 100원) A는 이자까지 갚기 위해 B라는 사람으로부터 보트를 10원에 산다.(통화량: 100원, A의 자본: 90원, B의 자본: 10원) A가 보트를 타고 잡은 물고기를 B가 10원에 산다.(통화량: 100원, A의 자본: 100원, B의 자본: 0원) 위와 같은 상황에서 A는 아무리 열심히 일을 해도 이자 10원을 갚을 수 없다.애초에 그 10원이란 돈은 존재하지 않기 때문이다. 따라서 중앙은행에서 이자 10원을 갚게 끔 해주기 위해 화폐를 발행한다.(통화량 110원, A의 자본: 100원, B의 자본: 0원) 발행한 10원을 B에게 이자 1원과 함께 빌려준다.(통화량 110원, A의 자본: 100원, B의 자본: 10원) 다시 A가 보트를 타고 잡은 물고기를 B가 10원에 산다.(통화량 110원, A의 자본: 110원, B의 자본: 0원) 이렇게 이자를 갚게 하기 위해 화폐를 발행하고, 기존에 대출받은 사람이 아닌 다른 사람에게 대출해주고, 그 사람의 대출금을 내가 빼앗아와야 이자까지 갚을 수 있다.즉, 다른 사람의 대출금을 뺏어야하는 무서운 시스템이다.또한 경기를 회복시키기 위해 화폐를 발행하는 것이 아닌 이자를 갚게 하기 위해서, 누군가 대출을 받게 하기 위해서 화폐를 발행하는 것 또한 정말 무섭다. 위와 같은 상황에서 B가 이자 11원까지 갚기 위해서는 중앙은행에서 또 화폐를 발행하고, B가 아닌 다른 누군가가 그 돈을 대출하고, 그 대출금을 뺏어와야 이자까지 갚을 수 있다. 결국 계속해서 누군가의 대출금을 뺏어와야 하는 시스템이고, 누군가의 대출금을 뺏어오지 못하는 가난하고 힘없는 자부터 파산을 하게 되는 아주 잔인한 시스템이다. 마치 폭탄 돌리기 같다… 통화량이 줄어드는 경우도 있을까? (feat. 디플레이션)대부분의 경우에는 통화량이 계속해서 증가한다.그러다가 폭탄 돌리기를 하다 시한폭탄이 터지듯, 누군가 빚을 갚지 못해 파산하는 경우에는 통화량이 줄어든다. A가 은행에 100원을 예금한다.(통화량: 100원, 은행 자본: 100원) 은행에서 지급 준비율 10%에 의해 10원만 남겨두고 90원을 B에게 대출해준다.(통화량: 190원, 은행 자본: 10원) B가 빚을 갚지 못해 파산한다.(통화량: 100원, 은행 자본: 10원) 이렇게 누군가 빚을 갚지 못해 파산하는 경우에 통화량이 줄어들고 그에 따라 은행도 타격을 받고, 기존 예금주도 타격을 입는다.이럴 때 디플레이션(통화량의 축소로 물가가 하락하고, 경제활동이 침체되는 현상)이 발생한다.통화량이 축소됐으므로 수중에 갖고 있는 돈이 적다는 뜻이니 당연히 경제 활동은 침체되는 것이다.기업이 위축되고, 생산과 투자를 줄이고 정리해고 하게 된다.그럼 일자리가 줄어들고 돈을 벌기 힘들어진다. 하지만 무서운 점은 인플레이션 후에 디플레이션이 오는 건 숙명이라고 한다.왜냐하면 경제 호황이 진정한 돈(생산을 통해서 번 돈 등등)이 아닌 빚으로 빌린 돈이기 때문이다.그럼 그 빚이 계속해서 쌓이다가 누군가는 갚지 못하고, 그로 인해 통화량이 줄어들기 때문에 빚을 갚지 못하고, 계속해서 파산에 파산을 꼬리 물듯이 지속되면서 디플레이션이 오는 것이다. 이런 디플레이션이 오는 이유 중 하나는 갚을 능력이 되지 않는 사람에게까지 대출해주는 것이다.당장 눈앞의 이익에 눈이 멀어 은행에서 나쁜 짓을 한 것이다.그럼 그 사람들이 줄줄이 빚을 갚지 못해 파산할 것이다.모기지 사태에서 이런 일이 벌어졌다는데 정확하게는 공부해봐야겠다. 물가가 감소되는 사례를 직접 경험하지 못해서(일본은 실제로 디플레이션이 일어난 적이 있다고 한다.) 맨날 물가는 오르기만 한다(인플레이션)고 불평불만 했는데, 오히려 내리는 것(디플레이션)보다 훨씬 나은 것 같다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"경제","slug":"기타/경제","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"}],"tags":[{"name":"경제","slug":"경제","permalink":"https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"자본주의","slug":"자본주의","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"},{"name":"재테크","slug":"재테크","permalink":"https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"},{"name":"인플레이션","slug":"인플레이션","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"디플레이션","slug":"디플레이션","permalink":"https://perfectacle.github.io/tags/%EB%94%94%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"중앙은행","slug":"중앙은행","permalink":"https://perfectacle.github.io/tags/%EC%A4%91%EC%95%99%EC%9D%80%ED%96%89/"}]},{"title":"돈은 빚이다.","slug":"money-is-debt","date":"2019-08-15T00:08:49.000Z","updated":"2022-10-30T08:42:16.867Z","comments":true,"path":"2019/08/15/money-is-debt/","link":"","permalink":"https://perfectacle.github.io/2019/08/15/money-is-debt/","excerpt":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다를 보고 나면 더 많은 인사이트를 얻을 수 있다. 돈은 어떻게 생성되는가?개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.하지만 이렇게 은행에서 찍어내는 돈은 실제 통화량(시중에 유통되고 있는 화폐의 양)의 극히 일부이다.대부분의 돈은 눈에 보이지 않는다.즉 대부분의 돈은 은행에 존재한다. 최초의 은행","text":"EBS 다큐프라임 자본주의 제1부 돈은 빚이다를 보고 나면 더 많은 인사이트를 얻을 수 있다. 돈은 어떻게 생성되는가?개인이 돈을 만드는 가장 쉬운 방법은 돈을 버는 것이다.좀 더 큰 관점에서 보면 돈 자체를 찍어내는 은행에서 돈을 만들어야 진정한 의미의 돈이 생성되는 것 같다.하지만 이렇게 은행에서 찍어내는 돈은 실제 통화량(시중에 유통되고 있는 화폐의 양)의 극히 일부이다.대부분의 돈은 눈에 보이지 않는다.즉 대부분의 돈은 은행에 존재한다. 최초의 은행현재는 돈으로 거래를 하지만 과거 영국에선 금으로 거래를 했다.사람들은 자신의 모든 금을 휴대하기 불편하고, 집에 보관하기도 불안하기 때문에 금 세공업자의 금고에 안전하게 보관해놓았다.그 때는 심지어 보관하는데 보관료까지 냈다.지금 생각해보면 은행에서 너네 돈 안전하게 보관하고 있으니 보관료 내놔하는 형태이다.(언젠가 진짜 이런 세상이 올지도 모른다.) 그리고 사람들은 휴대하기 불편한 금 대신에 휴대하기 편한 금 보관증으로 거래하기 시작했다.금 보관증만 갖고 있으면 금고로 가서 금으로 바꿀 수 있기 때문에 굳이 금으로 거래할 필요가 줄어든 것이다.여기서 금 세공업자는 이런 생각을 하게 된다.한 사람이 와서 자신의 모든 금을 찾는 일은 드물고, 모든 사람이 동시에 몰려오지도 않는다.그래서 금고에 놀고있는 금들을 대출해주고 이자를 받아 수익을 창출하기 시작한다. 이런 소문이 흘러서 금고에 금을 맡긴 사람들에게까지 퍼져나갔다.사람들은 자신의 허락도 없이 마음대로 금을 빌려주고, 이익을 얻는 금 세공업자에게 따지기 시작했다.그러자 금 세공업자는 대출로 얻은 이자의 일부를 주겠다라고 금의 주인들과 딜을 하기 시작했다.금의 주인들도 보관료를 내던 마당에서 오히려 이자를 준다니까 고마운 상황이었다.금 세공업자도 조금은 아쉽지만 보관료만 받기 보다 좀 더 쏠쏠한 대출 이자의 일부를 취하는 쪽을 택했다. 그런데 얼마 지나지 않아 금 세공업자는 더욱 욕심을 내게 된다.내 금고에 금이 얼마나 들어있는지는 나 밖에 모른다.는 전제 하에 있지도 않은 금을 빌려주게 되었다.물론 있지도 않은 금의 실물을 빌려줄 수 없으니 금 보관증을 마구 발행함으로써 있지도 않은 금을 만들게 된 것이다.또한 실물 금을 찾는 사람들이 평균적으로 자신이 맡긴 금의 10%를 찾아간다는 사실에 의거하여 금고의 금보다 실제로 10배가 많은 금 보관증을 발행하였다. 시간이 지나자 이런 소문도 다시 흘러서 금 보관증을 갖고 있는 사람들의 귀에 들어갔다.결국 금 세공업자를 의심한 부자들은 자신의 금을 모두 찾아갔고, 뒤늦게 금 보관증을 들고 온 사람들은 이미 금고는 텅 비었기 때문에 금을 받을 수 없었다. 이런 사태를 뱅크런(Bankrun, 은행에 돈을 맡긴 사람들이 동시에 돈을 찾는 현상)이라 부르며 현대의 우량한 은행들 조차 뱅크런을 맞으면 파산에 이르게 된다. 현재의 은행최초의 은행과 마찬가지로 은행은 돈이 생기면 대출을 해주고 이자를 통해 수익을 얻어낸다.그리고 그 이자의 일부를 예금자에게 돌려주는 형태도 마찬가지이다. 하지만 최초의 은행이 10배의 돈을 대출해 줄 수 있던 점과는 다른 점이 있는데 바로 지급 준비율(은행은 예금액의 10%를 지급할 준비, 즉 보유하고 있어야한다.)이다.은행은 지급 준비율이 10%가 돼야한다는 토대를 마련한 게 최초의 은행에서 말한 사람들이 평균적으로 자신이 맡긴 금의 10%를 찾아간다는 사실을 바탕으로 만들어졌다. (우리나라의 평균 지급 준비율은 3.5%이다, 즉 더 많은 돈을 빌려줄 수 있다.) 이 지급 준비율 때문에 시중에는 없던 돈이 탄생한다.간단하게 A가 은행에 100원을 예금했다고 생각해보자.그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.이제 통화량은 190원이 된다.여기서 90원의 없던 돈이 생겨났고, 이 돈을 신용통화라고 부른다. 간단한 계산을 통해 100원이란 돈이 얼만큼 불어나는지 계산해보자. 은행명 예금액 대출액 잔여 예금액 A 100 90 10 B 90 81 9 C 81 72 9 D 72 64 8 E 64 57 7 F 57 51 6 G 51 45 6 H 45 40 5 I 40 36 4 J 36 32 4 K 32 28 4 L 28 25 3 M 25 22 3 N 22 19 3 O 19 17 2 P 17 15 2 Q 15 13 2 R 13 11 2 S 11 9 2 T 9 8 1 U 8 7 1 V 7 6 1 W 6 5 1 X 5 4 1 Y 4 3 1 Z 3 2 1 AA 2 1 1 AB 1 0 1 100 + 90 + 81 + 72 + 64 + 57 + 51 + 45 + 40 + 36 + 32 + 28 + 25 + 22 + 19 + 17 + 15 + 13 + 11 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 &#x3D; 863원 정확한 계산인지는 모르겠으나 소수점까지 더하면 더 늘어날 것이다.즉 원래 통화량은 100원이었는데 신용통화 763원이 추가되어 통화량은 863원이 됐다.이것이 바로 통화량 대부분의 돈이 생성되는 과정이다. 지급 준비율이 낮아지면 더 많은 돈을 생성할 수 있다(통화량 증가). 돈은 빚이다.은행은 지급 준비율을 제외한 모든 예금액을 대출해주려고 한다.왜냐하면 이자를 통해 이익을 창출해내기 때문이다.따라서 은행 입장에서는 어떻게든지 간에 대출을 해주고 싶어한다.왜냐하면 은행에서 돈이 놀고 있으면 돈을 벌 수 없기 때문이다. 그럼 왜 돈은 빚인지 알아보자. A가 은행에 100원을 예금했다고 생각해보자.(A 은행의 잔여 예금액 100원, 통화량 100원) 그럼 지급 준비율 10%에 의해 은행은 10원만 은행에 남겨두고 B에게 90원을 대출해준다.(은행의 잔여 예금액 10원, 통화량 190원) 위와 같이 통화량 90원은 신용통화로 B가 진 빚에 해당한다.즉, 90원은 실제 은행에서 찍어낸 돈이 아닌 빚이다.즉, 돈은 빚이 됐다. 위 상황에서 만약 A가 예금액 100원을 찾으려고 하면 어떻게 될까?은행은 예금액을 가지고 있지 않으므로 파산하게 된다.아무리 우량한 은행이라도 뱅크런이 발생하게 되면 파산하게 된다.이런 뱅크런 사태는 금융위기 때 사람들이 한 번에 현금을 찾으러 오면서 발생한다고 알고 있다.대부분 이런 뱅크런 사태는 일어나지 않기 때문에 사람들의 예금액은 은행에 존재하지 않고, 다 대출돼있다.즉, 새로운 빚으로써 새로운 돈이 탄생하게 되는 것이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"경제","slug":"기타/경제","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"}],"tags":[{"name":"경제","slug":"경제","permalink":"https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"자본주의","slug":"자본주의","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"},{"name":"재테크","slug":"재테크","permalink":"https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"}]},{"title":"(Java) 람다 캡처링과 final 제약조건","slug":"java-8-lambda-capturing","date":"2019-06-30T14:18:57.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2019/06/30/java-8-lambda-capturing/","link":"","permalink":"https://perfectacle.github.io/2019/06/30/java-8-lambda-capturing/","excerpt":"람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다. 1234567891011public class LambdaCapturing &#123; private int a = 12; public void test() &#123; int b = 123; final Runnable r = () -&gt; System.out.println(a); final Runnable r2 = () -&gt; System.out.println(b); &#125;&#125; 이렇게 람다 시그니처의 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 **자유 변수(Free Variable)**라고 부른다.또한 람다 바디에서 자유 변수를 참조하는 행위를 유식한 말로 **람다 캡처링(Lambda Capturing)**이라고 부른다. 람다 캡처링의 제약 조건","text":"람다의 바디에서는 파라미터 말고 바디 외부에 있는 변수를 참조할 수 있다. 1234567891011public class LambdaCapturing &#123; private int a = 12; public void test() &#123; int b = 123; final Runnable r = () -&gt; System.out.println(a); final Runnable r2 = () -&gt; System.out.println(b); &#125;&#125; 이렇게 람다 시그니처의 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수를 **자유 변수(Free Variable)**라고 부른다.또한 람다 바디에서 자유 변수를 참조하는 행위를 유식한 말로 **람다 캡처링(Lambda Capturing)**이라고 부른다. 람다 캡처링의 제약 조건지역 변수를 람다 캡처링 할 때 아래 두 가지 제약조건이 존재한다. 지역변수는 final로 선언돼있어야한다. final로 선언되지 않은 지역변수는 final처럼 동작해야한다.즉, 값의 재할당이 일어나면 안 된다. 12345678910111213141516171819202122232425public class LambdaCapturing &#123; private int a = 12; public void test() &#123; final int b = 123; int c = 123; int d = 123; final Runnable r = () -&gt; &#123; // 인스턴스 변수 a는 final로 선언돼있을 필요도, final처럼 재할당하면 안된다는 제약조건도 적용되지 않는다. a = 123; System.out.println(a); &#125;; // 지역변수 b는 final로 선언돼있기 때문에 OK final Runnable r2 = () -&gt; System.out.println(b); // 지역변수 c는 final로 선언돼있지 않지만 final을 선언한 것과 같이 변수에 값을 재할당하지 않았으므로 OK final Runnable r3 = () -&gt; System.out.println(c); // 지역변수 d는 final로 선언돼있지도 않고, 값의 재할당이 일어났으므로 final처럼 동작하지 않기 때문에 X d = 12; final Runnable r4 = () -&gt; System.out.println(d); &#125;&#125; 왜??왜 이런 제약조건이 생기게 돼었을까?왜 인스턴스 변수에는 이런 제약조건이 없는 걸까? 우선 JVM의 메모리 구조를 알아야한다.JVM에서 지역 변수는 스택이라는 영역에 생성된다.그리고 실제 메모리와는 달리 JVM에서 스택 영역은 쓰레드마다 별도의 스택이 생성된다.따라서 지역 변수는 쓰레드끼리 공유가 안 된다.JVM에서 인스턴스 변수는 힙 영역에 생성된다.인스턴스 변수는 쓰레드끼리 공유가 가능하다. 람다는 별도의 쓰레드에서 실행이 가능하다.따라서 원래 지역 변수가 있는 쓰레드는 사라져서 해당 지역변수가 사라졌는데도 불구하고,람다가 실행 중인 쓰레드는 살아있을 가능성이 있다.하지만 이 람다에서 사라진 쓰레드의 지역변수를 참조하고 있으면 어떻게 될까?당연히 오류가 날 것이다. 하지만 우리의 예상과는 달리 오류는 나지 않는다.또한 별도의 쓰레드에서 실행된다면 별도의 스택 영역을 가질테고, 그럼 다른 쓰레드의 스택에 있는 지역변수는 참조조차 할 수 없다.왜 오류는 나지 않고, 어떻게 다른 쓰레드의 스택 영역에 있는 지역 변수를 참조할 수 있는 걸까?이는 람다에서 지역 변수(해당 쓰레드의 스택)에 직접적으로 접근하는 게 아니라 변수를 자신(쓰레드)의 스택에 복사하기 때문이다.그렇기 때문에 별도의 쓰레드의 스택에 있는 지역 변수와 동일한 값을 참조할 수 있는 거고, 원래 쓰레드가 사라져도 본인의 쓰레드에서 자신의 할 일을 착실히 수행할 수 있는 것이다.하지만 위와 같이 변수를 복사해서 쓰는데 그 변수의 값이 중구난방으로 변경된다고 하면 해당 복사본을 믿고 쓸 수 있을까?따라서 지역 변수에는 final이어야하거나 final 같이 동작해야한다는 제약 조건이 생긴 것이다. 그렇다면 인스턴스 변수는 왜 이런 조건이 없는 걸까?이는 인스턴스 변수는 힙에 존재하고, 쓰레드끼리 공유도 가능하기 때문에 별도로 복사할 필요도 없고, 직접 힙에 접근해서 사용하면 되기 때문이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Lambda","slug":"Lambda","permalink":"https://perfectacle.github.io/tags/Lambda/"},{"name":"Java8","slug":"Java8","permalink":"https://perfectacle.github.io/tags/Java8/"}]},{"title":"어노테이션이 달린 빈의 자동 스캔 (Without Spring Boot)","slug":"auto-scanning-annotation-based-bean","date":"2019-06-23T12:08:10.000Z","updated":"2022-10-30T08:42:16.131Z","comments":true,"path":"2019/06/23/auto-scanning-annotation-based-bean/","link":"","permalink":"https://perfectacle.github.io/2019/06/23/auto-scanning-annotation-based-bean/","excerpt":"스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다. 어노테이션 없이 빈 설정스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수인 줄 알았다.@Component, @Configuration, @Bean, @Service, @Controller, @Repository 하지만 직접 코딩을 해보니 이 생각은 거짓이었다.","text":"스프링 부트부터 접한 스프링 알못이라 스프링에 대해 공부를 하다보니 너무나 모르고 있는 게 많아서 정리해봤다.되게 간단한 건데 스프링 부트부터 접하면 몰라도 코드 짜는데는 문제가 없지만 개인적으로는 알고 있으면 너무나 좋은 내용같다. 어노테이션 없이 빈 설정스프링이 관리하는 객체인 빈으로 생성하기 위해서 아래와 같은 어노테이션이 필수인 줄 알았다.@Component, @Configuration, @Bean, @Service, @Controller, @Repository 하지만 직접 코딩을 해보니 이 생각은 거짓이었다. 우선 느슨한 결합을 위해 인터페이스를 하나 선언한다. 1public interface OrderService &#123;&#125; 인터페이스의 구현체도 하나 만들어준다. 1public class TimonOrderService implements OrderService &#123;&#125; 해당 구현체를 의존성으로 갖는 다른 구현체도 만들어보자. 12345678910111213public class CoupangOrderService implements OrderService &#123; private OrderService otherService; // 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다. public CoupangOrderService(OrderService orderSe) &#123; this.otherService = orderSe; &#125; // 의존성 주입이 제대로 됐는지 테스트하기 위한 용도의 getter public OrderService getOtherService() &#123; return otherService; &#125;&#125; 이제 CoupangOrderService 빈이 제대로 생성되는지 테스트 코드를 작성해보자. (JUnit5를 사용하였다.) 123456789101112@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;CoupangOrderService.class&#125;)class ApplicationContextTest &#123; @Autowired private CoupangOrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService); assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; 위 테스트를 실행하면 circular reference(순환 참조) 때문에 빈을 생성할 수 없는 오류가 난다.Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference? CoupangOrderService는 OrderService 인터페이스를 의존성으로 받는데 그 구현체가 CoupangOrderService 자신 밖에 없기 때문이다.(@ContextConfiguration(classes &#x3D; {CoupangOrderService.class})에 의해 ApplicationContext에서는 CoupangOrderService 밖에 모르기 때문이다.) 그럼 ApplicationContext가 OrderService의 다른 구현체인 TimonOrderService까지 알게 해주자. 123456789101112@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;CoupangOrderService.class, TimonOrderService.class&#125;)class ApplicationContextTest &#123; @Autowired private CoupangOrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService); assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; 이제 테스트는 성공한다.우리는 빈에 대한 어노테이션을 인터페이스나 구현체 어디에도 사용을 하지 않았는데 빈의 생성도 잘 이뤄졌고, 의존성 주입도 아주 잘 되었다.CoupangOrderService에서 OrderService를 의존성 주입 받는데 OrderService의 구현체는 CoupangOrderService와 TimonOrderService 두 개이다.하지만 스프링에서는 똑똑하게 순환참조 이슈를 피하려고 본인을 제외하고 빈을 찾기 때문에 순환참조 오류가 안 났다. 한 번 위 가설이 맞는지 검증해보자.OrderService의 구현체를 하나 더 만들어보자. 1public class WeMakePriceOrderService implements OrderService &#123;&#125; 이제 테스트를 돌려보면 아래와 같이 CoupangOrderService에 OrderService를 주입하는데 TimonOrderService를 주입해야할지, WeMakePriceOrderService를 주입해야할지 모른다는 오류가 나온다. 123456789101112@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;CoupangOrderService.class, TimonOrderService.class, WeMakePriceOrderService.class&#125;)class ApplicationContextTest &#123; @Autowired private CoupangOrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService); assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;OrderService&#39; available: expected single matching bean but found 2: timonOrderService,weMakePriceOrderService OrderService의 구현체는 세 개인데 당연스레 본인(CoupangOrderService)는 빼고 의존성 주입을 시도한 것이다.그럼 위 테스트는 왜 실패한 것인가?기본적으로 스프링은 아래와 같은 순서로 DI를 하게 된다. 빈의 타입으로 빈을 검색해서 주입한다. 해당 빈의 타입이 두 개 이상이면 빈의 이름으로 검색해서 주입한다. 123public CoupangOrderService(OrderService orderSe) &#123; this.otherService = orderSe;&#125; OrderService의 빈은 2개(CoupangOrderService 본인을 제외하고)라서 빈의 이름으로 검색을해야하는데 orderSe라는 이름의 빈은 없기 때문이다.빈의 이름은 기본적으로 클래스 이름을 기반으로 생성된다. (규칙은 나중에 찾아보는 걸로…) 이제 테스트가 성공하게 제대로 된 빈의 이름으로 바꿔주자. 12345678910111213public class CoupangOrderService implements OrderService &#123; private OrderService otherService; // 스프링 4.3부터 생성자가 하나이면 @Autowired 어노테이션이 생략 가능하다. // 파라미터로 넘긴 변수 이름이 빈의 이름이 된다. public CoupangOrderService(OrderService timonOrderService) &#123; this.otherService = timonOrderService; &#125; public OrderService getOtherService() &#123; return otherService; &#125;&#125; 빈 자동 스캔우리가 생성한 빈이 많으면 많을 수록 @ContextConfiguration에 다 등록해주기도 부담이다.이럴 때 쓰는 게 @Service, @Component, @Configuration, @Bean과 같은 어노테이션들이다. 우선 인터페이스와 구현체 어디다 쓰는 게 좋은지 모르니 다 붙여놓자. 12@Servicepublic interface OrderService &#123;&#125; 12@Servicepublic class TimonOrderService implements OrderService &#123;&#125; 12@Servicepublic class WeMakePriceOrderService implements OrderService &#123;&#125; 123456789101112@Servicepublic class CoupangOrderService implements OrderService &#123; private OrderService otherService; public CoupangOrderService(OrderService timonOrderService) &#123; this.otherService = timonOrderService; &#125; public OrderService getOtherService() &#123; return otherService; &#125;&#125; 그리고 빈을 자동으로 스캔해주는 빈을 만들어주자. 12@ComponentScan(&quot;some.package&quot;)public class ComponentScanConfig &#123;&#125; 해당 패키지에 있는 @Service, @Component, @Configuration, @Bean 요런 어노테이션들이 붙은 빈들은 자동으로 스캔하고 생성해주는 어노테이션이다.(자세한 건 나중에 또 알아보자 ㅠㅠ) 이제 테스트에서 Bean 클래스들을 한땀 한땀 넣어주는 부분을 수정해보자. 123456789101112@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;ComponentScanConfig.class&#125;)class ApplicationContextTest &#123; @Autowired private CoupangOrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService); assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; Config 파일 하나로 코드가 너무나 쾌적해졌다.이렇게 빈을 자동으로 스캔하고 생성할 때는 @ComponentScan 어노테이션이 엄청 큰 도움이 된다. 어노테이션은 인터페이스에? 구현체에?12@Servicepublic interface OrderService &#123;&#125; 어노테이션을 인터페이스에만 붙이면 구현체 타입으로 DI를 받을 수 없다. 1234567891011121314151617@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;ComponentScanConfig.class&#125;)class ApplicationContextTest &#123;// CoupangOrderService 타입의 빈은 @Service 어노테이션이 안 달려있어서 @ComponentScan에서 검색되지 못한다. // @Autowired// private CoupangOrderService coupangOrderService; @Autowired private OrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService);// OrderService 인터페이스에는 getOtherService() 메서드가 없다.// assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; 하지만 이번엔 빈을 생성하지 못한다는 에러가 나온다.Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;example.domain.OrderService&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;왜냐면 인터페이스만 @Service 어노테이션을 붙여서 빈으로 생성이 되는데 인터페이스는 객체로 생성이 불가능하기 때문에 위와 같은 오류가 나는 것이다. 그럼 이번엔 구현체에만 @Service 어노테이션을 붙이면 어떻게 될까? 123456789101112@Servicepublic class CoupangOrderService implements OrderService &#123; private OrderService otherService; public CoupangOrderService(OrderService timonOrderService) &#123; this.otherService = timonOrderService; &#125; public OrderService getOtherService() &#123; return otherService; &#125;&#125; 이제 테스트를 고쳐보자. 12345678910111213141516@ExtendWith(SpringExtension.class)@ContextConfiguration(classes = &#123;ComponentScanConfig.class&#125;)class ApplicationContextTest &#123;// CoupangOrderService는 OrderService를 구현한 것이므로 OrderService 타입으로도 DI 받을 수 있다.// @Autowired// private OrderService coupangOrderService; @Autowired private CoupangOrderService coupangOrderService; @Test void test() &#123; assertNotNull(coupangOrderService); assertNotNull(coupangOrderService.getOtherService()); &#125;&#125; 테스트를 돌리면 또 순환참조 오류로 실패한다.Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &#39;coupangOrderService&#39;: Requested bean is currently in creation: Is there an unresolvable circular reference? 다른 OrderService 구현체에도 @Service 어노테이션을 붙여주자. 12@Servicepublic class TimonOrderService implements OrderService &#123;&#125; 12@Servicepublic class WeMakePriceOrderService implements OrderService &#123;&#125; 이제 테스트를 돌리면 정상적으로 돌아간다. 인터페이스에 어노테이션 안 붙여도 인터페이스 타입으로 느슨하게 결합해서 DI도 가능하고, 특정 구현체에 기능이 쓰고 싶다면 해당 구현체 타입으로 DI도 가능하고…따라서 내가 봤을 때는 인터페이스에 어노테이션을 붙여놓는 건 딱히 의미가 없는 것 같다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Bean","slug":"Bean","permalink":"https://perfectacle.github.io/tags/Bean/"}]},{"title":"(Troubleshooting) 내 로컬에서는 잘 되는데...? (내로잘)","slug":"aws-sg-trobuleshooting","date":"2019-06-11T22:28:23.000Z","updated":"2022-10-30T08:42:16.139Z","comments":true,"path":"2019/06/11/aws-sg-trobuleshooting/","link":"","permalink":"https://perfectacle.github.io/2019/06/11/aws-sg-trobuleshooting/","excerpt":"내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.) PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다.","text":"내 PC에서는 잘 되는데 버그 제보자가 직접 모바일 웹에서 안 되는 걸 보여줬다.그리고 내 모바일에서도 해봤고, 다른 사람들의 모바일에서도 전부 안 됐다. (안드로이드, iOS에서 크롬, 사파리, 삼성 인터넷 가릴 것 없이 다 안 됐다.) PC에서는 잘 되고, 모바일에서는 안 된다… 나는 당연히 프론트 이슈로 여겼다.혹시 서버 쪽 이슈일까봐 액세스 로그를 모니터링해보니 헬스 체크 이외에 로그가 안 찍히길래 자바스크립트 어딘가에서 오류가 나서 API 호출도 못 하는 거라고 확신했다. 프론트 개발자 분께서 모바일 브라우저 디버깅을 위해 세팅도 다 했는데 브라우저의 콘솔을 보니 에러 로그가 안 찍히는 것이었다. 귀신이 곡할 노릇이라 환경을 완전히 통일시키기 위해 도커로 띄워야하나… 이런 고민까지 하고 있던 찰나에프론트 개발자 분께서 내가 접속한 와이파이(사내 와이파이)와 자신이 모바일로 접속한 와이파이(게스트용 와이파이)의 차이점을 발견하였다.(사내 정책 때문에 모바일에서는 게스트용 와이파이를 쓰고 있었다.) 분석 우선 상황은 이랬다. 초반에 상품 10개는 잘 불러온다. (왜 잘 불러와지지?) 추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다. (왜 안 불러와지지?) 계속 고뇌에 빠졌고, 결국 네트워크 지식이 부족한 탓에 이런 일이 일어났었다. 초반에 상품 10개는 잘 불러온다.우선 프론트 엔드에서 렌더링을 빠르게 하려는 이유에서인지 SSR(Server Side Rendering)을 사용했다. 일반적인 CSR(Client Side Rendering)에서는 클라이언트 측에서 AJAX 방식으로 API를 호출했다면,SSR은 클라이언트 측에서 렌더링이 되기 전에 필요한 데이터가 모두 갖춰진 상태로 서버에서 HTML 파일을 내려주는 형태이다.즉, API 호출이 서버에서 일어난다. (이는 Server to Server로 API 호출이 일어남을 의미한다.) 위와 같이 Security Group을 세팅하고, 초반에 불러오는 상품은 SSR의 특성상 Server to Server로 호출하기 때문에 API 호출이 성공했던 것이다. 추가로 상품 10개를 더 불러오려고 하면 불러와지지 않는다. 위와 같이 구성하니 개발환경이 아닌 경우(게스트 와이파이나 LTE 등등)에는 API 호출이 실패하는 것이었다.이래서 내 로컬(사내 와이파이)에서는 잘 되는데, 버그 제보자의 모바일(게스트 와이파이)에서는 장애가 재현된 것이다.즉, 초기 SSR로 호출하는 API(Server to Server 방식)을 제외하고는 제대로 API 호출이 안 되는 상황이었다. 따라서 모든 IP에 대해서 API에 대한 접근을 허용할 수 밖에 없었다.(추후에는 Front 서버를 통해서만 통신하게 끔 변경해야할 것이다.) 오늘의 교훈은 뭘까~~~요? 오늘 느낀 점은 남탓을 하지 말자 이다.나는 당연히 프론트 이슈일 줄 알고 뒷짐지고 있었다.그러는 와중에 프론트 개발자 분은 모바일 디버깅 환경까지 세팅하고, Charles(패킷 캡쳐 도구)까지 깔아서 오류를 분석해주셨다.심지어 이번 이슈의 핵심인 와이파이가 다르다는 점까지 발견해주셨다.그동안 나는 뒷짐을 지고 있었다. (그렇다고 일을 안 하고 있던 건 아니고…)프론트 개발자 분께서는 충분히 화가 날 수도 있는 상황이었다.그 분의 바쁜 시간을 본인의 이슈가 아닌데도 불구하고 열심히 삽질을 했으니 말이다. 요즘 들어 이 이슈, 저 이슈에 관여를 하면서 아... 내가 이 이슈까지 봐야할까? 내가 하고 있는 일이랑은 관련이 적어보이는데...하고 소극적인 태도를 많이 보였다.하지만 이번 일을 계기로 이런 생각을 고쳐먹어야겠다고 다짐했다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"}]},{"title":"(Troubleshooting) Thread Dump 분석 도전기","slug":"thread-dump-analyze","date":"2019-06-11T01:19:36.000Z","updated":"2022-10-30T08:42:16.947Z","comments":true,"path":"2019/06/11/thread-dump-analyze/","link":"","permalink":"https://perfectacle.github.io/2019/06/11/thread-dump-analyze/","excerpt":"사건의 시작 갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다. 12345678910# blackbox exporter configurationmodules: http_health: prober: http timeout: 5s http: method: GET valid_status_codes: [200] preferred_ip_protocol: &quot;ip4&quot; ip_protocol_fallback: false","text":"사건의 시작 갑자기 Nginx가 Down 됐다는 알림이 와서 해당 서버로 접속해보니 Nginx 서비스는 정상적으로 떠있고…curl도 때려보고, 브라우저에서 직접 URL로 접속해봤을 때 문제가 없었다. 12345678910# blackbox exporter configurationmodules: http_health: prober: http timeout: 5s http: method: GET valid_status_codes: [200] preferred_ip_protocol: &quot;ip4&quot; ip_protocol_fallback: false 80포트에 대해서 http 요청을 보냈을 때 5초 이내에 200 OK가 안 오면 알람을 발생시키게 했는데 내가 테스트 해 본 바로는 아무런 문제도 없었다.(일단 5초라는 관대한 시간으로 걸어놓은 것도 문제였고, 내가 간단히 메인 페이지만 몇 번 들락날락 해본 것도 문제였다.) 따라서 나는 Alert Manager가 오작동하나 보다... 역시 내가 이 쪽 경험이 부족하다보니 뭔가 잘못 셋팅했나 보다.하며 대수롭지 않게 넘겼다. 불행의 시작 우선 열심히 구축해놓은 모니터링 시스템을 굴릴 수 없으니 EC2 인스턴스 및 JVM 메모리에 대한 지표를 살펴보았다.우선 인스턴스의 CPU나 메모리는 문제가 없었고 JVM 메모리나 GC 쪽에도 문제가 없었다. 나는 쓰레드 쪽에 문제가 있으니 우선 쓰레드 덤프부터 뜨고 봐야하나? 이 생각이었는데 저 지표를 보자마자 저런 생각이 떠오른다는 건 역시 경험은 무시할 수가 없는 것 같다. Troubleshooting우선 DB 쪽에 장애가 서버까지 전파된 걸 확인했으니 서버 쪽에서 어떤 쿼리를 수행하길래 저런 에러가 나오는지 봐야했다.쓰레드 쪽에 문제가 있다고 판단했으니 우선 jstack으로 쓰레드 덤프를 뜨고 별도의 툴을 깔지 않고 온라인(fastThread)에서 쓰레드 덤프를 분석해봤다. 나는 뭔가 어플리케이션 코드가 스택 트레이스에 찍혀있길 기대했지만 그런 건 없었다.일단 쓰레드 네임을 보아하니 http 요청에 의한 것으로 판단되니 Nginx의 Access Log를 뒤져보면 뭔가 나오지 않을까 싶었다. 파라미터에도 ALL 하나만 들어가있는 걸 보면 뭔가 전체 조회를 하는 구린 냄새가 나는 코드 같다.눈여겨 볼 점은 처음 발생한 시점이다.11시 20분에 저렇게 느린 요청들이 발생하기 시작했는데, 내가 알람을 받은 건 23분부터 받기 시작했다.아마 5초라는 관대한 시간을 줬기 때문에 더 알람을 늦게 받게된 게 아닌가 싶다. 이제는 유저가 못참고 페이지를 이탈해서 HTTP Status Code 499도 나왔다.동일한 API에서 계속해서 10초 이상이 걸리고, 점점 느려지는 걸 보니 해당 API의 문제가 맞다고 80% 정도는 확신을 했다. 실제로 해당 코드를 보니 페이징 처리나 조건문이 좀 부실했었고, 쿼리를 손 본 후에야 문제를 해결할 수 있었다. 오늘의 교훈 피…피카츄!!Alert Manger가 알림을 줬을 때 난 무시를 했다.아니 무시한 건 아니지만 아주 간단하게만 테스트했다.기계는 사람보다 정확하니 무시하지 말고 좀 더 면밀히 관찰하고 얼른 팀 내에 공유를 해야 앞으로 이런 사태가 발생하지 않을 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"},{"name":"Thread","slug":"Thread","permalink":"https://perfectacle.github.io/tags/Thread/"}]},{"title":"(Troubleshooting) 레디스 사망일기","slug":"redis-monitoring","date":"2019-05-29T03:00:50.000Z","updated":"2022-10-30T08:42:16.895Z","comments":true,"path":"2019/05/29/redis-monitoring/","link":"","permalink":"https://perfectacle.github.io/2019/05/29/redis-monitoring/","excerpt":"사건의 발단사내에서 사용하는 어드민(이하 어드민 A)&#x2F;외부에서 사용하는 어드민(이하 어드민 B)이 사망하는 사례가 속출하였다.그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다. 왜 사망했나123org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is com.lambdaworks.redis.RedisCommandTimeoutException: Command timed out at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:66) at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41)","text":"사건의 발단사내에서 사용하는 어드민(이하 어드민 A)&#x2F;외부에서 사용하는 어드민(이하 어드민 B)이 사망하는 사례가 속출하였다.그 시점은 내가 새롭게 서버를 옮긴 이후부터 발생했다.내가 서버를 옮긴 것과 이 일이 관련이 없다고 생각했지만,우선 내가 서버를 옮긴 이후에 발생한 사건이기도 해서 부검을 통해 사인을 밝혀내는 게 우선이었다. 왜 사망했나123org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is com.lambdaworks.redis.RedisCommandTimeoutException: Command timed out at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:66) at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41) elasticsearch에 저장된 에러 로그를 확인해본 결과 위와 같은 스택 트레이스를 남기고 전사하셨다.즉, 레디스가 사망해서 레디스를 사용하는 어드민 서버도 사망한 것이었다.다행인 것은 아예 프로세스 자체가 사망한 게 아니라 Hang에 걸린 상태여서 레디스를 재시작하는 것만으로 사건은 일단락 되었다.하지만 머지않은 시점에 또 다시 사망하는 사례가 발생하였다. 응급 처치 우선 어드민 A가 사용하는 레디스(이하 레디스 A)와 어드민 B가 사용하는 레디스(이하 레디스 B)가 같은 EC2 인스턴스 내에 존재하였다.또한 메모리 1GB라는 소규모 서버에서 구동하다보니 인메모리 기반의 DB인 레디스에는 굉장히 협소하다고 생각했다.하지만 우리가 사용하는 건 로그인 세션을 위해서만 사용하지, 그 이외의 것은 사용하지 않고 있어서 여전히 의아하긴 했다.하지만 문제가 계속해서 발생하다보니 우선은 스케일업을 해야했다. 그 중에 레디스 A보다 레디스 B가 더 자주 뻗어서 레디스 B를 새로운 서버로 옮기기로 했다.트래픽이 그렇게 많지도 않은 어드민 서버의 로그인 세션만 저장하는데메모리를 8GB씩이나 주는 건 약간 오버하는 경향이 없잖아 보였지만 일단 안정성을 챙기고자 좀 빵빵하게 주었다. 진짜 이유를 찾아서나는 이미 8GB로 스케일업 했기 때문에 더이상 이런 사건이 발생하지 않을 것으로 예상했지만,CTO 님께서는 좀 더 정확하게 원인을 분석하자고 하셨다.나도 대충대충 넘어가다보면 영 찜찜하기도 해서 내 역량도 그닥 올라갈 거 같지 않아서 정확하게 원인을 분석해보는 게 좋을 것 같았다. 우선 모니터링하기 위해선 지표(Metric)을 수집해야한다.그래서 가장 유명한 Redis Exporter를 찾아서 적용해보려고 했다.해당 Exporter는 Redis의 INFO 커맨드의 출력 결과를 수집해서 /metrics라는 HTTP 엔드포인트로 노출하는 역할을 한다.그럼 Prometheus에서 일정 주기마다 Pulling 해서 저장하고, 그 데이터를 기반으로 Grafana라는 대시보드를 통해 볼 수 있다. 하지만 해당 Exporter는 Port를 옵션으로 받는 게 아니라 하드코딩 돼있다.Redis Exporter를 하나만 띄울 거라면 상관 없지만, 우리는 나중에 레디스 A도 업어와야하기 때문에 Redis Exporter를 하나 더 띄워야하는 경우였다. 따라서 주객이 전도된 것 같지만 지표 수집을 위해서 기존에 Host OS에 띄워놓은 Redis를 Docker Container로 띄우고,Redis Exporter도 Docker Container로 띄워서 각 컨테이너끼리 통신하게 끔 하였다. 123456789101112131415161718# docker-compose.ymlversion: &#x27;3&#x27;services: admin-b-redis: image: redis:5.0.5-alpine container_name: admin-b-redis ports: - 6380:6379 admin-b-redis-exporter: image: oliver006/redis_exporter:v1.0.0-alpine container_name: admin-b-redis-exporter environment: - REDIS_ADDR=redis://admin-b-redis - REDIS_EXPORTER_REDIS_ONLY_METRICS=true ports: - 9122:9121 restart: on-failure 또한 레디스 B 뿐만 아니라 기존 서버에서 레디스 A도 모니터링을 붙여놓았다. 레디스 A는 우리 사내에서 사용하는 어드민이 사용하는 레디스다.계열사까지 합쳐도 전사 직원이 1,000명도 안 될텐데 생성된 키만 70,000개를 넘었다. (실제로 해당 어드민을 사용하는 유저는 100명도 안 되는데 말이다.)이는 분명히 이상했지만, 명확하게 이렇게 생성된 원인을 파악할 수 없었다. (못난 나레기 ㅠㅠ…) 우선 스프링 레디스 세션에 설정한 만료기간인 하루가 지나야 뭔가 볼 수 있을 것 같아 날이 밝기를 기다렸다.그러자 위와 같이 그래프의 양상이 바뀌었다. 여기서 내린 추측은 세션이 만료됨과 동시에 누군가 계속 세션을 생성해서 그래프가 현상유지가 되는 것이라고 전제를 깔고 분석하기 시작했다.그래서 우선 Nginx의 Access Log부터 까보기로 했다. 123456789101112131415161718192021&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:35+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:40+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:50+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:00+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:05+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:10+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:20+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125; ELB와 Consul은 Health Check Endpoint를 제대로 찌르고 있다.하지만 Go-http-client/1.1라는 Agent는 계속해서 /을 찌르는데 이 때 바로 세션이 생성되는 것이다.(추후에 /login으로 302 redirect 되지만 실제 세션 생성 시점은 그 이전이다.비로그인 유저의 세션을 만드는 이유는 해당 세션을 가지고 동시 접속자 체크, 쇼핑몰 등등에서 비회원에게 장바구니 기능 제공 등등의 기능에서 사용이 가능하기 때문이다.라고 한국 스프링 사용자 모임에 질문한 결과 알게 되었다.) 내부 아이피를 직접 찌르고 있기 때문에 외부 크롤러나 봇에 의한 것이라는 전제는 일단 접어두었다. (AWS 계정이 해킹당했을 거라는 끔찍한 상상은 하지 않았다.)그리고 한 가지 든 의심이 서버의 헬스 체크를 해서 슬랙으로 알림을 주기 위해 사용한 Blackbox Exporter의 설정에 의해 Prometheus에서 위와 같이 헬스체크를 하는 게 아닐까 의심이 되었다.그리고 의심은 확신으로 접어들기 시작했다. 곧장 Prometheus에서 헬스 체크 엔드포인트를 어떻게 불러오는지 확인을 해보았다. 123global: scrape_interval: 10s evaluation_interval: 1s 내가 수집 주기를 scrape_interval: 10s로 설정해놨고, 아래는 172.12.1.189:80을 찌른 로그만 추려본 것이다. 123456789101112&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:44+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:41:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET / HTTP/1.1&quot;,&quot;status&quot;: &quot;302&quot;,&quot;body_bytes_sent&quot;:&quot;0&quot;,&quot;request_time&quot;:&quot;0.010&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-24T18:42:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /login HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;1769&quot;,&quot;request_time&quot;:&quot;0.012&quot;,&quot;http_referrer&quot;:&quot;http://172.12.1.189:80&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125; 정확히 10초 주기로 172.12.1.189:80을 찔렀고, 점점 강한 확신으로 변해가고 있다. Prometheus에서 Blackbox Exporter와 관련된 설정을 또 살펴보자. 1234567891011121314151617scrape_configs: - job_name: &#x27;blackbox_exporter_http&#x27; metrics_path: /probe params: module: [http_2xx] consul_sd_configs: - server: &#x27;http://consul-server-001.dns:8500&#x27; - server: &#x27;http://consul-server-002.dns:8500&#x27; - server: &#x27;http://consul-server-003.dns:8500&#x27; relabel_configs: - source_labels: [__meta_consul_tags] regex: .*,blackbox_exporter_http,.* action: keep - source_labels: [__address__] target_label: __param_target # 여기가 중요 - target_label: &#x27;__address__&#x27; replacement: &#x27;blackbox-exporter:9115&#x27; 유동적으로 늘어나고 줄어드는 인스턴스에 대비하기 위해 consul을 사용하였다.우선 consul에 등록된 태그 중에 blackbox_exporter_http란 값을 가지고 있는 서비스를 골라내고__address__ 레이블에 설정된 값(ip:port)을 그대로 __param_target에 설정되는 것에서부터 문제가 시작됐다.prometheus는 __param_target에 설정된 값을 토대로 헬스체크 한다는 것을 테스트를 통해 밝혔다.이제는 완전한 확신을 했다. 우선 consul client가 설치된 어드민 A서버로 가서 consul에 어떤 service들을 등록하게 했는지 설정부터 살펴보았다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; &quot;services&quot;: [ &#123; &quot;id&quot;: &quot;Nginx&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 80, &quot;check&quot;: &#123; &quot;id&quot;: &quot;Nginx Health Check&quot;, &quot;name&quot;: &quot;Nginx Status&quot;, &quot;http&quot;: &quot;http://localhost/health&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;interval&quot;: &quot;10s&quot;, &quot;timeout&quot;: &quot;1s&quot; &#125; &#125;, &#123; &quot;id&quot;: &quot;Server:8080&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 8080, &quot;check&quot;: &#123; &quot;id&quot;: &quot;Server:8080 Health Check&quot;, &quot;name&quot;: &quot;Server:8080 Status&quot;, &quot;http&quot;: &quot;http://localhost:8080/health&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;interval&quot;: &quot;10s&quot;, &quot;timeout&quot;: &quot;1s&quot; &#125; &#125;, &#123; &quot;id&quot;: &quot;Server:8081&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 8081, &quot;check&quot;: &#123; &quot;id&quot;: &quot;Server:8081 Health Check&quot;, &quot;name&quot;: &quot;Server:8081 Status&quot;, &quot;http&quot;: &quot;http://localhost:8081/health&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;interval&quot;: &quot;10s&quot;, &quot;timeout&quot;: &quot;1s&quot; &#125; &#125; ]&#125; 또한 이제 보니 Nginx 말고 8080 및 8081 포트까지 찌르게 되어있었다.(우리는 내부적으로 빠른 롤백을 위해 한 서버 인스턴스에 두 개의 어플리케이션 서버를 띄운 후 Nginx Upstream Server를 바꾸는 Blue&#x2F;Green Deployment 전략을 사용 중이다.)8080&#x2F;8081 포트는 Nginx를 타지 않고 직접 프라이빗 IP를 찌르기 때문에 Access Log에 남지는 않았지만 세션도 생성됐을거라고 추측된다. 우선 Prometheus에게 health check endpoint를 넘길 수 있게 끔 수정해야된다. 12345678910111213141516171819202122232425262728293031323334&#123; &quot;services&quot;: [ &#123; &quot;id&quot;: &quot;Nginx&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 80, &quot;meta&quot;: &#123; &quot;health_check_endpoint&quot;: &quot;health&quot; &#125;, ... &#125;, &#123; &quot;id&quot;: &quot;Server:8080&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 8080, &quot;meta&quot;: &#123; &quot;health_check_endpoint&quot;: &quot;health&quot; &#125;, ... &#125;, &#123; &quot;id&quot;: &quot;Server:8081&quot;, &quot;name&quot;: &quot;b2b-admin&quot;, &quot;tags&quot;: [&quot;blackbox_exporter_http&quot;], &quot;port&quot;: 8081, &quot;meta&quot;: &#123; &quot;health_check_endpoint&quot;: &quot;health&quot; &#125;, ... &#125; ]&#125; meta.health_check_endpoint를 사용하게 끔 Prometheus 설정 파일도 바꿔주자. 12345678910111213141516171819scrape_configs: - job_name: &#x27;blackbox_exporter_http&#x27; metrics_path: /probe params: module: [http_2xx] consul_sd_configs: - server: &#x27;http://consul-server-001.dns:8500&#x27; - server: &#x27;http://consul-server-002.dns:8500&#x27; - server: &#x27;http://consul-server-003.dns:8500&#x27; relabel_configs: - source_labels: [__meta_consul_tags] regex: .*,blackbox_exporter_http,.* action: keep - source_labels: [__address__, __meta_consul_service_metadata_health_check_endpoint] target_label: __param_target regex: &#x27;(.*)(\\/*);(.*)&#x27; replacement: &#x27;$1/$3&#x27; - target_label: &#x27;__address__&#x27; replacement: &#x27;blackbox-exporter:9115&#x27; 위와 같이 이제 설정을 바꾼 후 다시 Nginx의 Access log를 뒤져보았다. 123456789101112&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:52+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:57:54+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:02+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.000&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:04+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:12+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:14+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.004&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:15+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:19+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.005&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;ELB-HealthChecker/2.0&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:22+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:24+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:32+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;6&quot;,&quot;request_time&quot;:&quot;0.001&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Consul Health Check&quot;&#125;&#123;&quot;@timestamp&quot;:&quot;2019-05-26T13:58:34+00:00&quot;,&quot;remote_addr&quot;:&quot;&quot;,&quot;host&quot;:&quot;172.12.1.189:80&quot;,&quot;request&quot;:&quot;GET /health HTTP/1.1&quot;,&quot;status&quot;: &quot;200&quot;,&quot;body_bytes_sent&quot;:&quot;207&quot;,&quot;request_time&quot;:&quot;0.003&quot;,&quot;http_referrer&quot;:&quot;&quot;,&quot;http_user_agent&quot;:&quot;Go-http-client/1.1&quot;&#125; 이제 Go-http-client/1.1라는 Agent도 /health을 찌르기 시작했다.그 이후에 이제 레디스 A를 모니터링 해봤다. 진짜 진짜로 죽은 이유레디스 A와 같이 그래프가 현상유지만 됐으면 별 문제가 되지 않는다.램은 1GB이지만, 실제로 사용량은 100MB도 되지 않았으므로 전혀 문제될 게 없다.문제는 레디스 A가 아닌 레디스 B였다.레디스 B는 어드민 B(외부에서 사용하는 어드민)이 사용하는 레디스이다.해당 프로젝트는 세션의 만료기간을 Integer.MAX_VALUE(2³¹ − 1 &#x3D; 2,147,483,647)로 잡아놓았다.나는 해당 프로젝트의 개발에 참여하지 않아 잘 모르겠는데 아마 외부에서 사용하는 사람들이라면 매번 로그인하는 걸 번거롭게 생각해서 직접 요구사항이 들어오지 않았을까 싶다. 거의 평생동안 쓰레기 세션이 만들어진 채로 계속 유지가 된 거다. 1GB 장비에서 500mb가 넘는 메모리는 엄청난 장애를 동반할 수 있다.계속 유지되다가 버티지 못하고 레디스가 뻗고, 해당 레디스를 사용하는 서버도 뻗고, 다른 레디스 및 서버에도 영향을 미친 것으로 보인다. 헬스 체크 엔드포인트를 변경한 이후에는 새로운 세션은 거의 만들어지지 않고 계속 현상 유지만 된 것이다.500MB가 넘는 쓰레기 세션을 68년이 넘는 시간동안이나 끌고 가야하는 문제에 직면하게 되었다.일단 로그인이 풀리겠지만 쓰레기 세션이 너무 많은 관계로 한 번 털고 가고(레디스 재시작), 세션의 만료기간도 좀 줄이기로 하였다. 쓰레기 세션을 한 번 털고 나니 메모리 사용량이 확 줄어들었다. 이후 상황 재밌는 건 중간에 줄어들다가 현상유지되는 구간이다.이 구간은 내 실수로 두 대의 서버가 떠있는데 한 대의 서버의 헬스 체크 엔드포인트만 수정하고, 나머지 한대는 제대로 수정하지 않아서 현상 유지가 되었다.(Consul 클라이언트 프로세스를 죽이고 다시 띄웠는데도 Consul 서버에서는 해당 노드와 서비스들이 좀비처럼 살아있었다 ㅠㅠ…) 솔직히 말해서 스케일 아웃은 괜히했고, 애초에 로그인 세션만 사용하는데 비정상적으로 키가 많이 생성되고 용량 차지를 많이하는 것부터가 이상했다.다음부터는 좀 더 조심히 일하고 현상 파악을 해야겠다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"},{"name":"Redis","slug":"Redis","permalink":"https://perfectacle.github.io/tags/Redis/"},{"name":"Monitoring","slug":"Monitoring","permalink":"https://perfectacle.github.io/tags/Monitoring/"}]},{"title":"(JVM) Garbage Collection Advanced","slug":"jvm-gc-advanced","date":"2019-05-11T16:05:47.000Z","updated":"2022-10-30T08:42:16.699Z","comments":true,"path":"2019/05/11/jvm-gc-advanced/","link":"","permalink":"https://perfectacle.github.io/2019/05/11/jvm-gc-advanced/","excerpt":"들어가기에 앞서 이 글은 이일웅 님께서 번역하신 자바 최적화란 책을 읽던 도중 공부한 내용을 정리한 글입니다.절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.이 글을 읽어보시기 전에 Garbage Collection Basic 편을 읽어보시면 더 도움이 될 것입니다 :) Mark and Sweep Algorithm","text":"들어가기에 앞서 이 글은 이일웅 님께서 번역하신 자바 최적화란 책을 읽던 도중 공부한 내용을 정리한 글입니다.절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다.이 글을 읽어보시기 전에 Garbage Collection Basic 편을 읽어보시면 더 도움이 될 것입니다 :) Mark and Sweep AlgorithmBasic 편에서는 간단하게 Young&#x2F;Old Generation과 Mark and Sweep 알고리듬에 대해서 간단하게 알아보았다.해당 알고리듬을 사용하는 GC를 scavenge garbage collector라고도 부른다.Mark and Sweep Algorith의 단점은 GC를 수행하는 동안 Stop the World(이하 STW)가 발생한다는 것이다. 그럼 이제 해당 알고리듬을 사용하는 GC 알고리듬에는 뭐가 있는지 알아보자. Serial GC프로덕션에서 절대 사용하면 안 되는 GC이다. (싱글 코어 CPU를 사용하는 서버를 제외하고… 설마 아직도??)CPU 코어를 한 개만 사용하기 때문에, 해당 GC는 싱글 코어 환경에서만 적합하다. (쓰레드 간의 컨텍스트 스위칭도 적기 때문에…)Young&#x2F;Old Generation 모두 Mark and Sweep 알고리듬을 사용하여 GC를 수행한다.Young Generation에서는 gc 수행 시간을 줄이고자 memory compaction을 수행하지 않고 survivor 영역을 전전긍긍하다 Old Generation으로 승진시켜버린다.Old Generation은 survivor 영역처럼 별도의 메모리 영역이 없다보니 memory compaction도 하고, 메모리 사이즈도 크다보니 수행 시간이 길다. (그만큼 STW도 길다…) -XX:+UseSerialGC 파라미터를 주고 실행하면 적용된다. ParallelGC(Young) &#x2F; ParallelOldGC(Old)Java 78의 기본 GC이며 Serial GC의 멀티 코어 판이다.‘Serial GC에서 하던 걸 다수의 코어(및 쓰레드)가 하다보니 더 빠르게 수행하겠구나‘정도로 받아들이고 있다. 둘은 쌍쌍바 같은 녀석이라 -XX:+UseParallelGC 파라미터를 주면 자동으로 -XX:+UseParallelOldGC 파라미터가 활성화되고,-XX:+UseParallelOldGC 파라미터를 주면 자동으로 -XX:+UseParallelGC 파라미터가 활성화된다. Tri-color Marking AlgorithmTri-color Abstraction으로도 불리는 것 같으며 ‘자바 최적화’란 책에서는 ‘삼색 마킹 알고리즘’이라고 번역하였다.Tri라는 접두사는 숫자 3을 의미하며, 총 3가지 색을 써서 마킹하는 알고리듬을 뜻한다.Mark and Sweep Algorithm에서는 2가지 색(마킹되었거나, 마킹되지 않았거나)을 쓴 것과 차이점을 지닌다.이 알고리듬은 동시성 알고리듬과 GC의 정확성을 증명했다는데, 즉 어플리케이션이 멈추지 않으면서 GC를 동시에 정확하게 쓰기 위해 나온 알고리듬 같다. 먼저 알고리듬을 알아보기 전에 각각의 색에는 무엇이 있고, 어떤 역할을 하는지 알아보자. 회색(Grey)해당 객체가 참조하고 있는 객체를 식별하지 않은, 즉 처리가 되지 않은 객체 검은색(Black)해당 객체가 참조하고 있는 객체를 모두 식별한, 즉 모든 처리를 끝마친 객체 흰색(White)해당 객체를 참조하고 있는 객체가 아무런 객체도 없는 객체, 수집 대상이 되는 객체 IssueMark and Sweep Algorithm과 달리 Tri-color Marking Algorithm은 어플리케이션과 동시에 수행된다.따라서 마킹하는 도중에 어플리케이션 스레드(책에선 Mutator라고 표기)에서 수정 사항이 반영되기 때문에 라이브 객체가 수집되는 현상이 발생될 수 있다. 1aInstance.setSomeField(cInstance); 12345aInstance.setSomeField(cInstance);// blah blah...aInstance.setSomeField(bInstance); 여기서 두 가지 문제점이 발생한다. A는 검은색 객체로 모든 작업이 끝난 객체다.또한 B는 흰색으로 마킹돼있다, 즉 수집의 대상이다.라이브 객체를 수집하기 때문에 추후에 NPE(NullPointerException)이 발생할 가능성이 존재한다. C는 회색 객체로 마킹돼있고, 나중에 검은색 객체로 바뀐다.즉, C는 GC 루트로부터 아무도 참조하지 않는 객체가 된 죽은 객체인데도 불구하고 흰색으로 마킹되지 않는다.따라서 수집 대상이 되지 않기 때문에 메모리 릭을 유발할 수 있다. (물론 다음 GC에서 수거해가겠지만…)이렇게 아무도 참조하고 있지 않은데 혼자 남아있는 객체를 부유 가비지(Floating Garbage)라고 부른다. 위와 같은 경우에는 애플리케이션 스레드가 객체를 변경했을 때 재마킹하게 끔하거나,알고리듬을 깨버릴만한 모든 변경 사항을 큐 형태로 넣어놓고 GC의 main phase가 끝난 다음에 fixup phase에서 바로 잡는 방법 등등이 존재한다. CMS(Concurrent Mark Sweep) GCCMS GC는 Tri-color Marking Algorithm을 사용하기 때문에 GC와 함께 어플리케이션을 돌릴 수 있다.그렇다고 해서 아예 STW가 없는 건 아닌데 Parallel(Old)GC에 비하면 훨씬 짧다.즉, 레이턴시에 엄청 민감한 경우에 적합한 GC라고 볼 수 있다.절반은 GC 돌리고, 절반은 어플리케이션 스레드를 돌리는 것이다. (물론 평상시에는 100% 어플리케이션이 쓰겠지만…)CMS GC는 Old Generation 전용 GC이고, 해당 GC를 사용하면 자동적으로 Young Generation 전용으로 ParNewGC를 사용한다.(Java 8에서 -XX:+UseConcMarkSweepGC -XX:-UseParNewGC 이 조합이 Deprecate 되었다.그냥 -XX:+UseConcMarkSweepGC만 사용하면 된다.)ParNewGC에 대해선 좀 이따 간단히 설명하겠다. CMS GC의 장점은 아래와 같다. 어플리케이션 스레드가 오랫동안 멈추지 않는다. (짧게 짧게 쪼개서 멈춘다.) CMS GC의 단점은 아래와 같다. GC 풀 사이클 자체는 Parallel(Old)GC 보다 길다. GC가 도는 도중에는 어플리케이션 스레드가 절반만 돌기 때문에 처리율이 감소한다. Mark and Sweep 알고리듬에 비해 하는 일도 많고 복잡하다보니 메모리, CPU를 더 많이 쓴다. CMS GC는 Old Generation의 메모리 Compaction을 수행하지 않으므로 단편화가 발생한다. 역시 은총알은 없는 것 같다… ㅠㅠ CMS GC는 어플리케이션 쓰레드와 같이 돌기 때문에 좀 복잡하게 동작한다. 초기 마킹(Initial Mark, STW 발생) 이렇게 마킹해놓으면 마킹 단계에서 다른 메모리 영역은 신경쓰지 않고 하나의 GC 풀에만 신경쓰면 된다. 동시 마킹(Concurrent Mark) 동시 사전 정리(Concurrent Preclean) 그리고 Initial Mark 이후에 참조 간에 변경이 생긴 곳을 Dirty Card라고 부른다.자세한 내용은 The JVM Write Barrier - Card Marking을 참고하자. 이 phase의 목적은 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다. Abort 가능한 동시 사전 정리(Concurrent Abortable Precelan)이 phase의 목적 역시 5단계(재마크, Final Remark) 시에 STW 시간을 줄이기 위함이다.해당 phase는 이름부터 Abortable이 들어가기 때문에 아래와 같은 조건 의해 Abort 될 수 있다.반복 횟수를 넘거나, 정해진 시간을 초과하거나, 사전 정리가 효과적으로 이루어졌거나 등등… (JVM 옵션으로 설정 가능한 것들도 있다.) 재마크 (Final Remark, STW 발생) 동시 쓸어담기 (Concurrent Sweep) 동시 리셋 (Concurrent Reset) CMF(Concurrent Mode Failure)ParallelOldGC는 긴 STW를 가지는 대신에 CMS는 짧은 두 번의 STW만 있으므로 지연이 매우 적다. 하지만 Old Generation을 GC하고 있는 와중에 동시에 Eden 영역도 차게 되는데, 이러다 Eden 영역이 꽉찬 경우에는 어떻게 될까?Young Generation을 GC해야하는데 ParNewGC도 STW를 유발하는데 쓰레드 절반은 Minor GC, 쓰레드 절반은 Major GC를 수행하고 있기 때문에 Minor GC는 ParallelGC 보다 느리다.또한 Minor GC 이후에 적당한 나이를 먹은 객체는 Old Generation으로 승진시켜야하는데,CMS GC는 메모리 컴팩션을 하지 않기 때문에 메모리 단편화가 발생하기 때문에 ParallelGC 보다 더 적은 객체를 Old Generation으로 승진시킨다.(-XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold의 기본 값을 좀 높여서 사용하는 걸까…?)또한 Old Generation으로 승진시킴과 동시에 Old Generation은 아직 GC 중이기도 하고해서 좀 더 긴밀한 조정을 하게되는데 이것도 ParNewGC와 ParallelGC와의 차이점이다. 또한 객체의 할당률이 급증해서 조기 승진이 일어나기도 하고,급기야 승진한 객체가 너무 많은 경우에는 Old Generation 조차 꽉차는 경우가 존재한다. (단편화로 인해 연속된 메모리 공간을 확보하지 못하는 것도 한 몫 한다.)이런 경우에는 어쩔 수 없이 CMS GC에서 ParallelOldGC로 바뀌게 되고, STW가 발생한다. CMF가 발생하지 않게 하려면, Old Generation이 꽉 차기 전에 얼른얼른 GC를 수행해야하는데-XX:CMSInitiatingOccupancyFraction 파라미터로 정할 수 있고 기본값은 75이다. (Old Generation의 75%가 차면 GC 시작) CMS는 내부적으로 사용 가능한 빈 공간을 ‘프리 리스트’라는 걸 통해 관리한다.Concurrent Sweep 단계에서 Sweeper 쓰레드는 다음의 일을 한다. 여유 공간을 더 큰 덩어리로 만든다. 단편화로 인해 CMF가 발생하지 않도록 연속된 빈 블록들을 하나로 뭉친다. 하지만 Sweeper는 어플리케이션 쓰레드와 동시에 작동하므로 쓰레드가 적절히 동기화되지 않는 한 새로 할당된 블록이 잘못 수집될 가능성이 존재한다.따라서 Sweeper 쓰레드는 프리 리스트를 잠근 후에 작업한다. G1 GC(Garbage First GC)G1 GC는 자바 6에 실험적으로 등장하여 자바 8u40 이후부터 쓸만큼의 성능 및 안정성을 발휘하기 시작했고, 자바 9부터 기본 GC로 채택됐다. (자바 12가 나온 현재도 기본 GC이다.)G1 GC는 처음부터 CMS를 대체할 목적으로 설계되었는데 CMS GC를 사용중인데 아무런 문제가 없는데 성급하게 바꾸는 행위는 하지 않는 게 좋다.굳이 바꾸지 않아도 바꾸는 건 안정성을 떨어뜨리는 행위이며 조금이라도 처리율을 높이고 싶어서 올리고 싶다면 충분한 테스트를 거친 이후에 하자. 즉, Survivor 영역도 기존에는 2개였는데 G1 GC에서는 그러한 개념도 사라졌다.또한 거대한 객체(Humongous Object)를 저장하는 ‘거대 영역(Humongous Region)’이라는 특수한 영역도 존재한다.(Humongous Object는 Old Generation에 바로 할당된다.)Humongous Object라고 식별하는 기준은 리전 사이즈의 50%를 넘는 객체면 된다. G1 GC는 처음부터 CMS를 대체할 목적으로 중단 시간이 짧은 수집기로 설계했기 때문에 아래와 같은 특징이 있다. 수십 GB 이상의 힙에서도 짧은 STW를 지향한다. 객체 할당과 Old Generation으로 승진이 많은 경우에도 메모리 Compaction을 하기 때문에 CMS처럼 Full GC가 돌지 않는다. 짧은 STW와 예측 가능한 STW 시간-XX:MaxGCPauseMillis라는 옵션으로 지정할 수 있는데 100(ms) 이하로 지정하면 이를 어길 가능성이 크다고 한다. Java 10부터 Full GC 시에 Multi Thread로 작동한다. (JEP 307: Parallel Full GC for G1)참고로 CMS GC는 Full GC 시에 Single Thread로 동작하는 것으로 알고 있는데, 지금은 고쳐졌는지 모르겠다.애초에 CMS GC를 대체할 목적으로 G1 GC 개발에 몰두했을 거 같기 때문에 안 고쳤을 것 같다… G1 GC는 힙을 ‘영역(Region)’이라는 것으로 구성한다. (일단 힙크기는 4GiB라고 가정해보자.)영역의 크기 &#x3D; 힙크기 &#x2F; 2048 &#x3D;&gt; 4096 &#x2F; 2048 &#x3D; 2(MiB)만약 딱 나누어떨어지지 않는다면 크기 값게 가장 가까운 수치로 반올림하여 계산한다.영역의 크기는 1, 2, 4, 8, 16, 32 MiB 중에 정해진다. Why G1?이름이 왜 G1(Garbage First)일까?G1 GC는 살아있는 객체를 마킹한 후에 리전 별로 얼만큼을 살려둬야하는지 알 수 있다. (생존률?)그 다음 G1 GC는 리전 중에 모든 객체가 죽은 리전(유효한 객체가 없는 리전, 즉 Garbage만 있는 Region)부터 회수를 한다.메모리 회수를 먼저 하면 빈 공간 확보를 더 빨리 할 수 있다.빈 공간 확보를 더 빨리 한다는 건 조기 승격이나 급격히 할당률이 늘어나는 경우를 방지할 수 있다.이렇게 되면 Old Generation이 비교적 한가해지게 된다. 다른 컬렉터들과 달리 G1 GC는 죽어있는 객체만 있는 Region(Garbage)을 처음에(First) 수거하기 때문에 이런 이름이 붙게 됐다. G1 GC는 어떻게 대용량 힙에서 낮은 중단 시간을 가질 수 있게 되었을까?힙 용량이 커지면 커질 수록 객체의 갯수가 많아지고, 객체의 갯수가 많아지면 GC 수행시간이 길어지고, 그러다보면 STW 시간도 당연히 늘어나게 된다.근데 G1 GC는 어떻게 그렇게 빨리 대용량 힙을 GC할 수 있는 걸까?? GC 시에 전체 Heap에 대해서 GC를 수행해도 되지 않는다.GC 해야하는 Region만 GC를 하면 되기 때문이다.이 GC 해야만하는 Region을 뒤질 때도 좀 더 특수한 기법을 쓴다.바로 Region 별로 RSet(Remembered Set)을 두고, 이 RSet만 뒤져서 추적을 하면 되기 때문이다.RSet에는 외부에서 힙 영역 내부를 참조하는 레퍼런스를 관리하기 위한 정보들이 저장돼있다. Old Generation Compaction을 하는데 전체 Old Generation 대해서 Compaction을 하지 않아도 된다.해당 Region에 대해서만 Compaction을 하면된다. Garbage를 먼저 수집해간다.이는 G1 GC의 이름의 유래에서도 설명했는데 빈 공간을 먼저 확보하기 때문에 메모리의 여유 공간이 확보가 많이 된다.여유 공간이 확보가 빨리 빨리 되니 그만큼 GC 빈도도 줄어들게 되는 것이다. EvacuationMinor GC 이후에 Survivor Space로 객체를 옮기거나 Old Generation으로 객체를 옮겨야한다.이 때 G1 GC는 해당 객체를 기존의 Region 혹은 새 Region에 복사후에 메모리를 compact시킨다.마치 전쟁통에 **피난(Evacuation)**가는 느낌 때문인지 이러한 행위를 Evacuation이라고 부른다. Major GC 시에도 마찬가지다.Old Generation Region에 있는 생존 객체를 다른 리전으로 피난(Evacuation)시킨 후 해당 메모리를 Compact한다.하지만 Old Generation의 특수한 리전인 Humongous Region에 대해서는 Evacuation이 발생하지 않는다.그냥 해당 리전의 객체(Humongous Object)가 더 이상 참조하는 객체가 없어서 사망하셨으면 바로 회수해간다. G1 GC Cycle 위 그림은 알고리듬의 Phase 및 STW가 발생하는 걸 표현한 것이다. 모든 원은 STW가 발생함을 나타낸 것이고, 그 크기에 따라 시간이 달라진다고 생각하면 될 것 같다.파란원은 Minor GC가 진행함에 따라 STW가 발생하는 것이고,주황원은 Major GC가 진행하면서 객체를 마킹하느라고 생기는 STW이고,빨간원은 Mixed Collection(Minor&#x2F;Major GC)을 진행함에 따라 STW가 발생하는 것이다. Young Only Phase는 이름에서 보듯이 Young Only (Garbage Collection) Phase라고 이해하면 될 것 같다.여기서 Major GC가 일어나긴 하지만 마킹만 하는 단계고, 메모리를 회수해가는 단계는 아니기 때문이다.파란원이 Minor GC 때문에 생긴 STW이다.이렇게 평화롭게 Minor GC만 수행하다가 -XX:InitiatingHeapOccupancyPercent에 지정한 값을 초과하는 순간 Major GC도 시작한다.Major GC의 첫단계는 Initial Mark이며 Minro GC와 동시에 수행되며 둘 다 STW를 수반한다. (따라서 다른 파란원보다 크기가 크다.)그 이후에 어플리케이션 쓰레드, Minor GC, Concurrent Mark가 동시에 수행되는데 Remark가 수행되는 순간 다른 작업은 멈추게 된다.그리고 주황색 원에서 보다싶이 Remark가 수행되면서 STW가 발생한다. (일반 파란원보다 긴 시간이 필요하다.)그 이후에 또 짜잘하게 Minor GC가 수행되다가 주황색 원에서 보다싶이 Cleanup을 수행한다. 이제 Young Only Phase가 끝나고 Space Reclamation(공간 회수) Phase가 시작된다.Space Reclamation Phase는 이름에서 보다싶이 Young Only Phase에서 마킹한 리전(Space)의 메모리를 수집(Reclamation)하는 단계이다.Space Reclamation Phase에서는 Mixed Collection(Minor&#x2F;Major GC)이 수행되는데 이는 빨간원으로 표시했다.Mark 단계가 없어서인지 Space Reclamation Phase에서는 STW 빈도가 훨씬 줄어든 모습을 볼 수 있다. Space Reclamation Phase가 끝나면 다시 Young Only Phase로 돌아가서 Minor GC만 메모리를 수집하게 된다.이렇게 G1 GC는 Young Only Phase와 Space Reclamation Phase를 번갈아 수행하는 싸이클을 갖고 있다. Algorithm이제부터는 각 GC 및 단계를 좀 더 면밀히 관찰해보자.아래 나오는 모든 그림의 출처는 Getting Started with the G1 Garbage Collector - Oracle이다. Minor GC (Young Generation)Minor GC는 기존 GC들과 크게 다르지 않다.물론 멀티 쓰레드에서 병렬로 돌아간다. 이 단계에서 STW가 발생하고, Eden과 Survivor의 사이즈는 다음 Minor GC를 위해 재계산 된다. Major GC (Old Generation) Initial Mark는 Survivor Region에서 Old Region을 참조하는 게 있는지 파악해서 Mark하는 단계이다.Survivor Region에 의존적이기 때문에 Survivor Region은 깔끔한 상태여야하고,Survivor Region이 깔끔하려면 Minor GC가 전부 끝난 상태여야한다.따라서 Initial Mark가 Minor GC에 의존적이다. Concurrent Mark 단계에서는 Old Generation 내에 생존해있는 모든 객체를 마크하고 다닌다.STW가 없기 때문에 어플리케이션 쓰레드와 동시에 돌고, 종종 Minor GC한테 인터럽트 당한다. Remark Phase 역시 STW를 수반한다.또한 Concurrent Mark 단계에서 깔짝깔짝 마킹하던 걸 완전히 끝내버린다.그리고 SATB(snapshot-at-the-beginning) 기법을 쓰기 때문에 CMS GC보다 더 빠르다.여기서 SATB는 수집 사이클을 시작할 때 접근 가능하거나 그 이후에 할당된 객체를 라이브 객체로 간주하는 기법이다. 이 단계는 STW를 수반하지 않는다.Remark에서 제일 수집하기 쉬운 Empty Region을 수집해갔으니 이제 그 다음으로 수집하기 쉬운 영역을 수집해갈 차례다.Empty Region 다음으로 수집하기 쉬운 Region은 생존률이 제일 낮은 Region이고 생존률이 낮은 순으로 순차적으로 수거해가는 것이다.먼저 해당 region을 피난(copy or move)시키고, 수집해간다.G1 GC는 이렇게 Garbage의 수집을 우선(First)해서 계속해서 여유 공간을 신속하게 확보해둔다. 또한 Cleanup 단계에서는 아래와 같은 일을 한다. Performs accounting on live objects and completely free regions. (STW 발생)살아있는 객체와 완전히 비어있는 region을 계산함(번역이 맞는지 확인해주십시오 ㅠㅠ) RSet을 정리(STW 발생) 빈 리전을 정리하고나서 Free List에 추가(Concurrent) Epsilon Collector이 컬렉터는 GC를 전혀 수행하지 않는 컬렉터이다.따라서 실서버 운영 환경에서는 절대 절대 쓰면 안된다. 다음의 경우에 적합하다. 성능 테스트 전용정확한 성능 테스트를 해야하는데 GC가 돌아감에 의해 영향을 미칠 수도 있기 때문에이마저도 없앤 후에 성능 테스트를 하고 싶을 때 사용한다.JMH란 툴로 마이크로벤치마킹 할 때 이런 GC가 영향을 미치는 테스트도 있는 모양이다. 할당률이 낮거나 0인 자바 앱 등등존재하기나 할까… 싶다. 회귀 테스트(정확히 뭔지 모르겠음)변경된 코드 때문에 메모리 할당률이 급격히 달라지지 않았나 확인할 때 유용하다고 한다. 혹시나 사용하고 싶다면 -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC 옵션을 주자. 마치며은총알은 없는 것 같습니다.모든 GC에는 각자 장단점이 있으니 충분하고 검증된 테스트를 통해 본인의 상황에 맞는 GC를 고르는 역량을 길러야합니다. (이러고 작성자는 무조건 G1 GC를 디폴트로 쓰고 있습니다 ㅠㅠ)또한 작성자의 역량 부족으로 인해 Z GC에 대해서는 다루지 못했습니다.또한 Hotspot VM 계열의 GC만 다루었습니다. (제가 OpenJDK만 사용하고 있고, 다 다루기에는 이해하기도 힘들기도 하고 많기도 해서 ㅠㅠ…)혹시나 다른 VM 계열의 GC(셰난도아(Shenandoah), C4, IBM J9)가 궁금하신 분은 이일웅 님께서 번역하신 자바 최적화란 책을 참고하시면 좋을 것 같습니다.다시 한 번 거듭 말씀드리지만 절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다. 참고 링크 Concurrent Mark and Sweep | Plumbr Concurrent Mark Sweep (CMS) Collector - Oracle Java Garbage Collection - Naver D2 쓰레기 수집 (컴퓨터 과학) - 위키피디아 The JVM Write Barrier - Card Marking Java 12 HotSpot VM Options - Oracle Java 12 Garbage-First Garbage Collector - Oracle Getting Started with the G1 Garbage Collector - Oracle JVM 튜닝","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://perfectacle.github.io/tags/GC/"}]},{"title":"(JVM) Garbage Collection Basic","slug":"jvm-gc-basic","date":"2019-05-07T01:43:52.000Z","updated":"2022-10-30T08:42:16.711Z","comments":true,"path":"2019/05/07/jvm-gc-basic/","link":"","permalink":"https://perfectacle.github.io/2019/05/07/jvm-gc-basic/","excerpt":"읽기 전 주의사항(그림을 보는 법)그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.이건 둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조한다는 걸 그린 건데,사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.이 점 참고하셔서 보시길 바랍니다! 들어가기에 앞서","text":"읽기 전 주의사항(그림을 보는 법)그림을 그리다보니 Stack에 있는 동그라미 모양과 힙 메모리에 있는 동그라미 모양이 동일한 그림들이 많이 있습니다.이건 둘이 동일한 메모리를 의미하는 게 아니라 그냥 스택에서 힙을 참조한다는 걸 그린 건데,사실 둘의 모양을 다르게 그려야하는데 아무 생각없이 복붙해서 그리다보니 이렇게 그리게 되었고…되돌리기에는 너무 많이 그림을 그려놔서(히스토리 추적이 안 되게 막 그려서…) 귀챠니즘으로 인해 그림을 수정하지 않았습니다.이 점 참고하셔서 보시길 바랍니다! 들어가기에 앞서 이 글은 이일웅 님께서 번역하신 자바 최적화란 책을 읽던 도중 공부한 내용을 정리한 글입니다.절대 해당 책의 홍보는 아니며 좋은 책을 써준 사람과 번역해주신 분께 진심으로 감사하는 마음에 썼습니다. 자바는 C언어와 달리 프로그래머가 일일이 쓰지 않는 메모리(가비지)를 회수할 필요가 없게 끔 가비지 컬렉터가 알아서 열일한다.자바의 모든 가비지 컬렉션에는 Stop the World(어플리케이션 스레드를 모두 멈추기 때문에 어플리케이션이 멈추게 된다.)가 발생하고 GC 쓰레드만 열일하게 된다. 저수준 세부를 일일이 신경쓰지 않는 대가로 저수준 제어권을 포기한다는 사상이 자바의 핵심이다. 자바는 블루 컬러(주로 생산직에 종사하는 육체 노동자) 언어입니다. 박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠. — 제임스 고슬링(자바의 아버지) — 즉, 일일이 메모리 해제하는 걸 ‘박사 학위 논문 주제’ 급의 어려운 일이라고 자바에서 여기는 것이다.이런 어려운 일은 우리가 할테니 너희는 일을 해라!(비즈니스 로직이나 짜라!) 이런 뉘앙스 같다. GC는 아래 두 가지 원칙을 준수해야한다. (프로그래머가 일일이 메모리 해제하다간 이런 유형의 휴먼 에러가 발생한다는 걸 보여준다.) 반드시 모든 가비지(쓰지 않는 메모리)를 수집(free)해야한다.메모리만 엄~청 빵빵하다면 가비지가 많더라도 굳이 메모리 해제할 필요가 없다.사실 GC도 메모리가 부족할 때만 수행한다. 살아있는 객체(접근 가능한 객체)는 절대로 수집해선 안 된다.C언어에서는 살아있는 객체(접근 가능한 객체)를 해제하면 Dangling pointer가 만들어지고, 어플리케이션이 뻗거나 해당 메모리에 다른 데이터가 할당돼서 해당 데이터를 더럽히는 등의 버그가 발생하게 된다.자바에서는 살아있는 객체를 수집해가면 나중에 참조하는 쪽에서 NPE(NullPointerException) 등등이 발생할 가능성이 높다. Mark and Sweep Algorithm자바의 GC 알고리듬의 기본은 Mark(살아있는 객체를 표시) and Sweep(쓸어담기) 알고리듬이다. Weak Generational 가설 JVM 및 유사 소프트웨어에서 객체 수명은 이원적 분포 양상을 보인다.대부분의 객체는 아주 짧은 시간만 살아있지만, 나머지 객체는 기대 수명이 훨씬 길다. 이 법칙은 사람들이 실제 실험과 경험을 토대로 얻어냈다.따라서 GC의 대상인 힙은 아래 두 가지가 핵심이라는 결론이 나왔다. 젊은 객체를 빠르게 수집할 수 있도록 설계해야한다. 늙은 객체와 단명 객체를 떼어놓는 게 가장 좋다. Hotspot VM은 Weak Generational 가설을 활용해 아래와 같은 규칙을 만들었다. 객체마다 generational count(객체가 지금까지 무사통과한 가비지 컬렉션 횟수)를 센다. 새로운 객체는 Young Generation이라는 공간에 생성된다. 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역(Old Generation 또는 Tenured Generation)에 보관된다. 또한 Weak Generational 가설 중에 **’늙은 객체가 젊은 객체를 참조할 일은 거의 없다.’**는 내용도 있는데 아예 없는 건 아니므로Hotspot VM에서는 카드 테이블(JVM이 관리하는 바이트 배열로 각 요소는 Old Generation 공간의 512 바이트 영역을 가리킨다.)이라는 자료구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록한다.따라서 Young Generation의 GC가 수행될 때 늙은 객체가 젊은 객체를 참조하는지도 확인해봐야한다.하지만 이 때는 늙은 객체를 전부 뒤져보는 게 아니라 카드 테이블만 뒤져보면 돼서 GC의 수행 속도를 높여준다. 다행히 자바는 메모리의 raw address를 사용하지도 않고, offset 연산자(. 연산자)만으로 필드나 메서드에 액세스 할 수 있기 때문에 이런 문제로부터 자유롭다. Young GenerationWeak Generational 가설에 따라 단명하는 젊은 객체들만 모아놓은 공간이다.대부분의 객체가 Young Generation에서 사망하시고, 새로 생성된 객체가 할당되기 때문에 GC가 자주 일어나는 영역이다.GC가 일어나는 동안 Stop the World가 발생하는데 이 빈도가 매우 잦기 때문에 Young Generation의 GC는 수행 시간이 짧아야한다.수행 시간이 짧으려면 수거해가는 객체의 수를 줄이면 되고, 객체의 수를 줄이려면 영역의 사이즈를 적당히 줄이면 된다.수행 시간이 짧은 GC이기 때문에 Minor GC라고 부르는 게 아닐까? Young Generation 사이즈를 지정하는 JVM flag는 -XX:NewSize와 -XX:MaxNewSize이며-XX:NewRatio 속성을 통해 Old Generation 사이즈와 Young Generation 사이즈의 비율을 정할 수 있다.예를 들어 -XX:NewRatio&#x3D;3으로 지정하면 1:3&#x3D;Young:Old 라고 보면 된다.(Young은 힙 메모리의 1&#x2F;4를 먹고, Old는 힙 메모리의 3&#x2F;4를 먹게 되는 것이다.) The parameters NewSize and MaxNewSize bound the young generation size from below and above.Setting these to the same value fixes the young generation,just as setting -Xms and -Xmx to the same value fixes the total heap size.This is useful for tuning the young generation at a finer granularity than the integral multiples allowed by NewRatio.https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html -XX:NewRatio 파라미터보다는 -XX:NewSize와 -XX:MaxNewSize의 사이즈를 동일하게 설정하는 게 튜닝하는데 더 좋다고 한다.아마 동일하게 설정하는 이유는 해당 영역의 사이즈가 동적으로 줄어들고 늘어나게 되면, GC에도 영향을 미치고 기타 Ratio 관련 설정을 재계산해야되기 때문에 성능에 영향을 미치지 않기 때문 아닐까…? 또한 Young Generation의 GC는 자주 일어나기 때문에 수행 시간이 매우 짧아야하니 적어도 Old Generation의 사이즈보다 적게 할당하는 게 일반적이라고 한다.다만 객체의 수명이 긴 객체들이 많거나 새로운 객체의 할당이 별로 없는 객체의 경우는 Young Generation의 사이즈를 좀 더 과감하게 줄이는 등 케이스 바이 케이스로 사이즈를 정해야할 것 같다.이 모든 결정은 추측이 아닌 모니터링을 통해 할당 비율이라던지 기타 등등의 데이터들을 수치화해서 정확한 데이터 기반으로 의사 결정을 내려야할 것이다. (말이 쉽지 ㅠㅠ 어떻게 하는지도 모른다…) Eden SpaceYoung Generation의 일부분이다. OS 레벨에서는 연속된 메모리 공간에 할당하지 않고 쪼개서 할당해도 되긴 하지만 할당하는 데도 오랜 시간이 걸리고, 데이터를 불러올 때도 순차적인 접근이 아니기 때문에 오래 걸리게 된다.또한 JVM의 메모리 할당은 알아두면 좋을 상식에도 나오다시피 bump-the-pointer라는 기술을 써서 저렇게 중간에 메모리를 할당하는 일은 없다. Survivor Space위에서 언급한 Eden 영역에서 GC로 인해 생기는 오버헤드를 줄이고자 생긴 영역이다.이 영역 또한 Young Generaion의 일부이다.Survivor 영역은 동일한 사이즈의 두 개의 영역으로 구분되는데 각각의 이름은 from과 to이다.(VisualVM 같은 모니터링 툴에는 S0, S1으로 표시되곤 한다.) 또한 -XX:SurvivorRatio 속성을 통해 Eden Space 사이즈와 Survivor Generation 사이즈의 비율을 정할 수 있다.예를 들어 -XX:SurvivorRatio&#x3D;6으로 지정하면 1:6&#x3D;Survivor:Eden 라고 보면 된다.(Suivovr는 Young Generation의 1&#x2F;7를 먹고, Eden은 Young Generation의 6&#x2F;7를 먹게 되는 것이다.)즉, 두 Survivor 영역의 합보다 Eden 영역의 메모리가 더 크다.(생존해서 Survivor 영역에 존재하는 객체보다 새롭게 생성돼서 Eden 영역에 할당되는 객체가 훨씬 많으므로…) You can use the parameter SurvivorRatio can be used to tune the size of the survivor spaces, but this is often not important for performance. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html 퍼포먼스에 영향을 주는 경우는 드물다고 적혀있지 않으니 굳이 쓸 필요는 없을 것 같다. Survivor Space는 왜 2개일까? 알아두면 좋을 상식에도 나오다시피 bump-the-pointer라는 기술을 써서 중간에 빈 공간이 있더라도 해당 공간에 할당하지 않는다.그럼 Survivor Space의 단편화를 없애려면 어떻게 하면 될까? 따라서 새롭게 영역을 추가하다보니 Survivor Space가 두 개가 된 거다. Minor GC그럼 이제 Young Generation에서 일어나는 Minor GC에 대해서 알아보자.(물론 JVM 플래그를 어떻게 주느냐에 따라서 Minor GC의 알고리듬이 달라질 수 있고, 여기서 설명하는 Minor GC의 알고리듬은 아주 간단하고 기본적인 수준에서 설명하고 있다.) To Survivor Space에 Eden Space에 있는 내용보다 From Survivor Space에 있는 내용을 먼저 복사하는 이유는generational count가 적은 객체(Eden Space에 거주중인 객체들)보다 generational count가 높은 객체(From Survivor Space에 거주중인 객체들)의수명이 더 길 가능성이 높기 때문이다. (Weak Generational 가설에 의해…)수명이 더 길 가능성이 높은 메모리를 먼저 배치하는 이유는 메모리의 단편화를 줄이기 위함이다. Promotion아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다. generational count가 어느정도 있으려면(짬밥을 어느정도 먹었으려면) 당연히 Survivor Space에 있는 객체가 이동됨을 의미한다. 적당한 나이는 -XX:InitialTenuringThreshold와 -XX:MaxTenuringThreshold 파라미터로 정할 수 있다.(Old 영역으로 승진하는 객체의 갯수나 비율이 많아지면 자동으로 TenuringThreshold를 늘리는 원리인지 뭔지 잘 모르겠다…) Premature Promotion적당한 나이(TenuringThreshold)를 먹지 않았는데 어쩔 수 없이 Old Generation으로 이동하는 행위를 premature promotion(조기 승진)이라고 부른다.아래 나오는 그림에서 동그라미 안의 숫자는 객체의 나이(객체가 GC로부터 살아남은 횟수)를 의미한다. -XX:TargetSurvivorRatio는 Minor GC 이후의 From Survivor Space의 사용률(%)을 제한하는 옵션이다. 이 premature promotion의 경우에는 Old Generation에 놓기 때문에 Major GC 혹은 Full GC가 일어나기 전에는 회수해가지 않으며적당한 나이를 먹지 않고 와서 단명할 가능성이 높음에도 불구하고 쓸데없이 Old Generation을 차지하고 있기 때문에Major GC 혹은 Full GC의 발생 빈도를 늘려 어플리케이션 전반에 영향을 미치기 때문에 적절하게 Young Generation과 관련된 사이즈를 정하는 게 중요하다. Old Generation객체가 적당한 나이를 먹거나 조기 승진을 통해 넘어온 객체들이 존재하는 영역이다.Tenure Generation이라고도 부른다.해당 영역에 존재하는 객체들을 Young Generation에 있는 객체들보다 회수당할 가능성이 적다는 게 Weak Generational 가설이다.또한 대부분의 객체가 Young Generation에서 사망하시기 때문에 Old Generation으로 오는 객체는 Young Generation에 할당되는 객체의 비율에 비해 현저히 낮다. Major GCMajor GC 역시 Old Generation이 꽉 찼을 때 수행된다.기본적으로 Old Generation은 메모리 할당률이 낮기 때문에 GC가 일어나는 빈도가 적다.또한 대부분 Old Generation은 Young Generation 보다 용량을 크게 잡기 때문에 객체의 갯수도 많아서 GC 시간이 길다.GC의 시간이 길다는 것은 그만큼 Stop the World, 어플리케이션이 멈추는 시간도 길다는 의미고 그런 의미에서 Major GC(주요한 GC)라고 이름을 붙인 게 아닐까 싶다.또한 Old Generation은 Young Generation과 같이 Survivor Space가 존재하는 게 아니기 때문에 메모리 단편화도 신경써야하고 관리해야할 객체도 많다보니 훨씬 알고리듬이 복잡해진다.이에 대해선 다음에 글을 써볼 예정이다. Full GCMinor GC + Major GC를 Full GC라고 부른다.정확히 언제 일어나는지 모르겠지만 Old Generation GC에 대해 좀 더 자세히 공부하고 다시 작성해야겠다. Permanent GenerationJVM의 Method Area를 Hotspot VM에서 Permanent Generation(줄여서 PermGen)으로 부르기 시작하면서 다른 VM에서도 PermGen이라고 부르는 것 같다.PermGen은 자바 8에서 사라졌다.PermGen에는 클래스의 메타데이터, 메서드의 메타데이터, 상수풀, static 변수 등등이 들어간다.PermGen은 이름만 들어보면 Permanent(영구적인)가 들어가다보니 영구히 존재하는 데이터들만 저장될 거 같은데 필수는 아니지만 GC가 수행되기도 한다.GC가 수행된다는 관점에서인지 이 영역을 힙 메모리로 보는 사람도 있는데 나는 클래스의 인스턴스가 저장되는 것도 아니고-Xmx, -Xms와는 별개로 사이즈가 지정되다보니 힙메모리가 아니라고 생각하고 있다.-XX:PermSize와 -XX:MaxPermSize로 사이즈를 지정할 수 있고, GC를 수행하지 않는다면 용량이 부족해질 수 있고 아래와 같은 OOME가 난다.java.lang.OutOfMemoryError: PermGen space이러한 에러가 나는 이유는 여러가지가 있는데 대표적으로 다음과 같다. collection을 static으로 만들고 계속해서 요소를 추가하는 경우(이런 실수를 범하면 절대 안된다.) 서버를 재시작하지 않고 변경 내역을 바로바로 반영해주는 HotDeploy를 계속해서 사용하다보면 Class와 Method의 메타데이터가 계속해서 쌓이게 되는데서버를 주기적으로 재시작해주지 않고, 계속해서 HotDeploy 하는 경우(실서버에서 이런 경우는 거의 없을 것이다.) Metadata자바 8부터 PermGen의 역할을 Metadata 영역에서 맡기 시작했고 Native 영역으로 옮겨졌다. (즉 OS에서 관리한다는 의미)PermGen 중에 일부만 Metadata 영역에서 맡기 시작했고, 상수풀이나 static 변수는 Heap 메모리로 옮겨져왔다.즉, 개발자가 실수하기 쉽거나 변경이 잦은 내용들은 힙 메모리로 끌고와서 GC의 대상이 되게 하고, 정말 변경이 될 가능성이 적은 내용들만 Native 영역으로 옮겨버렸다.문제는 Native 영역은 dump를 떠도 안 나와서 분석하기 힘들다는데 이럴 일은 아마 거의 없을 것이다…Metadata에 대한 관리는 OS에서 함으로 믿고 맡겨도 된다고 생각하지만(개발자가 직접하는 것보다 낫지 않을까?),혹시 이 쪽을 튜닝해야하거나 OOME(java.lang.OutOfMemoryError: Metadata space)가 발생한 경우에는 -XX:MetaspaceSize와 -XX:MaxMetaspaceSize 파라미터를 사용해보자. OutOfMemoryException주로 OOME라고 줄여부르며 메모리 공간이 부족해서 나는 예외로 어플리케이션 자체가 뻗는 현상이 발생한다.이 예외가 발생했을 때는 메모리 릭(메모리 결함)이 발생한 경우이고 Heap 메모리나 PermGen(Metaspace) 등등의 영역이 부족할 때 발생하는데어떤 메모리가 부족한 건지, 아니면 왜 이 오류가 났는지 Stacktrace를 찍고 사망한다. 여기서는 힙 메모리가 부족해서 OOME가 발생한 경우의 원인에 대해서만 설명하겠다.우선 메모리가 부족하면 가비지 컬렉터는 힙메모리의 가비지 컬렉션을 수행한다.가비지 컬렉션을 수행했음에도 불구하고 새로운 객체를 더이상 할당할 수 없는 경우에 OOME가 발생하게 된다.이 때는 아주 급한 경우에는 일단 -Xmx와 -Xms로 메모리를 늘리고 보고, 12-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;PATH&#125;/$&#123;FILE_NAME&#125;.hprof 위 두가지 설정을 주고 실행해서 재발하면 힙덤프를 생성하거나 아니면jmap 등등으로 살아있는 서버의 힙덤프를 떠서 어디서 메모리 릭이 발생했는지 Eclipse MAT 등등으로 분석하거나 123456-Dcom.sun.management.jmxremote-Dcom.sun.management.jmxremote.port=$&#123;JMX_PORT&#125;-Dcom.sun.management.jmxremote.authenticate=false-Dcom.sun.management.jmxremote.ssl=false-Dcom.sun.management.jmxremote.rmi.port=$&#123;RMI_PORT&#125;-Djava.rmi.server.hostname=$&#123;HOST_NAME&#125; 위 설정 등등을 줘서 VisualVM으로 서버에 실제로 떠있는 어플리케이션 등등을 모니터링하는 방법이 있다. 알아두면 좋을 상식 Hotspot VM의 GC는 Arena라는 메모리 영역에서 작동한다. Hotspot VM은 시작 시 메모리를 유저 공간에 할당&#x2F;관리한다.따라서 힙 메모리를 관리할 때 시스템 콜을 하지 않으므로 커널 공간으로 컨텍스트 스위칭을 하지 않아서 성능 향상에 도움이 된다. Hotspot VM은 할당된 메모리 가장 마지막의 다음 영역을 가리켜 연속된 빈 공간에 효율적으로 빠르게 할당하는 bump-the-pointer라는 기술을 사용했다. Hotspot VM은 멀티 스레드 환경에서 객체를 할당할 때 스레드 간의 경합 등등의 문제를 줄이고자 TLAB(Thread Local Allocation Buffer)를 사용했다.Eden Space를 여러 버퍼로 나누어 각 어플리케이션 스레드에게 할당함으로써 자기 자신이 사용해야 할 버퍼를 바로 찾게되고, 리소스를 공유해서 생기는 문제를 없애버렸다.만약 본인에게 할당된 TLAB가 부족할 경우에는 크기를 동적으로 조정한다. 마치며해당 글을 읽고 Garbage Collection Advanced 편을 읽어보시면 GC에 대해 더 깊게 이해하실 수 있을 겁니다 :) 참조 링크 Naver D2 - Java Garbage Collection Naver D2 - JVM Internal The JVM and Java Garbage Collection - OLL Live (Recorded Webcast Event) JDK8에선 PermGen이 완전히 사라지고 Metaspace가 이를 대신 함. JDK8 적용 후, 심각한 성능저하가 발생한다면? JAVA8 Permanent 영역은 어디로 가는가 Understand the OutOfMemoryError Exception - Oracle Docs Sizing the Generations - Oracle Docs Minor GC vs Major GC vs Full GC Useful JVM Flags – Part 5 (Young Generation Garbage Collection) “-XX:TargetSurvivorRatio” - Second Tenuring Condition 그 외 더 많은 거 같은데 기억이 잘 나지 않는다…","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"https://perfectacle.github.io/tags/GC/"}]},{"title":"(삽질기) SSH 터널링을 통해 원격지에 존재하는 도커 컨테이너 안의 JMX 모니터링하기","slug":"jmx-monitoring-inside-docker-container-over-ssh-tunneling","date":"2019-05-05T08:36:13.000Z","updated":"2022-10-30T08:42:16.667Z","comments":true,"path":"2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/","link":"","permalink":"https://perfectacle.github.io/2019/05/05/jmx-monitoring-inside-docker-container-over-ssh-tunneling/","excerpt":"들어가기에 앞서JMX를 모니터링 하려면 VisualVM이나 JDK에 기본적으로 내장돼있는 JConsole을 사용해야한다. 로컬에서 JMX 모니터링하기우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.우선 자바 어플리케이션을 띄워보자.","text":"들어가기에 앞서JMX를 모니터링 하려면 VisualVM이나 JDK에 기본적으로 내장돼있는 JConsole을 사용해야한다. 로컬에서 JMX 모니터링하기우선 로컬에 어플리케이션을 띄우고 JMX 모니터링하기란 참 쉽다.우선 자바 어플리케이션을 띄워보자. 1java -jar air.jar 도커 컨테이너 안의 JMX 모니터링 하기우선 도커 이미지 파일부터 만들어야한다. 1234567891011121314FROM openjdk:11-jdk-slimWORKDIR /rootCOPY build/libs/air.jar .CMD (java \\ -Dcom.sun.management.jmxremote \\ -Dcom.sun.management.jmxremote.port=9090 \\ -Dcom.sun.management.jmxremote.authenticate=false \\ -Dcom.sun.management.jmxremote.ssl=false \\ -Dcom.sun.management.jmxremote.rmi.port=9090 \\ -Djava.rmi.server.hostname=localhost \\ -jar air.jar) jmxremote.port와 jmxremote.rmi.port를 달리 해도 되는데 그럼 docker container의 port 2개를 host os port 2개랑 바인딩해야한다.그냥 둘을 하나로 통일하면 하나만 바인딩하면 되기 때문에 굳이 두 개로 해야할 필요성을 느끼진 못했다.java.rmi.server.hostname에 로컬의 사설 IP(private ip)를 넣어도 되는데 굳이 귀찮게 그렇게 할 필요성도 느끼지 못했다.또한 SSH Tunneling을 거치게 됐을 때 서버의 사설 IP를 적었을 때는 접속이 불가능했으므로 무조건 localhost라고 적어주자. 해당 이미지를 빌드하고 이제 이미지를 container로 띄워보자. 123456# JMX를 모니터링 하는 것이기 때문에 어플리케이션의 포트는 바인딩하지 않았다.# JMX remote port(9090)와 다른 포트를 Host OS에 매핑하면 모니터링이 불가능하다.# 9091:9090 이렇게 하면 못 붙는다 무조건 9090:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.# 혹시 jmx remote port와 jmx remote rmi port를 다르게 했다면 두 포트를 모두 바인딩 시켜줘야한다.# jmx remote port가 9090이고 jmx remote rmi port가 9091이라면 -p 9090:9090 -p 9091:9091 이렇게 해줘야한다.docker run -p 9090:9090 air Host OS에 자바 어플리케이션이 뜬 게 아니라 컨테이너 안에서 뜬 거고, HostOS는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다. 만약 jmx remote port와 jmx remote rmi port를 다르게 했더라도 입력하는 포트는 jmx remote port를 입력해줘야한다. 아쉽지만 도커 컨테이너로 띄우게 되면 쓰레드 덤프는 떠지지만 힙 덤프는 안 떠진다.혹시 도커 컨테이너로 띄웠을 때도 힙 덤프를 뜨게 하려면 어떻게 해야하는지 댓글에 남겨주시면 정말 감사하겠습니다. SSH Tunneling을 통해 원격지의 JMX 모니터링하기서버를 퍼블릭 존에 두는 건 매우 위험하다. (크래커가 직접 SSH로 붙을 가능성이 존재하거나 각종 공격에 직접적으로 노출되기 때문에…)따라서 프라이빗 존에 둬야하는데 VPN을 쓸 경제적 여력이 안 되는 가난한 환경이나 VPN을 적용하지 않은 환경에서는 매우 귀찮아진다.(우리 회사가 가난하다는 게 아니다.) 기본적인 명령어는 위 사진에서 보는 바와 같고 명령어의 예시를 들어보겠다. 1234# JMX remote port(9090)와 다른 포트를 Localhost에 매핑하면 모니터링이 불가능하다.# 9091:$&#123;application_server_ip&#125;:9090 이렇게 하면 못 붙는다.# 무조건 9090:$&#123;application_server_ip&#125;:9090(jmx remote port를 다르게 했다면 해당 포트를...)을 바인딩 해야한다.ssh -N -L 9090:$&#123;application_server_ip&#125;:9090 -i ~/.ssh/key.pem ec2-user@&#123;bastion_host_ip&#125; 이번에도 역시 Host OS에 자바 어플리케이션이 뜬 게 아니라 원격지의 도커 컨테이너 안에서 뜬 거고, Localhost에는 JMX remort port만 바인딩 된 거기 때문에 모니터링 툴을 보면 바로 잡혀있지 않다. JMX remote port(9090)와 다른 포트를 매핑하는 바람에 몇 시간을 삽질했는지 모르겠다…혹시 이거보다 더 간단하게 연결하는 방법이 있다면 댓글로 남겨주시면 정말 감사하겠습니다. 참조 링크 VisualVM over ssh Docker 안에 숨어 있는 Web application JMX profiling Tip","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"삽질","slug":"Note/삽질","permalink":"https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"JMX","slug":"JMX","permalink":"https://perfectacle.github.io/tags/JMX/"}]},{"title":"(Troubleshooting) Hibernate MultipleBagFetchException 정복하기","slug":"hibernate-multiple-bag-fetch-exception","date":"2019-05-01T20:04:41.000Z","updated":"2022-10-30T08:42:16.655Z","comments":true,"path":"2019/05/01/hibernate-multiple-bag-fetch-exception/","link":"","permalink":"https://perfectacle.github.io/2019/05/01/hibernate-multiple-bag-fetch-exception/","excerpt":"TroubleSpring Data JPA를 이용하다보면 종종 org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags이란 메세지를 보게 된다.우선 어떤 상황에 나타나는지 한 번 살펴보자. 1234567891011121314151617181920212223242526272829303132333435363738394041@Entity@Getter@NoArgsConstructorpublic class Mother &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL, fetch = FetchType.EAGER) private List&lt;Daughter&gt; daughters = new ArrayList&lt;&gt;(); @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL, fetch = FetchType.EAGER) private List&lt;Son&gt; sons = new ArrayList&lt;&gt;(); @Builder public Mother(final Long id, final List&lt;Daughter&gt; daughters, final List&lt;Son&gt; sons) &#123; this.id = id; if(daughters == null) this.daughters = new ArrayList&lt;&gt;(); else &#123; daughters.forEach(daughter -&gt; daughter.setMother(this)); this.daughters = daughters; &#125; if(sons == null) this.sons = new ArrayList&lt;&gt;(); else &#123; sons.forEach(son -&gt; son.setMother(this)); this.sons = sons; &#125; &#125; public void bearDaughters(final List&lt;Daughter&gt; babyDaughters) &#123; babyDaughters.forEach(daughter -&gt; daughter.setMother(this)); daughters.addAll(babyDaughters); &#125; public void bearSons(final List&lt;Son&gt; babySons) &#123; babySons.forEach(son -&gt; son.setMother(this)); sons.addAll(babySons); &#125;&#125; 엄마가 있고, 아들&#x2F;딸들이 있는데 아들&#x2F;딸들을 EAGER로 fetch해 올 때 발생한다.(즉, OneToMany, ManyToMany인 Bag 두 개 이상을 EAGER로 fetch할 때 발생한다.)EAGER로 땡겨오면 N+1 쿼리 문제가 존재하기 때문에 fetchType을 전부 LAZY로 바꾼 후 한 방 쿼리로 불러와도 문제는 재발한다.","text":"TroubleSpring Data JPA를 이용하다보면 종종 org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags이란 메세지를 보게 된다.우선 어떤 상황에 나타나는지 한 번 살펴보자. 1234567891011121314151617181920212223242526272829303132333435363738394041@Entity@Getter@NoArgsConstructorpublic class Mother &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL, fetch = FetchType.EAGER) private List&lt;Daughter&gt; daughters = new ArrayList&lt;&gt;(); @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL, fetch = FetchType.EAGER) private List&lt;Son&gt; sons = new ArrayList&lt;&gt;(); @Builder public Mother(final Long id, final List&lt;Daughter&gt; daughters, final List&lt;Son&gt; sons) &#123; this.id = id; if(daughters == null) this.daughters = new ArrayList&lt;&gt;(); else &#123; daughters.forEach(daughter -&gt; daughter.setMother(this)); this.daughters = daughters; &#125; if(sons == null) this.sons = new ArrayList&lt;&gt;(); else &#123; sons.forEach(son -&gt; son.setMother(this)); this.sons = sons; &#125; &#125; public void bearDaughters(final List&lt;Daughter&gt; babyDaughters) &#123; babyDaughters.forEach(daughter -&gt; daughter.setMother(this)); daughters.addAll(babyDaughters); &#125; public void bearSons(final List&lt;Son&gt; babySons) &#123; babySons.forEach(son -&gt; son.setMother(this)); sons.addAll(babySons); &#125;&#125; 엄마가 있고, 아들&#x2F;딸들이 있는데 아들&#x2F;딸들을 EAGER로 fetch해 올 때 발생한다.(즉, OneToMany, ManyToMany인 Bag 두 개 이상을 EAGER로 fetch할 때 발생한다.)EAGER로 땡겨오면 N+1 쿼리 문제가 존재하기 때문에 fetchType을 전부 LAZY로 바꾼 후 한 방 쿼리로 불러와도 문제는 재발한다. 1234public interface MotherRepository extends JpaRepository&lt;Mother, Long&gt; &#123; @EntityGraph(attributePaths = &#123;&quot;daughters&quot;, &quot;sons&quot;&#125;) List&lt;Mother&gt; findAllWithChildrenBy();&#125; Bag우선 MultipleBagFetchException 파일을 둘러보자. 1234/** * Exception used to indicate that a query is attempting to simultaneously fetch multiple * &#123;@link org.hibernate.type.BagType bags&#125; */ 여러 BagType을 동시에 fetch 해 올 때 발생하는 예외라고 한다.그럼 Bag이 뭘까…? A generalization of the notion of a set is that of a multiset or bag, which is similar to a set but allows repeated (“equal”) values (duplicates). https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset A Bag is a java collection that stores elements without caring about the sequencing, but allow duplicate elements in the list. A bag is a random grouping of the objects in the list. https://en.wikipedia.org/wiki/Set_(abstract_data_type)#Multiset A is an unordered collection, which can contain duplicated elements. That means if you persist a bag with some order of elements, you cannot expect the same order retains when the collection is retrieved. There is not a “bag” concept in Java collections framework, so we just use a java.util.List corresponds to a . https://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate 즉, Bag(Multiset)은 Set과 같이 순서가 없고, List와 같이 중복을 허용하는 자료구조이다.하지만 자바 컬렉션 프레임워크에서는 Bag이 없기 때문에 하이버네이트에서는 List를 Bag으로써 사용하고 있는 것이다. Troubleshooting우선 두 Bag을 Set으로 바꾸면 우리가 원하는대로 한 방 쿼리로 날아간다. 1234567891011121314151617181920212223242526272829303132333435363738394041@Entity@Getter@NoArgsConstructorpublic class Mother &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL) private Set&lt;Daughter&gt; daughters = new HashSet&lt;&gt;(); @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL) private Set&lt;Son&gt; sons = new HashSet&lt;&gt;(); @Builder public Mother(final Long id, final Set&lt;Daughter&gt; daughters, final Set&lt;Son&gt; sons) &#123; this.id = id; if(daughters == null) this.daughters = new HashSet&lt;&gt;(); else &#123; daughters.forEach(daughter -&gt; daughter.setMother(this)); this.daughters = daughters; &#125; if(sons == null) this.sons = new HashSet&lt;&gt;(); else &#123; sons.forEach(son -&gt; son.setMother(this)); this.sons = sons; &#125; &#125; public void bearDaughters(final Set&lt;Daughter&gt; babyDaughters) &#123; babyDaughters.forEach(daughter -&gt; daughter.setMother(this)); daughters.addAll(babyDaughters); &#125; public void bearSons(final Set&lt;Son&gt; babySons) &#123; babySons.forEach(son -&gt; son.setMother(this)); sons.addAll(babySons); &#125;&#125; 실무에서 급하면 딱 이 수준까지만 하면 끝이고 이제 왜 Multiple Bag을 Fetch해 올 수 없는지 알아보자. 우선 두 Bag 중 하나만 Set으로 바꾼 후 결과를 보자. 1234567891011121314151617181920212223242526272829303132333435363738394041@Entity@Getter@NoArgsConstructorpublic class Mother &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL) private Set&lt;Daughter&gt; daughters = new HashSet&lt;&gt;(); @OneToMany(mappedBy = &quot;mother&quot;, cascade = CascadeType.ALL) private List&lt;Son&gt; sons = new ArrayList&lt;&gt;(); @Builder public Mother(final Long id, final Set&lt;Daughter&gt; daughters, final List&lt;Son&gt; sons) &#123; this.id = id; if(daughters == null) this.daughters = new HashSet&lt;&gt;(); else &#123; daughters.forEach(daughter -&gt; daughter.setMother(this)); this.daughters = daughters; &#125; if(sons == null) this.sons = new ArrayList&lt;&gt;(); else &#123; sons.forEach(son -&gt; son.setMother(this)); this.sons = sons; &#125; &#125; public void bearDaughters(final Set&lt;Daughter&gt; babyDaughters) &#123; babyDaughters.forEach(daughter -&gt; daughter.setMother(this)); daughters.addAll(babyDaughters); &#125; public void bearSons(final List&lt;Son&gt; babySons) &#123; babySons.forEach(son -&gt; son.setMother(this)); sons.addAll(babySons); &#125;&#125; 그리고 MotherRepository#findAllWithChildrenBy() 메서드를 통해 호출하면 아래와 같은 결과를 볼 수 있다.일단 날아간 쿼리는 아래와 같다. (혹시나 join 했을 때 자식들이 없을까봐 엄마라도 불러오려고 기본적으로 outer join을 하고 있다.) 123456789101112131415161718select mother0_.id as id1_1_0_, daughters1_.id as id1_0_1_, sons2_.id as id1_2_2_, daughters1_.mother_id as mother_i2_0_1_, daughters1_.mother_id as mother_i2_0_0__, daughters1_.id as id1_0_0__, sons2_.mother_id as mother_i2_2_2_, sons2_.mother_id as mother_i2_2_1__, sons2_.id as id1_2_1__ from mother mother0_ left outer join daughter daughters1_ on mother0_.id=daughters1_.mother_id left outer join son sons2_ on mother0_.id=sons2_.mother_id Set으로 저장한 딸들은 중복없이 잘 불러와졌고, List(Bag)로 저장한 아들들은 중복있이 잘 불러와졌다.(List라고 무조건 중복이 발생하는 건 아니다. 단일 List(Bag)만 Fetch 해오면 중복없이 잘 불러온다.) 이 결과를 Row로 표시해보자면 다음과 같다. mother.id daughter.id son.id 1 1 1 1 1 2 1 1 3 1 2 1 1 2 2 1 2 3 1 3 1 1 3 2 1 3 3 만약 daughters 마저도 중복도 보장이 안 되고, 순서도 보장이 안 됐다면 어떤 기준을 가지고 Row를 매핑할 수 있을까?(뭐, 물론 이 경우에는 될 수도 있겠지만 좀 더 엔터티의 관계가 복잡한 경우에는 매핑이 불가능하거나 너무 복잡해지는 거 아닐까?)그렇기 때문에 Multiple Bag은 Fetch가 안 되는 게 아닐까 싶다. 실제로 List로 저장한 데이터를 하이버네이트에서는 BagType으로 취급하고 있고, Set으로 저장한 데이터는 SetType으로 취급하고 있다.ListType 클래스도 있긴 한데 언제 어떻게 써야하는지는 잘 모르겠다 ㅠㅠ…","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"}]},{"title":"(삽질기) Spring Data JPA에서 Entity Manager 관련 삽질기","slug":"jpa-entity-manager-with-test","date":"2019-05-01T17:26:48.000Z","updated":"2022-10-30T08:42:16.675Z","comments":true,"path":"2019/05/01/jpa-entity-manager-with-test/","link":"","permalink":"https://perfectacle.github.io/2019/05/01/jpa-entity-manager-with-test/","excerpt":"오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.하지만 내 의도대로 동작하지 않았다.아래 코드를 보자. 12345678910111213141516@RunWith(SpringRunner.class)@DataJpaTestpublic class MotherTest &#123; @Autowired private SomeEntityRepository repository; @Before public void setup() &#123; repository.save(new SomeEntity()); &#125; @Test public void test() &#123; repository.findById(1L); &#125;&#125; 우선 테스트를 돌릴 때마다 DB를 초기화했다. (인메모리 DB인 H2를 사용했다.)따라서 테스트 할 데이터를 setup 메서드를 통해 데이터를 DB에 밀어넣고 있었다.그리고 테스트 케이스에서 해당 엔터티를 불러오는 간단한 코드인데 나는 select 쿼리가 날아갈 줄 알았다.하지만 insert 쿼리만 날아가고, 이거 가지고 코드를 이리저리 바꿔보며 온갖 삽질을 한 것 같다. 왜 select 쿼리가 찍히지 않을까… 한 2시간 가까이를 이거 때문에 계속 삽질하고 있었다.그리고 스프링 관련 커뮤니티에 질문하려고 아마 SomeEntity 엔터티가 생성되면서 ID 값이 어딘가에 저장돼서 동일한...까지 딱 치고 있는데어딘가 저장에 딱 꽂혀서 아! 맞다! 하고 그동안 JPA를 안 쓴 지 오래돼서 까먹었구나… 하고 한참동안 너무 허무했었다.","text":"오랜만에 Spring Data JPA를 가지고 뭔가 뻘뻘 대보고 있었다.하지만 내 의도대로 동작하지 않았다.아래 코드를 보자. 12345678910111213141516@RunWith(SpringRunner.class)@DataJpaTestpublic class MotherTest &#123; @Autowired private SomeEntityRepository repository; @Before public void setup() &#123; repository.save(new SomeEntity()); &#125; @Test public void test() &#123; repository.findById(1L); &#125;&#125; 우선 테스트를 돌릴 때마다 DB를 초기화했다. (인메모리 DB인 H2를 사용했다.)따라서 테스트 할 데이터를 setup 메서드를 통해 데이터를 DB에 밀어넣고 있었다.그리고 테스트 케이스에서 해당 엔터티를 불러오는 간단한 코드인데 나는 select 쿼리가 날아갈 줄 알았다.하지만 insert 쿼리만 날아가고, 이거 가지고 코드를 이리저리 바꿔보며 온갖 삽질을 한 것 같다. 왜 select 쿼리가 찍히지 않을까… 한 2시간 가까이를 이거 때문에 계속 삽질하고 있었다.그리고 스프링 관련 커뮤니티에 질문하려고 아마 SomeEntity 엔터티가 생성되면서 ID 값이 어딘가에 저장돼서 동일한...까지 딱 치고 있는데어딘가 저장에 딱 꽂혀서 아! 맞다! 하고 그동안 JPA를 안 쓴 지 오래돼서 까먹었구나… 하고 한참동안 너무 허무했었다. 답은 JPA의 동작 방식에 있었다.기본적으로 JPA는 select 쿼리를 DB에 날리기 전에 엔터티 매니저를 뒤짐으로써 성능을 향상시킨다.바로 save 메서드 당시에 엔터티 매니저에 해당 엔터티를 저장한 것이다.엔터티 매니저에 없는 다른 ID를 조회하거나 @Id 어노테이션이 붙지 않은 다른 필드를 조건에 줄 경우에는 실제로 select 쿼리가 날아갔다. 그럼 setup 메서드와 test 메서드에서 사용하는 엔터티 매니저가 동일하다는 것을 어떻게 알 수 있을까?기본적으로 엔터티 매니저는 thread safe하지 않아서 thread 별로 한 개의 엔터티 매니저 생성을 권장하는 것으로 알고 있다.따라서 Spring Data JPA에서도 그렇게 하지 않았을까…? 아래 테스트 코드를 통해 내가 생각한 가설이 맞는 거 같다. (멀티 스레드 환경에서 돌려본 건 아니긴 하지만…) 12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@DataJpaTestpublic class MotherTest &#123; @Autowired private SomeEntityRepository repository; @PersistenceContext private EntityManager em; private SomeEntity entity; @Before public void setup() &#123; entity = new SomeEntity(); assertFalse(em.contains(entity)); repository.save(entity); &#125; @Test public void test() &#123; assertEquals(Long.valueOf(1L), entity.getId()); assertTrue(em.contains(entity)); repository.findById(1L); &#125;&#125; 기본에 충실해야겠다 ㅠㅠ…","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"삽질","slug":"Note/삽질","permalink":"https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"}]},{"title":"(Troubleshooting) 생애 첫 Heap 메모리 분석기 (feat. Eclipse MAT)","slug":"heap-memory-analytics-with-eclipse-mat","date":"2019-04-28T23:25:38.000Z","updated":"2022-10-30T08:42:16.639Z","comments":true,"path":"2019/04/28/heap-memory-analytics-with-eclipse-mat/","link":"","permalink":"https://perfectacle.github.io/2019/04/28/heap-memory-analytics-with-eclipse-mat/","excerpt":"어느 날 서비스가 갑자기 다운되는 사례가 발생했다.다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.나의 실수로 인해 WAS 로그는 제대로 남겨져있지 않았고, CTO 님께서 힙 덤프 같은 거라도 떠져있나 보라고 하셔서 지푸라기라도 잪는 심정으로 기대를 했는데 희망을 저버리지 않았다. 12-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=./jvm.hprof 위 옵션으로 인해 OOME(Out of Memory Exception) 발생 시 힙 덤프를 뜨게 해놓았는데 다행히 힙 덤프가 존재했다. 여기서 힙 덤프는 힙 메모리의 내용을 그대로 떠놓은 파일이다.따라서 힙 메모리에 어떤 객체들로 가득 채워져있었는지 분석할 수 있게 되었다.여기서 흥분해서 서버에서 vi 등등을 이용해 힙 덤프 파일을 열면 안 된다. (용량이 큰 로그 및 다른 파일도 물론 서버에서 절대 열면 안 된다.)여는 순간 힙 메모리 사이즈만큼 서버의 메모리를 사용하게 돼서 서버가 다운될 수도 있다.무조건 scp 등등의 명령어를 통해 로컬로 복사한 후에 열어보는 습관을 가지자.","text":"어느 날 서비스가 갑자기 다운되는 사례가 발생했다.다행히 서버를 이중화시켜놓아서 장애가 발생하진 않았지만 그래도 왜 다운된 건지 원인 분석을 해야했다.나의 실수로 인해 WAS 로그는 제대로 남겨져있지 않았고, CTO 님께서 힙 덤프 같은 거라도 떠져있나 보라고 하셔서 지푸라기라도 잪는 심정으로 기대를 했는데 희망을 저버리지 않았다. 12-XX:+HeapDumpOnOutOfMemoryError \\-XX:HeapDumpPath=./jvm.hprof 위 옵션으로 인해 OOME(Out of Memory Exception) 발생 시 힙 덤프를 뜨게 해놓았는데 다행히 힙 덤프가 존재했다. 여기서 힙 덤프는 힙 메모리의 내용을 그대로 떠놓은 파일이다.따라서 힙 메모리에 어떤 객체들로 가득 채워져있었는지 분석할 수 있게 되었다.여기서 흥분해서 서버에서 vi 등등을 이용해 힙 덤프 파일을 열면 안 된다. (용량이 큰 로그 및 다른 파일도 물론 서버에서 절대 열면 안 된다.)여는 순간 힙 메모리 사이즈만큼 서버의 메모리를 사용하게 돼서 서버가 다운될 수도 있다.무조건 scp 등등의 명령어를 통해 로컬로 복사한 후에 열어보는 습관을 가지자. Eclipse Memory Analyzer (MAT)Eclipse Memory Analyzer 소개와 하나의 메모리 누수를 잡기까지에서 힙 덤프를 분석하는데 Eclipse MAT를 사용했다길래 나도 한 번 사용해보았다.다운로드 페이지에서 OS에 맞는 어플리케이션을 받으면 되는데 나는 MacOSX 버전을 다운받았다. 일단 툴의 사용방법도 잘 몰라서 무작정 메세지를 가지고 검색해보았다.우선 최대한 일반적인 메세지만 뽑아서 One instance of &quot;com.mysql.jdbc.JDBC42ResultSet&quot; loaded by를 통해 구글링을 하니MySQL Bugs: #90240: Possible memory leak in JDBC42PreparedStatement란 글이 눈에 띄었다.메모리 릭? 버그? 그럼 우리가 쓰고 있는 MySQL 관련된 무언가에서 버그가 존재한다는 것인가?란 생각이 들었다. Please try with MySQL connector 5.1.45 or 5.1.44 versions and let us know if memory leak happening. 위와 같이 답변이 달린 걸 보고 음… 역시 MySQL 버그인가 보구나… MySQL connector 버전을 올려보자~ 하고 gradle의 디펜던시를 보니 해당 버전보다도 높았다.그래서 뭐지? 하고 답변을 끝까지 쭉 봤더니 It was an application error loading too many rows in memory, nothing to do with the connector. 어플리케이션에서 너무 많은 row를 로딩해서 생긴 문제라고 했다.CTO 님께 말씀드려보니 CTO 님도 보시더니 아마도 저 문제가 맞을 거라고 하셨다.그리고 우리가 저렇게 Row를 많이 불러올만한 쿼리를 쓰는 게 주문 내역 등등을 엑셀로 다운로드 받는 기능에서 날 거라고 말씀해주셨다.따라서 해당 소스코드를 분석해봤는데 카운트 쿼리를 통해 사전에 너무 많은 Row를 불러오는 걸 방지하고 있었다.그럼 어디서 이렇게 많은 Row를 불러오는 쿼리를 사용하지…? 도무지 이해가 가지 않았다.그래서 다른 시니어 개발자 분의 도움을 받아 MAT의 간단한 사용 방법을 익혔다. 분석 및 해결 incoming이면 해당 object를 참조하는 object를, outgoing이면 해당 object가 참조하고 있는 object를 포함해서 보여준다.자세한 설명은 Eclipse MAT — Incoming, Outgoing References를 참고하자. 다른 Row들도 까봤더니 모두 동일한 필드 및 테이블에서 데이터를 가지고 오고 있었다.이를 통해 해당 테이블의 모든 Row를 가져오는 거라고 의심했고 해당 테이블을 실제로 보니 대략 120만 Row의 데이터가 있었다.실제로 소스코드도 보았더니 해당 테이블을 토대로 엑셀을 다운로드 받는 기능이 어딘가에 숨겨져있었고 제대로 조건문이 걸려있지 않았다.또한 Nginx의 Access log를 보니 힙 덤프가 떠지기 바로 직전에 해당 API를 호출한 이력도 있었다. 결국 해당 쿼리문에 조건을 추가해서 배포함으로써 해당 이슈는 일단락 짓게 되었다.어찌보면 별 거 아니고, 내가 로그를 제대로 남겼더라면 힙덤프까지 안 봤을지도 몰랐겠지만내가 로그를 남기지 않는 실수로 인해 힙 덤프를 분석해볼 수 있는 값진 기회가 주어졌다. (절대로 노린 건 아니다.)앞으로 이런 일이 있으면 안 되겠지만, 이런 일을 경험해보지 않고서 더 좋은 개발자로 다가가긴 힘든 것 같다.역시 소프트웨어는 개발도 중요하지만 그 후에 유지보수를 해나가는 경험 또한 매우 중요한 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"},{"name":"Heap","slug":"Heap","permalink":"https://perfectacle.github.io/tags/Heap/"}]},{"title":"(Troubleshooting) Nginx upstream에 AWS ELB DNS를 걸 때 주의사항","slug":"nginx-proxy-aws-elb","date":"2019-04-28T21:53:56.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2019/04/28/nginx-proxy-aws-elb/","link":"","permalink":"https://perfectacle.github.io/2019/04/28/nginx-proxy-aws-elb/","excerpt":"얼마 전에 서버를 새롭게 이전했다.기존에 있던 local의 upstream server 대신에 새로운 서버로 업스트림을 걸어놨다. 1234567http &#123; server &#123; location / &#123; proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com; &#125; &#125;&#125; LB에 바로 도메인을 붙여도 되지만 롤백을 최대한 빨리하기 위해 기존 서버에서 LB로 업스트림 걸어놓았다. 만약 새로운 서버에서 문제가 생겼다고 가정 이 때 LB에 바로 도메인을 달아놓았다면…2-1. 기존의 서버로 다시 도메인 변경2-2. DNS 캐시가 날아갈 때까지 유저에게 장애 발생2-3. 클라이언트의 설정에 따라서 DNS 캐시가 언제 날아갈지 모르는 상황… (과연 일반 유저들이 브라우저의 DNS 캐시 지우는 방법을 알고 있을까?) 이 때 기존 서버는 내비두고 LB로 업스트림을 걸어놓았다면…3-1. 기존 로컬 서버를 업스트림 서버로 변경3-2. nginx -s reload3-3. 수 초 이내로 원래 서버로 원복","text":"얼마 전에 서버를 새롭게 이전했다.기존에 있던 local의 upstream server 대신에 새로운 서버로 업스트림을 걸어놨다. 1234567http &#123; server &#123; location / &#123; proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com; &#125; &#125;&#125; LB에 바로 도메인을 붙여도 되지만 롤백을 최대한 빨리하기 위해 기존 서버에서 LB로 업스트림 걸어놓았다. 만약 새로운 서버에서 문제가 생겼다고 가정 이 때 LB에 바로 도메인을 달아놓았다면…2-1. 기존의 서버로 다시 도메인 변경2-2. DNS 캐시가 날아갈 때까지 유저에게 장애 발생2-3. 클라이언트의 설정에 따라서 DNS 캐시가 언제 날아갈지 모르는 상황… (과연 일반 유저들이 브라우저의 DNS 캐시 지우는 방법을 알고 있을까?) 이 때 기존 서버는 내비두고 LB로 업스트림을 걸어놓았다면…3-1. 기존 로컬 서버를 업스트림 서버로 변경3-2. nginx -s reload3-3. 수 초 이내로 원래 서버로 원복 Trouble하지만 문제는 며칠 후 발생했다.ELB의 DNS로 접속하면 잘 되는데 기존 서버 도메인으로 접속하면(LB를 upstream으로 걸어놓은) 1분 가까운 시간이 흐른 후에 502 Bad Gateway가 나는 것이었다.우선 급한 마음에 nginx -s reload 명령어를 입력했더니 다시 또 정상 동작하는 것이었다.Nginx의 Access Log까지는 정상적으로 남은 걸 보니 LB를 찾지 못해서 일정 시간동안 기다리다가 502를 뱉었던 것 같았다.나는 딱히 설정을 바꾼 것도 없는데… 잘 동작하니 귀신이 곡할 노릇이었다. ELB 동작 방식Best Practices in Evaluating Elastic Load Balancing을 보면 다음과 같은 구문이 나온다. The controller will also monitor the load balancers and manage the capacity that is used to handle the client requests. The Elastic Load Balancing service will update the Domain Name System (DNS) record of the load balancer when it scales so that the new resources have their respective IP addresses registered in DNS. The DNS record that is created includes a Time-to-Live (TTL) setting of 60 seconds, with the expectation that clients will re-lookup the DNS at least every 60 seconds. 컨트롤러는 로드 밸런서를 모니터링하고 클라이언트의 요청을 핸들링하는 capacity를 관리한다. Elastic Load Balancing은 스케일링할 때 로드 밸런서의 DNS 레코드를 업데이트한다. (새로운 리소스의 IP는 DNS에 등록된다.) DNS 레코드의 TTL은 60초로 세팅돼있고, 60초가 지나면 클라이언트는 다시 lookup한다. ELB는 트래픽에 따라서 알아서 스케일링되는 모양이다.또한 TTL은 60초이다.따라서 ELB의 아이피 주소는 매우 유동적이다. (늘어났다가 줄어들었다가… 혹은 LB가 다운되면 새로 생성한다던지…) Nginx 동작 방식Using DNS for Service Discovery with NGINX and NGINX Plus NGINX caches the DNS records until the next restart or configuration reload, ignoring the records’ TTL values. NGINX는 restart나 reload가 발생할 때까지 DNS record를 캐시하고 record의 TTL을 무시한다. 즉, ELB의 TTL인 60초는 무시되고, 설정파일을 읽을 당시에 DNS Lookup이 진행되기 때문에 ELB Scaling이 진행된 후에는 정상 동작하리란 보장을 할 수 없다.설정파일을 읽을 당시에 DNS Lookup을 통해 얻어온 LB의 IP 주소가 트래픽 감소에 의해 더 이상 유효하지 않은 IP 주소가 됐을 가능성이 높기 때문이다. ShootingUsing DNS for Service Discovery with NGINX and NGINX Plus When you use a variable to specify the domain name in the proxy_pass directive, NGINX re‑resolves the domain name when its TTL expires. You must include the resolver directive to explicitly specify the name server (NGINX does not refer to &#x2F;etc&#x2F;resolv.conf). By including the valid parameter to the resolver directive, you can tell NGINX to ignore the TTL and re‑resolve names at a specified frequency instead. proxy_pass directive의 domain name에 변수를 명시할 경우, NGINX는 domain name의 TTL이 만료됐을 때 다시 resolve한다. resolver directive에 name server를 꼭 명시해줘야한다. (NGINX는 &#x2F;etc&#x2F;resolv.conf 파일을 참조하지 않는다.) resolver directive에 valid parameter를 명시하면 TTL을 무시하고 valid parameter의 주기로 다시 resolve한다. 우리가 해야할 일은 이제 다음과 같다. /etc/resolv.conf 파일을 참조하여 resolver directive에 name server를 명시해준다. 12345cat /etc/resolv.conf# ; generated by /usr/sbin/dhclient-script# search ap-northeast-2.compute.internal# options timeout:2 attempts:5# nameserver 10.12.0.2 12345678http &#123; server &#123; resolver 10.12.0.2; location / &#123; proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com; &#125; &#125;&#125; resolver directive에 valid parameter에 ELB DNS의 TTL인 60보다 작은 값을 세팅한다.12345678http &#123; server &#123; resolver 10.12.0.2 valid=30s; location / &#123; proxy_pass http://elb-dns.ap-northeast-2.elb.amazonaws.com; &#125; &#125;&#125; proxy_pass directive의 domain name에 변수를 명시한다.123456789http &#123; server &#123; resolver 10.12.0.2 valid=30s; location / &#123; set $elb-dns elb-dns.ap-northeast-2.elb.amazonaws.com; proxy_pass http://$elb-dns; &#125; &#125;&#125; nginx -s reload를 통해 다운타임 없이 설정파일을 재적용한다. 참고 링크 Best Practices in Evaluating Elastic Load Balancing Amazon EC2 Elastic Load Balancer: Does its IP ever Change? Nginx proxy_pass 의 AWS ELB 연결 문제 Nginx를 ELB Reverse Proxy로 사용할때 주의 점 Some nginx reverse proxy configs stops working once a day","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"},{"name":"ELB","slug":"ELB","permalink":"https://perfectacle.github.io/tags/ELB/"},{"name":"Nginx","slug":"Nginx","permalink":"https://perfectacle.github.io/tags/Nginx/"},{"name":"Proxy","slug":"Proxy","permalink":"https://perfectacle.github.io/tags/Proxy/"}]},{"title":"무중단 배포란...?","slug":"non-stop-deployment","date":"2019-04-21T23:03:23.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2019/04/21/non-stop-deployment/","link":"","permalink":"https://perfectacle.github.io/2019/04/21/non-stop-deployment/","excerpt":"실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자. 80포트(혹은 다른 포트)에 우리의 서버를 띄운다. 새롭게 배포할 내용이 있다고 하면 포트가 충돌나면 안 되기 때문에 서버를 다운시킨다. (옵션) 유저의 이탈을 방지하고자 공사중 이미지를 띄운다. 80포트(혹은 다른 포트)에 새롭게 배포할 서버를 띄운다. 만약 서버가 뜨는데 30초가 걸린다고 하면 최소 30+@초만큼 다운타임(유저에게 서비스가 불가능한 시간)이 발생한다.현대의 어플리케이션이라면 유저에게 최상의 경험을 제공해주기위해 이런 다운타임이 없는 무중단 배포를 지원해야한다. 필요 조건","text":"실제로 우리가 간단하게 서버를 배포하는 시나리오를 생각해보자. 80포트(혹은 다른 포트)에 우리의 서버를 띄운다. 새롭게 배포할 내용이 있다고 하면 포트가 충돌나면 안 되기 때문에 서버를 다운시킨다. (옵션) 유저의 이탈을 방지하고자 공사중 이미지를 띄운다. 80포트(혹은 다른 포트)에 새롭게 배포할 서버를 띄운다. 만약 서버가 뜨는데 30초가 걸린다고 하면 최소 30+@초만큼 다운타임(유저에게 서비스가 불가능한 시간)이 발생한다.현대의 어플리케이션이라면 유저에게 최상의 경험을 제공해주기위해 이런 다운타임이 없는 무중단 배포를 지원해야한다. 필요 조건두 대 이상의 서버(혹은 서버 어플리케이션을 두 개)를 서비스해야한다.다운타임이 발생하지 않으려면 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야한다.비용을 줄이려면 배포할 때만 새롭게 서버를 띄우고 배포가 완료된 후에 기존 서버는 죽이면 된다. Rolling Deployment HA(High Availability)을 위해 프로덕션 환경은 2대 이상의 서버로 구성한다.이런 환경에서 무중단 배포하기 가장 간단한 방법이 바로 Rolling 배포이다.시나리오는 다음과 같다. 서버 1을 로드 밸런서에서 뺀다. 서버 1에 배포한다. 서버 1을 다시 로드 밸런서에 넣는다. 서버 2를 로드 밸런서에서 뺀다. 서버 2에 배포한다. 서버 2를 다시 로드 밸런서에 넣는다. 위와 같이 하면 다운타임 없이 배포가 가능하다.배포해야할 서버가 너무 많다면 1대씩 배포하면 너무 느리니 N대 단위로 배포하기도 한다.하지만 배포가 끝나기 전까지는 누구는 이전 버전을 서비스 받고, 누구는 신규 버전을 서비스 받는 등의 문제가 존재한다.또한 1대에 배포하는 거보다 최소 2배 이상 느리다. (아무리 못해도 2번 이상의 배포가 진행되기 때문에) Canary Deployment 광부들이 광산에서 유독가스가 나오는 것을 알아내기 위해서 가스에 민감한 카나리아(조류)를 광산 안에서 키웠다고 해서 유래된 배포이다.소수의 유저(혹은 사내)만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때 다른 모든 서버에 배포한다.Canary 환경은 뭐 QA Phase가 될 수도 있고, 랜덤하게 유저를 Canary 환경으로 라우팅시킬 수도 있고 구현하기 나름이다. Blue&#x2F;Green Deployment **실제로 서비스 중인 환경(Blue)**과 **새롭게 배포할 환경(Green)**을 세트로 준비해서 배포하는 방식을 말한다.장점으로는 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠르다. (배포할 서버가 N대라 하더라도 N대의 Green 서버에 동시에 배포하면 되기 때문에)또한 언제나 Green 환경이 떠있기 때문에 만약에 잘못된 버전으로 배포를 했을 경우에 신속하게 롤백이 가능하다. (수 백대의 서버에 거의 수 초 이내에 롤백이 가능함.)물론 언제나 Green 환경이 떠있어야하기 때문에 비용이 두 배로 든다는 단점도 있다.또한 Green 환경에서 Scheduler와 같은 배치성 Job이 도는 경우에 레거시 버전으로 돌기 때문에 장애가 발생할 가능성도 존재한다.(이럴 때는 배포를 연속적으로 두 번 해서 Blue와 Green의 버전을 일치시키는 것 이외에는 딱히 떠오르지 않는다 ㅠㅠ…) 이렇게 설명하면 이해가 잘 안 가니 그림과 함께 이해해보자.(그림에서는 Nginx를 프록시 서버로 사용했지만 Apache 등등을 사용해도 무방하다.또한 하나의 서버에 두 대의 어플리케이션을 띄우는 걸로 설명했지만 별도의 서버에 하나의 어플리케이션만 각각 띄워서 구성해도 된다.) Deployment Rollback 더 자세한 설명은 Martin Fowler가 쓴 블로그 글을 참고하자.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"Deployment","slug":"Deployment","permalink":"https://perfectacle.github.io/tags/Deployment/"}]},{"title":"(Docker) Spring Boot Application Image 최적화하기","slug":"spring-boot-docker-image-optimization","date":"2019-04-16T03:19:58.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2019/04/16/spring-boot-docker-image-optimization/","link":"","permalink":"https://perfectacle.github.io/2019/04/16/spring-boot-docker-image-optimization/","excerpt":"들어가기에 앞서이 글에서 Docker와 Spring Boot, Gradle에 대한 기본적인 지식은 있다고 판단하고 설명한다.프로젝트는 spring-boot-docker-demo 저장소에서 단계별로 브랜치를 확인해보면 된다.이해를 돕기 위해 docker image tag 단위로 branch를 땄다. 프로젝트의 build.gradle은 아래와 같다. 123456789101112131415161718192021plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.1.4.RELEASE&#x27; id &#x27;java&#x27;&#125;apply plugin: &#x27;io.spring.dependency-management&#x27;archivesBaseName = &#x27;demo&#x27;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;11&#x27;repositories &#123; jcenter()&#125;dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-webflux&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;io.projectreactor:reactor-test&#x27;&#125;","text":"들어가기에 앞서이 글에서 Docker와 Spring Boot, Gradle에 대한 기본적인 지식은 있다고 판단하고 설명한다.프로젝트는 spring-boot-docker-demo 저장소에서 단계별로 브랜치를 확인해보면 된다.이해를 돕기 위해 docker image tag 단위로 branch를 땄다. 프로젝트의 build.gradle은 아래와 같다. 123456789101112131415161718192021plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.1.4.RELEASE&#x27; id &#x27;java&#x27;&#125;apply plugin: &#x27;io.spring.dependency-management&#x27;archivesBaseName = &#x27;demo&#x27;group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = &#x27;11&#x27;repositories &#123; jcenter()&#125;dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-webflux&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;io.projectreactor:reactor-test&#x27;&#125; 가장 간단한 Spring Boot Docker Image 만들기이 상태에서 gradle wrapper를 이용해 build를 수행해보자. 1./gradlew build 그렇다면 build&#x2F;libs 디렉토리에 demo-0.0.1-SNAPSHOT.jar란 파일이 만들어진다.(build.gradle의 archivesBaseName과 version 값에 의해 위와 같은 이름으로 생성된다.) 이제 실행 가능한 jar 파일이 생성됐으니 Docker 이미지를 만들어서 해당 jar 파일을 실행하게 만들어보기 위해서 Dockerfile을 생성하자. 1234567FROM openjdk:11-jre-slimWORKDIR /rootCOPY build/libs/demo-0.0.1-SNAPSHOT.jar .CMD java -jar demo-0.0.1-SNAPSHOT.jar 이제 이미지를 빌드해보자. 12345# docker build -t $&#123;imageName&#125;:$&#123;tagName&#125; .# 예제에서는 이해를 돕기 위해 임의로 이미지와 태그 이름을 임의로 설정함.# perfectacle은 글쓴이의 docker hub 아이디이므로 본인의 docker hub 아이디를 입력해야 docker hub repository 충돌이 일어나지 않는다.docker build -t perfectacle/spring-boot-demo:basic . 이제 이미지를 통해 컨테이너를 띄워보자. 123456# docker run --rm -d -p $&#123;hostPort&#125;:$&#123;containerPort&#125; --name $&#123;containerName&#125; $&#123;imageName&#125;:$&#123;tagName&#125;# --rm 옵션은 컨테이너를 stop 하면 자동으로 컨테이너를 죽여버린다.# -d 옵션은 백그라운드에서 컨테이너를 실행한다는 옵션이다.# 예제에서는 이해를 돕기 위해 포트나 컨테이너 이름 등등의 값을 임의로 설정함.docker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic 실제로 어플리케이션이 잘 떴는지 확인해보자. 1234# 프로젝트의 com.example.demo.Router 파일에서 GET / 에 대한 라우터, 핸들러를 만들어두었다.curl localhost# ok ok라는 텍스트가 출력이 됐다면 성공적으로 컨테이너가 뜬 것이다.혹시나 curl: (52) Empty reply from server란 오류가 뜬다면 서버가 아직 뜨지 않은 것이니 10초 정도 기다렸다가 다시 시도해보자. 이제 Docker Hub에 우리가 작업한 이미지를 올려보자.(물론 Docker Hub에 Repository가 존재하는 상태로 시작해야한다.) 1234567891011# docker push $&#123;repositoryName&#125;:$&#123;tagName&#125;docker push perfectacle/spring-boot-demo:basic# The push refers to repository [docker.io/perfectacle/spring-boot-demo]# b61d0959344e: Pushing [================&gt; ] 6.096MB/18.22MB# 4bbad98352e9: Mounted from library/openjdk # 9f6ec1d0a99c: Mounted from library/openjdk # 8eb822456baf: Mounted from library/openjdk # 0d59dc1d96ca: Mounted from library/openjdk # 93df8ce6d131: Mounted from library/openjdk # 5dacd731af1b: Mounted from library/openjdk Docker Image는 여러 레이어로 겹겹이 쌓여있다.우리가 Dockerfile에 선언한 FROM openjdk:11-jre-slim 부분에 의해 openjdk:11-jre-slim 이미지의 레이어에서부터 쌓아가는 것이다.4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어를 사용한 것이다.그리고 제일 윗 라인에 b61d0959344e 이 부분이 Dockerfile의 COPY build/libs/demo-0.0.1-SNAPSHOT.jar .에 의해 생긴 레이어이다.바로 저 jar 파일이 하나의 레이어를 차지하고 있는 것이다.그럼 이 레이어란 건 어떻게 쓰이는지는 좀이따 살펴보자. 이제 어플리케이션 코드를 한 번 수정해보자.com.example.demo.Router 파일을 아래와 같이 수정해보자. 12345678910111213141516171819202122package com.example.demo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.reactive.function.BodyInserters;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.RouterFunctions;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;@Configurationpublic class Router &#123; @Bean public RouterFunction&lt;ServerResponse&gt; route() &#123; return RouterFunctions.route(GET(&quot;&quot;), serverRequest -&gt; ServerResponse.ok() .contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(&quot;ok!&quot;))); &#125;&#125; ok에서 ok!로 바꿨을 뿐이다. 이제 다시 소스 코드를 빌드해주자. 1./gradlew build 바뀐 소스 코드를 토대로 도커 이미지를 만들자. 1docker build -t perfectacle/spring-boot-demo:basic-change-app . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 1234# 포트 및 컨테이너 이름 충돌을 방지하고자 전에 띄워놨던 컨테이너를 멈추자.# 이전에 --rm 옵션을 줬기 때문에 stop을 하면 자동으로 컨테이너까지 죽여버린다.docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:basic-change-app 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 123456789docker push perfectacle/spring-boot-demo:basic-change-app# 54f0c4fe51ff: Pushing [=&gt; ] 590.8kB/18.22MB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 레이어의 진가가 여기서 나온다.4bbad98352e9 ~ 5dacd731af1b까지가 openjdk:11-jre-slim 이미지의 레이어이고,perfectacle&#x2F;spring-boot-demo:basic 이미지에서 이미 사용했고 해당 이미지는 이미 Docker Hub에 올려두었다.따라서 해당 레이어를 재활용하는 것이다.이건 push 뿐만 아니라 pull에도 해당하는 내용이다.실제 디스크에서 차지하는 용량도 해당 레이어를 재활용하기 때문에 이미지 push&#x2F;pull 속도 및 용량 측면에서도 매우 효율적이다. Spring Boot Docker Image 최적화하기이렇게 레이어를 잘 구성해서 재활용할 수 있는 부분을 최대한 늘리는 게 이번 포스트에서 진행할 최적화의 한 방법이다.하지만 우리는 레이어를 잘 활용하고 있지 못하고 있다. basic 태그의 이미지를 올릴 때도 b61d0959344e: 18.22MB를 업로드 했고,basic-change-app 태그의 이미지를 올릴 때도 54f0c4fe51ff: 590.8kB/18.22MB를 업로드 했다.우리가 변경한 부분은 매우 작은 것 같은데, 왜 이렇게 많은 용량을 업로드하는 것일까?그건 우리가 jar 파일을 하나의 레이어로 구성했기 때문이다. 우선 jar 파일이 어떻게 구성돼있는지 한 번 까보자. 123456789cd build/libstar -xvf demo-0.0.1-SNAPSHOT.jarls# 우리가 여기서 눈여겨 볼 것은 BOOT-INF 디렉토리이다.# BOOT-INF META-INF demo-0.0.1-SNAPSHOT.jar orgls BOOT-INF# classes에는 우리가 작성한 어플리케이션 소스 코드가 들어있고, lib 디렉토리에는 라이브러리들(*.jar)이 들어있다.# classes lib 즉, 우리는 classes에 있는 파일만 수정했음에도 불구하고 lib에 있는 파일까지 같은 레이어로 묶어서 push하고 있던 것이다.레이어를 재활용하기 위해선 jar 파일을 분해해서 이렇게 어플리케이션 레이어와 라이브러리 레이어를 쪼개야 최대한 레이어를 재활용할 수 있다. 빌드 후에 매번 저렇게 jar 파일을 분해하기 귀찮으니 build task를 손 봐주자.build.gradle에서 아래 내용을 추가해주자. 1234567891011task unpackJar(type: Copy) &#123; def unpackDir = &quot;$buildDir/unpack&quot; delete unpackDir from zipTree(jar.getArchiveFile()) into unpackDir&#125;build &#123; finalizedBy unpackJar&#125; 그리고 Dockerfile에서 어플리케이션 레이어와 라이브러리 레이어를 분리시키자. 12345678910FROM openjdk:11-jre-slimWORKDIR /rootARG buildDir=build/unpackCOPY $&#123;buildDir&#125;/BOOT-INF/classes/ appCOPY $&#123;buildDir&#125;/BOOT-INF/lib/ libCMD java -cp app:lib/* com.example.demo.DemoApplication 이제 바뀐 task로 빌드해보자. 1./gradlew build jar 파일이 build/libs/unpack에 제대로 풀어졌는지 확인해보고 이제 새로운 도커 이미지를 빌드하자. 1docker build -t perfectacle/spring-boot-demo:unpack-jar . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:unpack-jar# aefdad4cf83c: Pushing [=&gt; ] 592.9kB/18.12MB# c132ceeeb517: Pushing [==================================================&gt;] 9.728kB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists aefdad4cf83c는 라이브러리 레이어이고, c132ceeeb517는 어플리케이션 레이어이다. 여기까지 문제가 없긴한데 Dockerfile에서 메인 클래스(com.example.demo.DemoApplication)를 하드코딩하는 게 매우 귀찮다.JarLauncher를 이용해서 하드코딩 하는 부분을 없애보자! (물론 JarLauncher를 쓰면 main class를 하드코딩하는 거 보다 아주 조금 느리게 서버가 뜬다.)Dockerfile을 아래와 같이 수정해주자. 123456789101112FROM openjdk:11-jre-slimWORKDIR /rootARG buildDir=build/unpackCOPY $&#123;buildDir&#125;/BOOT-INF/classes BOOT-INF/classesCOPY $&#123;buildDir&#125;/BOOT-INF/lib BOOT-INF/libCOPY $&#123;buildDir&#125;/META-INF META-INFCOPY $&#123;buildDir&#125;/org orgCMD java org.springframework.boot.loader.JarLauncher 덕지덕지 클래스패스 붙던 게 사라지고, 메인 클래스 하드코딩하던 부분도 사라졌다. 이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자. 1docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 123456789101112docker push perfectacle/spring-boot-demo:unpack-jar-launcher# 55e024f80fff: Pushing [==================================================&gt;] 221.7kB# fb71d1d0e2a1: Pushing [==================================================&gt;] 3.072kB# 182065791613: Pushing [=&gt; ] 593.4kB/18.12MB# b0d121a9a0fe: Pushing [==================================================&gt;] 9.728kB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 위 Dockerfile에도 단점이 존재한다.바로 레이어가 4개나 존재한다는 것이다.우리는 어플리케이션 레이어&#x2F;라이브러리 레이어로만 구분하려고 했는데 메인 클래스 하드코딩, 클래스패스 두 가지 문제점 때문에 또 다른 문제점을 만들어냈다.이제 레이어를 다시 두 개로 줄여보자. 먼저 Copy의 횟수를 줄여야 레이어를 줄일 수 있으니 Copy하기 좋게 BOOT-INF&#x2F;lib 폴더만 다른 곳으로 빼야한다.그러기 위해서는 build task와 관련된 task들을 아래와 같이 수정해야한다. 1234567891011121314151617181920task moveLib &#123; doLast &#123; def unpackDir = &quot;$buildDir/unpack&quot; ant.move(file: &quot;$&#123;unpackDir&#125;/app/BOOT-INF/lib&quot;, toFile: &quot;$&#123;unpackDir&#125;/lib&quot;) &#125;&#125;task unpackJar(type: Copy) &#123; def unpackDir = &quot;$buildDir/unpack&quot; delete unpackDir from zipTree(jar.getArchiveFile()) into &quot;$unpackDir/app&quot; finalizedBy moveLib&#125;build &#123; finalizedBy unpackJar&#125; 그리고 Dockerfile을 아래와 같이 수정해서 레이어를 두 개(어플리케이션, 라이브러리)로 만들자. 12345678910FROM openjdk:11-jre-slimWORKDIR /rootARG buildDir=build/unpackCOPY $&#123;buildDir&#125;/app .COPY $&#123;buildDir&#125;/lib BOOT-INF/libCMD java org.springframework.boot.loader.JarLauncher 이제 바뀐 task로 빌드해보자. 1./gradlew build lib 폴더가 build/libs/unpack/app/BOOT-INF에 없고 build/libs/unpack/에 있는지 확인해보고이제 새로운 도커 이미지를 빌드하자. 1docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer# aeafcfee4d7d: Pushing [=&gt; ] 593.4kB/18.12MB# f69cb2892736: Pushing [==================================================&gt;] 231.4kB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 다시 레이어가 두 개로 줄어들었다. 그럼 이제 어플레이션 코드만 수정하고 과연 라이브러리 레이어는 재활용하는지 살펴보자.com.example.demo.Router 파일을 아래와 같이 수정해보자. 12345678910111213141516171819202122package com.example.demo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.reactive.function.BodyInserters;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.RouterFunctions;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;@Configurationpublic class Router &#123; @Bean public RouterFunction&lt;ServerResponse&gt; route() &#123; return RouterFunctions.route(GET(&quot;&quot;), serverRequest -&gt; ServerResponse.ok() .contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(&quot;ok!&quot;))); &#125;&#125; ok!에서 ok!!로 바꿨을 뿐이다. 소스코드가 바뀌었으니 다시 빌드하자. 1./gradlew build 새로운 도커 이미지로 빌드하자. 1docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok!! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-app# e5ff3f17bd79: Pushing [==&gt; ] 790kB/18.12MB# 6f4d8004dddf: Pushing [==================================================&gt;] 231.4kB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 엥? 어플리케이션 소스코드만 바꿨는데 왜 라이브러리 레이어는 재활용하지 못하는 거지?그럼 혹시 라이브러리를 추가했을 때 어플리케이션 레이어는 재활용할까? build.gradle에 modelmapper를 디펜던시로 추가해보자. 123456dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-webflux&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;io.projectreactor:reactor-test&#x27; implementation &#x27;org.modelmapper:modelmapper:2.3.3&#x27;&#125; 디펜던시를 추가했으니 다시 빌드하자. 1./gradlew build 새로운 도커 이미지로 빌드하자. 1docker build -t perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok!! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:unpack-jar-launcher-decrease-layer-change-lib# 1902203c1efa: Pushing [==&gt; ] 921.1kB/21.94MB# 6f4d8004dddf: Layer already exists# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 어플리케이션 레이어는 재활용이 잘 되고 변경된 라이브러리 레이어만 push 하는 걸 볼 수 있다. 근데 통상적으로 라이브러리 레이어보다 어플리케이션 레이어의 변경이 잦고,라이브러리 레이어의 용량이 더 커서 라이브러리 레이어를 재활용하는 게 훨씬 효율적이다. 혹시 Dockerfile에 선언한 레이어의 순서에 뭔가 연관이 있지 않을까 싶어 Dockerfile을 아래와 같이 수정해보았다. 12345678910FROM openjdk:11-jre-slimWORKDIR /rootARG buildDir=build/unpackCOPY $&#123;buildDir&#125;/lib BOOT-INF/libCOPY $&#123;buildDir&#125;/app .CMD java org.springframework.boot.loader.JarLauncher COPY 구문의 순서만 뒤바꾼 것이다. (lib 먼저, 그 다음에 app 레이어를 쌓게 끔) 이미 빌드는 했고, 소스코드에 변경된 건 없으므로 새로운 도커 이미지를 빌드하자. 1docker build -t perfectacle/spring-boot-demo:change-layer-order . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok!! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:change-layer-order# 43e70d9a1e7a: Pushing [==================================================&gt;] 231.4kB# 44d3b0d75158: Pushing [========&gt; ] 3.919MB/21.94MB# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 레이어 순서를 바꾼 후 첫 Push이기 때문에 어플리케이션&#x2F;라이브러리 레이어 모두 push 하고 있다. 이제 어플리케이션 코드를 바꿔보자.com.example.demo.Router 파일을 아래와 같이 수정해보자. 12345678910111213141516171819202122package com.example.demo;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.reactive.function.BodyInserters;import org.springframework.web.reactive.function.server.RouterFunction;import org.springframework.web.reactive.function.server.RouterFunctions;import org.springframework.web.reactive.function.server.ServerResponse;import static org.springframework.web.reactive.function.server.RequestPredicates.GET;@Configurationpublic class Router &#123; @Bean public RouterFunction&lt;ServerResponse&gt; route() &#123; return RouterFunctions.route(GET(&quot;&quot;), serverRequest -&gt; ServerResponse.ok() .contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(&quot;ok!!!!&quot;))); &#125;&#125; ok!!에서 ok!!!!로 바꿨을 뿐이다. 소스코드가 바뀌었으니 다시 빌드하자. 1./gradlew build 새로운 도커 이미지로 빌드하자. 1docker build -t perfectacle/spring-boot-demo:change-layer-order-and-app . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-app 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok!!!! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 12345678910docker push perfectacle/spring-boot-demo:change-layer-order-and-app# 13f989ce91ed: Pushing [==================================================&gt;] 231.4kB# 44d3b0d75158: Layer already exists# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 우리가 바라던대로 용량이 큰 라이브러리 레이어는 재활용하고 있고, 용량이 작은 어플리케이션 레이어는 변경했기 때문에 push하고 있다. 그럼 혹시 라이브러리 레이어를 수정했을 때 어플리케이션 레이어는 재활용할지 한 번 실험을 해보자.build.gradle에 modelmapper의 버전을 바꿔보. 123456dependencies &#123; implementation &#x27;org.springframework.boot:spring-boot-starter-webflux&#x27; testImplementation &#x27;org.springframework.boot:spring-boot-starter-test&#x27; testImplementation &#x27;io.projectreactor:reactor-test&#x27; implementation &#x27;org.modelmapper:modelmapper:2.3.2&#x27;&#125; 디펜던시를 변경했으니 다시 빌드하자. 1./gradlew build 새로운 도커 이미지로 빌드하자. 1docker build -t perfectacle/spring-boot-demo:change-layer-order-and-lib . 이제 새롭게 빌드한 이미지를 통해 컨테이너를 띄워보자. 12docker stop demodocker run --rm -d -p 80:8080 --name demo perfectacle/spring-boot-demo:change-layer-order-and-lib 실제로 어플리케이션이 잘 떴는지 확인해보자. 123curl localhost# ok!!!! 이제 Docker Hub에 좀 전에 새로 생성한 이미지를 올려보자. 1234567891011docker push perfectacle/spring-boot-demo:change-layer-order-and-lib# 7a3da3f26c6b: Pushing [==================================================&gt;] 231.4kB# c67d124680cf: Pushing [&gt; ] 265.7kB/25.75MB# 6f4d8004dddf: Layer already exists# 4bbad98352e9: Layer already exists # 9f6ec1d0a99c: Layer already exists # 8eb822456baf: Layer already exists # 0d59dc1d96ca: Layer already exists # 93df8ce6d131: Layer already exists # 5dacd731af1b: Layer already exists 아쉽지만 라이브러리 레이어만 바꿨다고 해서 어플리케이션 레이어를 재활용 할 순 없다.그래도 어플리케이션 레이어는 대부분 라이브러리 레이어 보다 용량이 적고,라이브러리 레이어가 변경이 되는 거보다 어플리케이션 레이어가 변경될 확률이 훨씬 높다.따라서 어플리케이션 레이어를 재활용하는 것보다 라이브러리 레이어를 재활용하는 것이 훨씬 낫다. 레이어 순서에 따라서 재활용할 수 있는 레이어가 달라진다우리의 Dockerfile을 보면 아래와 같다. 12COPY $&#123;buildDir&#125;/lib BOOT-INF/libCOPY $&#123;buildDir&#125;/app . 어플리케이션 레이어ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ라이브러리 레이어 위와 같이 라이브러리 레이어 위에 어플리케이션 레이어를 쌓고 있다.이 상황에서 어플리케이션 레이어만 수정하면 아래 있는 라이브러리 레이어를 재활용 할 수 있다.하지만 라이브러리 레이어를 바꾼다면 라이브러리 레이어를 쌓고 그 위에 다시 어플리케이션 레이어를 쌓아야한다.따라서 어플리케이션 레이어를 재활용하지 못하는 것이다.도커 이미지는 마치 스택 자료구조 안에 레이어들을 쌓아간다고 생각하면 좀 더 이해하기 쉬운 것 같다. 참조 링크 TOPICAL GUIDE Spring Boot Docker Optimizing Docker Images for Spring Boot","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Docker","slug":"Docker","permalink":"https://perfectacle.github.io/tags/Docker/"}]},{"title":"어떻게 웹플럭스는 적은 쓰레드만으로 많은 요청을 처리할 수 있을까?","slug":"how-can-webflux-process-huge-requests-with-fewer-threads","date":"2019-03-10T19:24:38.000Z","updated":"2022-10-30T08:42:16.655Z","comments":true,"path":"2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/","link":"","permalink":"https://perfectacle.github.io/2019/03/10/how-can-webflux-process-huge-requests-with-fewer-threads/","excerpt":"기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,Jetty의 경우에는 기본적으로 minimum 8개에서 maximum 200개로 설정돼있다.쓰레드 생성 비용은 비싸므로(오래 걸리므로) 미리 생성해서 ThreadPool에 쌓아놓는 것이다.여기서 말하는 Thread는 Green Thread vs Native Thread에서 얘기하다 싶이 Native Thread(OS에서 관리하는 Thread)이다.이 말은 동시에 요청을 최대 200개까지 처리 가능하단 얘기이다. 그에 반해 Webflux는 core * 2의 Thread만을 생성한다.SpringMVC에 비해 턱없이 모자란 쓰레드 갯수이고 그럼 싱글 코어의 경우에는 동시에 2개의 요청밖에 처리하지 못할 것처럼 보인다. SpringMVC는 어떻게 동작하는가? 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다. 그러다 I&#x2F;O(File I&#x2F;O, Network I&#x2F;O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.) 이 때 다른 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다. 이런 식으로 쓰레드를 돌아가면서 요청을 처리하고 block이 풀리면 작업을 이어나간다.","text":"기본적으로 SpringMVC에서 많이 사용하는 WAS인 Tomcat의 경우에는 기본적으로 쓰레드 풀의 갯수가 200개이고,Jetty의 경우에는 기본적으로 minimum 8개에서 maximum 200개로 설정돼있다.쓰레드 생성 비용은 비싸므로(오래 걸리므로) 미리 생성해서 ThreadPool에 쌓아놓는 것이다.여기서 말하는 Thread는 Green Thread vs Native Thread에서 얘기하다 싶이 Native Thread(OS에서 관리하는 Thread)이다.이 말은 동시에 요청을 최대 200개까지 처리 가능하단 얘기이다. 그에 반해 Webflux는 core * 2의 Thread만을 생성한다.SpringMVC에 비해 턱없이 모자란 쓰레드 갯수이고 그럼 싱글 코어의 경우에는 동시에 2개의 요청밖에 처리하지 못할 것처럼 보인다. SpringMVC는 어떻게 동작하는가? 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다. 그러다 I&#x2F;O(File I&#x2F;O, Network I&#x2F;O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.) 이 때 다른 요청이 들어오면 ThreadPool에서 Thread를 하나 사용한다. 이런 식으로 쓰레드를 돌아가면서 요청을 처리하고 block이 풀리면 작업을 이어나간다. Webflux는 어떻게 동작하는가?Webflux는 기본적으로 아래의 쓰레드로 이루어진다. 요청을 받는 쓰레드 (이하 A 쓰레드라 칭함) block 상태에서 풀린 쓰레드의 요청을 처리하는 쓰레드 (이하 B 쓰레드라 칭함) block 상태가 풀렸는지 무한 루프 돌면서 감시하는 event loop를 위한 쓰레드 (몇 개의 쓰레드가 쓰이는지는 케바케, 이하 C 쓰레드라 칭함.) 통상적으로 event loop를 위한 쓰레드의 갯수는 정확하지 않으므로 Webflux에서는 core * 2개의 쓰레드를 사용한다고 한다.그럼 어떻게 그 적은 쓰레드(리소스, 비용)로 수많은 요청을 동시에 처리할 수 있는 걸까? 요청이 들어오면 A 쓰레드에서 요청을 처리한다. 그러다 I&#x2F;O(File I&#x2F;O, Network I&#x2F;O 등등)가 발생하면 CPU를 block 시킨다. (idle 상태에 빠진다.) 이런 비동기 작업을 처리하기 위해 Queue에 넣는다. A 쓰레드는 계속해서 요청을 받아서 처리한다. 동시에 C 쓰레드에서 Queue를 무한 루프 돌면서 감시를 한다. Event Loop에서 감시를 하다가 작업이 끝난 이벤트가 있으면 B 쓰레드에서 해당 이벤트를 처리한다. 이런 일련의 흐름으로 인해 CPU가 놀 틈 없이 열심히 돌릴 수 있다. Webflux는 왜 CPU Core * 2개의 쓰레드를 사용할까?단순히 쓰레드 생성 비용이 비싸니까 쓰레드를 적게 쓰는 Webflux가 성능 상 뛰어나다고 생각하면 안 된다.조금만 더 인심 쓰지… 왜 2개만으로도 충분하다고 생각하는 걸까? 하나 더 생성하면 조금 더 좋아지는 것 아닐까?? 쓰레드가 많다는 건 뭔가?결국 쓰레드 사이에서 공유 자원의 동기화 이슈가 걸려있다.쓰레드가 많으면 많을 수록 동기화 이슈로 인해 시간이 오래 걸리게 된다.따라서 Thread가 적으면 적을 수록 동기화 이슈로 인한 문제에 덜 시달리게 된다. 또한 CPU는 한 번에 하나의 작업 밖에 수행하지 못한다.따라서 CPU Core 갯수보다 더 많은 쓰레드를 생성하는 건 무의미하게 동기화 이슈를 늘리는 것에 불과하다.하지만 Webflux에서 Core * 2개의 갯수를 만든 이유는 무엇일까?아는 사람이 있다면 댓글로 남겨주길 바란다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Spring","slug":"Programming/Spring","permalink":"https://perfectacle.github.io/categories/Programming/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Srping","slug":"Srping","permalink":"https://perfectacle.github.io/tags/Srping/"},{"name":"Webflux","slug":"Webflux","permalink":"https://perfectacle.github.io/tags/Webflux/"},{"name":"Reactive","slug":"Reactive","permalink":"https://perfectacle.github.io/tags/Reactive/"}]},{"title":"Green Thread vs Native Thread","slug":"green-thread-vs-native-thread","date":"2019-03-10T18:24:06.000Z","updated":"2022-10-30T08:42:16.639Z","comments":true,"path":"2019/03/10/green-thread-vs-native-thread/","link":"","permalink":"https://perfectacle.github.io/2019/03/10/green-thread-vs-native-thread/","excerpt":"Green ThreadGreen Thread는 우리가 알고 있는 쓰레드를 흉내낸 짝퉁 쓰레드이다.Green Thread는 VM(Virtual Machine)이나 Library 등등에서 관리되며 개발자가 통제할 수도 있어서 user-level 쓰레드라고도 불린다.하지만 Green Thread는 Many to One(Many는 쓰레드, One은 CPU) 모델로 설계된 쓰레드이다.따라서 CPU Core가 하나인 환경일 때 설계된 쓰레드이다보니 아무리 Green Thread가 많아도 Native Thread는 단 한 개 뿐이 만들어지지 않는다.Native Thread가 하나라는 건 CPU를 하나 밖에 사용하지 못한다는 뜻이다.따라서 CPU가 여러 개인 멀티 코어 환경에서는 그 장점을 전혀 살리지 못한다. 싱글 코어 환경에서는 동시에 여러 작업을 잘 수행하던 Green Thread는 그럼 단점만이 존재하는 걸까?아니다.싱글 코어 환경에서 네이티브 쓰레드를 10개 사용할 때와 그린 쓰레드를 10개 사용할 때를 비교해보자.네이티브 쓰레드를 10개 사용하면 네이티브 쓰레드가 10개 생성된다.그린 쓰레드를 10개 사용하면 네이티브 쓰레드는 한 개만 생성된다.CPU 입장에서는 10개의 네이티브 쓰레드를 사용하는 것보다 한 개의 네이티브 쓰레드만 사용하는 그린 쓰레드 쪽이 성능 이슈가 훨씬 잘 나온다.이유는 멀티 쓰레드 환경에서는 공유 자원의 동기화 문제가 매우 중요하다.동기화가 제대로 이루어지지 않는다면 프로그램은 치명적 오류를 유발한다.하지만 그린 쓰레드 환경에서는 네이티브 쓰레드가 1개 뿐이니 동기화할 공유 자원이 없게 된다. 따라서 그린 쓰레드가 싱글 쓰레드 환경에서는 더 좋은 성능을 발휘하게 된다.하지만 자바 환경에서는 멀티 코어 환경에서 그 강점을 발휘하지 못하기 때문에 자바 3부터 Native Thread로 전부 바뀌었다.","text":"Green ThreadGreen Thread는 우리가 알고 있는 쓰레드를 흉내낸 짝퉁 쓰레드이다.Green Thread는 VM(Virtual Machine)이나 Library 등등에서 관리되며 개발자가 통제할 수도 있어서 user-level 쓰레드라고도 불린다.하지만 Green Thread는 Many to One(Many는 쓰레드, One은 CPU) 모델로 설계된 쓰레드이다.따라서 CPU Core가 하나인 환경일 때 설계된 쓰레드이다보니 아무리 Green Thread가 많아도 Native Thread는 단 한 개 뿐이 만들어지지 않는다.Native Thread가 하나라는 건 CPU를 하나 밖에 사용하지 못한다는 뜻이다.따라서 CPU가 여러 개인 멀티 코어 환경에서는 그 장점을 전혀 살리지 못한다. 싱글 코어 환경에서는 동시에 여러 작업을 잘 수행하던 Green Thread는 그럼 단점만이 존재하는 걸까?아니다.싱글 코어 환경에서 네이티브 쓰레드를 10개 사용할 때와 그린 쓰레드를 10개 사용할 때를 비교해보자.네이티브 쓰레드를 10개 사용하면 네이티브 쓰레드가 10개 생성된다.그린 쓰레드를 10개 사용하면 네이티브 쓰레드는 한 개만 생성된다.CPU 입장에서는 10개의 네이티브 쓰레드를 사용하는 것보다 한 개의 네이티브 쓰레드만 사용하는 그린 쓰레드 쪽이 성능 이슈가 훨씬 잘 나온다.이유는 멀티 쓰레드 환경에서는 공유 자원의 동기화 문제가 매우 중요하다.동기화가 제대로 이루어지지 않는다면 프로그램은 치명적 오류를 유발한다.하지만 그린 쓰레드 환경에서는 네이티브 쓰레드가 1개 뿐이니 동기화할 공유 자원이 없게 된다. 따라서 그린 쓰레드가 싱글 쓰레드 환경에서는 더 좋은 성능을 발휘하게 된다.하지만 자바 환경에서는 멀티 코어 환경에서 그 강점을 발휘하지 못하기 때문에 자바 3부터 Native Thread로 전부 바뀌었다. Node.js에서는 Event Loop를 구현하기 위해 사용하고 있는libuv에서 Green Thread를 사용하고 있지 않을까… 추측을 해본다. Native Thread우리가 진짜로 알고 있는 쓰레드 개념이다.Green Thread와 달리 OS 단에서 쓰레드를 관리한다.Native Thread Model은 non-green(kernel-level) thread라고도 불리며 Many to Many(Thread도 Many, CPU도 Many)로 설계됐다.따라서 멀티 코어 환경에서 강점을 발휘한다.하지만 위에 말했던 것과 같이 쓰레드가 여러 개 있다는 것은 각 쓰레드 사이에 공유 자원에 대해 동기화 이슈를 가지게 된다는 소리이다.이는 네이티브 쓰레드를 1개만 가지는 Green Thread에 비해 훨씬 복잡한 동기화 문제를 가지고 있음을 뜻하며 그에 따라 성능도 좋지 못하단 소리다. 자바 1.3부터는 Green Thread 대신에 Native Thread를 사용하고 있다. 참조 링크 Green threads Wikipedia Green Threads vs Non Green Threads Why not Green Threads? Green vs Native Threads and Deprecated Methods in Java","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://perfectacle.github.io/tags/Thread/"}]},{"title":"(Java) synchronized 키워드가 가지는 의미","slug":"java-synchronized-note","date":"2019-03-10T17:45:29.000Z","updated":"2022-10-30T08:42:16.663Z","comments":true,"path":"2019/03/10/java-synchronized-note/","link":"","permalink":"https://perfectacle.github.io/2019/03/10/java-synchronized-note/","excerpt":"synchronized 키워드를 사용하는 이유를 살펴보기 전에 쓰레드를 왜 여러 개 사용하는지부터 알아보자. 쓰레드를 여러 개(멀티 쓰레딩) 사용하는 이유 CPU가 I&#x2F;O(파일, 네트워크 등등) 작업에 의해 Blocking 돼서 놀고 있을 때만약 DB를 호출하는 작업(네트워크 I&#x2F;O)이 있다고 치자.I&#x2F;O가 발생하면 기본적으로 CPU는 Block된다. (idle 상태에 빠져 놀고 있다.)이렇게 CPU가 놀고 있을 때 다른 쓰레드가 CPU를 점유한다면 CPU는 더 이상 놀지 않게 된다.이렇게 CPU의 병목을 줄이다보면 성능을 개선할 수 있다. 시분할 다중화를 통해 동시에 여러 작업이 처리되게 끔 보이게 할 때문서 작성을 하면서 동시에 웹 브라우저에서 파일을 다운로드 받을 수 있는 행위는 바로 CPU에서 쓰레드를 돌아가며 작업을 처리하기 때문이다.만약 파일 다운로드가 다 끝나야지만 문서 작성을 할 수 있다고 하면 얼마나 불편하겠는가?물론 그렇다고 해서 진짜 동시에 여러 작업이 수행되는 게 아니라 사람이 체감 못할 정도로 시간을 쪼개서 작업을 수행하는 것이다. 멀티 쓰레드 프로그래밍을 할 때 생기는 문제","text":"synchronized 키워드를 사용하는 이유를 살펴보기 전에 쓰레드를 왜 여러 개 사용하는지부터 알아보자. 쓰레드를 여러 개(멀티 쓰레딩) 사용하는 이유 CPU가 I&#x2F;O(파일, 네트워크 등등) 작업에 의해 Blocking 돼서 놀고 있을 때만약 DB를 호출하는 작업(네트워크 I&#x2F;O)이 있다고 치자.I&#x2F;O가 발생하면 기본적으로 CPU는 Block된다. (idle 상태에 빠져 놀고 있다.)이렇게 CPU가 놀고 있을 때 다른 쓰레드가 CPU를 점유한다면 CPU는 더 이상 놀지 않게 된다.이렇게 CPU의 병목을 줄이다보면 성능을 개선할 수 있다. 시분할 다중화를 통해 동시에 여러 작업이 처리되게 끔 보이게 할 때문서 작성을 하면서 동시에 웹 브라우저에서 파일을 다운로드 받을 수 있는 행위는 바로 CPU에서 쓰레드를 돌아가며 작업을 처리하기 때문이다.만약 파일 다운로드가 다 끝나야지만 문서 작성을 할 수 있다고 하면 얼마나 불편하겠는가?물론 그렇다고 해서 진짜 동시에 여러 작업이 수행되는 게 아니라 사람이 체감 못할 정도로 시간을 쪼개서 작업을 수행하는 것이다. 멀티 쓰레드 프로그래밍을 할 때 생기는 문제쓰레드는 프로세스 내부에 존재하기 때문에 프로세스 내부의 자원을 공유한다.따라서 공유 자원에 대해서 동기화 이슈가 매우 중요하다.A 쓰레드의 작업이 완전히 끝나기 전에 A’라는 자원이다른 쓰레드에 의해 값이 바뀌게 되면 A 쓰레드는 원하는 값을 얻어낼 수 없다. synchronized 키워드위와 같은 문제를 해결하기 위해서는 synchronized 키워드를 사용하여 **A 쓰레드의 작업이 끝날 때까지 대기해라!**라고 명령을 내릴 수 있다.더 나아가 **synchronized 블럭 내에 있는 공유 자원을 점유하라!**라고 이해를 하는 게 좀 더 정확하다.하지만 여기서 멈추면 안 된다, 좀 더 자세하게 이해해야한다. 쓰레드 로컬 변수CPU에서 명령을 수행하기 위해서는 메모리에 있는 데이터를 CPU로 가져와야한다.하지만 메모리에 있는 데이터를 CPU로 가져오는 행위는 매우 느리므로 CPU는 캐시 메모리가 있다. (L1 캐시, L2 캐시 등등)그리고 이 캐시 메모리를 쓰레드 로컬 변수라고 부른다.하지만 쓰레드 로컬 변수이기 때문에 다른 쓰레드에서는 메모리에 접근을 해도 해당 쓰레드 변수의 값을 얻어올 수 없다.따라서 공유 자원 A’에 대해 각각 쓰레드가 로컬 변수를 가질 수 있게 된다. 여기서 synchronized 키워드가 가지는 진정한 의미가 나온다.synchronized 키워드를 사용한다는 것은 해당 블럭 내에 있는공유 자원 A’가 쓰레드 로컬 변수에서 램으로 써지기 까지 다른 쓰레드는 대기(block)하라라는 의미를 가진다.쓰레드 로컬 변수가 램에 써진 순간 다른 쓰레드가 램에서 해당 값을 가져와서 작업할 수 있게 된다.즉 DB에서 커밋이 되기 전까지 해당 레코드를 조회하는 다른 커넥션은 lock에 빠지는 것과 비슷한 뉘앙스라고 받아들이면 된다. synchronized 키워드를 남발하게 되면 쓰레드 로컬 변수가 램에 써지기 전까지 다른 쓰레드는 block이 되므로 조심해서 사용해야한다.또한 잘못 쓴다면 무한한 block을 유발하는 dead lock 이슈도 조심해야할 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"}]},{"title":"(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, Comparable을 구현할지 고려하라","slug":"effective-java-ch03-item14-comparable-interface","date":"2018-12-21T11:00:45.000Z","updated":"2022-10-30T08:42:16.399Z","comments":true,"path":"2018/12/21/effective-java-ch03-item14-comparable-interface/","link":"","permalink":"https://perfectacle.github.io/2018/12/21/effective-java-ch03-item14-comparable-interface/","excerpt":"이번 아이템은 모든 객체의 부모 클래스인 Object 클래스에 있는 메서드가 아니다.아예 동떨어진 믹스인 인터페이스인 Comparable와 해당 인터페이스의 유일한 메서드인 compareTo에 대한 내용이다.그럼에도 불구하고 이번 챕터인 ‘모든 객체의 공통 메서드’에 넣은 이유는 모든 객체에 유용하게 쓰일 수 있는 메서드이고자바 플랫폼 라이브러리의 모든 값 클래스와 Enum에서 해당 인터페이스를 구현했기 때문이 아닐까 싶다.또한 compareTo 메서드를 쓰는 자바 API들(Arrays, Collections, TreeSet, TreeMap 등등)이 있기 때문에compareTo 메서드를 잘만 쓰면 좁살만한 노력으로 코끼리만 한 큰 효과를 누린다고 책에서 얘기하고 있으니 이 장을 주의 깊게 봐야한다. ComparableComparable은 믹스인 인터페이스이다.그럼 이 믹스인 인터페이스가 제공하는 선택적 기능은 무엇일까?바로 인스턴스 사이에 순서를 비교해주는 기능을 제공해준다. 규약","text":"이번 아이템은 모든 객체의 부모 클래스인 Object 클래스에 있는 메서드가 아니다.아예 동떨어진 믹스인 인터페이스인 Comparable와 해당 인터페이스의 유일한 메서드인 compareTo에 대한 내용이다.그럼에도 불구하고 이번 챕터인 ‘모든 객체의 공통 메서드’에 넣은 이유는 모든 객체에 유용하게 쓰일 수 있는 메서드이고자바 플랫폼 라이브러리의 모든 값 클래스와 Enum에서 해당 인터페이스를 구현했기 때문이 아닐까 싶다.또한 compareTo 메서드를 쓰는 자바 API들(Arrays, Collections, TreeSet, TreeMap 등등)이 있기 때문에compareTo 메서드를 잘만 쓰면 좁살만한 노력으로 코끼리만 한 큰 효과를 누린다고 책에서 얘기하고 있으니 이 장을 주의 깊게 봐야한다. ComparableComparable은 믹스인 인터페이스이다.그럼 이 믹스인 인터페이스가 제공하는 선택적 기능은 무엇일까?바로 인스턴스 사이에 순서를 비교해주는 기능을 제공해준다. 규약compareTo 메서드 명세서에 더 자세한 내용이 나와있으니 참고해보면 된다. 아래에서 나오는 sgn(표현식) 표기는 수학에서 말하는 부호 함수(signum function)을 뜻하고, 표현식의 값이 음수이면 -1, 0이면 0, 양수이면 1을 반환한다. 객체가 주어진 객체보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환한다. 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다. Comparable을 구현한 클래스는 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))여야한다.(따라서 x.compareTo(y)는 y.compareTo(x)가 예외를 던질 때에 한해 예외를 던져야한다.)이는 대칭성을 가져야한다는 의미이다. Comparable을 구현한 클래스는 x.compareTo(y) &gt; 0이고, y.compareTo(z) &gt; 0일 때 x.compareTo(z) &gt; 0이어야한다.이는 추이성을 가져야한다는 의미이다. Comparable을 구현한 클래스는 x.compareTo(y) == 0일 때 sgn(x.compareTo(z)) == sgn(y.compareTo(z))이다. 필수는 아니지만 권장하는 규약이다, 이 규약을 명시하지 않을 때는 주석으로라도 그 사실을 명시를 해둬야한다.Comparable을 구현한 클래스는 (x.compareTo(y) == 0) == (x.equals(y))이다.두 객체의 순서가 동일하다면 equals 메서드로 논리적 동치성을 비교했을 때도 동일해야한다는 얘기이다. 다른 건 다 이해가 잘 되는데 마지막 규약은 왜 필수가 아닌지 이해가 되지 않을 것이다.동작은 잘 하지만 어딘가 이상한 부분이 있어서 지키라고 하는 것이다.뭐가 이상한지 한 번 살펴보자.다음은 Set 인터페이스 문서에 나온 내용이다. sets contain no pair of elements e1 and e2 such that e1.equals(e2) e1.equals(e2)와 같은 논리적 동치성이 검증된 e1과 e2의 쌍은 Set 컬렉션에서 포함하지 않는다는 내용이다.이 내용 때문에 Set에는 중복을 허용하지 않는 것이다.그렇다면 Set 인터페이스를 구현했고, 순서도 보장한 SortedSet 인터페이스의 경우에는 어떨까? a sorted set performs all element comparisons using its compareTo (or compare) method SortedSet 인터페이스는 equals 메서드 대신에 compareTo(혹은 compare) 메서드를 통해 객체를 비교하고 있다.이 내용이 위에 적혀있는 Set 인터페이스의 규약을 위반한 건지는 잘 모르겠다.하지만 이렇게 Set 인터페이스를 준수한 SortedSet 인터페이스가 Set 인터페이스와 뭔가 엇박자가 있기 때문에 웬만하면마지막 규약인 (x.compareTo(y) == 0) == (x.equals(y))을 지키라는 얘기이다. 실제로 equals와 compareTo의 결과가 다른 BigDecimal 클래스를 통해 어떻게 동작하는지 알아보자. 12345678910111213141516171819202122232425262728293031@Testvoid test() &#123; final var one1 = new BigDecimal(&quot;1.0&quot;); final var one2 = new BigDecimal(&quot;1.00&quot;); // equals와 compareTo의 결과가 다르다. assertNotEquals(one2, one1); assertEquals(0, one1.compareTo(one2)); final HashSet&lt;BigDecimal&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add(one1); hashSet.add(one2); final TreeSet&lt;BigDecimal&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add(one1); treeSet.add(one2); // 동일한 요소를 넣었지만 hashSet과 treeSet의 크기가 다르다. assertNotEquals(hashSet.size(), treeSet.size()); // treeSet의 크기는 1이다. assertEquals(1, treeSet.size()); // compareTo 메서드를 사용하기 때문에 &quot;1.0&quot;과 &quot;1.00&quot;을 double로 바꾸면 중복이므로 처음 집어넣은 one1만 들어있다. assertEquals(one1, treeSet.first()); assertNotEquals(one2, treeSet.first()); // 하지만 contains 메서드를 사용하면 내부적으로 compareTo 메서드를 사용하기 때문에 둘 다 포함한다고 나온다. assertTrue(treeSet.contains(one1)); assertTrue(treeSet.contains(one2));&#125; 또한 자식 클래스에 필드를 추가한 경우에는 compareTo 메서드 규약을 지킬 수 없다. 12345678910111213141516171819202122232425262728293031public class Type implements Comparable&lt;Type&gt; &#123; private int number; public Type(final int number) &#123; this.number = number; &#125; @Override public int compareTo(final Type t) &#123; return Integer.compare(number, t.number); &#125;&#125;public class ChildType extends Type &#123; private int number2; public ChildType(final int number, final int number2) &#123; super(number); this.number2 = number2; &#125; @Override public int compareTo(final Type t) &#123; var result = super.compareTo(t); if(result == 0 &amp;&amp; (t instanceof ChildType)) &#123; final var child = (ChildType) t; result = Integer.compare(number2, child.number2); &#125; return result; &#125;&#125; 위와 같이 부모 클래스 Type과 필드를 추가한 자식 클래스 ChildType이 있다고 해보자.이 때 이 클래스들은 compareTo 메서드 규약을 지킬 수 있을까? 1234567891011121314151617@Testvoid test() &#123; final var x = new ChildType(3, 2); final var y = new Type(3); final var z = new ChildType(3, 1); // 다음 규약을 준수하는지 검증해봤는데 준수하지 못한다. // Comparable을 구현한 클래스는 `x.compareTo(y) == 0`일 때 `sgn(x.compareTo(z)) == sgn(y.compareTo(z))`이다. assertEquals(0, x.compareTo(y)); assertNotEquals(sgn(x.compareTo(z)), sgn(y.compareTo(z)));&#125;private int sgn(final int number) &#123; if(number &gt; 0) return 1; else if(number &lt; 0) return -1; return 0;&#125; 따라서 이를 위한 해결 방법은 상속 대신에 컴포지션을 쓰면 된다는 것이다. 12345678910111213141516171819202122public class ChildType implements Comparable&lt;ChildType&gt; &#123; private Type type; private int number2; public ChildType(final int number, final int number2) &#123; type = new Type(number); this.number2 = number2; &#125; // 부모 클래스의 기능을 쓰고 싶다면 이 메서드를 통해 접근하면 된다. public Type asType() &#123; return type; &#125; @Override public int compareTo(final ChildType child) &#123; var result = type.compareTo(child.type); result = Integer.compare(number2, child.number2); return result; &#125;&#125; 위의 규약들을 지키지 못한다면 compareTo 메서드를 활용하는 TreeSet, TreeMap, Collections, Arrays 등등과 어울리지 못한다.즉, 좁쌀만 한 노력으로 코끼리만 한 큰 효과를 얻는 기회를 상실하게 되는 것이다! 구현Comparable 인터페이스의 compareTo 메서드를 구현하는 방법은 어렵지 않다.equals 처럼 Object를 인자로 받지 않고 타입을 받기 때문에 Type 체크나 형변환이 필요치 않다. primitive type인 경우에는 &lt;**, **&gt;, &#x3D; 등등의 비교 연산자를 쓰기보다는Wrapper Class의 compare 클래스를 이용하는 게 오류도 줄이고, 코드의 가독성도 높이는 길이다.아래와 같이 해당 클래스들은 Comparable 인터페이스를 구현했기 때문이다.public final class Integer extends Number implements Comparable&lt;Integer&gt; 참조 클래스 같은 경우에는 재귀적으로 compareTo 메서드를 호출해야한다. 비교해야할 필드가 여러 개라면 변경 가능성이 높은 필드부터 검사를 해서 성능을 높일 수 있다. Comparator아래의 경우에 순서를 비교할 때 사용하는 인터페이스이다. Comparable을 구현하지 않은 클래스의 순서를 비교 Comparable을 구현한 클래스의 compareTo 메서드 대신에 커스텀한 로직으로 순서를 비교하고 싶은 경우String 클래스의 compareTo 메서드를 보면 아래와 같이 우리가 알고 있는 기본적인 알파벳(혹은 가나다) 순으로 비교하고 있다.&amp;nbsp; 비교하려는 두 문자열이 latin1인지 UTF16인지 Character Set을 비교 후 compareTo 메서드 호출 두 문자열의 길이를 구함. 두 문자열 중에 길이가 짧은 문자열의 길이까지만 비교(그 이후에는 비교할 문자열이 없으므로 비교가 불가능) 비교 대상의 문자열 중 다른 값이 있으면 알파벳(혹은 가나다) 순으로 비교 비교 대상의 문자열이 모두 같다면 길이가 짧은 문자열이 더 작다고 판단 12345678910111213141516171819202122232425262728293031public int compareTo(String anotherString) &#123; byte v1[] = value; byte v2[] = anotherString.value; if (coder() == anotherString.coder()) &#123; return isLatin1() ? StringLatin1.compareTo(v1, v2) : StringUTF16.compareTo(v1, v2); &#125; return isLatin1() ? StringLatin1.compareToUTF16(v1, v2) : StringUTF16.compareToLatin1(v1, v2);&#125;public static int compareTo(byte[] value, byte[] other) &#123; int len1 = value.length; int len2 = other.length; return compareTo(value, other, len1, len2);&#125;public static int compareTo(byte[] value, byte[] other, int len1, int len2) &#123; int lim = Math.min(len1, len2); for (int k = 0; k &lt; lim; k++) &#123; if (value[k] != other[k]) &#123; return getChar(value, k) - getChar(other, k); &#125; &#125; return len1 - len2;&#125;public static char getChar(byte[] val, int index) &#123; // &amp; 0xff는 unsigned value로 만들기 위함이라고 함. return (char)(val[index] &amp; 0xff);&#125; 위의 경우에는 대소문자 비교까지 하고 있는데 우리는 대소문자를 비교하지 않고 싶다면 어떻게 해야할까? compareTo 메서드를 호출하기 전에 두 문자열을 대문자 혹은 소문자로 변환 후 compareTo 메서드 호출 Comparator 인터페이스 사용 여기서는 후자를 다룰 것인데, Comparator는 인터페이스이기 때문에 대소문자를 가리지 않은 Comparator를 만들어도 되지만자바에서 기본적으로 이런 기본적인 내용을 구현한 Comparator에 대한 구현체들이 있기 때문에 아래와 같이 해당 클래스를 사용하면 편하다.String.CASE_INSENSITIVE_ORDER.compare(string1, string2) 또한 자바 8부터는 인터페이스가 디폴트 메서드를 가질 수 있기 때문에 같이 간편한 기능들도 제공한다.만약 아래와 같이 integer들을 가진 클래스를 비교한다고 가정했을 때 여태까지는 이렇게 해왔을 것이다. 12345678910111213141516public class Type implements Comparable&lt;Type&gt; &#123; private int number; private int number2; private int number3; private int number4; @Override public int compareTo(final Type t) &#123; int result = Integer.compare(number, t.number); result = result == 0 ? Integer.compare(number2, t.number2) : result; result = result == 0 ? Integer.compare(number3, t.number3) : result; result = result == 0 ? Integer.compare(number4, t.number4) : result; return result; &#125;&#125; 하지만 Comparator를 사용한다면 아래와 같이 간단하게 만들 수 있다. (약간의 성능 저하가 따라온다고 한다.) 1234567891011121314151617public class Type implements Comparable&lt;Type&gt; &#123; private int number; private int number2; private int number3; private int number4; @Override public int compareTo(final Type t) &#123; // 자바의 타입 추론의 한계 때문에 처음에는 타입을 명시해줘야한다. // 이렇게 해주는 것만으로 Comparator를 구현한 것이고 이 구현체를 통해 순서를 비교할 수 있다. return Comparator.comparingInt((Type t2) -&gt; t2.number) .thenComparingInt(t2 -&gt; t2.number2) .thenComparingInt(t2 -&gt; t2.number3) .thenComparingInt(t2 -&gt; t2.number4) .compare(this, t); &#125;&#125; 기본 타입을 비교하는 comparingInt(int보다 작은 short, byte 등등도 이 메서드를 사용), comparingLong, comparingDouble(double 보다 작은 float도 이 메서드 사용)등등이 있고, Collection의 순서를 거꾸로 뒤집는 reversed 메서드 등등 편의성을 제공해주는 메서드들이 있다.또한 기본 타입 이외에 참조 타입 비교를 위한 comparing 메서드도 제공해준다. 또한 값의 차로 순서를 비교하는 경우에는 정수 오버플로우나 부동 소수점계산 방식에 따라서 오류를 낼 수 있다. 123456final Comparator&lt;Object&gt; comparator = new Comparator&lt;&gt;() &#123; @Override public int compare(final Object o1, final Object o2) &#123; return o1.hashCode() - o2.hashCode(); &#125;&#125;; 따라서 직접 값의 차를 이용해 순서를 비교하기 보다는 Wrapper Class에서 제공해주는 compare 메서드를 사용하거나 123456final Comparator&lt;Object&gt; comparator = new Comparator&lt;&gt;() &#123; @Override public int compare(final Object o1, final Object o2) &#123; return Integer.compare(o1.hashCode(), o2.hashCode()); &#125;&#125;; 아니면 Comparator에서 제공해주는 메서드를 사용하는 게 더 안전하다. 1final Comparator&lt;Object&gt; comparator = Comparator.comparingInt(Object::hashCode);","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"}]},{"title":"(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, clone 재정의는 주의해서 진행해라","slug":"effective-java-ch03-item13-clone-method","date":"2018-12-16T21:50:10.000Z","updated":"2022-10-30T08:42:16.399Z","comments":true,"path":"2018/12/16/effective-java-ch03-item13-clone-method/","link":"","permalink":"https://perfectacle.github.io/2018/12/16/effective-java-ch03-item13-clone-method/","excerpt":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 믹스인 인터페이스Cloneable이 믹스인 인터페이스라고 책에서 소개하고 있는데 그럼 믹스인 인터페이스는 뭔지부터 살펴보도록 하자.아이템 20: 추상 클래스 보다는 인터페이스를 우선하라(130P)를 보면 다음과 같이 정의하고 있다. 믹스인이란 클래스가 구현할 수 있는 타입을 말한다. 믹스인을 구현한 클래스에 원래의 ‘주된 타입’ 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.","text":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 믹스인 인터페이스Cloneable이 믹스인 인터페이스라고 책에서 소개하고 있는데 그럼 믹스인 인터페이스는 뭔지부터 살펴보도록 하자.아이템 20: 추상 클래스 보다는 인터페이스를 우선하라(130P)를 보면 다음과 같이 정의하고 있다. 믹스인이란 클래스가 구현할 수 있는 타입을 말한다. 믹스인을 구현한 클래스에 원래의 ‘주된 타입’ 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다. 간단하게 말하서 믹스인 &#x3D;&#x3D; 클래스가 구현할 수 있는 **타입(클래스, 함수, 인터페이스 등등)**이다.예를 들어서 Comparable이란 인터페이스를 토대로 살펴보자. 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 그리고 Point라는 클래스가 있다고 생각해보자. 12345678public class Point &#123; int x; int y; public void print() &#123; System.out.println(String.format(&quot;x: %d\\ny: %d&quot;, x, y)); &#125;&#125; 그럼 Point의 믹스인(Point라는 클래스가 구현할 수 있는 타입)은 무엇일까?아주 여러가지 믹스인들이 있겠지만 그 중에 하나는 Comparable이라고 말할 수 있다.왜냐하면 아래와 같이 Point 클래스를 Comparable 인터페이스(타입)를 구현한 구현체로 만들 수 있기 때문이다. 12345678910111213public class Point implements Comparable&lt;Point&gt; &#123; int x; int y; public void print() &#123; System.out.println(String.format(&quot;x: %d\\ny: %d&quot;, x, y)); &#125; @Override public int compareTo(final Point o) &#123; return 0; &#125;&#125; 클래스가 구현할 수 있는 타입을 왜 믹스인이라고 부르는 걸까?바로 대상 타입(Point)의 주된 기능(점의 위치를 표시, print 메서드)에 선택적 기능(순서를 정함, Comparable)을 혼합(mixed in)한다고 해서 믹스인이라고 부른다.또한 믹스인에는 함수나 클래스 등등의 타입이 있기 때문에 그냥 믹스인이라고 부르면 헷갈리기 때문에 믹스인 성격을 가진 인터페이스를 믹스인 인터페이스라고 부르는 것 같다. CloneableCloneable 인터페이스는 믹스인 인터페이스이다.하지만 믹스인의 용도를 제대로 사용하지 않고 있다.이유는 Cloneable 인터페이스를 직접 보면 알 수 있다. 12public interface Cloneable &#123;&#125; 위에서 얘기했던 Comparable과의 차이점이 뭘까?인터페이스만 있을 뿐, 구현해야하는 메서드가 아무것도 없다.믹스인 인터페이스라면 선택적 기능을 제공해야하는데 제공하는 게 아무것도 없다.즉, 구현해봤자 아무짝에 쓸모없는 인터페이스처럼 보인다.그럼 clone 메서드의 위치는 어디일까?바로 쌩뚱맞게도 Object 클래스에 clone 메서드가 있다. 12@HotSpotIntrinsicCandidateprotected native Object clone() throws CloneNotSupportedException; 원본 메서드가 감춰져있어서 소스코드를 볼 수는 없지만 일단 객체를 복사해주는 메서드 같아 보인다.또 여태까지 살펴봤던 다른 메서드와 달리 protected 메서드이다.따라서 아래와 같이 리플렉션을 쓰지 않는 이상은 오버라이딩한 메서드에 접근할 수 있다는 게 보장되지 않는다.하지만 리플렉션을 사용한다 하더라도 해당 메서드를 오버라이딩 하지 않은 경우에는 NoSuchMethodException 예외를 던지기 때문에 리플렉션으로도 메서드에 접근할 수 있다는 걸 100% 보장할 수 없다. 12345678@Testvoid copyTest() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; final var cloneMethod = Point.class.getDeclaredMethod(&quot;clone&quot;); cloneMethod.setAccessible(true); final var instance = new Point(); final var copy = cloneMethod.invoke(instance);&#125; 오버라이딩 할 때 public으로 오버라이딩 할 수 있지만, 실수로라도 protected로 오버라이딩 할 여지가 존재하는 매우 부실한 프로토콜이다. 그럼 아무짝에 쓸모 없어보이는 Cloneable 인터페이스는 내비두고, Object 클래스의 clone 메서드를 바로 오버라이딩 하면 될 것 같다. 12345678910111213141516public class Point &#123; private int x; private int y; public Point(final int x, final int y) &#123; this.x = x; this.y = y; &#125; // 자바 5에 추가된 covariant return typing(공변 반환 타이핑, 리턴 타입이 서브 클래스의 범위 안에 있으면 된다는 내용) 덕분에 // 해당 메서드를 사용하는 사용자가 직접 형변환을 할 필요가 사라졌다. @Override public Point clone() &#123; return (Point) super.clone(); &#125;&#125; 공변성(covariant)과 반공변성(contravariant)에 대해서는 이 글의 주제를 넘어서므로 공변성과 반공변성은 무엇인가?에 들어가서 보면 된다. 위 clone 메서드를 보면 public으로 오버라이딩 했고 전부 잘 작성한 것 같은데 컴파일이 안 된다.바로 checked exception인 CloneNotSupportedException이 발생하기 때문이다.이유는 해당 예외 클래스를 보면 나온다. 123/* Thrown to indicate that the clone method in class Object has been called to clone an object, * but that the object&#x27;s class does not implement the Cloneable interface. */ clone 메서드가 호출 됐는데 클래스가 Cloneable 인터페이스를 구현하지 않았을 때 던지는 예외란다.아무런 쓸모도 없어보이던 녀석이 드디어 쓸모가 있어보인다.그럼 위 예외를 없애버리기 위해 Cloneable 인터페이스를 구현해보자. 1234567891011121314public class Point implements Cloneable &#123; private int x; private int y; public Point(final int x, final int y) &#123; this.x = x; this.y = y; &#125; @Override public Point clone() &#123; return (Point) super.clone(); &#125;&#125; Cloneable 인터페이스는 아무런 메서드가 없기 때문에 구현해야할 것도 아무것도 없다.하지만 이럼에도 불구하고 컴파일은 되지 않고, CloneNotSupportedException이 발생한다.따라서 다소 귀찮지만 아래와 같이 처리를 해주어야한다. 12345678910111213141516171819public class Point implements Cloneable &#123; private int x; private int y; public Point(final int x, final int y) &#123; this.x = x; this.y = y; &#125; @Override public Point clone() &#123; try &#123; return (Point) super.clone(); &#125; catch (final CloneNotSupportedException e) &#123; // Cloneable 인터페이스를 구현한 이상 이 코드는 절대 실행되지 않는다. throw new AssertionError(); &#125; &#125;&#125; 위와 같은 불편함을 초래하기 때문에 CloneNotSupportedException은 unchecked exception으로 만들었으면 더 좋았을 것 같다.unchecked exception이었다면 Cloneable 인터페이스를 구현하지 않은 경우에는 런타임 에러를 뱉겠지만,checked exception으로 만들어버려서 정상적으로 인터페이스를 구현한 경우에도 모두 불필요한 코드를 추가해야하는 불편함을 감수해야한다.또한 Cloneable 인터페이스는 특정 클래스(Object)의 메서드(clone) 동작 방식을 결정한다는 아주 요상한 방식이니 절대 따라하면 안 되고 따라하기 힘들 것 같다.우리가 위에서 선언한 clone 메서드는 super.clone()라는 코드로 인해 부모 클래스인 Object의 clone메서드의 결과값을 반환하는데그 객체의 필드들을 하나하나 복사한 객체를 반환한다.물론 primitive type만 제대로 복사하는 shallow copy이다.참조 타입은 reference value를 복사하기 때문에 불변 객체가 아닌 이상은 직접 deep copy를 구현해줘야한다. Object.clone() 메서드의 명세서에 적혀있는 규약을 정리해보자면 다음과 같다. x.clone() !&#x3D; x; x.clone().getClass() &#x3D;&#x3D; x x.clone().equals(x) 이 메서드가 반환하는 객체는 super.clone()을 호출해서 얻어야한다. 하지만 위 조건이 모두 필수는 아니다. 즉, 권장사항일 뿐이며 선택사항이다. 하지만 우리는 super.clone(), 즉 Object 클래스의 clone 메서드를 신뢰하지 못해서 아래와 같이 직접 생성자를 사용해서 객체를 복사한다고 가정해보자. 1234567891011121314151617181920212223242526272829// Object의 clone 메서드를 호출하는 게 아니므로 CloneNotSupportedException을 던지지 않기 때문에 Cloneable 인터페이스를 구현할 필요가 없다.public class Point &#123; private int x; private int y; public Point(final int x, final int y) &#123; this.x = x; this.y = y; &#125; @Override public Point clone() &#123; // 좀 더 메서드가 깔끔해진 것 같다. return new Point(this.x, this.y); &#125; // 실제로 객체가 잘 복사됐는지 비교하기 위해 equals 메서드를 오버라이딩 @Override public boolean equals(final Object o) &#123; if (this == o) return true; if (!(o instanceof Point)) return false; final var point = (Point) o; if(this.x != point.x) return false; if(this.y != point.y) return false; return true; &#125;&#125; 테스트 코드를 통해 객체가 제대로 복사가 됐는지 알아보자. 1234567891011121314@Testvoid testClone() &#123; final var point = new Point(1, 2); final var clone = point.clone(); // 내부적으로 동일 연산자를 통해 다른 인스턴스인지 비교 assertNotSame(point, clone); // 클래스 정보도 똑같다. assertEquals(point.getClass(), clone.getClass()); // 내부적으로 동등 연산자인 equals 메서드를 통해 논리적 동치성을 보장하는지 비교 assertEquals(point, clone);&#125; 이번엔 Point 클래스를 상속하는데 super.clone 메서드를 사용하는 클래스가 있다고 가정해보자. 1234567891011121314151617181920212223242526272829public class ColorPoint extends Point &#123; private String color; public ColorPoint(final int x, final int y, final String color) &#123; super(x, y); this.color = color; &#125; @Override public Object clone() &#123; // java.lang.ClassCastException을 유발한다. // super.clone() 메서드로 얻어온 메서드의 반환 타입은 Point 생성자를 통해 생성된 Point 클래스 인스턴스이다. // 부모 클래스를 가지고 자식 클래스로 형변환 했을 때 자식 클래스에 필요한 필수 필드들이 들어가있지 않을 가능성이 존재해서 // 변환된 클래스가 제대로 작동하리란 보장이 없기 때문에 위와 같이 예외를 던지는 게 아닐까? // 따라서 형 변환을 할 수 없기 때문에 자식 클래스에서 필드가 추가된 경우에는 제대로 clone 조차 하지 못한다. // return (ColorPoint) super.clone(); return super.clone(); &#125; @Override public boolean equals(final Object o) &#123; if (this == o) return true; if (!(o instanceof ColorPoint)) return false; if (!super.equals(o)) return false; final var colorPoint = (ColorPoint) o; return Objects.equals(color, colorPoint.color); &#125;&#125; 그럼 다시 테스트 클래스를 통해 올바르게 복사가 됐는지 확인해보자. 1234567891011121314@Testvoid testColorClone() &#123; final var colorPoint = new ColorPoint(1, 2, &quot;red&quot;); final var clone = colorPoint.clone(); // 내부적으로 동일 연산자를 통해 다른 인스턴스인지 비교 assertNotSame(colorPoint, clone); // 클래스 정보도 부모의 생성자를 통해서 만들었기 때문에 자식 클래스의 정보를 가지지 못한다. assertNotEquals(colorPoint.getClass(), clone.getClass()); // 내부적으로 동등 연산자인 equals 메서드를 통해 논리적 동치성을 보장하는지 비교하는데 red는 제대로 복사되지 않았음 assertNotEquals(colorPoint, clone);&#125; 자식 클래스를 구현할 필요 없는 final 클래스 등등의 경우에는 상관 없겠지만 위와 같은 사유 때문에 웬만하면 Object.clone() 메서드 명세서의 규약은 준수하는 게 좋다. 그럼 가변 객체가 있을 때는 어떻게 구현해야할까?우선 간단하게 배열을 필드로 가지고 있는 객체를 예로 들어보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Type implements Cloneable &#123; private int number; private Type[] children; public Type(final int number, final Type[] children) &#123; this.number = number; this.children = children; &#125; public int getNumber() &#123; return number; &#125; public void setNumber(final int number) &#123; this.number = number; &#125; public Type[] getChildren() &#123; return children; &#125; public void setChildren(final Type[] children) &#123; this.children = children; &#125; @Override public Type clone() &#123; try &#123; return (Type) super.clone(); &#125; catch (final CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; @Override public boolean equals(final Object o) &#123; if (this == o) return true; if (!(o instanceof Type)) return false; final var type = (Type) o; if(this.number != type.number) return false; if(!Arrays.equals(this.children, type.children)) return false; return true; &#125;&#125; 그럼 clone 메서드가 우리가 생각하는대로 동작하는지 알아보자. 1234567891011@Testvoid test() &#123; final var original = new Type(3, new Type[]&#123;new Type(1, null), new Type(2, null)&#125;); final var clone = original.clone(); // 원본 객체에서 첫 번째 자식을 다른 자식으로 대체 original.getChildren()[0] = new Type(4, null); // clone과 original이 완전 독립된 객체라면 이 테스트는 통과해선 안 된다. assertEquals(original, clone);&#125; 우리가 의도한 대로 동작하지 않음(둘이 완전히 독립된 객체이길 원함)을 볼 수 있다.그렇다면 우리의 의도대로 동작하게 끔 clone 메서드를 변경해보자. 123456789101112131415@Overridepublic Type clone() &#123; try &#123; final var clone = (Type) super.clone(); // 배열의 clone 메서드는 공변 반환 타이핑도 제대로 적용했고 unchecked exception인 CloneNotSupportedException도 제대로 처리한 유일한 예라고 책에서 설명하고 있다. // 하지만 가변 객체를 참조하는 필드는 final로 선언하라는 용법과는 상반된다. // final로 선언해도 완전 불변 객체를 만드는 것은 아니지만 적어도 레퍼런스 값이 바뀌는 경우는 막을 수 있으니까 final로 선언하라는 용법이 있는 것으로 알고 있는데 // 이 용법을 사용하면 가변 객체의 clone을 할당할 수 없다. clone.children = this.children.clone(); return clone; &#125; catch (final CloneNotSupportedException e) &#123; throw new AssertionError(); &#125;&#125; 이렇게 변경했다면 위 테스트는 통과하지 못하고 assertNotEquals(original, clone);와 같이 변경해야 테스트를 통과시킬 수 있고 우리의 의도대로 동작한다. 하지만 이마저도 얕은 복사이고 아래의 경우에는 객체의 완벽한 독립을 보장하지 못한다. 1234567891011@Testvoid test() &#123; final var original = new Type(3, new Type[]&#123;new Type(1, null), new Type(2, null)&#125;); final var clone = original.clone(); // 자식을 재할당하는 게 아니라 자식의 필드를 변경 original.getChildren()[0].setNumber(2); // clone과 original이 완전 독립된 객체라면 이 테스트는 통과해선 안 된다. assertEquals(original, clone);&#125; 아래와 같이 재귀를 통해 깊은 복사를 하면 우리가 원하는 문제를 해결할 수 있다. 1234567891011121314151617181920212223@Overridepublic Type clone() &#123; try &#123; final var clone = (Type) super.clone(); // 배열의 clone 메서드는 공변 반환 타이핑도 제대로 적용했고 unchecked exception인 CloneNotSupportedException도 제대로 처리한 유일한 예라고 책에서 설명하고 있다. clone.children = childrenDeepCopy(clone.children); return clone; &#125; catch (final CloneNotSupportedException e) &#123; throw new AssertionError(); &#125;&#125;private Type[] childrenDeepCopy(final Type[] parent) &#123; final var shallowClone = parent.clone(); return Arrays.stream(shallowClone) .map(origin -&gt; new Type(origin.number, origin.hasChildren() ? childrenDeepCopy(origin.children) : null)) .toArray(Type[]::new);&#125;private boolean hasChildren() &#123; return children != null &amp;&amp; children.length != 0;&#125; 하지만 재귀 함수의 단점은 자식의 깊이가 깊을 수록 재귀 호출을 통해 스택 프레임을 사용하기 때문에 스택 오버플로우를 유발할 수도 있다는 점이다.따라서 깊은 복사는 반복을 통해 풀 수 있다면 반복으로 푸는 것이 좋다. 또한 상속용으로 설계된 부모 클래스에서 clone을 재정의할 경우, 해당 메서드에서는 다른 재정의 가능한 메서드를 호출하면 안 된다.이유는 자식 클래스에서 clone을 재정의 했을 경우 연쇄적으로 super.clone();을 호출하기 때문에 부모의 clone 메서드를 호출하게 된다.그 과정에서 부모의 clone 메서드에서 재정의 가능한 어떤 메서드를 호출한다면 부모 클래스의 메서드를 호출하는 게 아니라 자식 클래스에서 재정의한 메서드를 호출하기 때문이다.정확하게 어떻게 예를 들어야할지 모르겠다… (다소 억지스러운 것들 밖에 안 떠올라서…) 위와 같은 오동작을 불러일으킬 수 있기 때문인지 책(84P)에서는 상속해서 쓰기 위한 클래스 설계 방식 두 가지(재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남긴 클래스,내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별하여 protected 메서드 형태로 공개한 클래스)에서도 Cloneable 구현 자체를 하지 말라고 하고 있다.clone 메서드를 깊은 복사까지 구현만 해놓고 Cloneable 인터페이스는 구현하지 않아서 하위 클래스에게 Cloneable 구현 여부를 선택하게 끔 하거나,아래와 같이 clone 메서드를 재정의하는데 하위 클래스에서 재정의하지 못하게 하는 것이다. 12345@Overridepublic Type clone() throws CloneNotSupportedException &#123; // 자식 클래스에서는 super.clone()을 통해 clone 메서드를 재정의 하니까 무조건 부모 클래스의 clone 메서드를 호출하게 돼있다. throw new CloneNotSupportedException();&#125; 또한 clone 메서드는 동기화(멀티 쓰레드로 돌아가는 환경에서 공유 자원에 대해 일관성 유지)도 고려돼있지 않기 때문에 동기화도 적절히 해줘야한다. 이러한 허술한 메커니즘 기반인 clone 보다는 아래와 같은 방법 중 하나를 추천한다. 12345// 복사 생성자public Type(final Type type) &#123; ... &#125;// 복사 팩터리 (복사 생성자를 모방한 정적 팩터리)public static Type newInstance(final Type type) &#123; ... &#125; 위와 같은 방법을 쓰면 허술한 메커니즘 뿐만 아니라 불필요한 checked exception 처리, final 필드 용법, 형변환 등등에서 자유로워 질 수 있다.또한 인자로 해당 클래스가 구현한 인터페이스 타입도 받을 수 있기 때문에 원본 클래스의 타입에 얽매이지 않고 사용할 수도 있다는 장점이 존재한다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"}]},{"title":"(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, equals를 재정의하려거든 hashCode도 재정의하라","slug":"effective-java-ch03-item11-hashCode-method","date":"2018-12-03T20:42:39.000Z","updated":"2022-10-30T08:42:16.399Z","comments":true,"path":"2018/12/03/effective-java-ch03-item11-hashCode-method/","link":"","permalink":"https://perfectacle.github.io/2018/12/03/effective-java-ch03-item11-hashCode-method/","excerpt":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 들어가기에 앞서…equals 메서드와 마찬가지로 hashCode를 오버라이딩 할 경우는 거의 없다.대부분 hashCode를 쓰는 쪽은 HashMap, HashSet 등등이다.이 마저도 키에다가 equals를 오버라이딩 한 클래스를 사용할 때이다.실무에서 대부분 키로 String, Integer를 쓰지, 해당 클래스를 써본 적은 한 번도 없다.(물론 특수한 경우에는 존재할 수도 있지만, 아주 특수할 것이다.)따라서 이런 아주 특수한 경우를 제외하고는 딱히 hashCode를 오버라이딩 할 이유가 없으니 이 글도 딱히 읽을 필요도 없다.그래도 혹여나 실무에서 당장 hashCode를 오버라이딩 하려면 세 가지 방법이 존재한다.내가 당신의 시간을 아껴주겠다.그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다. 구글에서 만든 AutoValue 사용하기. (권장)아주 사용하기가 간단하다.바로 클래스 위에 @AutoValue 어노테이션만 달아주면 끝이다.(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.얘는 자바 6부터 지원한다. IDEA가 생성해준 소스 코드 사용하기.여러가지 규칙을 직접 찾아보며 구현하기 귀찮으니까 생성해주는 코드를 사용하면 된다.인텔리제이 IDEA가 생성한 코드니 신뢰하고 써도 될 것이다.단점으로 클래스가 변경될 때마다 hashCode 쪽 소스도 넣어줘야해서 귀찮다. 직접 구현하기이 글을 보고 직접 구현해보면 될 것 같다.","text":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 들어가기에 앞서…equals 메서드와 마찬가지로 hashCode를 오버라이딩 할 경우는 거의 없다.대부분 hashCode를 쓰는 쪽은 HashMap, HashSet 등등이다.이 마저도 키에다가 equals를 오버라이딩 한 클래스를 사용할 때이다.실무에서 대부분 키로 String, Integer를 쓰지, 해당 클래스를 써본 적은 한 번도 없다.(물론 특수한 경우에는 존재할 수도 있지만, 아주 특수할 것이다.)따라서 이런 아주 특수한 경우를 제외하고는 딱히 hashCode를 오버라이딩 할 이유가 없으니 이 글도 딱히 읽을 필요도 없다.그래도 혹여나 실무에서 당장 hashCode를 오버라이딩 하려면 세 가지 방법이 존재한다.내가 당신의 시간을 아껴주겠다.그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다. 구글에서 만든 AutoValue 사용하기. (권장)아주 사용하기가 간단하다.바로 클래스 위에 @AutoValue 어노테이션만 달아주면 끝이다.(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.얘는 자바 6부터 지원한다. IDEA가 생성해준 소스 코드 사용하기.여러가지 규칙을 직접 찾아보며 구현하기 귀찮으니까 생성해주는 코드를 사용하면 된다.인텔리제이 IDEA가 생성한 코드니 신뢰하고 써도 될 것이다.단점으로 클래스가 변경될 때마다 hashCode 쪽 소스도 넣어줘야해서 귀찮다. 직접 구현하기이 글을 보고 직접 구현해보면 될 것 같다. hashCode Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode() object의 해시 값을 반환하는 메서드이다.key를 해싱해서 인덱스를 만들고, 해당 인덱스의 버킷(저장 공간)에 값을 저장하는 자료구조인 Hash Table에서 사용된다. 123456789public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 위 코드는 HashMap 클래스의 get 메서드인데 내부적으로 타고들어가다보면 Object의 hashCode 메서드를 사용해서 key의 hashCode를 구해서 원하는 value를 구하고 있다. 이제 hashCode의 규약을 알아보자. Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.This integer need not remain consistent from one execution of an application to another execution of the same application.equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.단, 어플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다. It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.단, 다른 객체에 대해서는 다른 값을 반환해야 해시 테이블의 성능이 좋아진다. 어, 지루하게 hashCode의 규약에 대해 살펴봤으니 우리가 간단하게 만든 클래스가 hashCode의 규약을 준수하는지 알아보자.우선 간단한 클래스를 만들어보자. 123456789101112131415161718192021public class Point &#123; private int x; private int y; public Point(final int x, final int y) &#123; this.x = x; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Point)) return false; final var obj = (Point) o; if(obj.x != this.x) return false; if(obj.y != this.y) return false; return true; &#125;&#125; 이 클래스가 동치 관계를 준수하면서 equals 메서드를 구현했는지 간단하게 검증해보자. 1234567891011121314151617181920212223242526@Testvoid test() &#123; // reflexive final var x = new Point(1, 1); assertEquals(x, x); // symmetric final var y = new Point(1, 1); assertEquals(x, y); assertEquals(y, x); // transitive final var z = new Point(1, 1); assertEquals(y, z); assertEquals(x, z); // consistent assertEquals(x, x); assertEquals(x, y); assertEquals(y, x); assertEquals(y, z); assertEquals(x, z); // For any non-null reference value x, x.equals(null) should return false. assertNotEquals(x, null);&#125; 5가지 규칙을 모두 지킨 참된 equals 메서드이다.그럼 이 클래스가 HashMap에서도 key로써 제대로 역할을 수행하는지 알아보자. 1234567891011121314151617181920@Testvoid test() &#123; // 두 인스턴스가 같다고 판단(내부적으로 equals 메서드 사용) assertEquals(new Point(1, 1), new Point(1, 1)); // 1번 규칙에 의하면 몇 번을 호출하더라도 동일한 hashCode가 나와야하는데 동일한 값이 나오지 않았음. // 사실 이 스트림은 한 번만 호출되더라도 !h.equals(hashCode) 조건을 만족하기 때문에 한 번 밖에 돌지 않음. final var hashCode = new Point(1, 1).hashCode(); final var result = IntStream.range(1, 100) .mapToObj(i -&gt; new Point(1, 1).hashCode()) .anyMatch(h -&gt; !h.equals(hashCode)); // 단 두 번만 호출했는데도 불구하고 둘이 다른 해시코드가 나옴. assertNotEquals(new Point(1, 1).hashCode(), new Point(1, 1).hashCode()); // 서로 다른 해시코드를 내뱉기 때문에 키의 역할을 제대로 수행하지 못하고 있음. final var map = new HashMap&lt;Point, Integer&gt;(); map.put(new Point(1, 1), 1); assertNull(map.get(new Point(1, 1)));&#125; 제대로 규칙을 이행하는 게 하나도 없다.그렇다면 기본 메서드인 Object.hashCode()는 어떻게 구현이 돼있길래 저런 결과가 나온 걸까…? 12@HotSpotIntrinsicCandidatepublic native int hashCode(); 내부 구현이 다 숨겨져 있다.주석을 살펴보면 아래와 같이 나와있다. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object’s memory address at some point in time.) https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode() object’s memory address가 핵심인 것 같다.객체의 참조값을 가지고 해싱을 한다는 것 같은데, 모든 객체 인스턴스는 싱글턴이 아닌 이상 각각 고유한 참조값을 가지고 있으므로hashCode의 기본 메서드로를 모든 인스턴스마다 고유한 hashCode를 생산한다.하지만 우리가 구현한 equals 메서드에 따르면 각 인스턴스마다 equals 값이 true로 나오고 있으므로 hashCode도 동일한 값이 나와야하는데그러고 있지 않으므로, 우리가 만든 클래스는 hashCode의 규약을 준수하지 못한 경우이다.따라서 equals 메서드를 오버라이딩 했으면 거의 hashCode도 같이 오버라이딩 해줘야 hashCode의 규약을 준수해서 hashMap 등등에서 key로써 제대로 된 역할을 수행한다고 말할 수 있다. 아주 간단하게 해시 코드를 작성해보면 다음과 같다.(실무에서 절대 쓰면 안된다.) 1234@Overridepublic int hashCode() &#123; return 1;&#125; 이렇게 구현하면 물론 equals 비교에 사용되는 정보가 변경됐는데도 똑같은 해시 값을 반환하므로 1번 규약을 지키지는 못한다.또한 모두 같은 해시 값을 반환하기 때문에 충돌이 발생하게 되는데 이 경우에는 index가 가리키고 있는 LinkedList 혹은 Tree에 값을 추가해서 데이터의 유실을 방지한다.따라서 해시 테이블의 단 하나의 버킷에 저장하기 때문에 평균 수행 시간이 O(n)으로 느려진다.이상적인 해시 값이라면 hashCode 규약을 준수하고, O(1)의 수행속도를 가져야한다. (각기 다른 버킷에 값을 저장하고, 따라서 충돌이 아주 적은…) 책에 나와있는 hashCode 작성법을 글로만 읽으면 이해가 안 되니 코드와 함께 이해해보자. 1234567891011121314151617181920212223242526272829303132333435363738394041public class Type &#123; private int x; private String y; private double[] z; private Type t; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Type)) return false; final var obj = (Type) o; // 첫 번째 핵심 필드 x if(obj.x != this.x) return false; if(obj.y.equals(this.y)) return false; if(Arrays.equals(obj.z, this.z)) return false; // 필드 t는 아예 equals 메서드에서 제외하였다. return true; &#125; @Override public int hashCode() &#123; // 첫 번째 핵심 필드 x의 해시값을 구함. // primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함. var result = Integer.hashCode(x); // 그 다음 핵심필드 y는 참조 타입이기 때문에 참조 타입의 hashCode() 메서드 사용. result = result * 31 + y.hashCode(); // 그 다음 핵심필드 z는 배열이고, 그 내부 원소가 모두 equals에 사용된 핵심 원소이므로 Arrays.hashCode() 메서드를 통해 구현. // 만약 특정 원소만 핵심 원소라면 해당 원소들에 대해서 for-loop 돌면서 hashCode를 구하면 됨. result = result * 31 + Arrays.hashCode(z); // equals 메서드에 사용되지 않은, 핵심필드가 아닌 t는 hashCode에서 사용하면 안 됨. // equals 메서드를 통해 같다고 판단한 객체가 서로 다른 hashCode를 내뱉는 현상이 발생해 hashCode 규약을 지키지 못할 수 있음. // 위에서 구한 result를 반환. return result; &#125;&#125; Q: 왜 기존 값에 해시코드를 더하지 않고, 31을 곱한 후에 더하는가?A: 아래의 예제를 통해 알아보자. 123456789101112131415161718192021222324252627282930public class Type &#123; private int x; private int y; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Type)) return false; final var obj = (Type) o; // 첫 번째 핵심 필드 x if(obj.x != this.x) return false; if(obj.y != this.y) return false; return true; &#125; @Override public int hashCode() &#123; // 첫 번째 핵심 필드 x의 해시값을 구함. // primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함. var result = Integer.hashCode(x); // 그 다음 핵심필드 y도 primitive type이기 때문에 WrapperClass.hashCode() 메서드를 통해 해시값을 구함. result += Integer.hashCode(y); // 위에서 구한 result를 반환. return result; &#125;&#125; 여기서 {x&#x3D;1, y&#x3D;2}와 {x&#x3D;2, y&#x3D;1}은 동등(equals)하지 않다.하지만 각 원소의 집합은 {1, 2}로 동일하기 때문에 해시코드를 구하면 일치하게 된다.이런 충돌을 줄이고자 31을 곱하는 것이다. (이는 String의 hashCode 메서드를 봐도 마찬가지다.) Q: 왜 31을 곱하는가?A: 31이 소수이기 때문이란다. Q: 왜 소수를 곱하는가?A: Modulo operation(나머지 연산)에서 충돌을 줄이기 위함이라고 한다.해시 함수의 예제를 구글링해보면 나머지 연산을 통해 해시 값을 구하는 예제가 참 많다.실제로 나머지 연산을 통해 해시값을 구할 때는 소수로 나누는 것이 훨씬 충돌 횟수가 적다. (입력값이 균일하게 분포돼있지 않다는 전제 하에…)그래서인지 곱하는 수도 소수를 곱하는 것 같다.하지만 명확하게 왜 소수를 곱하는지는 아직 찾지 못했다. Q: 충돌이 일어나면 어떻게 동작하는가?Java HashMap은 어떻게 동작하는가?에 자세히 설명돼있다.우선 데이터의 유실을 막기 위해 어디다가 저장하긴 해야한다.이를 위한 여러가지 동작 방식이 있는데 자바에서는 Separate Chaining 방식을 채택해서 버킷을 Linked List로 구현했다.자바 8에서는 데이터의 개수가 일정 이상일 때에는 링크드 리스트 대신 트리를 사용하는 것이 성능상 이점이 있다는 점을 토대로동일한 버킷에 데이터가 8개가 되면 Tree로 변경하고, 다시 6개로 줄어들면 LinkedList로 변경한다.8과 6 사이에 2라는 차이를 둔 것은 삽입과 삭제가 빈번하게 일어났을 때 Tree &lt;-&gt; LinkedList의 잦은 변환을 막고자 그렇게 구현했다고 한다.또한 Tree가 메모리를 더 많이 먹고, 데이터 갯수가 적을 때는 Worst Case가 LinkedList와 큰 차이가 없기 때문에 처음에는 LinkedList로 만든다고 한다.따라서 해시 코드가 충돌되더라도 일단 데이터는 저장되니 데이터의 유실은 막는다.하지만 충돌이 잦을 수록 검색 성능은 나빠지니 최대한 충돌이 적은 알고리즘을 찾아야한다.그리고 충돌이 발생하더라도 해당 키값에 대한 동등(equals) 비교가 일치하는 키 값이 없으면 null을 반환하게 된다. Q: 그 많은 소수 중에 왜 31인가? (추측)31은 2⁵ - 1이다.이를 비트 연산자로 표기하면 2 &lt;&lt; 5 - 1이다.왼쪽으로 n칸 이동하면 2ⁿ만큼 곱했다고 보면 된다.cpu는 비트 연산에 매우 최적화 돼있다.그리고 31은 1만 빼면 되는데, 37((2 &lt;&lt; 5) + 6)은 6을 더해야하니 31이 더 빠르지 않을까?31보다는 37이 더 충돌 횟수가 적긴 할텐데, 아마 31만으로도 충분히 충돌 횟수를 많이 줄일 수 있어서 굳이 37을 안 쓰는 게 아닐까 싶다…즉, 성능과 충돌 사이의 밸런스를 찾다보니 31이 나온 건 아닌가 싶다. 그리고 해시값을 구하는데 소수를 이용하는 거 보다 더 나은 알고리즘들이 있다고 하니 직접 찾아보는 것도 좋을 것 같다. 또한 위와 같이 일일이 귀찮게 hashCode를 계산하기 보다는 아래와 같이 할 수 있다.하지만 박싱&#x2F;언박싱 및 입력값을 담기 위한 배열 생성 비용 등등으로 인해 성능 측면에서는 조금 아쉽긴 하다. 123456789101112@Overridepublic int hashCode() &#123; // Array가 아닌 타입은 모두 Objects.hash() 메서드로 해시값을 구할 수 있다. int result = Objects.hash(x, y, t); result = 31 * result + Arrays.hashCode(z); return result;&#125;// 어차피 Objects.hash() 메서드를 따라들어가보면 Arrays.hashCode()를 사용하고 있다.public static int hash(Object... values) &#123; return Arrays.hashCode(values);&#125; 혹은 클래스가 불변인 경우에는 생성 당시에 해시코드 값을 미리 캐싱해놓는 것도 좋다. 123456789private final int hash;public Type(final int x, final String y, final double[] z, final Type t) &#123; this.x = x; this.y = y; this.z = z; this.t = t; this.hash = hashCode();&#125; 하지만 해시코드 생성 비용이 큰 경우에는 해시코드 값을 사용하기 전까지는 지연 초기화를 시켜놓으면 된다. 12345678910@Overridepublic int hashCode() &#123; if(hash != 0) return hash; var result = Objects.hash(x, y, t); result = 31 * result + Arrays.hashCode(z); hash = result; return hash;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"}]},{"title":"(이펙티브 자바 3판) 3장 - 모든 객체의 공통 메서드, equals는 일반 규약을 지켜 재정의하라","slug":"effective-java-ch03-item10-equals-method","date":"2018-11-26T01:16:30.000Z","updated":"2022-10-30T08:42:16.399Z","comments":true,"path":"2018/11/26/effective-java-ch03-item10-equals-method/","link":"","permalink":"https://perfectacle.github.io/2018/11/26/effective-java-ch03-item10-equals-method/","excerpt":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 들어가기에 앞서…equals 메서드를 오버라이딩 할 경우는 거의 없다.대부분 핵심 필드의 값이 일치하는지 파악하기 위해서 오버라이딩 할 것이다.그런 경우를 제외하고는 대부분 기본적인 레퍼런스 값 비교만으로도 충분히 비교가 가능하기 때문이다.equals 메서드를 오버라이딩 하는 건 그렇게 어렵지 않지만 몇가지 원칙이 있고, 글의 길이가 짧은 편도 아니고 얻는 수확이 크지 않다. (애초에 오버라이딩 할 일이 거의 없으니…)그래서 지금 당장 오버라이딩을 해야한다! 싶을 때는 두 가지 방법이 있다.내가 당신의 시간을 아껴주겠다.그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다. 구글에서 만든 AutoValue 사용하기. (권장)아주 사용하기가 간단하다.바로 클래스 위에 @AutoValue 어노테이션만 달아주면 끝이다.(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.얘는 자바 6부터 지원한다. IDEA가 생성해준 소스 코드 사용하기.사람이라면 실수를 하게 되니 IDE의 도움을 절실히 원하게 된다.하지만 클래스가 변하는 경우에 equals 코드도 계속해서 변경해줘야하니 구찮다…또 잘 짰는지 테스트 코드도 짜야하고… 테스트 코드도 변경해야하고…","text":"Object 클래스는 인스턴스가 생성 가능한 Concrete class이지만 기본적으로 상속해서 사용하도록 설계됐다고 한다.(그 이유는 모르겠지만… 그걸 찾으려면 또 이 장의 범위를 넘어서니 나중에 찾아보자.)따라서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize는)는 모두 메서드 오버라이딩을 염두하고 설계된 메서드이다.따라서 해당 메서드를 오버라이딩 할 때는 각 메서드마다 지켜야할 규칙들이 존재한다.이 규칙을 지키지 않았을 때 뻑나는 경우가 있다.일반적인 클래스들(Collection Framework 등등)은 이러한 규칙들은 지켰겠지~ 하고 작성된 코드들이 많다.따라서 위와 같은 규칙을 지키지 않은 채 오버라이딩을 한 클래스를 사용하면 제대로 동작하지 않을 가능성이 존재한다. 들어가기에 앞서…equals 메서드를 오버라이딩 할 경우는 거의 없다.대부분 핵심 필드의 값이 일치하는지 파악하기 위해서 오버라이딩 할 것이다.그런 경우를 제외하고는 대부분 기본적인 레퍼런스 값 비교만으로도 충분히 비교가 가능하기 때문이다.equals 메서드를 오버라이딩 하는 건 그렇게 어렵지 않지만 몇가지 원칙이 있고, 글의 길이가 짧은 편도 아니고 얻는 수확이 크지 않다. (애초에 오버라이딩 할 일이 거의 없으니…)그래서 지금 당장 오버라이딩을 해야한다! 싶을 때는 두 가지 방법이 있다.내가 당신의 시간을 아껴주겠다.그래도 공부 측면 등등에서 꼭 알아야하는 내용임에는 틀림이 없는 것 같다. 구글에서 만든 AutoValue 사용하기. (권장)아주 사용하기가 간단하다.바로 클래스 위에 @AutoValue 어노테이션만 달아주면 끝이다.(물론 equals, hashCode, toString 메서드까지 다 오버라이딩 해준다.)클래스가 변경돼도 hashCode 쪽 소스코드를 수정할 필요가 없다.얘는 자바 6부터 지원한다. IDEA가 생성해준 소스 코드 사용하기.사람이라면 실수를 하게 되니 IDE의 도움을 절실히 원하게 된다.하지만 클래스가 변하는 경우에 equals 코드도 계속해서 변경해줘야하니 구찮다…또 잘 짰는지 테스트 코드도 짜야하고… 테스트 코드도 변경해야하고… equalsequals 메서드는 오버라이딩 하기 쉬워보이지만 자칫했다가는 규칙을 어길 가능성도 곳곳에 존재한다.따라서 책에서 이런 가능성을 없애는 가장 좋은 방법은 오버라이딩 하지 않는 것이라고 한다.나도 내가 딱히 이런 equals 메서드를 직접 정의해본 기억은 거의 없다. 우선 우리가 오버라이딩 하지 않았을 때는 어떤 비즈니스 로직을 수행하고 있는지 모든 클래스의 부모 격인 Object 클래스의 equals 메서드를 까보자. 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 정말 별 거 없다.그냥 &#x3D;&#x3D; 연산을 통해 레퍼런스를 비교하는 정도이다.만약 클래스의 논리적 동치성(같은 레퍼런스가 아닐지라도 특정 필드의 값이 같다던지… 등등)을 확인하고 싶다면 equals 메서드를 오버라이딩 해야한다.가장 좋은 예가 Integer, String 클래스 등등이다. 123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 위 예는 Integer 클래스의 equals 메서드이다.레퍼런스를 가지고 비교하는 게 아니라 인스턴스가 가지고 있는 value(primitive type인 int)들끼리 비교하고 있다.혹은 인스턴스가 하나 뿐이라고 보장된 클래스(싱글턴)는 레퍼런스 비교만으로도 논리적 동치성을 보장하니 굳이 equals 메서드를 오버라이딩 할 필요가 없다. 그렇다면 equals에 어떤 규칙이 있는지는 아래 문서를 참고해 하나씩 알아보자.https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) equivalence relation(동치 관계) The equals method implements an equivalence relation on non-null object references euqals 메서드는 non-null object 레퍼런스에 대해 equivalence relation(동치 관계)를 구현해야한다. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) 아까부터 논리적 동치성이니, 동치 관계니, 계속 동치 동치 거리는데 일단 동치가 뭔지 알아보자.~~동치미도 아니고…~~~ 책에서는 동치 관계에 대해 아래와 같이 설명하고 있다. 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다. 이 부분집합을 동치류(equivalence class; 동치 클래스)라 한다. equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야한다. 그냥 읽어선 뭔 소린지 모르겠다.그림으로 이해를 해보자. (마우스 없는 환경에서 그리려니까 너무 힘들다…) 위 그림은 아래와 같은 기호를 통해 표현할 수 있다.X = &#123;a, b, c, a, b, c&#125;이제 이 집합 X를 서로 같은 원소들로 이뤄진 부분집합으로 나눠보자. 위 그림은 아래와 같은 기호를 통해 표현할 수 있다. 1234X = &#123;a, b, c, a, b, c&#125;A = &#123;a, a&#125;B = &#123;b, b&#125;C = &#123;c, c&#125; 이제 이 부분집합 A, B, C는 서로 같은 원소들끼리 뭉쳐있으므로 동치류(equivalence class; 동치 클래스)라고 부를 수 있다.equals 메서드가 쓸모 있으려면 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야한다고 한다. 그냥 뭔소린지 모르겠고 그냥 둘이 같아야한다는 걸 뭘 어렵게 풀어쓴 거 같다.수학을 모르니 ㅠㅠ…그럼 동치 관계가 가지는 특성에 대해 하나씩 알아보자. Reflexive(반사성) for any non-null reference value x, x.equals(x) should return true. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) null이 아니고, 참조값 x에 대해서 x.equals(x)는 true를 반환해야한다.위 규칙을 어기는 코드를 바로 작성해보자. 123456public class NotReflexive &#123; @Override public boolean equals(final Object o) &#123; return false; &#125;&#125; 그리고 아래와 같이 테스트 코드를 작성해서 위 규칙을 어겼는지 검증해보자. 12345@Testvoid test() &#123; final var x = new NotReflexive(); assertNotEquals(x, x);&#125; 테스트는 깔끔하게 통과한다. 그럼 이제 위 규칙을 어겼을 때 어떤 오동작을 유발하는지 살펴보자. 123456@Testvoid test() &#123; final var x = new NotReflexive(); final var list = List.of(x); assertFalse(list.contains(x));&#125; reflexive 하지 못한 인스턴스는 List(및 다른 Collection)에 포함돼었는지 제대로 파악할 수 없다.이유는 아래 보다싶이 List 클래스의 contains 메서드는 인스턴스의 equals 메서드를 활용하기 때문이다. 123456789101112131415@Overridepublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;@Overridepublic int indexOf(Object o) &#123; Objects.requireNonNull(o); for (int i = 0, s = size(); i &lt; s; i++) &#123; if (o.equals(get(i))) &#123; return i; &#125; &#125; return -1;&#125; 이런 경우에는 딱히 필드도 없고(극단적인 경우지만) 하니 메서드 오버라이딩 자체를 하지 않으면 문제가 해결된다. Symmetric(대칭성) for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) null이 아니고, 참조값 x와 y에 대해서 x.equals(y)가 true를 반환하면 y.equals(x)도 true를 반환해야한다.위 규칙을 어기는 코드를 바로 작성해보자. 1234567public class NotSymmetric &#123; @Override public boolean equals(final Object o) &#123; if(o instanceof NotSymmetric) return true; return o instanceof String; &#125;&#125; 그리고 아래와 같이 테스트 코드를 작성해서 위 규칙을 어겼는지 검증해보자. 12345678910111213@Testvoid test() &#123; final var x = new NotSymmetric(); // reflexive!! assertEquals(x, x); final var y = &quot;&quot;; // not symmetric!! assertEquals(x, y); assertNotEquals(y, x);&#125; 테스트가 깔끔하게 통과한다.NotSymmetric은 String을 알지만, String은 NotSymmetric을 알지 못하기 때문이다. 그럼 이제 위 규칙을 어겼을 때 어떤 오동작을 유발하는지 살펴보자. 12345678@Testvoid test() &#123; final var x = new NotSymmetric(); final var y = &quot;&quot;; final var list = List.of(y); assertTrue(list.contains(x));&#125; 대칭성이 없는 인스턴스 역시 List(및 다른 Collection)에 포함돼었는지 제대로 파악할 수 없다.이유는 위에서 얘기했다싶이 List 클래스의 contains 메서드는 인스턴스의 equals 메서드를 활용하기 때문이다.x(NotSymmetric)의 잘못 구현된 equals 메서드를 사용하기 때문에 포함되지도 않았는데 포함됐다고 판단하고 있다. 이런 경우에는 String에 대해 비교하는 구문을 아예 없애버리면 해결이된다. Transitive(추이성) for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) null이 아니고, 참조값 x와 y, z에 대해서 x.equals(y)가 true를 반환하고 y.equals(z)가 true를 반환하면, x.equals(z)도 true를 반환해야한다.마치 3단 논법같은 이 명제를 부셔버리는 예제를 작성해보자. 12345678910111213141516171819202122232425public class Parent &#123; @Override public boolean equals(final Object o) &#123; return o instanceof Parent; &#125;&#125;public class NotTransitive extends Parent &#123; private int a; public NotTransitive(final int a) &#123; this.a = a; &#125; @Override public boolean equals(final Object o) &#123; if(!super.equals(o)) return false; // Parent 인스턴스 경우 if(!(o instanceof NotTransitive)) return true; // NotTransitive 인스턴스인 경우 return a == ((NotTransitive) o).a; &#125;&#125; 이제 테스트 코드로 검증을 해보자. 1234567891011121314151617181920@Testvoid test() &#123; final var x = new NotTransitive(1); // reflexive!! assertEquals(x, x); final var y = new Parent(); // symmetric!! assertEquals(x, y); assertEquals(y, x); final var z = new NotTransitive(2); // not transitive!! assertEquals(x, y); assertEquals(y, z); assertNotEquals(x, z);&#125; 위와 같이 transitive하지 못한 경우에도 아래와 같이 당연히 오작동하기 마련이다. 12345678@Testvoid test() &#123; final var x = new NotTransitive(1); final var y = new Parent(); final var list = List.of(x); assertTrue(list.contains(y));&#125; 이를 해결하기 위해서는 Parent 클래스에 equals 메서드에서 instanceof 연산자 대신에 getClass() 메서드를 쓰면 해결된다. (정말?) 123456public class Parent &#123; @Override public boolean equals(final Object o) &#123; return (o != null) &amp;&amp; (o.getClass() == this.getClass()); &#125;&#125; 테스트 코드로 검증을 해보자. 123456789101112131415161718192021222324@Testvoid test() &#123; final var x = new NotTransitive(1); // reflexive!! assertEquals(x, x); final var y = new Parent(); // symmetric!! assertEquals(x, y); assertEquals(y, x); final var z = new NotTransitive(2); // transitive!! assertNotEquals(x, y); assertNotEquals(y, z); assertNotEquals(x, z); final var list = List.of(x); assertFalse(list.contains(y));&#125; 위 테스트에서 문제가 됐던 x.equals(y), y.equals(z), !x.equals(z) 문제는 발생하지 않았고,list.contains() 메서드에서 말썽이 발생했던 문제도 해결됐다. 하지만 이는 논리적 동치성을 검증하지 못했고, 리스코프 치환 원칙을 위배했기 때문에 올바르게 해결했다고 하기 거시기하다… LSP(Liskov substitution principle, 바바라 리스코프란 사람이 만들었다고 함.) 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하고, 따라서 그 타입의 메서드가 하위 타입에서도 똑같이 잘 동작해야한다. 간단한 예를 통해 알아보자.우선 Parent 클래스를 다음과 같이 바꿔보자. 123456789101112public class Parent &#123; private static final List&lt;Parent&gt; z = List.of(new Parent()); @Override public boolean equals(final Object o) &#123; return (o != null) &amp;&amp; (o.getClass() == this.getClass()); &#125; public boolean test(final Parent p) &#123; return z.contains(p); &#125;&#125; 그리고 간단한 테스트 클래스를 통해 의도한 대로 동작하는지 보자. 12345@Testvoid test() &#123; final var x = new Parent(); assertTrue(x.test(x));&#125; 무슨 일을 하는 코드인지는 모르겠지만 우리가 의도한 대로 잘 동작한다.리스코프 치환 원칙을 준수했다면 Parent의 하위 클래스인 NotTransitive 클래스로 타입을 치환해도 정상 동작해야한다. 12345@Testvoid test() &#123; final var x = new NotTransitive(1); assertTrue(x.test(x));&#125; 상위 타입(Parent)에서 하위 타입(NotTransitive)로 치환했는데 테스트가 깨진다.이는 하위 타입인 NotTransitive 클래스를 리스코프 치환 원칙에 위배했다는 증거가 된다.리스코프 치환 원칙은 객체 지향의 5대 원칙 중 하나이므로 이는 객체 지향적으로 설계하지 못했다는 증거가 된다. 그럼 하위 클래스에 필드를 추가하면서 equals 메서드를 오버라이딩 하는데 동치 관계를 준수하면서 객체 지향적으로 설계까지 하는 방법은 없는 걸까?답은 없다.그럼 어떻게 해야할까?하위 클래스(상속)로 만드는 대신에 Composition을 활용하는 것이다. 12345678910111213141516171819202122public class NotTransitive &#123; // 상속을 쓰지 않으니 부모 클래스로 접근할 수 있는 루트를 필드로써 제공하면 된다. private Parent p; private int a; public NotTransitive(final Parent p, final int a) &#123; this.p = p; this.a = a; &#125; // 부모 클래스의 기능을 쓰고 싶다면 이 메서드를 통해 접근하면 된다. public Parent asParent() &#123; return p; &#125; // 논리적 동치성을 검증. @Override public boolean equals(final Object o) &#123; if(!(o instanceof NotTransitive)) return false; return a == ((NotTransitive) o).a; &#125;&#125; 하지만 자바 라이브러리를 보면 하위 클래스에 필드를 추가하면서 equals를 재정의한 경우가 있다.바로 java.util.Date 클래스를 상속 받은 java.sql.Timestamp가 그 예이다.따라서 Timestamp API 문서에는 아래와 같은 문구가 적혀있다. This type is a composite of a java.util.Date and a separate nanoseconds value. Only integral seconds are stored in the java.util.Date component. The fractional seconds - the nanos - are separate. The Timestamp.equals(Object) method never returns true when passed an object that isn’t an instance of java.sql.Timestamp, because the nanos component of a date is unknown. As a result, the Timestamp.equals(Object) method is not symmetric with respect to the java.util.Date.equals(Object) method. Also, the hashCode method uses the underlying java.util.Date implementation and therefore does not include nanos in its computation. 위 클래스는 대칭성을 준수하지 못하고 있다. 12345678910@Testvoid test() &#123; long epochMilli = Instant.now().toEpochMilli(); final var date = new Date(epochMilli); final var timestamp = new Timestamp(epochMilli); // not symmetric!! assertEquals(date, timestamp); assertNotEquals(timestamp, date);&#125; 물론 하위 클래스에 필드를 추가하면서 equals 메서드를 오버라이딩 하는데 동치 관계를 준수하면서 객체 지향적으로 설계하는 경우도 있긴 하다.바로 부모 클래스가 추상 클래스인 경우이다.추상 클래스는 인스턴스를 만들 수 없으므로 위에 얘기했던 문제가 발생하지 않는다. Consistent(일관성) for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) equals 메서드의 결과가 가변 클래스의 경우에는 수정되기 전까지 항상 똑같아야한다. 불변 클래스의 경우에는 항상 똑같아야한다. equals 판단에 신뢰할 수 없는 자원이 끼어있는 경우 일관성을 해칠 수 있다. 그럼 일관성을 준수하지 못하는 경우를 작성해보자. (물론 Reflexive, 대칭성, Transitive도 준수하지 못하지만…) 1234567public class NotConsistent &#123; @Override public boolean equals(final Object o) &#123; if(!(o instanceof NotConsistent)) return false; return Instant.now().toEpochMilli() % 2 == 0; &#125;&#125; equals 판단에 신뢰할 수 없는 자원으로 시간을 넣었다.과연 이 경우에 일관성을 해치는지 검증해보자. 12345678@Testvoid test() &#123; final var x = new NotConsistent(); final var y = new NotConsistent(); // 숫자를 너무 작게하거나 운이 나쁘면 원하는 결과가 안 나올 수도... final var resultSet = IntStream.range(1, 1000000).mapToObj(i -&gt; x.equals(y)).collect(toSet()); assertNotEquals(resultSet.size(), 1);&#125; 하지만 이런 일관성을 깨뜨리면서 equals를 오버라이딩한 경우가 자바 라이브러리에도 존재한다.바로 java.net.URL 클래스가 그 예이다.java.net.URL의 equals 메서드는 URL과 매핑된 IP 주소를 이용해 비교한다.URL을 통해 매핑된 IP 주소를 알아내려면 네트워크를 이용해야한다.하지만 이 네트워크도 equals 판단에 신뢰할 수 없는 자원 중 하나이다.하지만 이 경우에는 하위 호환성 때문에 문제를 고치지 못하고 있다고 한다. null이 아닌 객체는 null과 같지 않아야한다. For any non-null reference value x, x.equals(null) should return false. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object) 이름만 들어도 뭔소린지 바로 파악이 된다.이 지키기 어려운 경우도 바로 아래와 같이 예제를 구현해보자. 1234567public class NotNull &#123; @Override public boolean equals(final Object o) &#123; if(o == null) return true; return o instanceof NotNull; &#125;&#125; 바로 비교하려는 대상이 null일 때 true를 리턴하면 된다. 그럼 이 규칙을 잘 어겼는지 검증해보자. 1234567891011121314151617181920212223242526@Testvoid test() &#123; // reflexive! final var x = new NotNull(); assertEquals(x, x); // symmetric! final var y = new NotNull(); assertEquals(x, y); assertEquals(y, x); // transitive! final var z = new NotNull(); assertEquals(y, z); assertEquals(x, z); // consistent! assertEquals(x, x); assertEquals(x, y); assertEquals(y, x); assertEquals(y, z); assertEquals(x, z); // x is null!! assertEquals(x, null);&#125; 모든 규칙을 지켰는데 null이 아닌 객체는 null과 같지 않아야한다를 지키지 못했으니 위의 경우에는 동치 관계를 준수하면서 equals 메서드를 구현한 게 아니다.간단하게 첫 번째 줄인 if(o == null) return true;만 삭제하면 모든 조건을 만족시키게 되는 것이다.instansof는 null safe한 연산자이기 때문에 굳이 null 체크를 안 해도 NullPointerException을 유발하지 않는다. Best Practice 가장 처음에는 레퍼런스 비교를 하자.애초에 같은 레퍼런스 값을 가진다면 동일한 객체(논리적으로도)로 봐도 무방하다.따라서 뒤에 있을 로직들을 쓸 데 없이 처리하지 않아도 돼서 성능 측면에서 좋아질 것이다. 123public boolean equals(final Object o) &#123; return o == this;&#125; instanceof 연산자로 올바른 타입인지 확인한다.올바른 타입인지 확인하지 않으면 뒤에 나오는 핵심 필드의 값을 비교할 수 없다. 123456public boolean equals(final Object o) &#123; // instanceof 연산자는 null safe 하기 때문에 아래 구문은 필요 없다. // if(o == null) return false; // 혹은 인터페이스를 구현한 것이면 클래스 대신에 인터페이스를 넣어서 비교할 수도 있다. return o instanceof Type;&#125; 올바른 타입으로 형변환 하고, 핵심 필드의 값만 비교하자.모든 필드의 값이 일치하지 않아도 되는 경우에는 모든 필드를 비교하면 성능 상에 좋지 않다.혹은 인터페이스의 구현체라면 인터페이스의 메서드를 사용해서 필드에 접근해야할 것이다. 12345678910public boolean equals(final Object o) &#123; // 올바른 타입인지 비교하지 않으면 ClassCastException을 면치 못할 것이다. if(!(o instanceof Type)) return false; final var obj = (Type) o; // 모든 필드를 비교할 필요는 없고 핵심적인 필드만 비교하면 된다. if(!obj.a.equals(this.a)) return false; return true;&#125; float과 double을 제외한 primitive type은 &#x3D;&#x3D; 연산자를 통해 값을 비교하고,float과 double은 Float.NaN, -0.0D 등등의 특수한 경우 때문에 &#x3D;&#x3D; 연산자로는 비교가 불가능하다.그렇다고 equals 메서드를 통해 비교하면 오토박싱 때문에 성능상 좋지 않을 수도 있으니 compare 메서드를 통해 비교하도록 하자.그 외에 자바가 제공해주는 라이브러리의 경우에는 대부분 동치관계를 준수했을 것이므로 equals 메서드로 비교하자. (이 마저도 주의해서 사용하긴 해야한다.)혹은 특정 타입의 경우에는 null이 아닌 객체는 null과 같지 않아야한다는 원칙을 준수하지 않고 equals 메서드를 오버라이딩 했을 수 있기 때문에 Objects.equals를 쓰는 게 좀 더 안전하긴 하다. 123456789public boolean equals(final Object o) &#123; final var obj = (Type) o; if(obj.a != this.a) return false; if(Double.compare(obj.b, this.b) != 0) return false; if(!(obj.c.equals(this.c))) return false; if(!Objects.equals(obj.d, this.d)) return false; return true;&#125; 특정 필드로부터 값이 추론되는 필드는 검증하지 말자.사각형은 너비(width), 높이(height)만으로 넓이(area)가 결정되기 때문에 너비와 높이만 비교했으면 넓이는 비교할 필요가 없다. 123456789101112131415161718192021222324public class Rectangle &#123; private final double width; private final double height; private final double area; public Rectangle(final double width, final double height) &#123; this.width = width; this.height = height; // width(너비)와 height(높이)를 통해 area(너비)가 결정된다. this.area = width * height; &#125; public boolean equals(final Object o) &#123; final var obj = (Rectangle) o; if(obj.width != this.width) return false; if(obj.height != this.height) return false; // width와 height만 알면 area 값은 자동으로 알 수 있으니 굳이 비교할 필요가 없다. // if(obj.area != this.area) return false; return true; &#125;&#125; 변경 가능성이 높은 필드부터 비교하자.변경 가능성이 높은 필드부터 비교하면 더 빠르게 해당 타입의 논리적 동치성을 검출할 수 있다. 12345678910111213141516171819202122public class Type &#123; private final int a; private int b; public Type(final int b, final int a) &#123; this.b = b; this.a = a; &#125; public void setB(int b) &#123; this.b = b; &#125; public boolean equals(final Object o) &#123; final var obj = (Type) o; // 변경이 불가능한 a를 먼저 검사하기 보단 변경이 가능한 b를 검사해야 더 빠르게 논리적 동치성을 검출할 수 있다. if(obj.b != this.b) return false; if(obj.a != this.a) return false; return true; &#125;&#125; @Override 어노테이션을 사용하자.잘못 오버라이딩 한 경우 컴파일 에러를 내주기 때문에 버그를 최대한 빨리 찾을 수 있다.만약 해당 어노테이션이 없다면 메서드 오버라이딩(재정의)가 아니라 메서드 오버로딩 취급해서 새로운 메서드를 추가한 거라고 생각한다.그리고 새로 추가한 메서드를 통해 equals 메서드를 호출하는 게 아니라 부모 클래스에 있는 원본 클래스의 equals 메서드를 호출하게 된다. 12345// method does not override or implement a method from a supertype@Overridepublic boolean equals(final Type o) &#123; return true;&#125; 위 규칙들을 준수해서 간단하게 equals 메서드를 구현해보자면 아래와 같다. 1234567891011121314151617181920212223242526public class Point &#123; private int x; private int y; private double center; private Color color; public Point(final int x, final int y, final double center, final Color color) &#123; this.x = x; this.y = y; this.center = center; this.color = color; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Point)) return false; final var obj = (Point) o; if(obj.x != this.x) return false; if(obj.y != this.y) return false; if(Double.compare(obj.center, this.center) != 0) return false; if(!Objects.equals(obj.color, this.color)) return false; return true; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"}]},{"title":"(Java8) 날짜와 시간 API","slug":"java8-date-time","date":"2018-09-26T13:36:45.000Z","updated":"2022-10-30T08:42:16.663Z","comments":true,"path":"2018/09/26/java8-date-time/","link":"","permalink":"https://perfectacle.github.io/2018/09/26/java8-date-time/","excerpt":"부끄럽게도 Java8에 나온 날짜와 시간 API를 제대로 모르고 계속해서 사용해왔다.늦었지만 지금이라도 정리를 해봤다. 들어가기에 앞서먼저 날짜와 시간 API는 JSR-310이라고도 불린다.이걸 풀어서 설명하면 JCP(Java Community Process)에서 관리하는 JSR(Java Specification Requests)의 310번 째 Request(?)로Date and Time API이다. 이 API는 현재 표준으로 자리잡았고, 날짜와 시간 관련 라이브러리인 Joda-Time의 창시자인 Joda도 이 API를 만드는데 동참했다.","text":"부끄럽게도 Java8에 나온 날짜와 시간 API를 제대로 모르고 계속해서 사용해왔다.늦었지만 지금이라도 정리를 해봤다. 들어가기에 앞서먼저 날짜와 시간 API는 JSR-310이라고도 불린다.이걸 풀어서 설명하면 JCP(Java Community Process)에서 관리하는 JSR(Java Specification Requests)의 310번 째 Request(?)로Date and Time API이다. 이 API는 현재 표준으로 자리잡았고, 날짜와 시간 관련 라이브러리인 Joda-Time의 창시자인 Joda도 이 API를 만드는데 동참했다. 기존 Date, Calander와 달리 Thread Safe하고, 날짜 연산 관련된 편의 기능이 많고, TimeOffset&#x2F;TimeZone 관련된 기능들도 있어서 글로벌 서비스에서도 적합하다. LocalTime&#x2F;LocalDate&#x2F;LocalDateTime시간대(Zone Offset&#x2F;Zone Region)에 대한 정보가 전혀 없는 API이다.따라서 한국에서 2018-09-07T08:00:04였으면 미국으로 들고가도 2018-09-07T08:00:04이다.이러한 경우는 생일 같은 경우 제일 적합하다.나는 1993-05-30T01:05:30 KST(1993-05-29T06:05:30 HST)에 태어났고, KST(Korea Standard Time)를 사용하는 한국에서 매년 5월 30일에 생일 파티를 했다.하지만 HST(Hawaii Standard Time)를 쓰는 하와이로 갔다고 해서 내 생일 파티를 매년 5월 29일에 하지 않는다.여전히 내 생일 파티는 매년 5월 30일에 할 것이다. 12345678910111213import java.time.LocalDate;import java.time.LocalTime;import java.time.LocalDateTime;public class LocalDateTimeTest &#123; public static void main(String[] args)&#123; // 1993-05-30T01:05:30는 아래와 같이 나타낼 수 있다. final var birthDateTime = LocalDateTime.of(1993, 5, 30, 1, 5, 30); final var birthDate = LocalDate.of(1993, 5, 30); final var birthTime = LocalTime.of(1, 5, 30); final var birthDay = LocalDateTime.of(birthDate, birthTime); &#125;&#125; ZoneOffsetUTC 기준으로 시간(Time Offset)을 나타낸 것이라고 보면 된다.우리나라는 KST를 사용하는데 KST는 UTC보다 9시간이 빠르므로 UTC +09:00으로 표기한다.ZoneOffset은 ZoneId의 자식 클래스이다. 123456789101112131415161718192021222324252627282930313233343536import java.time.ZoneOffset;import java.time.ZoneId;public class ZoneOffsetTest &#123; public static void main(String[] args)&#123; // UTC +09:00은 아래와 같이 나타낼 수 있다. final var zoneOffset = ZoneOffset.of(&quot;+9&quot;); final var zoneOffset2 = ZoneOffset.of(&quot;+09&quot;); final var zoneOffsetIso8601Format = ZoneOffset.of(&quot;+09:00&quot;); final var zoneOffset3 = ZoneOffset.of(&quot;+09:00:00&quot;); final var zoneOffset4 = ZoneId.of(&quot;+9&quot;); final var zoneOffset5 = ZoneId.of(&quot;+09&quot;); final var zoneOffsetIso8601Format2 = ZoneId.of(&quot;+09:00&quot;); final var zoneOffset6 = ZoneId.of(&quot;+09:00:00&quot;); // UTC ±00:00은 아래와 같이 나타낼 수 있다. final var zoneOffset7 = ZoneOffset.of(&quot;+0&quot;); final var zoneOffset8 = ZoneOffset.of(&quot;-0&quot;); final var zoneOffset9 = ZoneOffset.of(&quot;+00&quot;); final var zoneOffset10 = ZoneOffset.of(&quot;-00&quot;); final var zoneOffsetIso8601Format3 = ZoneOffset.of(&quot;+00:00&quot;); final var zoneOffsetIso8601Format4 = ZoneOffset.of(&quot;-00:00&quot;); final var zoneOffsetIso8601Format5 = ZoneOffset.of(&quot;Z&quot;); // Zulu Time final var zoneOffset11 = ZoneOffset.of(&quot;+00:00:00&quot;); final var zoneOffset12 = ZoneOffset.of(&quot;-00:00:00&quot;); final var zoneOffset13 = ZoneId.of(&quot;+0&quot;); final var zoneOffset14 = ZoneId.of(&quot;-0&quot;); final var zoneOffset15 = ZoneId.of(&quot;+00&quot;); final var zoneOffset16 = ZoneId.of(&quot;-00&quot;); final var zoneOffsetIso8601Format6 = ZoneId.of(&quot;+00:00&quot;); final var zoneOffsetIso8601Format7 = ZoneId.of(&quot;-00:00&quot;); final var zoneOffsetIso8601Format8 = ZoneId.of(&quot;Z&quot;); // Zulu Time final var zoneOffset17 = ZoneId.of(&quot;+00:00:00&quot;); final var zoneOffset18 = ZoneId.of(&quot;-00:00:00&quot;); &#125;&#125; ZoneRegionTime Zone을 나타낸 것이라고 보면 된다.KST는 타임존의 이름이고 이를 나타내는 ZoneRegion은 Asia&#x2F;Seoul이다.ZoneRegion은 ZoneId의 자식 클래스이다.하지만 public 클래스가 아니라 외부에서 직접적인 접근은 하지 못해 ZoneId 클래스를 통해서만 생성이 가능하다. 1234567891011121314151617181920import java.time.ZoneId;public class ZoneIdTest &#123; public static void main(String[] args)&#123; // KST는 아래와 같이 나타낼 수 있다. final var zoneId = ZoneId.of(&quot;Asia/Seoul&quot;); final var zoneId2 = ZoneId.of(&quot;UTC+9&quot;); final var zoneId3 = ZoneId.of(&quot;UTC+09&quot;); final var zoneId4 = ZoneId.of(&quot;UTC+09:00&quot;); final var zoneId5 = ZoneId.of(&quot;UTC+09:00:00&quot;); final var zoneId6 = ZoneId.of(&quot;GMT+9&quot;); final var zoneId7 = ZoneId.of(&quot;GMT+09&quot;); final var zoneId8 = ZoneId.of(&quot;GMT+09:00&quot;); final var zoneId9 = ZoneId.of(&quot;GMT+09:00:00&quot;); final var zoneId10 = ZoneId.of(&quot;UT+9&quot;); final var zoneId11 = ZoneId.of(&quot;UT+09&quot;); final var zoneId12 = ZoneId.of(&quot;UT+09:00&quot;); final var zoneId13 = ZoneId.of(&quot;UT+09:00:00&quot;); &#125;&#125; ZoneRulesZoneOffset의 UTC +09:00과 ZoneRegion의 Asia&#x2F;Seoul을 보면 전혀 차이가 없다.그럼 ZoneOffset과 ZoneRegion은 왜 따로 분리돼있는 걸까?좀 더 지역에 특화된, 지명 등등을 넣어서 그 의미를 살리고자 분리가 되거나 한 걸까?이 차이는 DST(Daylight saving time, 서머타임)와 같은 Time Transition Rule을 포함하느냐, 포함하지 않느냐로 갈린다.ZoneOffset은 Time Transition Rule을 포함하지 않는 ZoneRules를 가진다.ZoneRegion은 Time Transition Rule을 포함할 수도, 포함하지 않을 수도 있다. 1234567891011121314151617import java.time.ZoneOffset;import java.time.ZoneId;public class ZoneRulesTest &#123; public static void main(String[] args)&#123; // ZoneOffset이기 때문에 Time Transition Rule이 없기 때문에 아무것도 찍히지 않는다. ZoneOffset.of(&quot;+1&quot;).getRules().getTransitionRules().forEach(System.out::println); // ZoneRegion이지만, Time Transition Rule이 없기 때문에 아무것도 찍히지 않는다. ZoneId.of(&quot;Africa/Brazzaville&quot;).getRules().getTransitionRules().forEach(System.out::println); // ZoneRegion이고, Time Transition Rule이 있기 때문에 내용이 찍힌다. // TransitionRule[Gap +01:00 to +02:00, SUNDAY on or after MARCH 25 at 02:00 STANDARD, standard offset +01:00] // TransitionRule[Overlap +02:00 to +01:00, SUNDAY on or after OCTOBER 25 at 02:00 STANDARD, standard offset +01:00] ZoneId.of(&quot;CET&quot;).getRules().getTransitionRules().forEach(System.out::println); &#125;&#125; 그럼 UTC+01:00인 CET(Central European Time)와 UTC+02:00인 CEST(Central European Summer Time)를 왜 구분하지 않는 것일까?그 이유는 CET와 CEST가 동시에 사용되지 않기 때문이다.CET를 사용하는 모든 나라는 CEST도 사용하고 있고, 겨울에는 CET를, 여름에는 CEST를 사용하기 때문에 절대 동시에 사용하지 않는다. 이런 ZoneRules는 ZonedDateTime과 사용했을 때 진가를 발휘한다. OffsetDateTimeLocalDateTime + ZoneOffset에 대한 정보까지 포함한 API이다.이러한 경우는 축구 경기 생중계 등등에 적합하다. 레알 마드리드와 바르셀로나의 경기인 엘 클라시코 더비의 경우를 살펴보자. 123456789101112131415161718192021222324252627282930313233343536import java.time.OffsetDateTime;import java.time.LocalDateTime;import java.time.ZoneOffset;import java.time.ZoneId;public class OffsetTimeTest &#123; public static void main(String[] args)&#123; final var barca = OffsetDateTime.of(LocalDateTime.of(2018, 5, 6, 20, 45, 0), ZoneOffset.of(&quot;+2&quot;)); // 2018-05-06T20:45+02:00 System.out.println(barca); final var seoul = OffsetDateTime.of(LocalDateTime.of(2018, 5, 7, 3, 45, 0), ZoneOffset.of(&quot;+9&quot;)); // 2018-05-07T03:45+09:00 System.out.println(seoul); // 둘을 UTC로 변환했을 때 같은 시간이기 때문에 둘은 같은 시간이라고 볼 수 있다. // 2018-05-06T18:45Z System.out.println(barca.atZoneSameInstant(ZoneId.of(&quot;Z&quot;))); // 2018-05-06T18:45Z System.out.println(seoul.atZoneSameInstant(ZoneId.of(&quot;Z&quot;))); // 1970-01-01T00:00Z final var unixTimeOfUTC = OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC); // 1970-01-01T00:00+09:00 final var unixTimeOfUTC9 = OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.of(&quot;+9&quot;)); // false, 둘은 다른 ZoneOffset을 가진다. System.out.println(unixTimeOfUTC.equals(unixTimeOfUTC9)); // 1970-01-01T00:00 final var unixTimeOfUTCLocalDateTime = unixTimeOfUTC.toLocalDateTime(); // 1970-01-01T00:00 final var unixTimeOfUTCL9ocalDateTime = unixTimeOfUTC9.toLocalDateTime(); // true, LocalDateTime은 ZoneOffset이 없기 때문에 둘 다 똑같은 걸로 취급한다. System.out.println(unixTimeOfUTCLocalDateTime.equals(unixTimeOfUTCL9ocalDateTime)); &#125;&#125; ZonedDateTimeOffsetDateTime + ZoneRegion에 대한 정보까지 포함한 API이다.UTC +09:00의 Time Offset을 가지는 Time Zone도 여러가지이다. Asia&#x2F;Seoul Asia&#x2F;Tokyo 등등 하지만 시간을 나타내는데 있어서 Asia&#x2F;Seoul을 쓰던 Asia&#x2F;Tokyo를 쓰던 큰 차이점이 없다.OffsetDateTime과의 차이점은 DST(Daylight Saving Time)와 같은 Time Transition Rule을 포함하는 ZoneRegion을 갖고 있는 ZoneRules의 유무이다.독일 등등에서 사용하는 CET(겨울), CEST(여름)는 서머타임을 사용하지 않는 나라에 사는 나 같은 경우에는 굉장히 생소하다.그래서 어떤 때는 CET를 사용해야하고, 어떤 때는 CEST를 사용해야할지 매우 애매하고 계산하기도 까다롭다.자바에서는 이 두 Time Zone을 하나의 Time Zone(CET)로 통일하고 Time Transition Rule을 가지는 ZoneRules를 통해 알아서 내부적으로 계산해준다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.time.OffsetDateTime;import java.time.ZoneId;public class ZonedDateTimeTest &#123; public static void main(String[] args)&#123; // 2018-03-25T01:59:59+01:00[CET] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 3, 25, 1, 59, 59), ZoneId.of(&quot;CET&quot;))); // 2018-03-25T03:00+02:00[CET] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 3, 25, 2, 0, 0), ZoneId.of(&quot;CET&quot;))); // 2018-10-28T02:59:59+02:00[CET] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 10, 28, 2, 59, 59), ZoneId.of(&quot;CET&quot;))); // 2018-10-28T03:00+01:00[CET] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 10, 28, 3, 0, 0), ZoneId.of(&quot;CET&quot;))); // DST 등등의 Time Transition Rule을 사용하지 않는 ZoneRegion이나 ZoneOffset 같은 경우에는 겨울이나 여름이나 UTC 기준 시간이 동일하다. // 2018-06-01T00:00+09:00[Asia/Seoul] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 6, 1, 0, 0, 0), ZoneId.of(&quot;Asia/Seoul&quot;))); // 2018-12-01T00:00+09:00[Asia/Seoul] System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 12, 1, 0, 0, 0), ZoneId.of(&quot;Asia/Seoul&quot;))); // 2018-06-01T00:00+09:00 System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 6, 1, 0, 0, 0), ZoneId.of(&quot;+9&quot;))); // 2018-12-01T00:00+09:00 System.out.println(ZonedDateTime.of(LocalDateTime.of(2018, 12, 1, 0, 0, 0), ZoneId.of(&quot;+9&quot;))); final var zonedDateTimeOfSeoul = ZonedDateTime.of(2018, 1, 1, 0, 0, 0, 0, ZoneId.of(&quot;Asia/Seoul&quot;)); final var zonedDateTimeOfTokyo = ZonedDateTime.of(2018, 1, 1, 0, 0, 0, 0, ZoneId.of(&quot;Asia/Tokyo&quot;)); // false, 둘은 다른 Region에서 사용하는 TimeZone을 사용하고 있기 때문이다. System.out.println(zonedDateTimeOfSeoul.equals(zonedDateTimeOfTokyo)); final var offsetDateTimeOfSeoul = zonedDateTimeOfSeoul.toOffsetDateTime(); final var offsetDateTimeOfTokyo = zonedDateTimeOfTokyo.toOffsetDateTime(); // true, 둘은 같은 Offset에 다른 Region이지만, OffsetDateTime은 ZoneRegion에 대한 정보는 없고 ZoneOffset에 대한 정보만 있기 때문에 동일한 것으로 취급한다. // 같은 Region에서 사용하는 형식인지 아닌지는 알 수 없다. System.out.println(offsetDateTimeOfSeoul.equals(offsetDateTimeOfTokyo)); final var zonedDateTimeOfWinter = ZonedDateTime.of(2018, 1, 1, 0, 0, 0, 0, ZoneId.of(&quot;CET&quot;)); final var zonedDateTimeOfSummer = ZonedDateTime.of(2018, 6, 1, 0, 0, 0, 0, ZoneId.of(&quot;CET&quot;)); // true, 둘 다 CET라는 ZoneRegion이다. System.out.println(zonedDateTimeOfWinter.getZone().equals(zonedDateTimeOfSummer.getZone())); // false, Offset은 겨울에는 +01:00, 여름에는 +02:00이다. System.out.println(zonedDateTimeOfWinter.getOffset().equals(zonedDateTimeOfSummer.getOffset())); final var offsetDateTimeOfWinter = zonedDateTimeOfWinter.toOffsetDateTime(); final var offsetDateTimeOfSummer = zonedDateTimeOfSummer.toOffsetDateTime(); // false, ZoneRegion이 없어서 ZoneOffset을 갖고 구분해야하는데 둘은 같은 Region에서 사용하는 것인데도 불구하고 다른 Offset을 가진다고 판단해서 // OffsetDateTime만으로는 두 날짜가 같은 Region에서 사용하는 건지 아닌지를 알 수 없다. System.out.println(offsetDateTimeOfWinter.getOffset().equals(offsetDateTimeOfSummer.getOffset())); &#125;&#125; Instant어느 순간을 나타내는 클래스이다.Unix Timestamp를 구할 때 사용한다.0 ~ 999,999,999의 integer 범위(Integer는 10억 단위를 전부 제대로 표시하지 못하기 때문에)의 Unix Timestamp Nanosecond와long의 자료형을 가지는 Unix Timestamp Second(2038년 문제를 해결하기 위해 long을 택한 듯)를 가진다. Unix Timestamp를 사용하는 이유는 기본적으로 integer, long 등등의 숫자 자료형을 가지고 연산을 하기 때문에Local&#x2F;Offset&#x2F;ZonedDateTime과 비교했을 때 연산 속도가 훨씬 빠를 것이다.그리고 다양한 NumberUtils의 기능들도 사용할 수 있고, UTC 기준이기 때문에 글로벌한 서비스에서도 매우 적합할 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.time.LocalDateTime;import java.time.ZonedDateTime;import java.time.OffsetDateTime;import java.time.ZoneId;import java.time.ZoneOffset;import java.time.Instant;import java.util.HashSet;import java.util.List;public class InstantTest &#123; public static void main(String[] args)&#123; // 2018-09-26T11:41:56.281466 final var localDateTimeNow = LocalDateTime.now(); // Unix Timestamp는 UTC 기준인데 LocalDateTime은 이런 정보가 하나도 없기 때문에 어떤 Time Zone인지 알려줘야 Unix Timestamp를 구할 수 있다. // Unix Timestamp는 UTC(+00:00)이기 때문에 UTC+09:00인 KST(Asia/Seoul)에서는 9시간을 뺀 시간이 나온다. // 2018-09-26T02:41:56.281466Z final var instantFromAsiaSeoulLocalDateTime = localDateTimeNow.atZone(ZoneId.of(&quot;Asia/Seoul&quot;)).toInstant(); // 2018-09-26T02:41:56.281466Z final var instantFromAsiaSeoulLocalDateTime2 = Instant.from(localDateTimeNow.atZone(ZoneId.of(&quot;Asia/Seoul&quot;))); // Unix Timestamp는 UTC(+00:00)이기 때문에 UTC(+00:00)인 GMT에서는 동일한 시간이 나온다. // 2018-09-26T11:41:56.281466Z final var instantFromGMTLocalDateTime = localDateTimeNow.atZone(ZoneId.of(&quot;GMT&quot;)).toInstant(); // 2018-09-26T11:41:56.281466Z final var instantFromGMTLocalDateTime2 = Instant.from(localDateTimeNow.atZone(ZoneId.of(&quot;GMT&quot;))); // ZonedDateTime은 Time Zone을 가지지만 Unix Timestamp는 UTC 기준이기 때문에 어떤 Time Zone으로 세팅해도 알아서 UTC로 변환한다. // 시스템의 기본 시간이 KST(UTC+09:00)이기 때문에 9시간을 뺀 시간이 나온다. // 2018-09-26T02:41:56.281834Z final var instantFromZonedDateTime = ZonedDateTime.now().toInstant(); // 2018-09-26T02:41:56.281933Z final var instantFromAsiaSeoulZonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;Asia/Seoul&quot;)).toInstant(); // 2018-09-26T02:41:56.281884Z final var instantFromGMTZonedDateTime = ZonedDateTime.now(ZoneId.of(&quot;GMT&quot;)).toInstant(); // OffsetDateTime은 Time Offset을 가지지만 Unix Timestamp는 UTC 기준이기 때문에 어떤 Time Offset으로 세팅해도 알아서 UTC로 변환한다. // 시스템의 기본 시간이 KST(UTC+09:00)이기 때문에 9시간을 뺀 시간이 나온다. // 2018-09-26T02:41:56.281834Z final var instantFromOffsetDateTime = OffsetDateTime.now().toInstant(); // 2018-09-26T02:41:56.281834Z final var instantFromUTC9OffsetDateTime = OffsetDateTime.now(ZoneOffset.of(&quot;+9&quot;)).toInstant(); // 2018-09-26T02:41:56.281834Z final var instantFromUTCOffsetDateTime = OffsetDateTime.now(ZoneOffset.UTC).toInstant(); // 가장 쉽게 시스템의 Unix Timestamp를 구하는 방법이다. // 2018-09-26T02:41:56.281834Z final var instantNow = Instant.now(); // true, LocalDateTime UTC를 빼고 모두 동일하다(시스템 Time Offset이 UTC+09:00인 가정 하에) final var allAreSame = new HashSet&lt;&gt;((List.of(instantFromAsiaSeoulLocalDateTime.getEpochSecond(), instantFromAsiaSeoulLocalDateTime2.getEpochSecond(), instantFromZonedDateTime.getEpochSecond(), instantFromGMTZonedDateTime.getEpochSecond(), instantFromAsiaSeoulZonedDateTime.getEpochSecond(), instantFromOffsetDateTime.getEpochSecond(), instantFromUTCOffsetDateTime.getEpochSecond(), instantFromUTC9OffsetDateTime.getEpochSecond(), instantNow.getEpochSecond()))).size() == 1; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"}],"tags":[{"name":"Time","slug":"Time","permalink":"https://perfectacle.github.io/tags/Time/"},{"name":"Date","slug":"Date","permalink":"https://perfectacle.github.io/tags/Date/"},{"name":"Java8","slug":"Java8","permalink":"https://perfectacle.github.io/tags/Java8/"}]},{"title":"날짜와 시간","slug":"date-and-time","date":"2018-09-26T00:27:20.000Z","updated":"2022-10-30T08:42:16.367Z","comments":true,"path":"2018/09/26/date-and-time/","link":"","permalink":"https://perfectacle.github.io/2018/09/26/date-and-time/","excerpt":"GMT(Greenwich Mean Time) vs. UTC(Coordinated Universal Time)세계 표준 시간 관련해서 위 두 키워드가 자주 나오길래 구글에서 검색해보았다. There is no time difference between Greenwich Mean Time and Coordinated Universal Time.6:13 AM Tuesday, Greenwich Mean Time (GMT) is 6:13 AM Tuesday, Coordinated Universal Time (UTC) 둘의 차이점이 없다고 한다.그래서 다른 사이트를 뒤져보았다.","text":"GMT(Greenwich Mean Time) vs. UTC(Coordinated Universal Time)세계 표준 시간 관련해서 위 두 키워드가 자주 나오길래 구글에서 검색해보았다. There is no time difference between Greenwich Mean Time and Coordinated Universal Time.6:13 AM Tuesday, Greenwich Mean Time (GMT) is 6:13 AM Tuesday, Coordinated Universal Time (UTC) 둘의 차이점이 없다고 한다.그래서 다른 사이트를 뒤져보았다. GMT is a time zone and UTC is a time standard.Although GMT and UTC share the same current time in practice.https://www.timeanddate.com/time/gmt-utc-time.html Time Zone과 Time Standard인 게 차이라는데…둘의 차이는 무엇일까… 찾아보았다. Time Zone세계에는 다양한 Time Zone이 존재한다.우선 우리나라에서 사용하는 KST(Korea Standard Timezone), 하와이에서 사용하는 HST(Hawaii Standard Time), UK 등등에서 사용하는 GMT 등등이 있다. GMT(Greenwich Mean Time) GMT is a time zone officially used in some European and African countries.The time can be displayed using both the 24-hour format (0 - 24) or the 12-hour format (1 - 12 am&#x2F;pm).https://www.timeanddate.com/time/gmt-utc-time.html 뭐, 유럽과 아프리카 쪽에서 주로 사용되는 타임존이란다.의문점은 왜 0 ~ 23이 아니라 0 ~ 24라고 표기했을까…0 ~ 23이라고 표기하는 국가도 있고, 1 ~ 24라고 표기하는 국가도 있어서 그런 걸까…?뭐, 짜치는 문제이므로 건너 뛰자. Greenwich는 영국에 위치한 도시이고, 경도(longitude)가 0도인 곳이다.다른 경도가 0인 도시도 많을텐데 아마 이런 표준을 제정할 때 영국이 강대국이었을 것이고, 지리 및 정치 기타 등등의 요소로 인해 Greenwich가 선정된 게 아닐까 싶다. GMT is based on the Earth’s motion, mainly its daily rotation. The day is the “mean (average) solar day” of 86,400 (mean solar) seconds. That’s simply 24 hours of 60 minutes, each with 60 seconds. https://www.quora.com/What-is-difference-between-GMT-and-UTC GMT는(아마 다른 타임존들도 동일할 것이다.) 지구의 자전(daily rotation)을 기반으로 한다.따라서 하루(The day)는 지구의 자전을 의미하고, 지구의 자전 주기를 86,400으로 나눈 단위를 초(Second)라고 부른다.즉, 천재지변의 사유로 지구의 자전 주기가 조금 느려졌다 하더라도 하루는 86,400초로 동일하다.초의 단위가 절대적이지 않음을 의미한다. Time Standard세계 어디서나 사용할 수 있는 시간의 표준을 의미한다.그 대표는 어디를 기준으로 해야할까?시간은 경도(longitude)에 따라 달라지지, 위도(longitude)에 따라 달라지지 않는다.따라서 경도가 0°인 곳을 기준으로 하다보니 GMT가 Time Standard로 선정됐었다.과거형이니 현재는 GMT가 Time Standard가 아님을 의미한다.현재는 UTC가 Time Standard라는 뜻이다.왜 GMT는 Time Standard에서 탈락하게 된 것일까…? UT(Universal Time) Universal Time (UT) was created at the International Meridian Conference in 1884. This is the basis for the 24-hour time zone system we know today. At the time, Greenwich Mean Time (GMT) was chosen as the world’s time standard. https://www.timeanddate.com/time/aboututc.html 1884년에 UT(24시간 시스템의 기본)가 만들어졌다.이 때 선정된 표준 시간(Time Standard)이 GMT이다. GMT에서 UTC로… In 1960, the International Radio Consultative Committee formalized the concept of UTC, and it was put into practice the year after.The name Coordinated Universal Time was officially adopted in 1967.UTC was adjusted several times until 1972.https://www.timeanddate.com/time/aboututc.html UTC는 1972년까지 여러 번 제정되었다. Until 1972, Greenwich Mean Time (also known as Zulu time) was the same as Universal Time (UT).Since then, GMT is no longer a time standard.Today, Greenwich Mean Time (GMT) is only the name of a time zone.https://www.timeanddate.com/time/aboututc.html 동시에 1972년부터 GMT는 Time Standard의 자리를 박탈당하고 일개 Time Zone에 불과하게 되었다. UTC(Coordinated Universal Time) UTC is not a time zone, but a time standard that is the basis for civil time and time zones worldwide.This means that no country or territory officially uses UTC as a local time.https://www.timeanddate.com/time/gmt-utc-time.html GMT와는 달리 세계에서 공통적으로 쓰이는 **시간 표준(time standard)**이란다.KST, GMT와 같이 현지 시간을 반영한 Time Zone과 달리 UTC는 현지 시간(local time)이 반영되지 않은, 즉 Time Zone에 얽매이지 않는 게 특징이다.그래서 세계 표준 시간을 언급할 때 UTC가 많이 언급되는 것 같다. UTC is almost the same as GMT, but it’s based on the scientific definition of a second (the SI second), which does not depend on the time it takes the Earth to rotate. The day length, based on UTC, is also 86,400 seconds, but they are SI seconds. The “mean solar day” is about 86,400.002 “SI seconds”. That difference is very slowly increasing as the rotation period of Earth very slowly increases. https://www.quora.com/What-is-difference-between-GMT-and-UTC UTC는 지구의 자전(the Earth to rotate)에 기반하지 않고, SI 기준의 초(이하 SI Second)에 기반하고 있다.즉 UTC에서는 하루(The day length)는 SI Second로 86,400초이다.절대적인 기준으로 하루를 세기 때문에 GMT(지구의 자전을 기반으로 하는)와는 미세한 차이가 존재한다.이를 보정하기 위해 UTC에서는 윤초(Leap Second)라는 개념을 도입했다. UTC를 위에 Coordinated Universal Time라고 적어놨는데 왜 UTC라고 줄여서 부르는 걸까…?원래 UTC는 표준 명칭이 CUT(Coordinated Universal Time in English), TUC(Temps Universel Coordonné in French)로 두 개였다.혼란을 줄이기 위해 표준을 정해야하는데 한 쪽의 손을 들어주면 정치적 싸움판이 될테므로 아마 둘 다 택하지 않고 쌩뚱맞은 UTC로 간 게 아닐까… 싶다.하지만 왜 Universal Coordinated Time이 아닌 Coordinated Universal Time이라고 부르는지는 잘 모르겠다…영어가 불어보다는 글로벌하기 때문에 풀네임은 영어권의 손을 들어준 것일까…? Zulu Time Zulu (short for “Zulu time”) is used in the military and in navigation generally as a term for Universal Coordinated Time (UCT), sometimes called Universal Time Coordinated ( UTC ) or Coordinated Universal Time (but abbreviated UTC), and formerly called Greenwich Mean Time. https://whatis.techtarget.com/definition/Zulu-Zulu-time 짧게는 Zulu라고 부르고, 군사적이나 배, 비행기 항법 등등에서 주로 사용한다. Zulu Time Zone (Z) has no offset from Coordinated Universal Time (UTC). Zulu Time Zone is often used in aviation and the military as another name for UTC +0. https://www.timeanddate.com/time/zones/z UTC +0(GMT가 아니다)의 또다른 이름으로 이해하면 될 것 같다. 그래서 우리나라는…?우리나라는 **KST(Korea Standard Time)**를 사용하고 있다.KST는 UTC에 9시간을 더한 시간으로 UTC +9 와 같이 표기하고 있다.그리고 UTC +9을 사용하는 나라가 더 있는데 대표적으로 일본이 있다.하지만 KST는 우리나라에서나 사용하지, 일본에서는 **JST(Japan Standard Time)**를 사용하고 있다.따라서 일본과 우리나라는 세계 시간이 동일하다. 또한 영토가 좌우로 쭉 뻗은 미국 같은 경우에는 여러 타임존(HST(Hawaii Standard Time), PDT(Pacific Daylight Time) 등등)을 사용하고 있다. 이러한 사유로 AWS RDS의 기본 타임존은 UTC이고, 우리는 현재 시간을 저장(now())했다고 판단했는데 DB에 저장된 시간을 보면 9시간 이전의 시간이 저장된 사례를 볼 수 있다.이게 바로 우리나라가 UTC +9인 KST를 사용하고 있기 때문이다. ISO-8601 - Date and time formatISO(International Organization for Standardization)는 세계에서 인정하는 표준을 정의하는 기관이다.이 기관에서 시간과 날짜에 관한 표준을 지정하였는데 이게 이 기관에서 정한 8601번 째 표준이라는 의미이다.자바를 비롯해서 많은 프로그래밍 언어에서 날짜와 시간을 표기할 때 위 표준을 준수하고 있다. 사진에서 보다싶이 동아시아권(한국, 일본, 중국 등등)에서는 연-월-일의 순서로 표기한다.하지만 다른 많은 나라에서는 일-월-연, 월-일-연 등등 아주 다양하게 쓰고 있다.우리나라에서는 1970년 01월 02일을 표기할 때 1970-01-02이지만, 미국에서는 02-01-1970이 된다.이런 혼란을 줄이고자 ISO 8601이 나오게 된 것이다. 기본적인 규칙은 다음과 같다. 큰 단위부터 작은 단위로(연 월 일 시 분 초) 표기한다. 0 ~ 9의 숫자는 00 ~ 09와 같이 표기한다. 날짜는 **-**을 구분자(delimiter)로 사용하고, 시간은 **:**을 구분자(delimiter)로 사용한다. Time Zone(KST, GMC 등등) 대신에 UTC를 기준으로 시간대를 ±기호를 사용해서 표기한다. 포스팅 날짜 및 시간인 2018년 9월 26일 00시 10분 13초 KST를 ISO 8601 표기법으로 나타내면 다음과 같다.2018-09-26T00:10:13+09:002018-09-25T15:10:13+00:002018-09-25T15:10:13Z여기서 T는 날짜와 시간의 구분자(delimiter)이고, Z는 Zulu Time을 의미한다. 꼭 날짜와 시간을 함께 표시할 필요는 없고 날짜만 표기해도 ISO 8601 표준을 준수했다고 볼 수 있다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"Time","slug":"Time","permalink":"https://perfectacle.github.io/tags/Time/"},{"name":"Date","slug":"Date","permalink":"https://perfectacle.github.io/tags/Date/"},{"name":"UTC","slug":"UTC","permalink":"https://perfectacle.github.io/tags/UTC/"},{"name":"GMT","slug":"GMT","permalink":"https://perfectacle.github.io/tags/GMT/"},{"name":"Zulu","slug":"Zulu","permalink":"https://perfectacle.github.io/tags/Zulu/"}]},{"title":"Unix Timestamp","slug":"unix-timestamp","date":"2018-09-25T23:05:08.000Z","updated":"2022-10-30T08:42:16.999Z","comments":true,"path":"2018/09/25/unix-timestamp/","link":"","permalink":"https://perfectacle.github.io/2018/09/25/unix-timestamp/","excerpt":"들어가기 앞서 Unix Timestamp의 동의어를 살펴보자. Epoch Posix Time Epoch Posix Timestamp Epoch Unix Time Epoch Unix Timestamp Posix Epoch Posix Epoch Time Posix Epoch Timestamp Posix Time Posix Timestamp Unix Epoch Unix Epoch Time Unix Epoch Timestamp Unix Time Unix Timestamp 그냥 Epoch, Unix, Posix, Time, Timestamp 등의 조합으로 이뤄진 것 같다… Epoch가 뭐지?","text":"들어가기 앞서 Unix Timestamp의 동의어를 살펴보자. Epoch Posix Time Epoch Posix Timestamp Epoch Unix Time Epoch Unix Timestamp Posix Epoch Posix Epoch Time Posix Epoch Timestamp Posix Time Posix Timestamp Unix Epoch Unix Epoch Time Unix Epoch Timestamp Unix Time Unix Timestamp 그냥 Epoch, Unix, Posix, Time, Timestamp 등의 조합으로 이뤄진 것 같다… Epoch가 뭐지? An epoch means an instant in time chosen as the origin of a particular era. The “epoch” then serves as a reference point from which time is measured. Time measurement units are counted from the epoch so that the date and time of events can be specified unambiguously. https://www.symantec.com/connect/articles/what-epoch-time-and-how-convert-human-understandable-format 시간을 측정하는 기준점을 Epoch라고 부르는 것 같다. In a machine, time is represented by a counter: At the center of a system is a quartz-crystal heart that pulses every second, and each second is added to the count. For a computer to have any comprehension of now, it must determine how many seconds have elapsed since then – and the earliest then is called the “epoch,” or the theoretical time the clock began ticking. https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/ PC에서 시간은 카운터로 표시되고, 매 초마다 카운트가 증가한다.컴퓨터는 현재 시간(now)을 알려면 “epoch”라고 불리는 것으로부터 얼마나 흘렀는지 알아야한다. 그래서 그게 뭔데?ISO 8601 표기법 1970-01-01T00:00:00Z 기준으로 현재까지 몇 초가 지났는지를 나타내는 것이다.윤초(Leap Second)는 포함하지 않는다.1970-01-01T00:00:00Z는 Unix Timestamp가 0이고, 1970-01-01T00:00:01Z은 Unix Timestamp가 1이고, 1969-12-31T23:59:59Z는 Unix Timestamp가 -1이다. 왜 1970년 01월 01일 00시 00분 00초를 기준으로 했을까?Unix의 10억 초 문제를 기념해 2001년 9월 8일에 쓰여진 UNIX TICK TOCKS TO A BILLION의 기사를 찾아보니 그 설명이 나온다. The Unix epoch is midnight on January 1, 1970. It’s important to remember that this isn’t Unix’s “birthday” – rough versions of the operating system were around in the 1960s. Instead, the date was programmed into the system sometime in the early 70s only because it was convenient to do so, according to Dennis Ritchie, one the engineers who worked on Unix at Bell Labs at its inception. Unix Epoch(Unix OS에서 사용되는 Epoch)는 Unix OS의 탄생일이 아니다. (이미 1960년대에 Unix의 대략적인 버전은 이미 존재했다는 것 같다.)그냥 1970년이 프로그래밍 하기 편리해보여서 지정한 걸로 보인다. “At the time we didn’t have tapes and we had a couple of file-systems running and we kept changing the origin of time,” he said. “So finally we said, ‘Let’s pick one thing that’s not going to overflow for a while.’ 1970 seemed to be as good as any.” 그냥 1970년이 진짜 날짜&#x2F;시간을 계산하기에 당분간 편리해보여서 선택했다고 한다.왜 당분간일까? 2038년 문제위에 언급한 10억 초 문제를 비롯해 497일 문제 등등이 있지만 여기서는 2038년 문제만 다뤄보겠다. 이는 32bit Integer의 Overflow 현상을 이해하면 된다.Unix Timestamp가 만들어질 당시 대부분 32bit OS 밖에 존재하지 않았다.32bit Integer의 범위는 −2,147,483,648 (−2³²) ~ 2,147,483,647 (2³¹ − 1)이다.Unsigned Integer를 사용할 경우 부호를 없애서 0 ~ 4,294,967,295 (2³² − 1)까지 가능하지만 1970-01-01T00:00:00Z 이전을 나타낼 수 없으므로 어쩔 수 없이 Signed Integer를 사용했다.따라서 1970-01-01T00:00:00Z에서 2,147,483,647초를 더하면 2038-01-19T03:14:07Z인데(Unix Timestamp 2,147,483,647),여기서 1초가 추가된 2038-01-19T03:14:08Z이 되는 순간 Unix Timestamp 0이 되어 시스템은 1970-01-01T00:00:00Z와 동일한 시간으로 인식한다.즉, 타임머신을 돌렸다고 보면 된다. 그냥 와, 타임머신 탔다~ 신기하다~로 끝나는 게 아니다.대부분의 서버는 Unix 기반(Linux도 Unix 기반이고 Mac OS도 Unix 기반이므로 시스템의 시간을 나타낼 때 Unix Timestamp를 사용한다.)이기 때문에현재 시간이 1970년대로 표시되고, 시간을 처리하는 로직들(금융권, 각종 행정 처리, 특정 기간 동안의 이벤트 등등)이 망가질 것이다. 해결책으로는 아주~ 간단하게 생각했을 때 64bit OS를 사용하면 해결될 일이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"Time","slug":"Time","permalink":"https://perfectacle.github.io/tags/Time/"},{"name":"Unix","slug":"Unix","permalink":"https://perfectacle.github.io/tags/Unix/"}]},{"title":"(AWS) Security Group에서 다른 Security Group을 참조하는 경우","slug":"aws-security-group-reference-another-security-group","date":"2018-08-30T03:41:08.000Z","updated":"2022-10-30T08:42:16.135Z","comments":true,"path":"2018/08/30/aws-security-group-reference-another-security-group/","link":"","permalink":"https://perfectacle.github.io/2018/08/30/aws-security-group-reference-another-security-group/","excerpt":"상황결제 서비스는 아래와 같은 접근 경로를 허용해야한다. 사내 결제 서비스 개발자의 작업 공간 A라는 웹 서비스 따라서 아래와 같은 Security Group을 가져야한다.","text":"상황결제 서비스는 아래와 같은 접근 경로를 허용해야한다. 사내 결제 서비스 개발자의 작업 공간 A라는 웹 서비스 따라서 아래와 같은 Security Group을 가져야한다. Type Protocol Port Range Source Description HTTPS TCP 443 12.34.44.12&#x2F;32 Developer Home HTTPS TCP 443 13.44.12.55&#x2F;32 Developer Cafe HTTPS TCP 443 22.33.44.11&#x2F;32 Office HTTPS TCP 443 77.33.44.22&#x2F;32 A Web Service 또한 인증 서비스는 아래와 같은 접근 경로를 허용해야한다. 사내 개발자의 작업 공간 B라는 웹 서비스 따라서 아래와 같은 Security Group을 가져야한다. Type Protocol Port Range Source Description HTTPS TCP 443 12.34.44.12&#x2F;32 Developer Home HTTPS TCP 443 13.44.12.55&#x2F;32 Developer Cafe HTTPS TCP 443 22.33.44.11&#x2F;32 Office HTTPS TCP 443 41.22.44.22&#x2F;32 B Web Service 결제 서비스의 Security Group과 인증 서비스의 Security Group은 어떤 웹 서비스에서 접근해야하느냐만 다르고, 나머진 동일하다.위와 같은 문제는 개발자나 사내의 IP(즉 공통된 부분)이 변경됐을 때 각 시큐리티 그룹을 일일이 찾아서 수정해줘야한다는 문제점이 존재한다. 따라서 먼저 공통 부분을 Security Group으로 뺏다. (id는 sg-workaround라고 가정)이렇게 하면 공통된 부분이 변경됐을 때 일일이 찾아다녀도 되지 않는다는 장점이 존재한다. Type Protocol Port Range Source Description HTTPS TCP 443 12.34.44.12&#x2F;32 Developer Home HTTPS TCP 443 13.44.12.55&#x2F;32 Developer Cafe HTTPS TCP 443 22.33.44.11&#x2F;32 Office 그리고 다시 결제 서비스 Security Group을 만들었다. Type Protocol Port Range Source Description HTTPS TCP 443 sg-workaround Developer + Office HTTPS TCP 443 77.33.44.22&#x2F;32 A Web Service 그리고 다시 인증 서비스 Security Group을 만들었다. Type Protocol Port Range Source Description HTTPS TCP 443 sg-workaround Developer + Office HTTPS TCP 443 41.22.44.22&#x2F;32 B Web Service Security Group을 리팩토링(?)해서 공통된 부분을 추출해서 장애의 가능성을 좀 더 줄였다.하지만 위와 같이 작동을 할까?답은 아니다. 문제 해결Security Group의 Source 부분에 다른 Security Group을 추가하는 것은 중첩이나 상속 등등을 의미하지 않는다.Security Group에서 다른 Security Group을 참조하는 경우가 어떨 때 쓰는 건지는 좀 이따 설명하겠다.우리는 우선 위 문제부터 해결해보자. 우선 공통된 부분을 따로 빼야한다는 사실은 변하지 않는다. (id는 sg-workaround라고 가정)이렇게 하면 공통된 부분이 변경됐을 때 일일이 찾아다녀도 되지 않는다는 장점이 존재한다. Type Protocol Port Range Source Description HTTPS TCP 443 12.34.44.12&#x2F;32 Developer Home HTTPS TCP 443 13.44.12.55&#x2F;32 Developer Cafe HTTPS TCP 443 22.33.44.11&#x2F;32 Office 그리고 결제 서비스에서만 차이점을 가지는 서버들을 시큐리티 그룹에 추가해주자. (id는 sg-payment라고 가정) Type Protocol Port Range Source Description HTTPS TCP 443 77.33.44.22&#x2F;32 A Web Service 그리고 인증 서비스에서만 차이점을 가지는 서버들을 시큐리티 그룹에 추가해주자. (id는 sg-auth라고 가정) Type Protocol Port Range Source Description HTTPS TCP 443 41.22.44.22&#x2F;32 B Web Service 그리고 결제 서비스의 Security Group에는 sg-workaround, sg-payment 두 개를 적용하고,인증 서비스의 Security Group에는 sg-workaround, sg-auth 두 개를 적용해주면 된다. 이거보다 더 나은 방법이 있으면 댓글 남겨주시면 감사하겠습니다 :) Security Group에서 다른 Security Group을 참조하는 경우시큐리티 그룹을 source에 왜 할당할 수 있는 걸까??Elastic Load Balancer(AWS에서 제공하는 Load Balancer라고 보면 됨, 이하 ELB) - EC2(AWS에서 제공하는 웹 서버라고 보면 됨) 구조를 이해하면 편하다.여기서 가정할 것은 ELB는 public subnet에 있어서 외부에서 바로 접근이 가능해야하고,EC2 인스턴스는 private subnet에 있어서 외부에서 접근이 불가능 하고, 오직 ELB를 통해서만 접근이 가능하다는 점이다. 우선 ELB의 Security Group부터 구성해보자. (id는 sg-elb라고 가정.) Type Protocol Port Range Source Description HTTPS TCP 443 0.0.0.0&#x2F;0 public access EC2 인스턴스로는 다이렉트로 요청이 오는 게 아니라 무조건 ELB를 통해서 온다.ELB와 EC2 사이의 통신은 private network를 통해 이뤄지므로 외부로 패킷이 새어나갈 일이 거의 없다고 보면 된다.따라서 EC2 인스턴스와 ELB 사이의 통신은 HTTPS일 필요가 없으므로 EC2에는 TLS(SSL) 인증서를 붙일 필요도 없고, ELB의 http 포트(80번)만 열어주면 되고,ELB의 IP를 EC2 인스턴스의 시큐리티 그룹으로 추가해주면 된다. AWS에서는 ELB가 죽으면 서비스가 죽는 걸(SPOF, Single Point of Failure) 방지하고자 ELB까지 이중화했다.AWS의 이런 세심한 배려 덕분에 우리는 EC2의 Security Group을 다음과 같이 구성하면 된다.Network Load Balancer의 경우에는 Elastic IP(AWS에서 제공하는 고정 IP, 이하 EIP)를 설정하고 그것만 등록하면 된다. Type Protocol Port Range Source Description HTTP TCP 80 13.124.xxx.124&#x2F;32 ELB 1 HTTP TCP 80 13.209.xxx.125&#x2F;32 ELB 2 하지만 위와 같이 설정해도 다음과 같은 문제가 존재한다.시간이 지나면 ELB의 ip는 변한다.또한 우리는 Public DNS를 가지고 nslookup 명령어를 때려서 ip 주소를 가져왔다.Public DNS를 가지고 온 ip는 Public ip이다. (13.124.xxx.124, 13.209.xxx.125)ELB와 EC2 사이의 통신은 private network를 통해 이뤄지므로 ELB의 private ip가 Security Group에 추가돼야한다.하지만 우리는 ELB의 private ip를 알 방법이 없다. 방법이 없는 것은 아니다.private ip는 서브넷의 cidr block 안에서 생성된다.따라서 elb가 존재하는 public subnet의 cidr block을 설정하면 된다. (여기서는 cidr block을 가정하겠다.) Type Protocol Port Range Source Description HTTP TCP 80 10.0.1.0&#x2F;24 Public Subnet 위와 같이 설정하면 ELB를 통해서 접속은 된다.하지만 한 가지 문제점이 존재한다.해당 서브넷의 모든 리소스가 EC2 인스턴스에 접근이 가능하다는 문제점이 존재한다. private ip는 고정할 수 없고, ELB의 private ip는 알 방법이 없는데 어떻게 해당 ELB만 EC2에 접근할 수 있게 설정할 수 있을까?해답은 바로 EC2의 Security Group에 ELB의 Security Group을 추가하는 것이다. Type Protocol Port Range Source Description HTTP TCP 80 sg-elb ELB 위와 같이 설정하면 sg-elb를 사용하는 리소스를 통과한 호스트들만 EC2로 다시 통과할 수 있게 되는 구조다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"Security Group","slug":"Security-Group","permalink":"https://perfectacle.github.io/tags/Security-Group/"}]},{"title":"YAML","slug":"yaml","date":"2018-08-19T13:56:20.000Z","updated":"2022-10-30T08:42:17.023Z","comments":true,"path":"2018/08/19/yaml/","link":"","permalink":"https://perfectacle.github.io/2018/08/19/yaml/","excerpt":"YAML YAML Ain’t Markup LanguageYAML is a human friendly data serialization standard for all programming languages. YAML은 마크업 언어가 아니고, 사람에게 친숙한 데이터 Serializaition 표준이다.아마 XML, HTML과 같이 YAML도 ML이 들어가서 사람들의 오해를 샀던 모양이다.마크업 언어는 태그를 이용하여 문서나 데이터의 구조를 표현하는 언어이다. (HTML, XML)Serialization(직렬화)은 데이터를 시스템 외부(파일로 쓰거나 네트워크로 전송하거나)에서 사용할 때 사용한다. (Byte Array, JSON, YAML)","text":"YAML YAML Ain’t Markup LanguageYAML is a human friendly data serialization standard for all programming languages. YAML은 마크업 언어가 아니고, 사람에게 친숙한 데이터 Serializaition 표준이다.아마 XML, HTML과 같이 YAML도 ML이 들어가서 사람들의 오해를 샀던 모양이다.마크업 언어는 태그를 이용하여 문서나 데이터의 구조를 표현하는 언어이다. (HTML, XML)Serialization(직렬화)은 데이터를 시스템 외부(파일로 쓰거나 네트워크로 전송하거나)에서 사용할 때 사용한다. (Byte Array, JSON, YAML) Spring에서는 YAML Parser인 SnakeYAML이 내장돼있다.따라서 YAML 파일을 POJO로 매핑할 수도 있고, Configuration 파일에서도 사용할 수 있다.주의사항은 Spring에 내장된 SankeYAML은 YAML 1.1 스펙을 구현한 점이다. Node.js 기반의 블로그 프레임워크인 Hexo에서도JS-YAML이라는 YAML Parser를 이용해 Configuration을 설정하고 있다.JS-YAML은 Python의 YAML Parser인 PyYAML을 포팅하면서 처음에는 YAML 1.1 스펙을 지원했는데, 현재는 YAML 1.2 스펙까지 구현했다. YAML vs. JSON JSON’s foremost design goal is simplicity and universality.Thus, JSON is trivial to generate and parse, at the cost of reduced human readability.In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures.Thus, YAML allows for extremely readable files, but is more complex to generate and parse. JSON의 최우선 설계 목표는 간편성과 보편성이다. 따라서 JSON은 가독성을 조금 떨어트리는 대신에 생성 및 파싱이 용이하다.반면에 YAML의 최우선 설계 목표는 가독성과 데이터 구조 Serialization이다. 따라서 YAML은 사람이 읽기 쉬운 반면에 생성 및 파싱이 JSON 보다 복잡하다. YAML can therefore be viewed as a natural superset of JSON.This is also the case in practice; every JSON file is also a valid YAML file.This makes it easy to migrate from JSON to YAML if&#x2F;when the additional features are required. YAML을 JSON의 Superset으로 볼 수도 있다.모든 JSON 파일은 유효한 YAML 파일이다.따라서 JSON에서 YAML로 마이그레이션 하기가 용이하다. 가독성YAML 홈페이지 조차도 아래와 같이 유효한 YAML 문법으로 이루어져있다. 12345678%YAML 1.2---Projects: C/C++ Libraries: - libyaml # &quot;C&quot; Fast YAML 1.1 - libcyaml # YAML de/serialization of C data structures (using libyaml) - Syck # (dated) &quot;C&quot; YAML 1.0 - yaml-cpp # C++ YAML 1.2 implementation 과연 JSON 형태로 YAML 홈페이지를 가독성 좋게 표현할 수 있었을까…? 12345&#123; &quot;Projects&quot;: &#123; &quot;C/C++ Libraries&quot;: [&quot;libyaml&quot;, &quot;libcyaml&quot;, &quot;Syck&quot;, &quot;yaml-cpp&quot;] &#125;&#125; 퍼포먼스 JSON It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments. JSON 보다 YAML의 모델이 좀 더 복잡하기 때문에 파싱하고 생성하는데 YAML이 더 느리다.속도도 느린데 직접 파싱을 한다고 생각해도 JSON이 훨씬 간단하다. 용도 대부분의 웹 기술(AJAX 등등)에서 데이터 통신을 위해서 성능을 위한 것인지는 잘 모르겠지만 대부분 JSON을 많이 사용하고,reference가 있는 YAML은 복잡한 object 구조를 표현하는데 적합해서, 오프라인에서 data serialization을 위해 더 적합하다. 파이썬 커뮤니티에서는 &#123; &#125; [ ] : ,과 같은 Indicator 보다는 파이썬 문법과 비슷한 indent로 indicate level을 구분하는 YAML을 더 선호하고,자바스크립트 진영에서는 별도의 파서가 필요없고, Javascript Object와 구조가 유사한 JSON을 선호하는 편이다. 그 외. JSON은 주석이 없다. YAML은 한 파일에 여러 Document를 표현할 수 있다. JSON’s RFC4627 requires that mappings keys merely “SHOULD” be unique, while YAML insists they “MUST” be.Technically, YAML therefore complies with the JSON spec, choosing to treat duplicates as an error.In practice, since JSON is silent on the semantics of such duplicates, the only portable JSON files are those with unique keys, which are therefore valid YAML files. JSON은 Key의 중복을 Warning으로 표시하지만, YAML은 허용하지 않는다. YAML vs. XML two languages may actually compete in several application domains, there is no direct correlation between them. YAML is primarily a data serialization language. XML was designed to be backwards compatible with the Standard Generalized Markup Language (SGML), which was designed to support structured documentation. XML과 YAML은 전혀 연관이 없다.XML은 구조화된 문서를 위해 설계된 언어이고, YAML은 data serialization을 위해 설계된 언어이다. Version 1.2 Specification1.1에서 1.2로 바뀐 주요 사항은 JSON의 Superset처럼 동작하기 위해서 많은 사항들이 바뀌었다. All other characters, including the form feed (#x0C), are considered to be non-break characters. Note that these include the non-ASCII line breaks: next line (#x85), line separator (#x2028) and paragraph separator (#x2029). YAML version 1.1 did support the above non-ASCII line break characters; however, JSON does not. Hence, to ensure JSON compatibility, YAML treats them as non-break characters as of version 1.2. In theory this would cause incompatibility with version 1.1; in practice these characters were rarely (if ever) used. YAML 1.2 processors parsing a version 1.1 document should therefore treat these line breaks as non-break characters, with an appropriate warning. 따라서 JSON Syntax를 YAML 1.2에서는 거의 완벽하게 지원한다. 목적 YAML is easily readable by humans. YAML은 사람이 읽기 쉽다. YAML data is portable between programming languages. YAML 데이터는 프로그래밍 언어 간에 이동이 가능하다. YAML matches the native data structures of agile languages. YAML은 agile 언어의 native data structure와 매치된다. YAML’s core type system is based on the requirements of agile languages such as Perl, Python, and Ruby.YAML directly supports both collections (mappings, sequences) and scalars.Support for these common types enables programmers to use their language’s native data structures for YAML manipulation Perl, Python, Ruby와 같은 agile language에 존재하는 scalar, collection 타입을 지원해서,프로그래머가 native data structure를 조작하기가 용이하다. YAML has a consistent model to support generic tools. YAML은 parser들을 위해서 일관적인 모델이 있다. YAML supports one-pass processing. YAML은 one-pass processing을 지원한다. YAML is expressive and extensible. YAML은 표현력과 확장성이 뛰어나다. YAML is easy to implement and use. YAML은 구현 및 사용이 쉽다. Prior Art(들어가기에 앞서?)HTML의 EOL(End of Line)에 영감을 받아서 sinlge line break는 single space로 해석되고,empty line은 line break character를 뜻한다. 123456asdf: &quot;asdfaass&quot;qwer: &quot;qwerzxcv&quot; 위와 아래의 결과는 같다. 12asdf: &quot;asdf aass&quot;qwer: &quot;qwer\\nzxcv&quot; YAML 스펙 문서는 BNF 표기법을 사용하고 있기 때문에 BNF 표기법에 대해 조금은 알고 있어야 읽기가 수월하다. Node Kinds일반적인 자료형과 비슷하다는 생각으로 보면 된다. Scalar The content of a scalar node is an opaque datum that can be presented as a series of zero or more Unicode characters. 스칼라 노드는 0개 이상의 유니코드 문자이다.일반적인 primitive type을 생각하면 편하다. 1b 10 여기서 b와 0 모두 scalar 노드이다. Scalar의 종류는 아래와 같다. Block Styles Block Scalar Styles Literal Style Floded Style Flow Styles Flow Scalar Styles Double-Quoted Style Single-Quoted Style Plain Style Collections When appropriate, it is convenient to consider sequences and mappings together, as collections. Sequence와 Mapping 두 개를 합쳐 collections로 퉁친다는 소리 같다. Sequence The content of a sequence node is an ordered series of zero or more nodes. In particular, a sequence may contain the same node more than once. It could even contain itself (directly or indirectly). 시퀀스 노드는 0개 이상의 순서가 보장된 노드이다.또한 똑같은 노드를 여러 번 포함할 수 있다.심지어 자기 자신을 포함할 수도 있다.일반적인 list를 생각하면 편하다. 123- a- b- a 여기서 -a -b -a를 통틀어 시퀀스 노드라고 부른다. Mapping The content of a mapping node is an unordered set of key: value node pairs, with the restriction that each of the keys is unique. YAML places no further restrictions on the nodes. In particular, keys may be arbitrary nodes, the same node may be used as the value of several key: value pairs, and a mapping could even contain itself as a key or a value (directly or indirectly). 매핑 노드는 순서가 보장되지 않은 key:value 쌍의 집합이다.key는 고유하다는 제한을 빼고는 다른 제한은 있지 않다. 키는 임의의 노드일 수도 있고 자기 자신을 포함할 수 있다.-&gt; 키에 문자열을 대부분 넣는데 문자열은 scalar 노드이니까 임의의 노드일 수도 있다고 표현한 게 아닐까? 동일한 노드를 여러 key:value 쌍의 값으로 사용할 수 있고,-&gt; key는 고유한데, value는 고유하지 않다는 걸 표현한 게 아닐까? 자기 자신을 포함할 수 있다. 1234a: bc: - e - f a: b, c: -e -f 이 두 개 모두 매핑 노드이다. Block Styles In YAML block styles, structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. 구조를 표현할 때 indentation를 사용한다.라인의 시작점에 존재하는 0개 이상의 white space character에 의해 정의된다.하지만 이식성을 고려해서 Tab키는 사용하면 안 된다.시스템들 사이에서 Tab키를 취급하는 방법이 서로 다르기 때문이다. 12345678asdf: qwerzxcv: ssss: dd qwer: - z - xssdd: cc# asdf mapping node에서 key:value 쌍을 구분짓기 위해 :라는 indicator를 사용한다.또한 sequence node의 value들을 구분짓기 위해 -라는 indicator를 사용한다.주석을 표시하기 위해서 #라는 indicator를 사용한다. 12345678&#123; &quot;asdf&quot;: &quot;qwer&quot;, &quot;zxcv&quot;: &#123; &quot;ssss&quot;: &quot;dd&quot;, &quot;qwer&quot;: [&quot;z&quot;, &quot;x&quot;] &#125;, &quot;ssdd&quot;: &quot;cc&quot;&#125; Flow Styles YAML’s flow styles can be thought of as the natural extension of JSON to cover folding long content lines for readability Flow style은 JSON의 확장 정도로 생각하면 된다. flow styles, using explicit indicators rather than indentation to denote scope flow style은 socope를 나타내기 위해 indentation 보다 indicator 문자를 사용한다. 123456789&#123;asdf: qwer,zxcv: &#123;ssss: dd,qwer: [z, x]&#125;,ssdd: cc#qqww&#125; 12345678&#123; &quot;asdf&quot;: &quot;qwer&quot;, &quot;zxcv&quot;: &#123; &quot;ssss&quot;: &quot;dd&quot;, &quot;qwer&quot;: [&quot;z&quot;, &quot;x&quot;] &#125;, &quot;ssdd&quot;: &quot;cc&quot;&#125; Anchor &amp; AliasObject의 Reference를 표기하는 방법이다. 123# Block Stylesb-anchor: &amp;name valueb-alias: *name 1234&#123; &quot;b-anchor&quot;: &quot;value&quot;, &quot;b-alias&quot;: &quot;value&quot;&#125; 12345# Flow Styles&#123; f-anchor: &amp;name value, f-alias: *name&#125; 1234&#123; &quot;f-anchor&quot;: &quot;value&quot;, &quot;f-alias&quot;: &quot;value&quot;&#125; Directives Directives are instructions to the YAML processor. This specification defines two directives, “YAML” and “TAG”, and reserves all other directives for future use. There is no way to define private directives. This is intentional. Directives are a presentation detail and must not be used to convey content information. Directives는 YAML Processor에게 어떻게 해석해라라고 지시하는 것이다.YAML의 버전을 명시하는 YAML Directive와node tags를 명시하는 TAG Directive가 있다.맨 첫 번째 줄의 % Indicator를 통해 표시한다. 1%YAML 1.2 1%TAG !yaml! tag:yaml.org,2002: Multiple Documents YAML uses three dashes (“—”) to separate directives from document content. This also serves to signal the start of a document if no directives are present. Three dots ( “…”) indicate the end of a document without starting a new one, for use in communication channels. --- Indicator로 Directive와 Documnet content를 구분지을 수 있고, document content의 시작이라는 신호도 된다.... Indicator로 Directive와 Document content를 구분지을 수 있고, document content의 끝이라는 신호도 된다. 12345678910%YAML 1.2 # Directive--- # Document content begina: b # Document contentc: d... # Document content end%YAML 1.1 # Directive--- # Document content begina: d # Document contentc: b... # Document content end 좀 더 다양한 예제를 살펴보자. 1234spring: profiles: local datasource: url: jdbc:mysql://local 위와 아래는 같다. 123456---spring: profiles: local datasource: url: jdbc:mysql://local... 이번엔 multiple documents를 표현해보자. 123456789spring: profiles: local datasource: url: jdbc:mysql://local---spring: profiles: dev datasource: url: jdbc:mysql://dev 위와 아래는 같다. 12345678910111213---spring: profiles: local datasource: url: jdbc:mysql://local...---spring: profiles: dev datasource: url: jdbc:mysql://dev... Indentation In YAML block styles, structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line. To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Block Style의 구조는 들여쓰기에 의해 결정된다.라인의 시작점에 존재하는 0개 이상의 white space character에 의해 정의된다.하지만 이식성을 고려해서 Tab키는 사용하면 안 된다.시스템들 사이에서 Tab키를 취급하는 방법이 서로 다르기 때문이다. 1s-indent(n) ::= s-space × n A block style construct is terminated when encountering a line which is less indented than the construct. Each node must be indented further than its parent node. All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently. Block Style의 구조는 이전 라인보다 더 적은 들여쓰기가 있는 라인을 만나면 끝난다.각각의 노드는 부모 노드보다 더 많은 들여쓰기를 써야만 한다.모든 형제 노드는 같은 들여쓰기 레벨을 써야만 한다.하지만 각 형제 노드의 내용들은 독립적이다. White Space Characters123s-space ::= #x20 /* SP */s-tab ::= #x9 /* TAB */s-white ::= s-space | s-tab 스페이스와 탭 문자만 white space character로 인식한다. IndicatorBlock Style Indicator-: Block Style에서 sequence node임을 나타내는 문자 1c-sequence-entry ::= “-” 12- a- b 1[&quot;a&quot;, &quot;b&quot;] :: Block Style에서 mapping node의 value임을 나타내는 문자 1c-mapping-value ::= “:” 1a: b 1&#123;&quot;a&quot;: &quot;b&quot;&#125; ?: Block Style에서 mapping node의 key임을 알리는 문자 1c-mapping-key ::= “?” 12? a: b 1&#123;&quot;a&quot;: &quot;b&quot;&#125; Flow Style Indicator&#123;: Flow Style에서 mapping node의 시작을 알리는 문자 1c-mapping-start ::= “&#123;” &#125;: Flow Style에서 mapping node의 끝을 알리는 문자 1c-mapping-end ::= “&#125;” 123&#123;a: b&#125; 123&#123; &quot;a&quot;: &quot;b&quot;&#125; [: Flow Style에서 sequence node의 시작을 알리는 문자 1c-sequence-start ::= “[” ]: Flow Style에서 sequence node의 끝을 알리는 문자 1c-sequence-end ::= “]” 1[a, b] 1[&quot;a&quot;, &quot;b&quot;] ,: Flow Style에서 collection node의 끝을 알리는 문자 1c-collect-entry ::= “,” 1234&#123;a: b,b: [c, d],&#125; 마지막 [c, d],는 마지막 ,를 생략해서 [c, d]로 써도 똑같다. 1234&#123; &quot;a&quot;: &quot;b&quot;, &quot;b&quot;: [&quot;c&quot;, &quot;d&quot;]&#125; Common Indicator#: 주석을 나타내는 문자 1c-comment ::= “#” 123? a: b# asdf 1&#123;&quot;a&quot;: &quot;b&quot;&#125; &amp;: node의 anchor property를 나타내는 문자 1c-anchor ::= “&amp;” *: alias node를 나타내는 문자 1c-anchor ::= “&amp;” 12anchor: &amp;name valuealias: *name 12anchor: valuealias: value %: Directive Line 임을 나타내는 문자 1c-directive ::= “%” 1%YAML 1.2 1%TAG !yaml! tag:yaml.org,2002: ---: Directive Line이 끝나고 Document content의 시작을 알리는 문자 1c-directives-end ::= “-” “-” “-” 123%YAML 1.2---asdf: qwer ,,,: Document content가 끝나고 Directive Line과 구분을 짓는 문자 1c-document-end ::= “.” “.” “.” 123asdf: qwer...%YAML 1.2 *.yaml vs *.ymlYAML FAQ에서는 *.yaml을 공식 확장자라고 얘기하고 있다.그럼에도 불구하고 *.yml이 있는 이유는 *.html vs *.htm 과도 비슷한 이유일 것 같다.MS-Dos 시절에는 파일의 확장자 길이가 3자로 제한됐었다.그 시절의 영향 때문인지, 3글자 확장자 스타일을 고수하는 사람들 때문에 *.yml이나 *.htm 같은 확장자가 보이는 것 같다. *.yaml vs. *.properties스프링에서 개발 환경 별로 configuration을 구성할 때 *.properties를 사용하면 아래와 같이 할 수 있다. 12345spring.profiles=devspring.datasource.url=jdbc:mysql://management.endpoints.web.base-path=/spring.datasource.hikari.minimum-idle=1spring.datasource.hikari.maximum-pool-size=3 12345spring.profiles=prodspring.datasource.url=jdbc:mysql://management.endpoints.web.base-path=/spring.datasource.hikari.minimum-idle=5spring.datasource.hikari.maximum-pool-size=10 하지만 *.yaml로 구성하게 되면 아래와 같이 구성할 수 있다. 1234567891011121314151617181920212223spring: profiles: dev datasource: url: jdbc:mysql:// hikari: minimum-idle: 1 maximum-pool-size: 3management: endpoints: web: base-path: /---spring: profiles: prod datasource: url: jdbc:mysql:// hikari: minimum-idle: 5 maximum-pool-size: 10management: endpoints: web: base-path: / *.yaml로 했을 때 특징은 다음과 같다. 한 파일에서 모든 configuration을 관리할 수 있다.이건 호불호가 갈릴 것 같다.오히려 특정 환경의 설정만 바꾸고 싶은데 똑같은 key들이 환경별로 있어서 헷갈린다는 사람도 있을 것이고,하나의 파일에서 설정을 다 바꿀 수 있어서 여기 저기 다른 파일을 탐색하지 않아서 좋다고 하는 사람도 있을 수 있을 것이다.환경 별로 쪼개서 사용할 수도 있으니 자기 취향 혹은 팀의 가이드라인을 따라 사용하면 될 것 같다. 비슷한 설정들끼리 뭉친다.동일한 key를 허용하지 않기 때문에 동일한 부모를 가진 key들끼리 뭉치는데, 동일한 부모 아래의 자식이기 때문에 비슷한 설정들끼리 뭉친다.비슷한 설정들끼리 뭉치기 때문에 yaml 파일을 읽을 때 흐름을 파악하기가 훨씬 용이하다.물론 *.properties에서도 비슷한 설정들끼리 뭉쳐놓으면 되는데 설정의 순서를 강제할 순 없기 때문에 yaml이 난 더 좋은 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Dev","slug":"Note/Dev","permalink":"https://perfectacle.github.io/categories/Note/Dev/"}],"tags":[{"name":"YAML","slug":"YAML","permalink":"https://perfectacle.github.io/tags/YAML/"}]},{"title":"BNF 표기법","slug":"bnf","date":"2018-08-15T16:08:01.000Z","updated":"2022-10-30T08:42:16.187Z","comments":true,"path":"2018/08/15/bnf/","link":"","permalink":"https://perfectacle.github.io/2018/08/15/bnf/","excerpt":"BNF(Backus–Naur form)프로그래밍 언어를 정의하기 위한 메타 언어이다.정규화 표현에 많이 사용들 한다고 한다.표기법 창시자인 베커스와 그 표기법을 향상시킨 나우르에 의해 베커스 나우르 표기법이란 이름으로 불리고 있다. 표기법1&lt;이름&gt; ::= &lt;표현식&gt;","text":"BNF(Backus–Naur form)프로그래밍 언어를 정의하기 위한 메타 언어이다.정규화 표현에 많이 사용들 한다고 한다.표기법 창시자인 베커스와 그 표기법을 향상시킨 나우르에 의해 베커스 나우르 표기법이란 이름으로 불리고 있다. 표기법1&lt;이름&gt; ::= &lt;표현식&gt; 표현식은 단말 표현식(더 이상 유도할 수 없는 표현식으로써 0 1 + * 같은 애들,비단말 표현식(유도가 가능한 표현식으로써 &lt;digit&gt;, &lt;character&gt;과 )과 같은 표현들을 뜻한다. 예를 들면 아래와 같이 표기할 수 있다. 123&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9&lt;hex_letter&gt; ::= A | B | C | D | E | F&lt;hex&gt; ::= &lt;digit&gt; | &lt;hex_letter&gt; 연산자 |: or을 의미한다.0 | 1 | 2 (0도 되고 1도 되고 2도 되고) -: 뺄셈의 의미인데 항목 제거의 의미로도 해석할 수 있다. 1234&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9&lt;pre-half-digit&gt; ::= 0 | 1 | 2 | 3 | 4&lt;post-half-digit&gt; ::= &lt;digit&gt; - &lt;half-digit&gt;&lt;post-half-digit&gt; ::= 5 | 6 | 7 | 8 | 9 *: 0개 이상1&lt;string&gt; ::= &lt;character&gt;* 문자열을 빈 문자열(문자열이 0개)도 포함하므로 문자열이 0개 이상이다. +: 1개 이상1&lt;integer&gt; ::= &lt;digit&gt;+ 정수는 1개 이상의 숫자로 이루어져있다. ?: Optional, 있어도 되고, 없어도 되고 12&lt;oct-digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7&lt;oct&gt; ::= 0?&lt;oct-digit&gt; 8진수 표기법은 헷갈리지 않게 04 와 같이 표기하지만, 0이 없다고 해서 8진수가 아니라고 말할 수는 없을 것이다. (물론 헷갈릴 순 있겠지만…) 기타 등등 많지만… 기본적인 내용들은 빼고 자주 쓰는 애들만 적어봤다. 누가 쓰나 yaml 스펙 말고는 아직… 못 봤다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Dev","slug":"Note/Dev","permalink":"https://perfectacle.github.io/categories/Note/Dev/"}],"tags":[{"name":"BNF","slug":"BNF","permalink":"https://perfectacle.github.io/tags/BNF/"}]},{"title":"(Spring) Spring Boot 2.0에서 로깅 환경 구축하기","slug":"spring-boot-2-log","date":"2018-07-22T20:31:55.000Z","updated":"2022-10-30T08:42:16.911Z","comments":true,"path":"2018/07/22/spring-boot-2-log/","link":"","permalink":"https://perfectacle.github.io/2018/07/22/spring-boot-2-log/","excerpt":"오늘은 서버를 구성할 때 필수적인 로깅에 대해 알아보자!우선 환경 별로 profile 쪼개기가 진행된 상태에서 시작한다.최종 결과물은 github 저장소에서 확인 가능하다. 로깅 라이브러리여러가지 logging 라이브러리가 있는데 Spring Boot 2.0에서는 사진과 같이Java Util Logging,Log4j 2,Logback을 기본적으로 사용할 수 있다.","text":"오늘은 서버를 구성할 때 필수적인 로깅에 대해 알아보자!우선 환경 별로 profile 쪼개기가 진행된 상태에서 시작한다.최종 결과물은 github 저장소에서 확인 가능하다. 로깅 라이브러리여러가지 logging 라이브러리가 있는데 Spring Boot 2.0에서는 사진과 같이Java Util Logging,Log4j 2,Logback을 기본적으로 사용할 수 있다. logback 사용해야 하는 이유에 왜 logback을 사용해야하는지 나왔있으니 logback으로 로깅 라이브러리를 선택했다. 혹시나 다른 로깅 라이브러리로 갈아타기 편하기 위해 Facade 패턴을 적용한 Slf4j를 사용하기 위해 lombok을 디펜던시에 추가해야한다. 1compileOnly(&#x27;org.projectlombok:lombok&#x27;) 또한 logback 관련된 설정을 찾다보면 logback.xml vs logback-spring.xml을 보게 되는데Web Application이 시작되고 나서 classpath 내의 logback.xml을 뒤져서 환경 설정을 적용한다.이 때는 Spring이 구동되기 이전이라 application.properties 내에 존재하는 값들을 불러올 수 없다.logback-spring.xml에서는 Spring이 구동된 후라 application.properties에 있는 값들을 불러올 수 있다. 콘솔 로깅기본적으로 콘솔 로깅은 뭔가 디버깅할 용도로 많이 사용하기 때문에 local, test 환경에서 많이 사용한다.우선 resources 디렉토리를 아래와 같이 구성하자. 123- resources - log - console.xml 아래 내용을 복붙해주자. 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;yyyyMMdd HH:mm:ss.SSS&#125; [%thread] %-3level %logger&#123;5&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; name은 다른 파일이나 위치에서 해당 appender를 무슨 이름으로 참조할지 이름을 정한 것이고,ConsoleAppender 클래스를 사용해서 콘솔에 로깅한다고 명시하는 거 같다.한글이 들어갈지도 모르니 charset을 UTF-8로 세팅해주자.패턴은 어떤 형태로 찍을지에 대해서 규칙을 정한 것이다.자세한 내용은 PatternLayout을 살펴보자. %d&#123;yyyyMMdd HH:mm:ss.SSS&#125; - 날짜 %thread - 어떤 스레드에서 실행한 것인지 %-3level - 로깅 레벨 %logger&#123;5&#125; - 어떤 클래스의 로거가 실행된 건지 %msg - 메세지 %n - 줄바꿈 이제 해당 appender를 사용하게 끔 resources 디렉토리에 logback-spring.xml을 만들어주자. 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;include resource=&quot;log/console.xml&quot; /&gt; &lt;root level=&quot;info&quot;&gt; &lt;springProfile name=&quot;local&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;prod&quot;&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;test&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/springProfile&gt; &lt;/root&gt;&lt;/configuration&gt; include를 쓰지 않고 직접 xml 소스 코드를 넣어도 되지만 가독성을 해치는 것 같아 분리했다.또한 root에 설정했다 싶이 default logging level을 info로 설정했다.그리고 springProfile name 값에는 !local과 같은 값도 넣을 수 있다.appender-ref를 통해 appender를 참조할 수 있다.아니면 직접 그 코드를 삽입해도 되긴 하지만 중복이 상당히 많아질 것이다. 로컬 환경과 dev 환경을 실행해보면 로컬 환경은 콘솔 창에 로그가 잘 찍히는데 dev 환경에서는 아래 로그가 끝일 것이다. 1234567 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.3.RELEASE) 로그 파일 남기기console 로깅은 휘발성 데이터이고, 관리 측면에서도 용이하지 않기 때문에 날짜 별로 로그 파일로 남기게 해보자.console.xml과 같은 디렉토리에 file.xml을 만들어주자. 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;appender name=&quot;dailyRollingFileAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;LOG_FILE&#125;/tomcat_log.%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;yyyy:MM:dd HH:mm:ss.SSS&#125; %-5level --- [%thread] %logger&#123;35&#125; : %msg %n&lt;/pattern&gt; &lt;/encoder&gt;&lt;/appender&gt; 하루에 하나씩 생성되는 설정이다. (tomcat_log.2018-07-23-0.log와 같이)maxHistory를 30일로 설정해서 30일이 지난 로그들은 삭제된다.또한 maxFileSize를 100MB로 설정해서 로그 파일 용량이 100MB를 초과하면 자동으로 인덱스가 증가하면서 새로운 로그 파일이 생성된다. (시작은 0)그리고 log file 생성 경로를 위해 env 별 application.properties 파일에서 아래 코드를 추가해주면 된다. 1logging.file=./log/local 이렇게 되면 프로젝트 루트 디렉토리에 log 폴더가 생긴다.$LOG_FILE을 바인딩 했다고 보면 된다.위 설정을 하지 않으면 LOG_FILE_IS_UNDEFINED라는 디렉토리가 생기고 거기에 log 파일이 생성된다. 이제 해당 appender를 사용하게 끔 resources 디렉토리에 logback-spring.xml를 수정하자. 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;include resource=&quot;log/console.xml&quot; /&gt; &lt;include resource=&quot;log/file.xml&quot; /&gt; &lt;root level=&quot;info&quot;&gt; &lt;springProfile name=&quot;local&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;appender-ref ref=&quot;dailyRollingFileAppender&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;appender-ref ref=&quot;dailyRollingFileAppender&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;prod&quot;&gt; &lt;appender-ref ref=&quot;dailyRollingFileAppender&quot;/&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;test&quot;&gt; &lt;appender-ref ref=&quot;STDOUT&quot;/&gt; &lt;/springProfile&gt; &lt;/root&gt;&lt;/configuration&gt; test 환경에서는 로그 파일을 굳이 남길 필요가 없다.각 환경별로 로깅을 잘 하는지 확인해보고 테스트를 실행했을 때 로깅 파일이 제대로 생성되지 않으면 성공이다. 로깅 레벨 정하기local, dev, test 환경에서는 디버깅용 로그를 볼 일이 많다.하지만 prod 환경에서는 디버깅용 로그를 남기는 것은 불필요하므로 끄는 게 좋다.if 문으로 컨트롤 하는 것 또한 성능에 미비한 영향을 미칠테니 application.properties를 컨트롤 함으로써 해결해보자. local&#x2F;dev&#x2F;test env의 application.properties를 아래와 같이 수정해보자. 1logging.level.com.example.demo=debug com 부터는 본인의 application이 있는 패키지를 선택해주면 된다. 그리고 시험삼아 Applications 클래스를 아래와 같이 수정해봤다. 12345678910111213141516171819package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Slf4jpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); log.error(&quot;error&quot;); log.warn(&quot;warn&quot;); log.info(&quot;info&quot;); log.trace(&quot;trace&quot;); log.debug(&quot;debug&quot;); &#125;&#125; 파일&#x2F;콘솔 로그에 찍히는 결과는 아래와 같았다. 123420180723 00:54:06.524 [main] ERROR c.e.d.DemoApplication - error 20180723 00:54:06.524 [main] WARN c.e.d.DemoApplication - warn 20180723 00:54:06.524 [main] INFO c.e.d.DemoApplication - info 20180723 00:54:06.524 [main] DEBUG c.e.d.DemoApplication - debug trace가 가장 높은 레벨(?)인 거 같다. logging level을 아무것도 설정하지 않은 prod env로 실행하면 아래와 같이 나온다. 12320180723 00:54:06.524 [main] ERROR c.e.d.DemoApplication - error 20180723 00:54:06.524 [main] WARN c.e.d.DemoApplication - warn 20180723 00:54:06.524 [main] INFO c.e.d.DemoApplication - info default level을 info로 설정했기 때문이다. Hibernate Logging을 하고 싶다면 아래와 같이 하면 된다. 123logging.level.org.hibernate=debugspring.jpa.show-sql=truespring.jpa.properties.hibernate.format_sql=true spring.jpa.properties.hibernate.format_sql은 좀 더 보기 좋게 출력하는 것이니 필수는 아니다.logging.level.org.hibernate를 info로 세팅했을 때는 콘솔에는 찍혔지만, 파일에는 찍히지 않았다. Access Log이 포스트에선 Tomcat을 사용한다고 가정하겠다.유저가 어떤 URL을 호출했는지 알기 위해서는 Access Log를 남겨야한다.그러기 위해서는 웹 어플리케이션을 만들어야하기 때문에 아래 두 디펜던시를 인젝션 받자. 12compile(&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;)compile(&#x27;org.springframework.boot:spring-boot-starter-web&#x27;) actuator는 health check, monitoring, metrics 등등 다양한 기능을 지원하는데 나는 health check 용으로 밖에 안 써봤다.actuator는 필수는 아니다.web은 @RestController, @GetMapping 등등 다양한 Rest API용 어노테이션을 제공해준다. 또한 2.0 들어서 actuator의 url이 /health와 같은 형태에서 /actuator/health와 같은 형태로 바뀌었다.actuator의 url을 바꾸고 싶으면 application.properties에 아래와 같은 코드를 추가해주면 된다. 1management.endpoints.web.base-path=/ 그리고 테스트용 컨트롤러를 하나 만들자. 1234567891011121314package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@Slf4jpublic class Controller &#123; @GetMapping public void test() &#123; log.info(&quot;info&quot;); &#125;&#125; 그리고 이제 access log용 설정을 application.properties에 해야하는데 application.properties로 설정하면health check나 *.ico, *.js 등등의 정적 파일 access log까지 생기게 된다.그러기 위해선 커스텀하게 설정을 해야하고, application.properties에는 디렉토리만 설정해주자. 1server.tomcat.basedir=./log/local 좀 더 커스텀한 설정을 하기 위해서는 Apache Tomcat Access Log Valve를 사용해야한다.그리고 AccessLogConfig.java를 만들자.(참고로 spring boot 1.x는 이 코드대로는 동작하지 않고, 링크를 참조하자.) 12345678910111213141516171819202122232425package com.example.demo;import org.apache.catalina.valves.AccessLogValve;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.WebServerFactory;import org.springframework.boot.web.server.WebServerFactoryCustomizer;import org.springframework.context.annotation.Configuration;/** * Created by kwonsungyang on 18/07/2018 */@Configurationpublic class AccessLogConfig implements WebServerFactoryCustomizer &#123; @Override public void customize(final WebServerFactory factory) &#123; final TomcatServletWebServerFactory containerFactory = (TomcatServletWebServerFactory) factory; final AccessLogValve accessLogValve = new AccessLogValve(); accessLogValve.setPattern(&quot;%&#123;yyyy-MM-dd HH:mm:ss&#125;t\\t%s\\t%r\\t%&#123;User-Agent&#125;i\\t%&#123;Referer&#125;i\\t%a\\t%b&quot;); accessLogValve.setDirectory(&quot;.&quot;); accessLogValve.setSuffix(&quot;.log&quot;); accessLogValve.setCondition(&quot;ignoreLogging&quot;); containerFactory.addContextValves(accessLogValve); &#125;&#125; %&#123;yyyy-MM-dd HH:mm:ss&#125;t - 날짜 %s - status code %r - First line of the request (method and request URI) %&#123;User-Agent&#125;i - user agent(browser, 검색 엔진 등등) %&#123;Referer&#125;i - Referer 헤더 %a - remote ip address %b - 몇 바이트 응답했는지(Content-Length랑 똑같을 거 같다.) 우선 위와 같은 패턴을 아래와 같이 나오며 자세한 내용은 Access Logging 파트를 참고하자. 12018-07-23 01:42:29 200 GET / HTTP/1.1 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 - 119.149.166.27 - L4 switch&#x2F;Proxy Server를 쓰는 경우에는 remote ip에 고정된 l4&#x2F;proxy ip가 찍히게 되므로원래 클라이언트의 IP를 알기 위해선 %a를 %{X-Forwarded-For}i로 고쳐줘야한다.%{X-Forwarded-For}i를 사용하게 되면 remote ip address, l4/proxy ip address 순서로 찍히게 된다. directory를 세팅해주지 않으면 server.tomcat.basedir로 정한 디렉토리 안에 또 logs 디렉토리가 생겨서 지저분해서 세팅했다.또한 suffix를 세팅해주지 않으면 access_log.2018-07-23와 같이 파일명이 저장되서 log 파일 extension을 붙여주는 코드를 세팅했다.condition은 request.getAttribute(“ignoreLogging”)의 값이 null이 아니면 logging 하는 것이고,conditionIf는 request.getAttribute(“ignoreLogging”)의 값이 null이면 logging 하는 것이다.무시할만한 로그가 많다면 일일이 set하는 건 비효율적이므로 conditionIf를 쓰면 되고,무시할만한 로그가 적다면 set 하는 게 더 효율적이므로 condition을 쓰면 좋을 것 같다. 이제는 url을 분석해서 attribute를 세팅하는 Filter를 구현하자. 1234567891011121314151617181920212223242526272829package com.example.demo;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Componentpublic class LoggingFilter implements Filter &#123; @Override public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain chain) throws IOException, ServletException &#123; final String url = ((HttpServletRequest) req).getRequestURI(); if(url.matches(&quot;/(health|.+\\\\.(ico|js))&quot;)) &#123; req.setAttribute(&quot;ignoreLogging&quot;, true); &#125; chain.doFilter(req, res); &#125; @Override public void init(FilterConfig filterConfig) &#123;&#125; @Override public void destroy() &#123;&#125;&#125; url을 분석해서 &#x2F;health이거나, ico, js 확장자인 경우에 로깅하지 않게 세팅했다.저 정규표현식에 매칭되지 않는 url만 로깅하겠단 뜻이다. 실제로 남은 access log를 보면 health check url이나 favicon.ico 등의 로그는 남아있지 않는다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"log","slug":"log","permalink":"https://perfectacle.github.io/tags/log/"}]},{"title":"(Spring) Spring Boot 2.0 with Gradle에서 환경 별로 profile 쪼개기","slug":"spring-boot-2-env","date":"2018-07-22T15:31:41.000Z","updated":"2022-10-30T08:42:16.911Z","comments":true,"path":"2018/07/22/spring-boot-2-env/","link":"","permalink":"https://perfectacle.github.io/2018/07/22/spring-boot-2-env/","excerpt":"Spring Boot 1.x와 달리 Spring Boot 2.0에서는 Profile 설정하는 게 좀 달라졌다.알아보자.최종 결과물은 github 저장소에서 확인할수 있다. 디펜던시우선 아래 이유로 Lombok을 추가할 것이다. Facade 패턴을 이용해서 어떤 로깅 라이브러리에서도 동작할 수 있게 만들어주는 @Slf4j DI 할 때 코딩할 양을 줄여줘서 우리의 생산성을 조금이나마 높여주는 @RequiredArgsConstructor","text":"Spring Boot 1.x와 달리 Spring Boot 2.0에서는 Profile 설정하는 게 좀 달라졌다.알아보자.최종 결과물은 github 저장소에서 확인할수 있다. 디펜던시우선 아래 이유로 Lombok을 추가할 것이다. Facade 패턴을 이용해서 어떤 로깅 라이브러리에서도 동작할 수 있게 만들어주는 @Slf4j DI 할 때 코딩할 양을 줄여줘서 우리의 생산성을 조금이나마 높여주는 @RequiredArgsConstructor 12345dependencies &#123; compile(&#x27;org.springframework.boot:spring-boot-starter&#x27;) compileOnly(&#x27;org.projectlombok:lombok&#x27;) testCompile(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125; 실행 환경에 따라 분리하기우선 패키지 구조는 아래와 같이 돼있다고 가정하자. 123456789101112- src - main - java - resources - application-core.properties - resources-env - local - application.properties - dev - application.properties - prod - application.properties 먼저 local 환경을 위해서 local 디렉토리의 application.properties를 아래와 같이 수정해주자. 1234spring.profiles.active=localspring.profiles.include=coreval=local 그 다음에 개발 서버 환경을 위해서 dev 디렉토리의 application.properties를 아래와 같이 수정해주자. 1234spring.profiles.active=devspring.profiles.include=coreval=dev 그 다음에 프로덕션 서버 환경을 위해서 prod 디렉토리의 application.properties를 아래와 같이 수정해주자. 1234spring.profiles.active=prodspring.profiles.include=coreval=prod 그 다음에 이제 공통으로 쓸 application-core.properties를 정의하자. 1val2=core spring.profiles.active&#x3D;local,core 이렇게 해도 똑같은 결과가 나오는데spring.profiles.include로 추가적으로 포함될 profile을 설정하는 게 좀 더 의미에 부합하는 것 같아서 설정했다. 그리고 spring boot 2.0의 profile은 기본적으로 resources&#x2F;config 디렉토리의 application.properties(혹은 application.yaml 파일) resources 디렉토리의 application.properties(혹은 application.yaml 파일) classpath&#x2F;config 디렉토리의 application.properties(혹은 application.yaml 파일) classpath 디렉토리의 application.properties(혹은 application.yaml 파일)을 찾는다. 이제 같은 directory 내에서도 다음과 같은 우선순위로 경쟁을 한다. application.properties(application.yaml)를 찾는다. application.properties(application.yaml)에서 spring.profiles.active, spring.profiles.include가 설정돼있지 않다면기본적으로 profile에 default가 setting 되고, 아래와 같은 로그를 볼 수 있다.No active profile set, falling back to default profiles: default 설정된 profile에 따라서 application-{profile}.properties(application-{profile}.yaml)을 찾는다.spring.profiles.active=local, spring.profiles.include=core의 경우에는application-local.properties(application-local.yaml), application-core.properties(application-core.yaml) Environment 별로 디렉토리를 쪼개 놨으니 이 디렉토리를 잘 사용하게 끔 build.gradle을 수정하자. 123456789ext.profile = (!project.hasProperty(&#x27;profile&#x27;) || !profile) ? &#x27;local&#x27; : profilesourceSets &#123; main &#123; resources &#123; srcDirs &quot;src/main/resources&quot;, &quot;src/main/resources-env/$&#123;profile&#125;&quot; &#125; &#125;&#125; argument로 profile을 넘기는데 없으면 local이 기본으로 profile 변수에 할당된다.그리고 resources directory는 기본적으로 core property가 포함된 src&#x2F;main&#x2F;resources는 디폴트로 포함시키고,profile에 넘긴 값에 따라서 resources 디렉토리를 설정해서 쓸 데 없는 디렉토리(application.properties 파일도)가 포함되는 걸 방지하게 만들었다. 실행 환경에 따라 코드 작성하기이제 한 번 각 env 별로 다른 값&#x2F;클래스를 쓰도록 코드를 작성해보자.기본이 되는 인터페이스를 만들자. 12345678package com.example.demo;import org.springframework.stereotype.Service;@Servicepublic interface OrderService &#123; void order();&#125; local env 전용 서비스 구현체를 만들자. 1234567891011121314151617181920212223package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Service;@Service@Slf4j@Profile(&quot;local&quot;)public class LocalOrderService implements OrderService &#123; @Value(&quot;$&#123;val&#125;&quot;) private String val; @Value(&quot;$&#123;val2&#125;&quot;) private String val2; @Override public void order() &#123; log.info(val); log.info(val2); &#125;&#125; dev env 전용 서비스 구현체를 만들자. 1234567891011121314151617181920212223package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Service;@Service@Slf4j@Profile(&quot;dev&quot;)public class DevOrderService implements OrderService &#123; @Value(&quot;$&#123;val&#125;&quot;) private String val; @Value(&quot;$&#123;val2&#125;&quot;) private String val2; @Override public void order() &#123; log.info(val); log.info(val2); &#125;&#125; prod env 전용 서비스 구현체를 만들자. 1234567891011121314151617181920212223package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Service;@Service@Slf4j@Profile(&quot;prod&quot;)public class ProdOrderService implements OrderService &#123; @Value(&quot;$&#123;val&#125;&quot;) private String val; @Value(&quot;$&#123;val2&#125;&quot;) private String val2; @Override public void order() &#123; log.info(val); log.info(val2); &#125;&#125; 어떤 profile에 있는 값을 쓸 것인지 @Profile로 구분할 수 있다.이 @Profile 어노테이션을 안 쓸거라면 사실상 application.properties에서 spring.profiles.active는 없어도 된다. 간단하게 해당 서비스를 쓰는 코드를 작성해보자. 12345678910111213141516171819202122package com.example.demo;import lombok.RequiredArgsConstructor;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.annotation.PostConstruct;@SpringBootApplication@RequiredArgsConstructorpublic class DemoApplication &#123; private final OrderService orderService; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @PostConstruct public void test() &#123; orderService.order(); &#125;&#125; @RequiredArgsConstructor의 이름을 풀이해보면… final이 붙어있으면 무조건(Required) 초기화를 해야하고, 생성자(Constructor)를 이용한 DI를 하게 돼서 나중에 모킹할 때도 좋다. @PostConstruct는 아래와 같은 설명을 보면 된다. The PostConstruct annotation is used on a method that needs to be executedafter dependency injection is done to perform any initialization. 즉 DI 이후에 실행되는 메서드라고 보면 된다. 실행 환경에 따라 실행하기project의 specific gradle을 실행하는 Gradle Wrapper를 통해 실행해보자.터미널을 키고 프로젝트 루트 디렉토리로 이동해서 아래 커맨드를 실행하자. 12345678# local./gradlew bootRun# dev./gradlew bootRun -Pprofile=dev# prod./gradlew bootRun -Pprofile=prod 위와 같이 실행하면 profile에 따라 아래와 같은 로그를 볼 수 있다. 122018-07-22 18:46:00.338 INFO 37955 --- [ main] com.example.demo.ProdOrderService : prod2018-07-22 18:46:00.339 INFO 37955 --- [ main] com.example.demo.ProdOrderService : core IntelliJ IDEA에서는 아래와 같이 하면 된다. test profile123456- test - java - com - example - demo - resources 테스트 패키지 구조가 위와 같다고 했을 때 resources 디렉토리에 application.properties를 만들자. 1234spring.profiles.active=testspring.profiles.include=coreval=test 그리고 ApplicationTests 클래스에 test 클래스를 사용하도록 수정하자. 123456789101112131415package com.example.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@ActiveProfiles(&quot;test&quot;)public class DemoApplicationTests &#123; @Test public void contextLoads() &#123;&#125;&#125; 그리고 test 용 OrderService 서비스를 구현해보자. 1234567891011121314151617181920212223package com.example.demo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Profile;import org.springframework.stereotype.Service;@Service@Slf4j@Profile(&quot;test&quot;)public class TestOrderService implements OrderService &#123; @Value(&quot;$&#123;val&#125;&quot;) private String val; @Value(&quot;$&#123;val2&#125;&quot;) private String val2; @Override public void order() &#123; log.info(val); log.info(val2); &#125;&#125; contextLoads 메서드를 테스트 해보면 아래와 같이 원하는 결과가 로깅돼서 나온다. 122018-07-22 19:45:31.941 INFO 38688 --- [ main] com.example.demo.TestOrderService : test2018-07-22 19:45:31.941 INFO 38688 --- [ main] com.example.demo.TestOrderService : core","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Gradle","slug":"Gradle","permalink":"https://perfectacle.github.io/tags/Gradle/"}]},{"title":"(JPA) 엔터티 상속","slug":"jpa-entity-inheritance","date":"2018-07-10T01:13:20.000Z","updated":"2022-10-30T08:42:16.675Z","comments":true,"path":"2018/07/10/jpa-entity-inheritance/","link":"","permalink":"https://perfectacle.github.io/2018/07/10/jpa-entity-inheritance/","excerpt":"어이쿠야… 정말 백만년만에 포스팅하는 것 같다…나태하게 살지 말기로 작심만 몇 번째 하는 건지 ㅠㅠ여튼 이번에 JPA를 통해 엔터티를 용도에 맞게 잘게 쪼개보다 보니 겪었던 이슈를 간단히 정리해봤다. 엔터티 상속먼저 Deal(상품) 클래스이다.이 녀석은 베이스(부모) 클래스이다. 1234567891011121314@Getterpublic class Deal &#123; @Id private long id; @Enumerated(EnumType.STRING) @Column(name =&quot;deal_type&quot;) private DealType type; private int price; @OneToMany(mappedBy = &quot;deal&quot;) private List&lt;CategoryDealMap&gt; categoryDealMaps;&#125;","text":"어이쿠야… 정말 백만년만에 포스팅하는 것 같다…나태하게 살지 말기로 작심만 몇 번째 하는 건지 ㅠㅠ여튼 이번에 JPA를 통해 엔터티를 용도에 맞게 잘게 쪼개보다 보니 겪었던 이슈를 간단히 정리해봤다. 엔터티 상속먼저 Deal(상품) 클래스이다.이 녀석은 베이스(부모) 클래스이다. 1234567891011121314@Getterpublic class Deal &#123; @Id private long id; @Enumerated(EnumType.STRING) @Column(name =&quot;deal_type&quot;) private DealType type; private int price; @OneToMany(mappedBy = &quot;deal&quot;) private List&lt;CategoryDealMap&gt; categoryDealMaps;&#125; 기본적으로 pk, 상품 유형, 가격, 해당 상품에 해당하는 카테고리 목록들을 가지고 있다. 그 다음으로 Deal과 매핑된 CategoryDealMap 엔터티 클래스이다. 1234567891011@Entity@Getterpublic class CategoryDealMap implements Serializable &#123; @Id private long id; @ManyToOne private Deal deal; private long categoryId;&#125; 이제 자식이 되는 항공권 상품(Air)이다. 1234567@Getter@Entity@Table(name = &quot;deal&quot;)public class Air extends Deal &#123; private LocalDate departure; private LocalDate arrival;&#125; 언제 출발해서 언제 도착하는지 정보를 포함한 컬럼이다. 이제 또 다른 자식인 숙박 상품(Lodge)이다. 1234567@Getter@Entity@Table(name = &quot;deal&quot;)public class Lodge extends Deal &#123; private LocalDate checkIn; private LocalDate checkOut;&#125; 언제 체크인 해서 언제 체크아웃 하는지 정보를 포함한 컬럼들이다. 문제 Deal 클래스는 엔터티가 아니라 CategoryDealMap 엔터티와 매핑할 수가 없다. CategoryDealMaps 컬럼이 없더라도 where 절에 아래와 같은 요상한 조건이 붙어서 쿼리 자체를 실행할 수가 없다.where dtype = &#39;AIR&#39; 또는 where dtype = &#39;Lodge&#39; 해결@Inheritance 어노테이션, 그리고 @DiscriminatorColumn과 @DiscriminatorFormula 어노테이션을 적절히 잘 쓰면 된다. @DiscriminatorColumn어떤 컬럼을 가지고 어떤 자식 엔터티를 판별할 것인가에 대한 힌트를 주는 어노테이션이다.여기선 type 컬럼을 가지고 엔터티를 구분하므로 Deal 클래스를 다시 아래와 같이 설정해주자. 1234567891011121314151617@Getter@Entity@Inheritance@DiscriminatorColumn(name = &quot;deal_type&quot;)public class Deal &#123; @Id private long id; @OneToMany(mappedBy = &quot;deal&quot;) private List&lt;CategoryDealMap&gt; categoryDealMaps; private int price; @Enumerated(EnumType.STRING) @Column(name =&quot;deal_type&quot;) private DealType type;&#125; @Entity 어노테이션도 붙여주고, @Inheritance 어노테이션, @DiscriminatorColumn 어노테이션도 붙여줬다.@Inheritance 어노테이션의 기본 strategy 필드값은 SINGLE_TABLE이다.name은 실제 필드명을 입력해주면 된다.그리고 @DiscriminatorColumn 어노테이션의 name field를 보면 위에 dtype이라는 조건이 왜 붙었었는지 알게 된다. 123456789@Target(&#123;TYPE&#125;)@Retention(RUNTIME)public @interface DiscriminatorColumn &#123; /** * (Optional) The name of column to be used for the discriminator. */ String name() default &quot;DTYPE&quot;;&#125; name 필드의 기본값이 DTYPE이기 때문에 요상한 조건 절이 붙었던 것이다. 그리고 Air 엔터티와 Lodge 엔터티를 아래와 같이 고치면 된다. 1234567@Getter@Entity@DiscriminatorValue(&quot;AIR&quot;)public class Air extends Deal &#123; private LocalDate departure; private LocalDate arrival;&#125; 1234567@Getter@Entity@DiscriminatorValue(&quot;LODGE&quot;)public class Lodge extends Deal &#123; private LocalDate checkIn; private LocalDate checkOut;&#125; @Table 어노테이션은 부모 클래스에 있는 걸 가져다 쓰면 되니 사라졌고, @DiscriminatorValue 어노테이션이 붙었다.부모 클래스에서 정한 @DiscriminatorColumn(name &#x3D; “deal_type”), 즉 deal_type 필드의 값이 뭐냐에 따라서 어떤 엔터티를 사용할지가 정해진다고 보면 된다. @DiscriminatorFormula@DiscriminatorColumn의 경우에는 해당 컬럼의 값으로 딱 자식 클래스가 명확하게 구분되어질 때 사용하면 된다.DealType enum에 딱 AIR와 LODGE에 해당하는 타입이 각각 있으면 상관 없다.하지만 숙박에 해당하는 타입은 MOTEL, HOTEL, PENSION 등등 다양한 타입이 존재한다.해당 타입들도 전부 Lodge 엔터티를 사용해야할 때는 어떻게 해야할까? 컬럼 대신에 조건을 줄 수 있는 @DiscriminatorFormula 어노테이션을 써서 Deal 엔터티를 아래와 같이 수정해보자. 12345678910111213141516@Getter@Entity@Inheritance@DiscriminatorFormula(&quot;case when deal_type = &#x27;AIR&#x27; then &#x27;AIR&#x27; else &#x27;LODGE&#x27; end&quot;)public class Deal &#123; @Id private long id; @OneToMany(mappedBy = &quot;deal&quot;) private List&lt;CategoryDealMap&gt; categoryDealMaps; private int price; @Enumerated(EnumType.STRING) private DealType type;&#125; deal_type의 값을 AIR면 AIR고 나머지는 LODGE로 값을 세팅하게 끔 한 것이다.그럼 MOTEL이건 HOTEL이건 PENSION이건 동일한 엔터티인 Lodge 엔터티를 사용하게 된다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"}]},{"title":"후니의 쉽게 쓴 시스코 네트워킹 정리 - OSI 7 Layer 네트워크 장비","slug":"network-hardware","date":"2018-05-30T03:34:00.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2018/05/30/network-hardware/","link":"","permalink":"https://perfectacle.github.io/2018/05/30/network-hardware/","excerpt":"Layer 1(Physical Layer)랜선, 랜카드는 너무 익숙하고 짜치니 일단 생략.기본적으로 이더넷 방식을 기준으로 설명. 리피터(Repeater): 신호를 증폭해주는 것LAN선의 경우에 최대 거리가 100m인 것들이 있다. (데이터의 무결성을 보장할 수 있는 거리인 듯)이런 장비가 그럼 어떻게 수 십 km 떨어진 곳에 있는 데이터를 받아올 수 있는 것일까?바로 최대 거리인 100m 내에 리피터라는 장비를 둬서 데이터를 전달만 하는 역할을 하는 걸 보고 리피터라고 한다.음악 장비에 있어서는 엠프(소리를 크게 내주게 하는 장비) 정도로 이해하면 편할 것 같다.OSI 7 Layer의 1 Layer(Physical Layer)에 속한다.허브가 리피터 역할까지 하고 가격도 싸지면서 거의 쓰이지 않는 장비로 알고 있다.무선랜의 경우 신호의 세기를 증폭시켜주는 중계기&#x2F;리피터&#x2F;증폭기 등등으로 쓰이는데 예전에 사용하던 유선랜 리피터와 해주는 역할이 유사하긴 하다. 허브(Hub): 멀티포트(Multiport) 리피터리피터의 역할을 하는데 포트가 여러 개인 것이다.리피터는 입력한 데이터를 그대로 출력한다고 했고, 허브에서는 멀티포트로 연결된 장비들에게 이 데이터를 그대로 전달하는 역할을 한다.1번 포트에 연결된 장비가 데이터를 보내면 이더넷 특성상 1번 포트를 제외하고 나머지 모든 포트로 데이터를 뿌리게 된다.눈치 없는 2번 포트에 연결된 장비가 동시에 데이터를 보내게 되면 이더넷의 특성 상 CSMA&#x2F;CD 프로토콜을 사용하고 충돌이 발생하게 된다.이 때 충돌한 두 장비는 다시 눈치게임을 통해 데이터를 뿌리게 된다.위와 같이 같은 허브에 물려있는 모든 장비는 같은 Collision Domain 상에 존재하게 되는 것이다.따라서 허브가 엄청 많은 포트를 지원한다고 해서 꼭 좋은 것만은 아니다.위와 같이 데이터를 어느 한 순간에만 보낼 수 있는 허브를 Shared Hub라고 부르고,위와 같은 특성 때문에 인터넷 속도를 사실 N빵 했다고 보면 된다.Collision Domain은 별도의 허브를 쓴다고 해서 해결되는 게 아니라 오히려 Collision Domain의 범위를 늘리는 일이다.아마 인터넷&#x2F;IP 공유기가 허브이지 않을까 싶다. 모뎀(Modem): 아날로그 신호 &lt;-&gt; 디지털 신호아날로그 신호(빛, 전기) -&gt; 디지털 신호(0, 1)를 수행하는 장비를 Modulator(변조기)라고 부르고,반대인 디지털 신호 -&gt; 아날로그 신호를 수행하는 장비를 Demodualtor(복조기)라고 부르고, 이 둘을 합친 게 모뎀이다.과거에는 전화선으로 연결을 해서 매우 느렸지만 요즘에는 빛을 신호로 사용하는 기가광랜 등등의 등장으로 모뎀 장비도 크게 성장하였다. Layer 2(Data Link Layer)","text":"Layer 1(Physical Layer)랜선, 랜카드는 너무 익숙하고 짜치니 일단 생략.기본적으로 이더넷 방식을 기준으로 설명. 리피터(Repeater): 신호를 증폭해주는 것LAN선의 경우에 최대 거리가 100m인 것들이 있다. (데이터의 무결성을 보장할 수 있는 거리인 듯)이런 장비가 그럼 어떻게 수 십 km 떨어진 곳에 있는 데이터를 받아올 수 있는 것일까?바로 최대 거리인 100m 내에 리피터라는 장비를 둬서 데이터를 전달만 하는 역할을 하는 걸 보고 리피터라고 한다.음악 장비에 있어서는 엠프(소리를 크게 내주게 하는 장비) 정도로 이해하면 편할 것 같다.OSI 7 Layer의 1 Layer(Physical Layer)에 속한다.허브가 리피터 역할까지 하고 가격도 싸지면서 거의 쓰이지 않는 장비로 알고 있다.무선랜의 경우 신호의 세기를 증폭시켜주는 중계기&#x2F;리피터&#x2F;증폭기 등등으로 쓰이는데 예전에 사용하던 유선랜 리피터와 해주는 역할이 유사하긴 하다. 허브(Hub): 멀티포트(Multiport) 리피터리피터의 역할을 하는데 포트가 여러 개인 것이다.리피터는 입력한 데이터를 그대로 출력한다고 했고, 허브에서는 멀티포트로 연결된 장비들에게 이 데이터를 그대로 전달하는 역할을 한다.1번 포트에 연결된 장비가 데이터를 보내면 이더넷 특성상 1번 포트를 제외하고 나머지 모든 포트로 데이터를 뿌리게 된다.눈치 없는 2번 포트에 연결된 장비가 동시에 데이터를 보내게 되면 이더넷의 특성 상 CSMA&#x2F;CD 프로토콜을 사용하고 충돌이 발생하게 된다.이 때 충돌한 두 장비는 다시 눈치게임을 통해 데이터를 뿌리게 된다.위와 같이 같은 허브에 물려있는 모든 장비는 같은 Collision Domain 상에 존재하게 되는 것이다.따라서 허브가 엄청 많은 포트를 지원한다고 해서 꼭 좋은 것만은 아니다.위와 같이 데이터를 어느 한 순간에만 보낼 수 있는 허브를 Shared Hub라고 부르고,위와 같은 특성 때문에 인터넷 속도를 사실 N빵 했다고 보면 된다.Collision Domain은 별도의 허브를 쓴다고 해서 해결되는 게 아니라 오히려 Collision Domain의 범위를 늘리는 일이다.아마 인터넷&#x2F;IP 공유기가 허브이지 않을까 싶다. 모뎀(Modem): 아날로그 신호 &lt;-&gt; 디지털 신호아날로그 신호(빛, 전기) -&gt; 디지털 신호(0, 1)를 수행하는 장비를 Modulator(변조기)라고 부르고,반대인 디지털 신호 -&gt; 아날로그 신호를 수행하는 장비를 Demodualtor(복조기)라고 부르고, 이 둘을 합친 게 모뎀이다.과거에는 전화선으로 연결을 해서 매우 느렸지만 요즘에는 빛을 신호로 사용하는 기가광랜 등등의 등장으로 모뎀 장비도 크게 성장하였다. Layer 2(Data Link Layer) 브릿지(Bridge): 허브를 이어주는 다리허브의 단점인 충돌을 피하기 위해 등장한 장비.브릿지가 포트가 4개라면 여기에 허브를 4개 물릴 수 있고, 각기 다른 Collision Domain을 가진다.브릿지의 기능 중에 필터링이 있는데, 다른 포트로 못 건너가게 막는 기능이다.같은 포트 내의 장비끼리 통신인 경우에는 다른 포트로 건너가지 못하게 막고,이 기능 때문에 서로 다른 Collision Domain을 가지고, 동시에 통신이 가능하게 된다.만약 다른 포트에 있다면 ‘포워딩’이란 기능을 통해 다리를 건너가게 해주는 것이다.허브와 달리 L2이기 때문에 L2의 특성인 에러 처리 능력도 가졌다.하지만 허브는 에러 처리 없이 곧이 곧대로 받으면 되기 때문에 허브 보다는 데이터 처리 속도가 느리다.스위치의 우수성과 값이 싸짐에 따라서 거의 사장됐다고 보면 된다. 스위치(Switch): 브릿지의 진화판기본적으로 브릿지가 가진 특성을 모두 가지고 있고 다음과 같은 차이점과 값이 싸짐에 따라 브릿지를 대체했다. 스위치는 프레임 처리 방식이 하드웨어 방식이라 소프트웨어 방식인 브릿지에 비해 훨씬 빠르다.왜냐하면 처리 절차를 미리 칩에 구워서 만들었기 때문이다. 브릿지와 달리 각 포트별로 다른 속도를 할당해 줄 수 있다. 브릿지보다 포트가 훨씬 많다. 프레임을 처리하는 방식이 브릿지는 들어오는 프레임을 전부 받아들인 다음 처리를 시작하는 Store and Forwarding 방식만 지원하지만,스위치는 프레임의 목적지 주소만을 보고 바로 전송하는 Cut Through 방식이나 앞에 두 개의 방식의 장점을 살린 Fragment Free 방식도 지원한다. Layer 3(Network Layer) 라우터(Router): 통신하는데 최적의 경로를 찾아주는 장비여러 알고리즘에 따라서 통신하는데 최적의 경로를 찾아주는 장비이다.Layer 3에서는 IP가 존재하는 계층이라 라우터에서는 IP 주소를 보고 포워딩하지만, 스위치에서는 MAC 주소를 보고 포워딩한다.라우터의 가장 큰 목적은 외부 네트워크와 통신하기 위해서 쓰인다는 점이다.따라서 라우터는 두 가지 포트를 가지게 되는데 내부 네트워크(스위치)와 연결하는 포트를 이더넷 인터페이스라고 한다.다른 하나는 외부 네트워크와 연결하는 시리얼 인터페이스(WAN과의 접속)라고 부른다.이더넷 인터페이스는 내부 네트워크의 IP 주소를 가지며, 이 주소를 Default Gateway라고 부른다.대부분 기본적으로 192.168.0.1과 같은 공유기 관리자 페이지로 가지는 곳이 바로 Default Gateway이다.시리얼 인터페이스도 마찬가지로 IP 주소를 부여받고, 스위치에 연결된 모든 장비가 이 IP 주소로 변환되서 나가지 않을까…?스위치&#x2F;허브 등등의 경우에는 IP 주소를 할당하지 않아도 되지만 라우터의 경우에는 외부 네트워크와 통신해야하기 때문에 IP 주소를 무조건 할당받아야 한다.아마 공유기가 라우터의 기능까지 수행하고 있는 건 아닐까 싶다.또한 요즘에는 라우터와 모뎀의 일체형인 제품들도 나오는 것 같다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"후니의 쉽게 쓴 시스코 네트워킹 정리 - Ethernet, MAC Address, xCast","slug":"network-ethernet-mac-address-x-cast","date":"2018-05-30T02:11:22.000Z","updated":"2022-10-30T08:42:16.875Z","comments":true,"path":"2018/05/30/network-ethernet-mac-address-x-cast/","link":"","permalink":"https://perfectacle.github.io/2018/05/30/network-ethernet-mac-address-x-cast/","excerpt":"이더넷(Ethernet)네트워킹 방식에는 아래와 같은 애들이 존재한다. FDDI ATM Token Ring Ethernet 이더넷 말고도 전공 시간에 배웠는데 다 까먹었다.전공 시간에는 이더넷에 대해서는 잘 안 배우고 CSMA&#x2F;CD 방식에 대해서만 배웠는데 이더넷과 연관이 있다고 하니 뭔가 와닿는다.","text":"이더넷(Ethernet)네트워킹 방식에는 아래와 같은 애들이 존재한다. FDDI ATM Token Ring Ethernet 이더넷 말고도 전공 시간에 배웠는데 다 까먹었다.전공 시간에는 이더넷에 대해서는 잘 안 배우고 CSMA&#x2F;CD 방식에 대해서만 배웠는데 이더넷과 연관이 있다고 하니 뭔가 와닿는다. 여튼 위와 같이 여러 네트워킹 방식이 존재하고 어떤 네트워킹 방식을 쓰느냐에 따라서 랜카드에서 모든 네트워크 장비가 달라진다.우리가 쓰는 대부분의 네트워킹 방식은 이더넷 방식을 쓴다고 이해하면 된다.그래서 LAN 카드를 Ethernet Card, NIC(Network Interface Card) 등등으로도 많이 부른다. 이 이더넷의 큰 특징 중 하나가 CSMA&#x2F;CD(Carrier Sense Multiple Access&#x2F;Collision Detection) 프로토콜을 이용한다는 것이다. Carrier Sense: 네트워크 상에서 통신이 일어나고 있는지, 신호를 감지 Multiple Access: 두 대 이상의 장비에서 네트워크 상에 동시에 통신을 시도하는 경우 Collision Detection: Multiple Access의 경우 충돌(Collision)이 발생하는데 이를 감지(Detection)하는 것Collision Detection이 발생하면 체감 할 수 없을 정도로 짧은 랜덤한 시간동안 대기를 한 후 재시도하게 된다. 이더넷의 특성 상 충돌이 발생하는 것은 자연스럽고, 충돌이 발생하면 계속해서 대기 후 재전송을 하게 된다.네트워크에 연결된 호스트가 많을 수록 충돌은 자주 발생하고 이런 단점을 해결하고자 콜리전 도메인(충돌이 발생하는 범위)을 줄이는 방식으로 해결이 가능하다. MAC(Media Access Control) Address어따 써먹는 놈인지 참 궁금했다.IP 주소만 있으면 장비 찾아가지 뭐하러 MAC Address를 사용하는지 이해가 안 갔다. 이더넷 카드에는 전 세계에서 고유한 주소인 MAC Address가 부여되고, 6바이트(48비트)의 16진수로 표현되고,하이픈(-), 점(.), 콜론(:)을 구분자로 표기하며 앞의 24비트는 이더넷 카드 제조 업체의 코드를 의미하고, 뒤의 24비트는 일련번호를 나타낸다.MAC Address는 절대 변하지 않으므로 Physical Address라고 부르기도 하고, 어떻게 보면 전세계에서 유일하고, 식별 가능한 주소이기 때문에 개인정보로 취급되기도 한다. 이제 진짜 MAC Address를 왜 쓰는지 알아보자.우선 IP 주소만 있어도 통신은 일어날 것 같다.하지만 IP가 속한 L3(Network Layer)를 보면 다양한 프로토콜이 존재하고,IPX(Internetwork Packet Exchange)를 보면 IP 주소를 전혀 사용하지 않는다.물론 IPX는 TCP&#x2F;IP Stack에는 속하지 않지만 엄밀히 IP 프로토콜과 동등한 레이어의 프로토콜이다.즉 IPX를 통해서 패킷을 원하는 장비에까지 전달이 가능하다는 소리이다.이런 경우에는 IP 주소가 없기 때문에 IP 주소가 속한 L3보다 더 아랫단에서 컨트롤 가능한 주소를 가지고 통신해야한다.그러기 위해서 L1(Physical Layer)에 속하는 이더넷 카드에 존재하는 MAC Address를 가지고 통신을 하면 된다. 위와 같은 이유로 사실 내부적으로 통신을 할 때는 IP 주소를 MAC Address로 변경하는 작업을 수행해서 MAC Address로 통신을 하게 되는 것이다.IP -&gt; MAC Address는 ARP(Address Resolution Protocol)를 이용하고, 반대인 MAC Address -&gt; IP의 경우에는 RARP(Reverse ARP)를 이용하게 된다. 통신은 두 가지 경우로 나눌 수 있고 각 경우 별로 MAC Address를 어떻게 알아내는지 알아보자. 같은 네트워크에 있는 호스트끼리 통신하는 경우먼저 해당 IP의 MAC Address를 알려달라는 브로드캐스트를 날리게 된다.다른 호스트들은 하던 작업을 멈추고 자신의 IP 주소와 일치하는지 확인하고, 일치하지 않으면 무시한다.일치하면 자신의 MAC Address를 담아서 응답하고, 해당 MAC Address를 통해서 통신이 이루어진다. 다른 네트워크에 있는 호스트끼리 통신하는 경우먼저 해당 IP의 MAC Address를 알려달라는 브로드캐스트를 날리게 된다.다른 호스트들은 하던 작업을 멈추고 자신의 IP 주소와 일치하는지 확인하고, 일치하지 않으면 무시한다.아무도 응답을 안 해주니까 라우터 A가 자신의 MAC Address를 알려주고, 자신이 대신해서 전달해주겠다고 한다.그럼 목적지를 라우터 A의 MAC Address로 정하고 패킷을 날리고, 해당 라우터 A는 또 해당 IP가 존재하는 라우터 B를 찾게 된다.라우터 B를 찾았으면 목적지를 라우터 B의 MAC Address로 정하고 라우터 B에게 패킷 전달을 위임한다.이제 라우터 B는 브로드캐스트를 날려서 해당 IP의 MAC Address를 획득하고, 해당 MAC Address를 가지고 통신이 이루어진다. Unicast1:1 통신을 말하며 대부분의 통신이 이러한 방식으로 이루어진다.전송되는 프레임 안에 목적지 MAC Address를 넣는다.유니캐스트로 프레임을 날려도 다이렉트로 해당 MAC Address를 가진 장비에게 전달되는 게 아니라 로컬 이더넷의 기본 특성이네트워크에 존재하는 모든 호스트에게 정보를 날리는 Shared 방식이라서 모든 호스트에게 일단 프레임이 전달된다.해당 프레임을 받은 호스트는 목적지 MAC Address가 자신이 가지고 있는 Ethernet Card의 MAC Address와 비교해서 다르면 해당 프레임을 버린다.Ethernet Card에서 비교가 가능하기 때문에 CPU까지 해당 프레임을 올릴 필요가 없어서 PC의 성능 저하를 유발하지 않는다. Broadcast동일한 네트워크에 존재하는 모든 호스트와 통신을 하는 방식이다.라우터 밖으로 나가지 않는 범위를 뜻하며 이 범위를 브로드캐스트 도메인이라고 부른다.브로드캐스트는 거부 권한이 없기 때문에 무조건 프레임을 받아야한다.해당 프레임을 받아서 인터럽트를 걸고 CPU로 해당 프레임을 올려서 프레임을 버릴지 말지 결정하게 된다.따라서 이 경우에는 네트워크 트래픽&#x2F;성능 저하를 유발하기도 하지만 해당 PC의 성능 저하도 유발하기 때문에 남발해선 안 된다. 브로드캐스트는 IP 주소로 MAC Address를 알아내는 ARP 프로토콜이나 새로 연결한 호스트에게 IP를 할당하기 위해남은 IP 주소를 알아내고 자동 할당해주는 DHCP 프로토콜 등등에서 쓰인다. Multicast브로드캐스트는 통신 거부 권한이 없는데 멀티캐스트는 그룹을 만들어서 그 그룹을 구독하고,그룹(에 속해있는 구독자)에 프레임을 날리는 방식이다.더 이상 통신을 하고 싶지 않다면 구독 해제하면 된다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(AWS) Public Subnet","slug":"aws-public-subnet","date":"2018-04-25T06:01:08.000Z","updated":"2022-10-30T08:42:16.131Z","comments":true,"path":"2018/04/25/aws-public-subnet/","link":"","permalink":"https://perfectacle.github.io/2018/04/25/aws-public-subnet/","excerpt":"Subnet서브넷이란 Sub Network, 네트워크의 서브, 메인 네트워크를 쪼갰다고 보면 된다.AWS 관점에서 봤을 때 메인 네트워크는 VPC라고 보면 된다. Public SubnetPublic Subnet이란 외부에서 접근이 가능한 네트워크 정도로 이해하면 될 것 같다.","text":"Subnet서브넷이란 Sub Network, 네트워크의 서브, 메인 네트워크를 쪼갰다고 보면 된다.AWS 관점에서 봤을 때 메인 네트워크는 VPC라고 보면 된다. Public SubnetPublic Subnet이란 외부에서 접근이 가능한 네트워크 정도로 이해하면 될 것 같다. Public Subnet을 만드려면 AWS 콘솔에서 VPC 서비스로 이동해서 좌측 탭 중에 Subnets를 클릭하고, Create Subnet를 클릭한다. Name tag를 정하고 어떤 VPC에 Subnet을 생성할 것인지 선택하면 된다.VPC가 Region에 생성되는 것에 반해 Subnet은 어떤 AZ(Availability Zone)에 생성될 것인지도 정해야한다.따라서 AZ가 다운돼서 장애가 발생하는 것을 방지하려면 Multi AZ로 Subnet을 생성해야하지만, 포스트에서는 단일 AZ로 진행하도록 하겠다.그리고 Subnet의 CIDR Block을 지정해야하는데,Subnet은 VPC의 Subset이기 때문에 VPC의 cidr block을 초과해서 정할 수 없다.또한 미리 생성한 Subnet의 cidr block과 겹쳐서도 안 된다.ip class를 참고해서 네트워크 규모에 따라서 cidr block을 설정하면 된다. 또한 서브넷 내의 리소스(EC2 인스턴스, ELB 등등)는 무조건 private ip를 가지는데, private ip는 고정할 수 없고, 생성될 때 서브넷의 cidr block 내의 ip가 랜덤으로 할당된다. 기본적으로 서브넷에는 설정에는 서브넷 내의 리소스에 대해 public ip를 자동으로 할당하지 않게 설정돼있다.우리는 만드는 목적 자체가 public subnet이기 때문에 public ip를 자동으로 할당하도록 설정하자. Internet GatewayInternet Gateway는 VPC의 문지기와도 같은 역할을 한다.VPC 외부에서 접근할 때 항상 Internet Gateway를 거쳐서 접근하게 된다.따라서 Public Subnet을 구성하기 위해서는 Internet Gateway를 무조건 만들어야한다.VPC 서비스 좌측 탭 중에 Internet Gateways를 클릭하고 Create internet gateway를 클릭하고 Name tag를 입력해서 Internet Gateway를 생성하자. Internet Gateway는 기본적으로 vpc에 안 붙어있기 때문에 vpc에 붙여주자.여기서 끝이 아니고, Subnet에 Route Table을 설정해줘야한다. Route TableRoute Table이란 어떤 IP 주소로 가야할 때 어디로 가야하는지를 나타낸 경로를 뜻한다.기본적으로 VPC를 생성하면 Main Route Table이 생성되고, 라우트 테이블을 설정하지 않은 서브넷들은 암묵적으로 메인 라우트 테이블이 설정된다.이 포스트에서는 메인 라우트 테이블을 수정하도록 하겠다. Route Table을 수정하려면 AWS 콘솔에서 Route Tables 서비스로 이동해서 해당 vpc의 메인 라우트 테이블을 선택하고, Edit 버튼을 클릭한다. 우선 메인 라우트 테이블의 Destination은 vpc의 cidr block이 할당돼있고, target은 local로 돼있다.vpc 내부 자원에 대해서는 cidr block 범위에 해당하는 private ip가 할당돼있기 마련이다.따라서 cidr block 내의 ip의 경우에는 local, vpc 내부에서 자원을 찾을 수 있다는 뜻이다. 우리는 외부와 통신을 해야하기 때문에 라우트 테이블에 인터넷 게이트웨이를 붙어야하기 때문에 Edit 버튼을 누르고 아래와 같이 설정하면 된다. 0.0.0.0&#x2F;0, 즉 모든 ip에 대해서 인터넷 게이트웨이로 향하게 끔 설정을 했다. 목적지 ip가 cidr block 내의 private ip(10.0.0.0&#x2F;16)인 경우에 대해서는 vpc 내부(local)에서 자원을 찾게 끔 설정한 것이고,목적지 ip가 cidr block 내의 private ip(10.0.0.0&#x2F;16)가 아닌 경우(0.0.0.0&#x2F;0)에 대해서는 인터넷 게이트웨이를 통해서 vpc 외부로 내보내는 것이다. EC2 인스턴스 생성다른 리소스(ELB 등등)을 해도 되지만 포스트에서는 가장 간단한 EC2로 선택했다.EC2 인스턴스는 간단하게 설명하면 그냥 서버 장비 한 대라고 생각하면 된다. AWS 콘솔에서 EC2 서비스로 이동해서 Launch Instance를 클릭하자.입맛에 맞게 설정을 하면 되는데, Step 2에서 Review and Launch 대신에 Configure Instance Details를 선택해주자. Step3가 핵심이다.위에서 만든 VPC와 Public Subnet을 설정하고, public ip 할당 부분을 enable로 하던가,아니면 서브넷에 자동으로 public ip 할당 설정이 돼있다면 Use subnet setting을 그대로 내비두면 된다. 그 이후에는 입맛에 맞게 인스턴스를 생성하면 외부에서 접근 가능한 리소스를 만든 셈이다. 외부에서 접근 가능하게 하기 위한 조건 Subnet에 설정된 Route Table에 Internet Gateway가 설정돼있어야한다. (Public Subnet) 결국 외부에서 접근하는 IP 주소는 Subnet 내의 리소스로 접근하기 때문에 리소스를 만들 때는 꼭 public ip를 할당해야한다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"VPC","slug":"VPC","permalink":"https://perfectacle.github.io/tags/VPC/"},{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"},{"name":"Subnet","slug":"Subnet","permalink":"https://perfectacle.github.io/tags/Subnet/"}]},{"title":"(AWS) VPC","slug":"aws-vpc","date":"2018-04-25T06:00:53.000Z","updated":"2022-10-30T08:42:16.143Z","comments":true,"path":"2018/04/25/aws-vpc/","link":"","permalink":"https://perfectacle.github.io/2018/04/25/aws-vpc/","excerpt":"자세한 내용을 보고 싶으면 Amazon VPC란 무엇인가?를 참고하면 된다. VPC(Virtual Private Cloud)란?가상의 네트워크라고 보면 된다.네트워크는 분산되어 있는 컴퓨터 자원들끼리 통신이 가능하게 끔 구축되어있는 환경 정도로 이해하면 될 것 같다.즉, 네트워크에는 네트워크 외부와 통신이 가능한 인터넷 뿐만 아니라 네트워크 내부에서만 통신이 가능한 인트라넷 등등이 있다.그 앞에 가상이 붙었다 싶이 물리적으로 네트워크를 구성한 게 아니라 논리적인 단위로 네트워크를 구성한 것이다.이렇듯 클라우드 컴퓨팅은 많은 레이어들을 추상화 해놓고, 자동화 해놓음으로써 물리적으로 구축하기 힘든 환경을 손쉽게 제공해준다는 장점이 존재한다. VPC 생성","text":"자세한 내용을 보고 싶으면 Amazon VPC란 무엇인가?를 참고하면 된다. VPC(Virtual Private Cloud)란?가상의 네트워크라고 보면 된다.네트워크는 분산되어 있는 컴퓨터 자원들끼리 통신이 가능하게 끔 구축되어있는 환경 정도로 이해하면 될 것 같다.즉, 네트워크에는 네트워크 외부와 통신이 가능한 인터넷 뿐만 아니라 네트워크 내부에서만 통신이 가능한 인트라넷 등등이 있다.그 앞에 가상이 붙었다 싶이 물리적으로 네트워크를 구성한 게 아니라 논리적인 단위로 네트워크를 구성한 것이다.이렇듯 클라우드 컴퓨팅은 많은 레이어들을 추상화 해놓고, 자동화 해놓음으로써 물리적으로 구축하기 힘든 환경을 손쉽게 제공해준다는 장점이 존재한다. VPC 생성 VPC는 Region에 생성되므로서비스하려는 region을 고민하고 신중하게 생성해야한다. 여기서는 VPC Wizards 대신에 직접 VPC를 만들어 볼 것이다.AWS 콘솔에서 VPC 서비스로 이동해서 좌측 탭 중에 Your VPCs를 클릭하고, Create VPC를 클릭한다. Name Tag와 IPv4 CIDR Block을 정해줘야하는데,AWS 공식 문서에서는RFC 1918에 명시된 private ip를 권장하고 있다.vpc와 같은 서비스는 전 세계에서 공통으로 사용하는 서비스이고 IP 주소는 자원을 식별하기 위한 주소이므로 충돌이 일어나면 안 된다.따라서 private ip를 추천하는 것 같고, ip class 별 private ip는 다음과 같다. A 클래스 - 10.0.0.0 - 10.255.255.255 (cidr block 10.0.0.0&#x2F;8) B 클래스 - 172.16.0.0 - 172.31.255.255 (cidr block 172.16.0.0&#x2F;12) C 클래스 - 192.168.0.0 - 192.168.255.255 (cidr block 192.168.0.0&#x2F;16) vpc에서 netmask는 16(65536개의 네트워크, 65536개의 호스트) ~ 28(약 26억개의 네트워크, 16개의 호스트)을 지정해줘야한다. 이렇게만 진행하면 간단하게 VPC를 생성했으니 이제 다음으로 Public Subnet을 만들어보자.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"VPC","slug":"VPC","permalink":"https://perfectacle.github.io/tags/VPC/"},{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(보안) 대칭/비대칭키 암호화","slug":"key-algorithm","date":"2018-04-13T02:00:23.000Z","updated":"2022-10-30T08:42:16.731Z","comments":true,"path":"2018/04/13/key-algorithm/","link":"","permalink":"https://perfectacle.github.io/2018/04/13/key-algorithm/","excerpt":"이번 포스트에서는 평문의 데이터를 암호화&#x2F;복호화 하는 방법에 대해서 이해해보자.사람이 알아볼 수 있는 데이터를 평문(plain text)라고 말하고, 평문을 암호화한 걸 암호문(cipher text)라고 부른다.수학적 원리를 알아보는 것도 아니기 때문에 간단하게만 정리해봤다. 키(KEY)암호화&#x2F;복호화 할 때 핵심 역할을 한다.예를 들면 알파벳 순서를 3칸 땡겨라와 같은 키가 있을 때 키는 두 가지 관점에서 바라볼 수 있다. 알파벳 순서를 땡겨라&#x2F;밀어라 - 알고리즘암호화 할 때 땡겨라 였으면 복호화 할 때는 밀어라 가 된다. 3칸 - 비밀번호비밀번호에 따라서 동일한 알고리즘이지만 암호화 했을 때 다른 값이 나온다.","text":"이번 포스트에서는 평문의 데이터를 암호화&#x2F;복호화 하는 방법에 대해서 이해해보자.사람이 알아볼 수 있는 데이터를 평문(plain text)라고 말하고, 평문을 암호화한 걸 암호문(cipher text)라고 부른다.수학적 원리를 알아보는 것도 아니기 때문에 간단하게만 정리해봤다. 키(KEY)암호화&#x2F;복호화 할 때 핵심 역할을 한다.예를 들면 알파벳 순서를 3칸 땡겨라와 같은 키가 있을 때 키는 두 가지 관점에서 바라볼 수 있다. 알파벳 순서를 땡겨라&#x2F;밀어라 - 알고리즘암호화 할 때 땡겨라 였으면 복호화 할 때는 밀어라 가 된다. 3칸 - 비밀번호비밀번호에 따라서 동일한 알고리즘이지만 암호화 했을 때 다른 값이 나온다. 동일한 알고리즘을 사용했다고 해서 항상 동일한 키가 생성되는 게 아니고, 동일한 패스워드를 사용했다고 해서 동일한 키가 생성되는 게 아니다.대부분의 경우에는 수학적 원리를 따지지 않고, 보안상 이슈가 없는 알고리즘을 그냥 선택하기 마련이라서 개발자들이 선택하는 알고리즘은 비슷한 걸 많이 쓰는 걸로 알고 있다.알고리즘만 가지고 키를 유추할 수 있다면 웬만한 서비스들의 보안은 구멍 투성이었을 것이다. 대칭키 암호화암호화&#x2F;복호화 할 때 사용하는 키가 동일한 경우를 말한다.(triple)DES(Data Encryption Standard, 많이 취약한 것으로 알려짐), AES(Advanced Encryption Standard) 등등이 있지만AES256 CBC를 가장 많이 쓴다.국내에서 만든 걸로는 SEED, ARIA 등등이 있다.위 알고리즘은 세 가지 구분으로 나눠서 볼 수 있다. AES - 알고리즘 256 - 키의 길이를 나타냄. CBC(cipher-block chaining) - 자세한 링크는 블록 암호 운용 방식를 참조 암호화&#x2F;복호화 관련해서 실습을 해볼 때는 OpenSSL을 이용하면 매우 간편하다. 1echo &quot;LOVE&quot; | openssl enc -aes-256-cbc -a 위 명령어를 치고 비밀번호를 입력하면 해당 키를 가지고 암호화 된 텍스트가 나온다. 암호화 된 텍스트를 평문으로 복호화 할 때는 아래 명령어를 입력하면 된다. 1echo &quot;U2FsdGVkX1+3CGPrtP48HYcpt1x2jMB3ZlvUnpLP6H4=&quot; | openssl enc -aes-256-cbc -a -d 비밀번호를 잘못입력하면 bad decrypt와 같은 문구가 나올 것이고, 비밀번호를 잘 입력하면 올바른 키로 복호화 된 LOVE란 평문을 볼 수 있다. 이렇듯 암호화&#x2F;복호화 할 때 동일한 키를 사용하는 것을 대칭키라고 부른다.대칭키는 암호화 연산 속도가 빠르다는 장점을 가지고 있다.하지만 내가 어떤 키로 암호화를 했다면 수신자도 같은 키를 가지고 있어야한다.그러기 위해서는 둘이 실제로 만나서 암호화에 쓰였던 키를 교환해야한다.하지만 이 과정에서 중간에 제 3자가 개입해서 키를 몰래 엿보거나 조작을 할 수 있다.이런 행위를 중간자 공격(man in the middle attack)이라고 부른다. 비대칭키 암호화대칭키의 키 관리가 매우 취약하다는 문제를 해결하고자 등장한 방식이다.대칭키와 반대로 암호화 할 때 사용하는 키와 복호화 할 때 사용하는 키가 다른 경우를 말한다.타인에게 절대 노출되서는 안되는 비밀키(개인키), 비밀키를 토대로 만든 공개키가 쌍을 이룬 형태이다. Diffie–Hellman 키 교환, RSA(알고리즘 제작자인 Ron Rivest, Adi Shamir, Leonard Adleman의 성의 이니셜을 땀) 등등의 알고리즘이 있다.TLS, SSH 프로토콜에서는 주로 RSA 알고리즘을 채택해서 사용한다. 비대칭키 암호화는 키 교환 알고리즘이 안전하다는 장점에 비해 알고리즘이 복잡한 수학적 연산으로 구성돼있어서 속도 측면에서는 단점이다. 또한 앞으로 설명할 비밀키&#x2F;공개키, 전자 서명, 전자 인증서, CA를 통틀어 PKI(Public Key Infrastructure, 공개키 기반 구조)라고 부른다. 공개키 암호화공개키를 통해 암호화하는 경우를 말한다.공개키로 암호화를 했다는 것은 비밀키로만 풀 수 있다는 뜻이다.주로 보안에 민감한 정보를 공개키 암호화 방식으로 보낸다. 특정(수신자) 비밀키로만 복호화가 가능한 공개키를 만드려면 해당 비밀키로 공개키를 만들면 된다.하지만 비밀키는 어떠한 사유에서도 유출하면 안 되고, 송신측에서는 수신측의 비밀키가 없으므로 공개키를 만들 수 없다.따라서 아래와 같은 시나리오를 따른다. 수신측에서 본인의 비밀키로 공개키를 만든다. 수신측은 해당 공개키를 송신측에 보낸다. 송신측은 해당 공개키로 데이터를 암호화해서 보낸다. 수신측은 본인의 비밀키로 데이터를 복호화한다. 위 과정에서 다음과 같은 의문을 품을 수 있다.2번의 과정에서 수신측의 공개키가 제 3자에게 탈취당하면 어떡하지?탈취 당해도 된다. 그래봤자 수신측의 비밀키가 없기 때문에 데이터를 복호화 할 수 없다. 하지만 위 과정에서 다음과 같은 취약점이 존재한다. 수신측에서 본인의 비밀키로 공개키를 만든다. 수신측은 해당 공개키를 송신측에 보낸다. 송신 측에 전달하기 전에 제 3자가 패킷을 가로채 자신의 공개키를 송신측에 전달한다. 송신 측은 제 3자의 공개키로 데이터를 암호화해서 보낸다. 이 때 제 3자가 또 패킷을 가로채서 본인의 개인키로 데이터를 복호화하면 원본 데이터 탈취가 가능하다. 전자 인증서 공개키 암호화 방식으로 통신할 때 내가 원하지 않는 상대방에게 데이터가 전달되는 취약점을 방지하고자 등장했다.전자 인증서는 자기 자신이라는 것을 증명하기 위한 수단이라고 보면 된다.tcp 3way handshake를 통해서 연결이 확립됐다고 해서 안심하면 안 된다.공개키 암호화 방식으로 통신을 하기 위해 공개키를 전달하는 과정에서공개키를 보내주는 쪽을 흉내낸 제3자가 보낸 공개키일 가능성이 있을 수 있기 때문이다.이렇듯 신뢰할 수 있는 곳이 아닌 곳에서 보낸 공개키에 대한 검증 없이 바로 해당 공개키로 암호화해서 데이터를 보내면 데이터가 탈취당한 것이다. 전자 인증서를 발급받기 위해서는 CA(Certification Authority, 인증 기관)에 발급 요청을 해야한다.최근 이슈를 일으킨 시만텍(symantec), 무료 SSL&#x2F;TLS 인증서를 발급해주는 Let’s Encrypt에서 사용하는 ISRG(Internet Security Research Group), Comodo 등등이 있다.별도의 검증 없이 인증서를 발급해주면 각종 벤더사 등등으로부터 외면받고 신뢰도가 떨어지는 경우도 있으니 어느 인증기관에서 발급한 인증서인지도 중요하다.이 CA 사이에도 계층 구조가 있어서 루트 CA가 있고, 그 하위 CA가 연쇄적으로 있다.따라서 특정 CA는 인증서의 묶음을 가지게 되는데 이걸 보고 인증서 체인(certificate chain)이라고 부른다. 전자 인증서를 발급받으려면 다음과 같은 시나리오를 따른다. 본인의 공개키와 소유자 정보(도메인 주소 같은 정보)를 CA에 보낸다. CA에서는 소유자 정보와 공개키를 검증해서 전자 인증서를 발급해준다. 전자 인증서에는 공개키, 소유자 정보, 인증 기관의 전자 서명이 포함돼있다. 전자 인증서가 공개키 암호화에 어떻게 사용하는지는 아래 시나리오를 보면 된다. 수신측에서 본인의 비밀키로 공개키를 만든다. 수신측은 해당 공개키와 소유자 정보를 토대로 CA에 전자 인증서 발급 요청을 한다. 정상적이라면 전자 인증서를 발급받고 송신측에 전자인증서를 보낸다. 송신측은 전자인증서를 토대로 수신측이 정말 수신자가 맞는지 확인을 한다.전자인증서를 발급해준 CA에게 정말 해당 CA에서 발급한 인증서가 맞는지 확인 요청한다. 검증이 끝났으면 전자인증서에 있는 공개키로 데이터를 암호화 해서 수신측에 보낸다. 수신측은 암호화된 데이터를 본인의 개인키로 풀어서 복호화된 데이터를 본다. 전자 서명(비밀키 암호화)전자서명은 비밀키로 암호화한 데이터를 의미한다.비밀키로 암호화 했다는 것은 공개키로만 풀 수 있다는 뜻이다.공개키로 복호화 할 수 있다니 아래와 같은 의문을 품을 수 있다.공개키면 아무나 다 해당 메시지를 풀어볼 수 있는 건가?맞다, 애초에 공개를 위한 메시지이다.그렇다면 공개를 위한 메시지인데 왜 암호화를 한 것일까?이름에서부터 알 수 있듯이 전자 서명이다, 본인의 신원을 보증하는 역할을 한다. 어떤 근거로 전자 서명이 본인의 신원을 보증하는 역할을 하는 것일까?바로 비밀키로 암호화하기 때문이다.비밀키는 본인만 가지고 있어야하고, 그런 전제가 성립된다면 해당 비밀키를 가진 장비에서 데이터를 보냈다는 사실이 입증되는 것이다.따라서 비밀키는 어떠한 경우에도 공유가 이뤄지면 안 된다. 전자 서명은 아래와 같은 시나리오를 따른다. 송신측에서 데이터를 비밀키로 암호화한다. 수신측에서 데이터를 복호화해야하니 암호화한 데이터 + 공개키를 같이 보낸다. 수신측에서는 암호화한 데이터를 받아서 송신측의 공개키를 통해 데이터를 복호화한다. 하지만 위와 같은 과정에서는 다음과 같은 문제가 발생한다.2번의 과정에서 제 3자가 패킷을 가로채서 데이터를 조작하고 본인의 개인키로 암호화한 후에 본인의 공개키를 실어서 보내면수신측에서는 송신측에서 보낸 정보라고 취급하기 때문에 이 부분은 취약점이라고 할 수 있다. 해시 함수(메시지 다이제스트 함수)해시 함수는 데이터의 무결성(위변조가 일어나지 않았다는 검증)을 위해 등장했다.해시 함수는 임의의 메시지를 입력 받으면 고정된 블록의 길이의 메시지를 출력하는 함수이다.데이터 압축과는 달리 복호화가 불가능한 함수이다.복호화가 불가능 하기 때문에 단방향 암호화에서도 쓰이며 비밀번호화 같이 데이터가 유출돼도 원본 데이터의 유추가 불가능해야하는 보안에 아주 민감한 정보에 대해 이런 방식으로 암호화를 한다.라고 생각할 수 있으나 해시 함수는 애초에 비밀번호와 같은 데이터를 암호화 하려고 설계된 게 아니라 짧은 시간에 데이터를 검색하기 위해 설계됐으므로데이터의 무결성을 체크할 때만 확인해야한다, 자세한 내용은 안전한 패스워드 저장을 확인하자.(이러한 이유 때문에 대부분의 웹서비스가 비밀번호를 알려주고 싶어도 보안상 이슈로 알려주지 못하고 초기화를 진행하게 되는 것이다.만약 아직도 비밀번호를 알려주는 서비스가 있다면 보안에 대한 관리가 허술하게 운영되고 있는 사이트라고 판단하면 된다.)데이터 압축은 데이터의 모든 데이터를 들고 있는 반면에 해시 함수는 데이터의 손실이 발생해서 복구가 불가능하다.데이터의 손실이 있기 때문에 다른 입력값인데도 불구하고 동일한 출력이 발생하는 충돌(Collision)이 발생할 가능성이 존재한다.이런 충돌에 관해서는 비둘기집 원리나 생일 문제를 참고해도 재미있다. 예를 들면 이름을 입력하면 성을 출력하는 해시 함수를 생각해 볼 수 있다. 12f(양권성) = 양f(양간장) = 양 양권성이란 데이터를 입력했더니 양이란 데이터가 출력됐다.이 과정에서 데이터의 손실이 발생했다.또한 양권성과는 다른 양간장이란 데이터를 입력했더니 동일한 출력이 양이 나왔다.해시 함수의 출력값을 메시지 다이제스트라고 부른다. 이렇듯 충돌이 잦은 알고리즘은 좋은 해시 함수라고 말할 수 없으며 취약점이 아주 많다.따라서 혼자서 해시 함수를 만들어서 상용 서비스에 사용하겠다는 생각보다는MD5(Message-Digest algorithm, 보안상 취약점으로 권장되지 않음)나SHA(Secure Hash Algorithm, SHA-1도 보안상 취약점이 발견됨) 같은 검증된 알고리즘(취약점이 발견되지 않고, 충돌이 잦지 않은)을 사용하는 게 좋다. 이 해시 함수가 어떻게 전자 서명에 사용되는지 아래 시나리오를 보면 된다. 송신측에서 해시 함수를 통해 원본 메시지를 해싱해서 메시지 다이제스트를 구한다. 메시지 다이제스트를 비밀키로 암호화한다. 수신측에 해시 함수 알고리즘, 비밀키로 암호화한 메시지 다이제스트, 원본 데이터, 공개키를 전달한다. 수신측에서는 비밀키로 암호화한 메시지 다이제스트를 공개키로 풀어서 원래 메시지 다이제스트를 구한다. 원본 데이터를 해시 함수 알고리즘으로 해싱해서 메시지 다이제스트를 구한다. 4번과 5번의 메시지 다이제스트가 일치하면 데이터 위변조가 없다고 판단하고 송신측에서 전달한 데이터라는 걸 신뢰하면 된다. 대칭키 암호화와 비대칭키 암호화의 혼용대칭키는 속도가 빠른 대신에 키 교환에 있어서 취약점이 존재하고,비대칭 키는 키 교환에 있어서 안전한 반면에 속도가 느리다는 단점이 존재한다.따라서 위 두 방식을 섞어 사용하면 장점만을 살릴 수가 있다.키 교환에는 비대칭 키를 사용하고, 데이터 암호화&#x2F;복호화에는 대칭키 암호화를 진행하면 된다. 송신측에서 대칭키를 공개키 암호화 한다. 수신측에서 공개키가 포함된 전자 인증서를 송신측에게 보낸다. 송신측에서 전자 인증서를 토대로 수신측의 신원 확인을 한다. 검증이 끝나면 공개키를 신뢰하고 쓰면 되고, 이제 공개키를 위한 키 교환 알고리즘은 끝났다. 수신측에서는 암호화 된 대칭키를 비밀키로 푼다. 송신측&#x2F;수신측 모두 대칭키를 안전하게 전달받았으므로 해당 대칭키로 암호화&#x2F;복호화를 통해 통신하면 된다. 위 과정을 이해하면 SSL&#x2F;TLS 프로토콜이 어떻게 동작하는지 이해할 수 있다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"},{"name":"Security","slug":"Security","permalink":"https://perfectacle.github.io/tags/Security/"}]},{"title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 5장 하드웨어와 네트워크 인터페이스 계층","slug":"tcp-ip-book-index-5","date":"2018-04-01T14:14:24.000Z","updated":"2022-10-30T08:42:16.947Z","comments":true,"path":"2018/04/01/tcp-ip-book-index-5/","link":"","permalink":"https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-5/","excerpt":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.여기서부터는 백엔드도 딱히 몰라도 되는 내용인 것 같다.","text":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.여기서부터는 백엔드도 딱히 몰라도 되는 내용인 것 같다. 예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다. 백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다. 더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다. 목차 컴퓨터 네트워크 네트워크 서비스와 애플리케이션 계층 트랜스포트 계층 라우팅과 인터넷 계층 하드웨어와 네트워크 인터페이스 계층 보안 5장, 하드웨어와 네트워크 인터페이스 계층OSI 7 Layer에서 L1(Physical Layer), L2(Data Link Layer)에 해당한다.이제부터는 하드웨어에 대한 설명도 같이 나온다.이더넷 카드의 스펙, 랜선의 스펙, 공유기의 스펙, 모뎀의 스펙 등등이 전부 연관이 돼있기 때문이다.이 계층은 통신할 기기에게 데이터를 전달만 하면 끝이다.나머지는 그 상위 계층에서 알아서 할 일이다.또한 이 계층은 비교적 근거리 통신(PC -&gt; 공유기, 공유기 -&gt; 모뎀 등등) 위주이다.따라서 버스나 지하철을 환승한다고 생각하면 이해하기 쉬울 것이다. 5-1. 네트워크 인터페이스 계층의 역할소프트웨어적인 부분(프로토콜, OSI L2(데이터링크 계층))과 하드웨어적인 부분(이더넷 카드, 랜케이블 등등, OSI L1(물리 계층))의 역할을 담당한다. 네트워크 인터페이스에서 쓰는 프로토콜은 전화 회선을 사용해서 원격지와 접속하는 PPP(Point-to-Point Protocol),IP 주소로 Physical Address인 Mac Address를 구하는 ARP(Address Resolution Protocol),ARP의 역인 RARP(Reverse Address Resolution Protocol) 등등이 있다. 하드웨어 장비에는 엄~청나게 많은데 그나마 우리와 밀접하게 쓰이는 건 아래와 같은 게 있다. 이더넷 카드(Ethernet Card)NIC(Network Interface Card)라고도 부르고, 한국에서는 랜카드라고도 많이 부른다.ethernet은 하나의 스펙이라고 보면 된다.이 이더넷 카드에는 전세계에서 식별가능한 고유한 ID인 MAC Address가 있는데 이것 또한 개인정보로 볼 수도 있어서 함부로 알려줘서도 안 되고,ActiveX와 같은 구리구리한 기술이나 OS단을 직접 컨트롤하지 않는 이상은 IP 주소까지는 캐치해도 MAC Address까지는 알아낼 수 없다. 랜선모뎀 &lt;-&gt; (공유기 &lt;-&gt;) 이더넷 카드를 연결해주는 역할을 한다. 공유기ISP 측에서 제공해주거나 직접 돈을 주고 사기도한다.퍼블릭 IP 하나를 여러명이 공유해서 쓰게끔 해서 인터넷은 하나만 가입했는데 여러대의 장비가 인터넷을 쓸 수 있게 해준다.그래서 IP 공유기, 인터넷 공유기 등등으로 불린다. 모뎀ISP 측에서 제공해주는 장비로(혹은 아예 없고 아파트 단지 내 어딘가에 존재하기도 한다.)ISP 측에서 제공해주는 (광)케이블은 빛(아날로그 신호)을 보내주는데 컴퓨터는 빛을 모르고 디지털 신호(0, 1) 밖에 모른다.또한 컴퓨터는 디지털 신호를 보내는데 케이블은 아날로그 신호 밖에 모른다.이렇게 디지털 신호 &lt;-&gt; 아날로그 신호 상호 변환시켜주는 장비를 모뎀이라고 한다. (광)케이블ISP 업체에서 깔아주는 케이블인데 이 케이블에 따라서 100메가 광랜이냐 기가광랜이냐가 구분된다. 상위 레이어는 특정 하드웨어에 의존하지 않게 끔 설계가 돼있는데 이 레이어는 하드웨어와 뗄래야 뗄 수 없는 관계이다. 5-2. MAC 어드레스NIC에는 MAC(Media Access Control) 어드레스라고 하는 물리적 주소(IP 주소는 논리적 주소)라고 하는 식별 번호가 부여돼있다.이 번호는 제조사가 제조 단계부터 붙이는 것으로 전 세계의 어떤 NIC와도 식별 가능하도록 설계가 돼있다.16진수 12글자(48비트)로 구성이 돼있고 각 자리가 IPv4는 .으로 구분되는 것에 비해 IPv6처럼(같은 16진수 표기법 사용) :(콜론)으로 구분돼있다.첫 24비트는 제조가 식별 번호이고, 뒤에 24비트는 제조가에서 정의한 식별 번호이다. 네트워크 인터페이스 계층에서는 IP 주소가 존재하는 인터넷 계층보다 더 하위 레이어라서 IP 주소의 존재를 모른다.따라서 통신을 할 때 MAC 주소를 사용한다.그리고 유&#x2F;무선 LAN과 더불어 블루투스의 경우에도 MAC Address를 이용하여 통신이 이루어진다.트랜스포트 계층에서 보내는 데이터를 세그먼트라고 부르듯이 네트워크 인터페이스 계층에서는 프레임이라고 부른다.프레임의 헤더를 까보면 데이터의 시작을 알리는 프리앰블, 송&#x2F;수신지 맥 주소, 길이&#x2F;타입이 들어있고,데이터의 뒤에 FCS(Frame check sequence, 오류 방지를 위한 정보)가 붙는다. IP 주소와의 차이점을 보자면 IP 주소는 목적지 주소가 달라지지 않는다.하지만 Mac 주소는 대부분 단거리 통신을 위해 쓰인다.따라서 바로 다음 목적지(최종 목적지가 아닌, 예를 들면 라우터)의 MAC Address만 알고 있으면 된다.이것도 라우터, 링크드 리스트와 마찬가지로 이전 MAC Address가 뭐든, 최종 MAC Address가 뭐든 신경쓰지 않고 바로 다음 MAC Address에만 신경을 쓴다. 5-3. 이더넷이더넷은 유선 LAN(Local Area Network) 상에서 쓰이는 하나의 스펙이다.LAN이란 말이 붙었듯이 근거리 통신을 위해서만 쓰이는 규격이지 않을까 싶다. (저 태평양 너머 미국 서버와 통신하려면 이더넷 스펙 말고 WAN(Wide Area Network)에 쓰이는 뭔가를 써야하지 않을까…) 프레임의 패킷을 까보면 프리앰블(preamble)이라는 게 있다.네트워크 어댑터(이더넷 카드)는 수많은 디지털 신호를 받아들이는데 그럼 어디서부터가 프레임의 시작인지 모르기 마련이다.그래서 일단 먼저 프레임의 시작을 알리는 신호를 줘야하는데 그게 프리앰블이다.프리앰블의 길이는 상당히 길어서 중간에 조금 유실이 되어도 특정 패턴으로 인해 프리앰블이라는 사실을 캐치할 수 있다. 이더넷 규격(랜선의 규격)을 보다보면10BASE-T, 100BASE-X, 1000BASE-TX 같은 게 있는데앞에 10 100 1000은 Mbps를 뜻한다.메가 바이트도 아니고 메가 비트이며, 1024를 1GB로 치는 것도 아니고 1000을 1GB로 치기 때문에 이런 상술에 속아나지 않으려면 인터넷 속도에 대한 진실을 읽어보자.BASE는 신호 변조 방식을 의미하는데BASE는 Baseband 방식을 의미하고 다른 방식으로는 Broadband 방식이 있다.전공에서 다 배웠는데 다 까먹… ㅠㅠ아래 글을 참고해보자. 브로드밴드와 베이스밴드 전송의 차이점과 특성이 무엇인지 알려주세요 베이스밴드와 브로드밴드 마지막 TX는 케이블의 재질을 의미한다.T는 트위스트페어로 뭐 선가닥을 꼬아놔서 간섭이나 그런 거에 좀 더 견고한 형태인 것 같다.선의 종류에는 STP, UTP, FTP 등등과 성능을 카테고리로 분류해둔 CAT가 있는데 아래 글을 참고하자.랜선의 종류와 구분 (UTP&#x2F;STP&#x2F;FTP 차이점) 5-4. 네트워크 허브네트워크 허브는 중계 기기라는 거 같다.공유기가 데이터를 네트워크 내의 다른 컴퓨터에 전달하므로 공유기는 네트워크 허브 역할도 담당한다. L2 스위치는 스위칭 허브라고 부르기도 하며 오늘날 가장 많이 사용되는 네트워크 중계 기기(네트워크 허브)라고 한다.L2 스위치는 OSI 7 Layer에서 데이터 링크 계층(2계층)에 속하는 장비이고, 각 포트(공유기 뒤에 보면 유선랜 꽂는 포트가 있다.)에 연결된호스트의 MAC Address를 기억해뒀다가 통신할 때 사용한다.공유기의 랜포트에는 하나의 랜선만 꽂을 수 있기 때문에 MAC Address가 충돌이 일어나지 않기 때문에 통신에 문제가 없다. 또한 브로드캐스트 도메인이란 게 존재하는데 수신지의 주소가 브로드캐스트 어드레스일 때 데이터가 전달되는 범위를 의미한다.따라서 L2 스위치(일반적인 가정의 공유기)로 네트워크를 구성했다면 네트워크 전체가 브로드캐스트 도메인이 된다.네트워크에 연결된 호스트가 많다면 수많은 트래픽을 유발하므로 망이 혼잡해질 수 있다. 이러한 L2 스위치가 나오기 전에는 리피터 허브란 것을 사용했다.한개의 호스트에서 수신한 데이터를 다른 모든 호스트에게 전달하는 방식이었다.이 경우에는 모든 호스트가 회선을 공유하기 때문에 여러 대의 호스트가 동시에 통신을 하게 되면 네트워크 상에서 충돌이 발생했다.이렇게 충돌이 발생할 수 있는 범위를 Collision Domain(충돌 도메인)이라고 불렀고,이더넷 스펙에서는 충돌이 발생했으면 모든 호스트가 통신을 멈추고 대기하게 끔 기술돼있어서호스트의 갯수가 증가하면 할 수록 통신 속도가 떨어지는 단점이 존재했다. 네트워크와 네트워크를 넘어서 중계를 하고 싶다면 L3 스위치(Network Layer) 장비를 사용해야한다.L3 스위치에서는 VLAN(Virtual LAN)을 사용해서 LAN을 몇 개의 가상적인 네트워크로 분할해서 통신의 효율을 높일 수 있게 된다.이렇게 되면 브로드캐스트 도메인이 네트워크 전체 호스트가 아닌 특정 VLAN에 속한 호스트로 한정지을 수 있게 된다.L3 스위치를 사용하면 라우터처럼 라우팅을 하면서 VLAN 사이를 넘나들 수 있으며 규모상 대규모 사무실에 적합하다고 책에 쓰여져있다.VLAN 내에서는 L2 스위치와 같이 MAC Adress로 통신이 이루어진다. 5-5. 무선 LAN유선랜이 광랜일 때는 빛을 통해 통신이 이루어졌던 반면에무선랜의 경우에는 전파를 이용해서 통신이 이루어진다.유선랜의 스펙이 이더넷이었다면 무선랜의 스펙은 IEEE 802.11이다.유선랜 같은 경우에는 IEEE 802.3으로 이더넷이란 이름까지 붙었는데 무선랜의 경우에는 딱히 이름이 안 붙은 모양이다. 스펙은 현재 IEEE 802.11, IEEE 802.11a, IEEE 802.11b, IEEE 802.11g, IEEE 802.11n 등이 나왔다. 통신을 할 때는 다른 통신 장비가 전파를 발신하고 있는지 확인 후 통신을 시작하는 CSMA&#x2F;CA(Carrie Sense Multiple Access with Collision Avoidance) 방식을 사용한다. 무선랜의 프레임을 보면 프리앰블이 보이고, 맨 끝에 오류 제어를 위한 FCS도 있고, 갖가지 정보가 있는데유선랜의 경우에는 송수신지 맥 주소만 있으면 됐는데 무선랜의 경우에는 맥 주소가 4개나 된다.일단 송&#x2F;수신지 맥 주소 2개를 제외하고 나머지 하나는 공유기(AP, Access Point)의 MAC Address가 들어간다. 무선 -&gt; 무선이면 송신지의 무선 AP의 MAC Address가 들어가고 하나는 공란 무선 -&gt; 유선이면 송신지의 무선 AP의 MAC Address가 들어가고 하나는 공란 유선 -&gt; 무선이면 무선 AP의 MAC Address가 들어가고 하나는 공란 (무선 AP를 통해서 통신) 무선 -&gt; 유선이면 송신지의 무선 AP의 MAC Address가 들어가고, 하나는 수신지의 유선 AP의 MAC Address가 들어간다. 5-6. ARP유무선 통신을 하려면 수신측의 MAC Address를 알아야한다.데이터를 보낼 때는 상위 계층에서 하위 계층으로 내려오므로 IP 주소는 알지만 MAC Address는 모르는 상황이다.이 때 IP 주소를 가지고 MAC Address를 알아내는 ARP(rotocol)를 사용해야한다.브로드캐스팅을 통해 IP 주소를 때리고 해당 IP 주소를 가진 호스트는 자신의 MAC 어드레스를 응답하게 된다. ARP 헤더를 보면 앞에 이더넷 헤더가 붙어있는데이더넷 헤더에 있는 수신지 MAC Address는 브로드캐스트 어드레스의 MAC Address를 의미하고,ARP 헤더에 목적지 MAC Address는 아직 어디로 가야할지 모르는 MAC Address를 의미한다.따라서 목적지의 IP Address를 브로드캐스트 어드레스의 MAC Address로 보내서 목적지의 MAC Address를 응답받는 행위가ARP 프로토콜을 통해 일어난다. 또한 대부분 ARP는 같은 네트워크 내에서 이뤄지기 마련인데 네트워크를 쪼갠 같은 서브넷 사이에서는 문제가 없는데가끔 서브넷 마스크가 다른 외부의 서브넷(크게 보면 같은 네트워크 클래스에 속하지만 서브넷 마스크로 쪼갰으므로 별도의 네트워크라고 봐야한다.)에 대해서 ARP 통신이 일어날 때도 있다.이럴 때는 프록시 ARP를 둬서 호스트 대신에 라우터가 ARP에 대한 응답을 하게 끔 한다.브로드캐스팅 때려도 같은 네트워크가 아니니 라우터가 받아서 해당 네트워크에 브로드캐스팅을 날리고 그거에 맞는 응답을 받아서 다시 라우터가 송신측에 응답을 주게 된다. 5-7. FTTx와 xDSLISP 업체가 쓰는 광랜이니 하는 것은 대부분 광섬유 케이블에 레이저 빛을 쏘아 통신하는 광섬유 회선이다.광 회선이 어디까지 들어오느냐에 따라 달라지는데 FTTH(Fiber to th Home) 등등 FTTx로 불린다. 또한 ISP에서 집까지 인터넷이 들어오는 것은 점유형과 공유형이 있는데점유형은 ISP에서 집까지 하나의 케이블로 연결되고, 공유형은 중간에 광 신호를 분기해서 여러개의 케이블이 공유하는 형태이다.아마 성능 등등을 생각하면 점유형이 좋겠지만, 비용 등등의 이유로 인해, 혹은 그만한 성능을 낼 필요가 없기 때문에 대부분은 공유형을 쓸 것이다. 그리고 ADSL(Asymmetric Digital Subscriber Line)이나 VDSL(Very high bitrate Digital Subscribe Line)은 금속 케이블을 사용하는 통신 회선이다.통신 방식이나 속도, 거리 등등 몇 가지 규격에 따라 구분이 되는데 이를 통틀어 xDSL이라고 부른다. 전화 회선을 사용하는 ADSL은 전화에서 사용하지 않는 높은 주파수로 디지털 신호를 전송하고, 다운로드 속도가 업로드 속도보다 훨씬 빠른편이다.옥외 배선에서 사용되는 VDSL은 아파트나 호텔 같은 공동 주택에서 ISP에서 FTTx로 연결을 한 후 중앙에서 분기틀 태워서 각 방까지 분배하는 형식을 취하고 있다. 5-8. PPP와 PPPoEPPP(Point to Point Protocol)은 원격지에 있는 컴퓨터를 일대일로 연결하기 위한 프로토콜이다.이 프로토콜은 다양한 통신 하드웨어를 지원하도록 설계돼있어 전화 회선을 사용하는 다이얼 업 PPP나이더넷을 사용하는 PPPoE(Point to Point over Ethernet)와 같은 형태가 있다. 5-9. ARP 명령으로 MAC 어드레스 알아내기DNS와 마찬가지로 MAC Address도 캐시에 저장을 하게 된다.똑같은 IP에 대해서 MAC Address를 계속 구하는 것도 짜치는 일이기 때문이다.따라서 이렇게 ARP 프로토콜로 얻어낸 MAC Address의 캐시를 확인하는 명령어가 arp 명령어다.arp -a 명령어를 쳐서 캐시에 저장된 IP Address&#x2F;MAC Address를 확인할 수 있고-s 옵션을 줘서 수동으로 IP Address&#x2F;MAC Address가 매핑된 정보를 저장할 수도 있다.하지만 이렇게 수동으로 정보를 저장하는 건 매우 위험할 수도 있으므로 추천하지 않는다.또한 LAN 내에서는 ARP가 매우 자주 일어나는데 와이어샤크 같은 패킷 캡쳐 도구를 이용해서 확인해보는 것도 좋은 방법이다. 5-10. 모바일 통신 기술모바일 통신 기술 중에 LTE로 연결하는 거하고, 와이파이로 연결하는 거하고 통신 거리가 엄청난 차이가 난다.와이파이는 꽁짜(아닌 경우도 있을테지만)인 대신에 AP(Access Point, 공유기)와 멀어지면 멀어질 수록 느려지고 끊기기도 한다.하지만 LTE의 경우에는 기지국과 수 십 km 떨어져있는데도 통신이 잘 된다.이는 사용하는 주파수 대역과 데이터 변조 방식에 차이가 있기 때문이라고 한다. 또한 3G와 4G는 통신 속도 뿐만 아니라 데이터 통신 방식 자체가 달라졌다.3G의 경우에는 패킷 교환 방식(회선 점유 X), 회선 교환 방식(회선 점유 O)의 통화를 동시에 사용할 수 있었는데4G(LTE)의 경우에는 패킷 교환 방식의 데이터 통신(VoIP 프로토콜이 패킷 교환 방식, UDP 프로토콜 사용)만 지원한다.4G로 오면서 음성 위주의 전화 통화보다 데이터 위주의 통신(영상 통화도 있고)을 하다보니안정성 보다는 실시간 성에 좀 더 초점을 맞춘 거라고 볼 수 있다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 4장 라우팅과 인터넷 계층","slug":"tcp-ip-book-index-4","date":"2018-04-01T13:00:38.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2018/04/01/tcp-ip-book-index-4/","link":"","permalink":"https://perfectacle.github.io/2018/04/01/tcp-ip-book-index-4/","excerpt":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.여기서부터는 프론트는 딱히 몰라도 된다고 생각하는 내용이므로 목차 뒤에 F&#x2F;B를 구분해서 달지 않겠다.","text":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.여기서부터는 프론트는 딱히 몰라도 된다고 생각하는 내용이므로 목차 뒤에 F&#x2F;B를 구분해서 달지 않겠다. 예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다. 백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다. 더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다. 목차 컴퓨터 네트워크 네트워크 서비스와 애플리케이션 계층 트랜스포트 계층 라우팅과 인터넷 계층 하드웨어와 네트워크 인터페이스 계층 보안 4장, 라우팅과 인터넷 계층OSI 7 Layer 기준 L3(Network Layer)이다.IP 주소를 가지고 송신지로부터 수신지로 데이터를 전달하는 역할을 수행한다.유선 전화번호가 지역 번호를 내장하고 있는 것과는 달리 IP 주소는 지역 정보로 구분되는 게 아니라 네트워크 단위로 할당이 된다.따라서 IP들을 보면 같은 네트워크에 속해있는지, 소규모 네트워크인지 대규모 네트워크인지 정도만 알 수 있다. 그리고 각 네트워크들은 라우터라는 장비를 통해 연결이 되므로 라우팅 테이블이 복잡하게 연결돼있으면 지리상으로 가까운데도 불구하고데이터 전송을 하는데 오래 걸리는 경우도 존재한다.반대로 지리상으로 먼데 라우팅 테이블이 잘 설계돼있으면 금방 데이터가 도착할 수도 있다. 4-1. 인터넷 계층의 역할IP 주소로 데이터를 전달하는 역할을 한다.바로 다이렉트로 목적지 IP 어드레스를 찌르는 게 아니라 라우터(Router)라는 장비들을 통해서 전송이 이루어진다.클라이언트는 인접한 라우터를 찾고 그 라우터는 또 인접한 라우터들을 찾아서 데이터를 보내려는 목적지와 인접한 라우터까지 이 과정이 반복되고최종 라우터에서 목적지로 데이터를 보낸다.이렇게 라우터를 통해 목적지의 경로를 찾아가는 작업을 라우팅(Routing)이라고 부른다. 간단하게 가정집을 시나리오로 생각해보자. 내가 웹 브라우저를 통해 네이버로 접속하려고 한다. 내 컴퓨터가 공유기(라우터의 역할을 수행한다)로 데이터를 쏜다. 공유기는 모뎀(얘가 라우터의 역할도 한다)로 데이터를 쏜다. 공유기는 다른 라우터들을 통해서 ISP(올레나 SK 브로드 밴드 등등의 인터넷 서비스 제공자) 라우터로 토스를 한다. 그 라우터가 다른 수많은 라우터를 거쳐 네이버 서버와 연결된 라우터까지 간다. 해당 라우터가 네이버에게 요청을 보낸다. 요즘 들어 핸드폰이며 TV며 냉장고며 IoT가 나오기도 하고 온갖 사물들이 인터넷과 통신을 하면서 IP 주소를 막 할당받기 시작했다.그러면서 진작부터 IP 주소가 고갈되기 시작했다.그래서 등장한 것이 Private IP(사설 IP)이다.공유기를 쓰면 내 컴퓨터와 다른 사람의 컴퓨터가 다른 IP를 사용하는 것 같은데이건 내부적으로 사용하는 private IP나 다른 것이지 외부로 달고 나가는(외부에서 접속 가능한) Public IP(공용 IP)는 하나만 존재한다.그리고 외부에서는 하나의 IP만 할당한 것으로 보이기 때문에 이런 방식으로 IP 주소 부족의 문제를 해결하고 있다.이런 방식과는 별개로 IPv4 주소가 32비트(2^32, 약 42억)여서 42억 개의 IP만 할당이 가능한 데 비해IPv6의 경우에는 128비트(2^128, 3.4028237e+38)로 단위로 표현할 수도 없는 갯수의 IP 할당이 가능하다.하지만 여러 기술의 도입으로 인해 아직 IPv6를 사용하지 않아도 되는 수준인지 IPv6는 딱히 써본 적이 없다.IPv4는 IP 프로토콜을 사용하는데 반해 IPv6는 IPSec이라는 프로토콜을 지원해서 패킷 자체를 암호화하고 있다.그리고 IPv4는 사람한테 익숙한 10진수를 쓰긴 했는데 마지막 자리가 255라는 애매한 숫자로 떨어지는데IPv6는 16진수를 사용해서 마지막 자리가 FF로 떨어져서 그나마 가독성이 조금 올라간 것 같다. 4-2. IPv4와 IPv64-2-1. IPv4는 32비트 어드레스IP 주소는 인터넷 계층(혹은 L3) 장비에만 할당되기 때문에 이더넷 카드나 모뎀 등등에는 할당되지 않는다. 4-2-2. IPv4 헤더IPv4 패킷의 헤더에는 송수신지 IP 어드레스나 생존기간, 프로토콜, 체크섬, 버전, 우선순위, 패킷 전체의 길이 등등을 담고 있다. 4-2-3. IP 패킷에도 유통기한이 있다.HTTP 1.1 스펙에서 Keep-Alive를 통해 TCP 커넥션의 유효기간을 설정하듯이IP 패킷에도 생존기간을 설정할 수 있다.IP 패킷의 TTL(Time to Live)를 7홉(Hop)으로 설정하면 라우터를 하나 탈 때마다 TTL이 하나씩 깎인다.7홉 내에서 목적지까지 도착하지 못하면 해당 패킷은 소멸된다.패킷을 라우터를 찾기 위해 무한정 뺑뺑이 돌리면 효율이 떨어지므로 TTL이 있는 것 같다. 4-2-4. 좁은 길을 지날 때는 작게 분할해서 지나간다.한 번에 전송할 수 있는 데이터 크기를 MTU(Maximum Transmission Unit)라고 하고통신 경로의 상태(라우터의 상태)에 따라 달라진다.패킷을 보낼 때 다음 라우터의 MTU보다 작으면 해당 MTU 만큼 패킷을 쪼개서 보낸다.하지만 패킷이 중간에 유실되면 복구하기 어려우므로 처음부터 전체 경로에 대해서 MTU를 구하고 해당 MTU만큼 보내는 게 제일 안전하다. 4-2-5. 데이터를 분할하고 복원하는 방법패킷 헤더를 보면 아래와 같은 필드로 데이터를 분할하고 복원한다. 식별자: 같은 데이터인지 식별하기 위한 16비트 숫자 값 분할 플래그: 분할 허가 플래그와 이후에 남은 분할이 있는지 표시하기 위한 플래그 프래그먼트 옵션: 원래 데이터에서의 위치 값을 표현하는 13비트 숫자 위 헤더 필드를 통해 데이터를 분할하고 복원하게 된다. 4-2-6. IPv6IPv4 주소(32비트)의 고갈로 인해 등장(128비트)했는데 private IP 등등의 기술로 인해 IPv4에 산소호흡기를 달아놓은 상태이다.헤더를 보면 버전, 패킷의 우선순위를 결정하는 트래픽 클래스, 데이터 부분의 길이를 담당하는 페이로드의 길이, TTL을 나타내는 홉 리미트, 송수신지 IP 어드레스 등등이 있다. 4-2-7. IPv6로 갈아타기소프트웨어를 새로운 버전으로 마이그레이션 하거나 다른 소프트웨어로 마이그레이션 하는 것은 상당한 일이다.IPv4와 IPv6의 패킷은 서로 호환이 되지 않기 때문에 송신지는 IPv6를 쓰는데 수신지는 IPv4를 쓰는 난감한 상황이 존재하기 마련이다.이런 점을 방지하고자 하나의 장비에서 IPv4, IPv6 두 어드레스를 지원하는 듀얼스택(Dual Stack)이란 기술도 있고,터널링(tunneling)이라는 기술을 통해 IPv6가 오면 IPv4로, IPv4가 오면 IPv6로 변환해주는 기술들이 존재한다. 4-3. IP 어드레스의 활용4-3-1. 네트워크 부와 호스트 부IP 어드레스는 네트워크 부분과 호스트 부분으로 구성된다.호스트는 네트워크에 구성된 장비(PC, 스마트폰 등등)을 의미한다.라우터는 송신지 IP 어드레스의 네트워크 부분을 보고 자신과 같은 네트워크에 있는지 외부의 네트워크에 있는지 판단한다. 네트워크 부분과 호스트 부분을 나눈 이유는 모든 호스트들을 하나의 네트워크로 묶어두면 관리하기 어렵다는 측면에서 나오게 되었다. 4-3-2. 어드레스 클래스하나의 IP 어드레스를 봤을 때 어디까지가 네트워크 부분이고 어디까지가 호스트 부분인지 알 수가 없다.A, B, C, D 클래스에 따라서 네트워크 부분과 호스트 부분의 경계를 알 수 있는데해당 IP를 보고 어떤 클래스에 속했는지는 32비트 중에 앞에 2비트만 보면 알 수 있다.앞에 1비트가 0이면 A 클래스, 앞에 2비트가 10이면 B 클래스, 앞에 3비트가 110이면 C클래스가 된다. 예를 들면 116.322.45.26을 32비트로 바꾸면 아래와 같다.01110100 101000010 00101101 00011010앞에 1비트가 0이므로 A 클래스에 속하는 IP 주소가 된다. A 클래스의 IP 범위는 0.0.0.0 ~ 127.255.255.255가 되고,B 클래스의 범위는 128.0.0.0 ~ 191.255.255.255가 되고,C 클래스의 범위는 192.0.0.0 ~ 223.255.255.255가 되고,D 클래스는 멀티 캐스트를 위해 사용되는데 224.0.0.0 ~ 239.255.255.255까지 사용되고, 특이하게 네트워크 부분으로 32비트 전체를 다 사용하고,E 클래스는 240.0.0.0 ~ 255.255.255.255로 미래를 위해 만들어뒀다고 한다. A 클래스는 8비트까지가 네트워크 부분인데 앞에 1비트인 0은 고정이므로 실제는 7비트만 사용 가능하고 따라서 128개의 네트워크를 만들 수 있을 거 같은데 책에는 126개라고 나와있다.또한 호스트는 24비트를 사용가능해서 약 1677만개의 호스트가 하나의 네트워크로 묶일 수 있다.매우 대규모의 호스트를 수용할 수 있으므로 특수한 정부 기관 등등에서 쓰이지 않을까 싶다. B 클래스는 16비트까지가 네트워크 부분인데 앞에 2비트인 10은 고정이므로 실제는 14비트만 사용해서 약 만 6천 개의 네트워크를 구성할 수 있다.그리고 호스트 부분은 16비트를 사용할 수 있어서 약 6만 5천대의 장비를 연결할 수 있다.아마 대기업&#x2F;중견기업 정도에서 쓰지 않을까 싶다. C 클래스는 24비트까지가 네트워크 부분인데 앞에 3비트인 110은 고정이므로 실제는 21비트만 사용해서 약 209만 개의 네트워크를 만들 수 있다.그리고 호스트 부분은 8비트만 사용해서 약 254개의 장비를 연결할 수 있다.일반 가정집이나 중소 기업에 어울리는 네트워크 클래스인 것 같다.8비트라 256개라고 생각할 수 있지만 호스트의 마지막 부분인 255는 브로드캐스팅을 위한 IP로 사용된다.모든 호스트가 브로드캐스팅 IP를 리스닝 하고 있다고 생각하면 된다.그리고 호스트의 첫 번째 부분인 0은 네트워크 주소로써 해당 호스트에 속한 모든 IP를 관리하기 위한 IP이다.따라서 8비트(0~255) 중에 0과 255는 특수한 목적으로 쓰이기 때문에 호스트는 총 254개만 사용 가능한 것이다. VPC는 가상의 네트워크라고 보면 된다.IP 주소 범위를 보면 10.2.0.0으로 0.0.0.0 ~ 127.255.255.255에 속하니까 A 클래스 IP 주소이다. 4-3-3. 어드레스 클래스의 제약클래스 A 같은 경우에 1677만대가 연결된 완전 초대규모 네트워크라고 볼 수 있다.하지만 실제로 하나의 네트워크에서 1677만대의 호스트를 전부 연결하는 곳은 거의 없기 때문에많은 IP 어드레스가 사용되지 않고 낭비된다는 단점이 존재한다.당장 내가 위에 만든 VPC만 봐도 A 클래스인데 과연 1677만대의 호스트를 등록할 일이 있을까?또한 126개의 네트워크보다 더 많은 네트워크를 구성하고 싶을 수도 있을 때는 어떻게 해야할까? 4-3-4. 서브넷 마스크(Subnet Mask)A클래스의 IP이지만 최대 2만대의 호스트만 수용할 예정이라면 15비트(약 3만대의 호스트 수용 가능)만 호스트 부분으로 사용하고,32비트에서 15비트를 뺀 17비트를 네트워크 부분으로 사용하면 어드레스의 낭비를 훨씬 줄일 수 있다.A 클래스의 IP이지만 A 클래스보다 훨씬 적은 호스트를 수용할 예정이고, A 클래스 보다 많은 개의 네트워크를 구성해야한다면 서브넷 마스크를 사용하면 된다. 위의 경우에는 앞에 IP 주소 17비트만 맞으면 동일한 네트워크라고 인식을 시켜야한다.주어진 IP 주소와 서브넷 마스크를 논리 비트 연산자인 &amp;로 AND 연산을 수행했을 때 참이 나오게 해야한다.따라서 17비트에 대한 서브넷 마스크는11111111 11111111 10000000 00000000앞에 17비트를 1로 설정하면 되고, 10진수로 표현하면 255.255.128.0이 된다.그리고 CIDR 블록이란 걸 적용시켜서 표현해보자면 10.2.0.0&#x2F;17이 된다.위 스크린샷에서는 10.2.0.0&#x2F;16이므로 사실상 A 클래스의 IP 주소를 B 클래스의 IP 주소와 같이 분할을 시킨 것이다. 위 공식을 적용시켜 보자면 A 클래스는 네트워크 부분이 8비트이므로 기본 서브넷마스크는 255.0.0.0이 되고 CIDR 블록으로 0.0.0.0&#x2F;8 과 같은 형태로 표시된다.B 클래스는 네트워크 부분이 16비트이므로 기본 서브넷 마스크는 255.255.0.0이 되고 CIDR 블록으로 적용시켜 보면 128.0.0.0&#x2F;16과 같은 형태가 된다.C 클래스는 네트워크 부분이 24비트이므로 기본 서브넷 마스크는 255.255.255.0이 되고 CIDR 블록으로 적용시켜 보면 192.0.0.0&#x2F;24와 같은 형태가 된다. 기본적으로 가정집에서는 C 클래스의 IP를 사용하고 서브넷 마스크를 기본적으로 설정하지 않으면 디폴트 서브넷 마스크인 255.255.255.0이 적용된다. 4-3-5. IP 어드레스의 할당 방법IP 어드레스는 네트워크 상에서 호스트(컴퓨터, 라우터, 스마트폰 등등)을 식별하기 위해 사용되는데,전체 32비트 중 네트워크 부를 제외한 호스트 부분만 자유롭게 할당할 수 있다. 이 때 호스트 부분이 모두 0인 건 네트워크 주소로 사용되고, 모두 1인 건 브로드캐스트 주소로 사용된다. 4-3-6. 서브넷 마스크로 네트워크 세분화하기 다시 한번 AWS의 VPC를 보자.원래는 A클래스인 걸 네트워크 부분을 16비트로 바꿔서 B클래스로 바꿨으니 이것도 네트워크를 세분화 했다고 할 수 있다.이런 걸 서브넷(Sub Network)라고 부른다.하지만 여기서 끝이 아니다, B클래스를 다시 C클래스나 다른 서브넷 마스크를 사용해서 서브넷 안에 서브넷을 또 만들 수 있다. 기존에 10.0.2.0&#x2F;16이었던 네트워크를 다시 CIDR Block을 10.2.0.0&#x2F;24로 나누었다.서브넷 마스크는 255.255.255.0이 됐고, 네트워크 부분이 24비트이므로 C클래스 IP 주소로 네트워크를 쪼갰다. 이렇게 서브넷 마스크를 통해 서브넷을 만드는 행위를 서브넷팅(Subnetting)이라고 부른다. 하지만 이렇게 클래스가 큰 규모에서 더 많은 네트워크를 사용하기 위해, 적은 규모의 호스트를 수용하기 위해 서브넷팅하는 건 매우 효율적이다.하지만 C 클래스의 IP 주소는 애초에 254개의 호스트만 수용 가능하고, 호스트 부분을 1비트씩 줄일 수만 있고 늘릴 수는 없으므로그의 절반인 126개, 62개, 30개, 14개, 6개, 2개, 0개 이렇게 줄어들다보니애초부터 수용가능한 호스트의 갯수가 적은 환경에서는 서브넷팅이 크게 효율적이진 않다. 4-3-7. 가정이나 사무실에서 자유롭게 사용하는 프라이빗 IP 어드레스프라이빗 어드레스는 같은 네트워크 내에서 충돌만 일어나지 않으면 자유롭게 사용할 수 있는 IP 주소다.옆집 철수의 private ip가 192.168.1.7이고, 나도 private ip가 192.168.1.7인데 통신이 잘 되는 이유는둘은 서로 다른 네트워크 상에 존재하기 때문이다.즉, 다른 공유기에 연결됐기 때문이라고 생각하면 된다. A 클래스의 프라이빗 IP 어드레스 범위는 10.0.0.0 ~ 10.255.255.255이고,B 클래스의 프라이빗 IP 어드레스 범위는 172.0.0.0 ~ 172.255.255.255이고,C 클래스의 프라이빗 IP 어드레스 범위는 192.168.0.0 ~ 192.168.255.255이다.이 외의 주소들은 전부 퍼블릭 IP이다. IP 어드레스의 할당 방법을 통해 봤듯이 private ip도 마찬가지로 호스트 부분 내에서 할당 받는다.이 때 DHCP란 프로토콜을 통해 브로드캐스트 트래픽으로 사용중인 IP 목록들을 파악해서 사용 가능한 ip를 새로운 호스트에게 할당하는 방식으로 진행되는 것 같다. 4-3-8. 퍼블릭 IP 어드레스의 관리위에 적어놓은 프라이빗 ip는 같은 네트워크 내에서 통신하기 위한 주소이고, 외부 네트워크와 통신하기 위해서는 퍼블릭 IP가 필요하다.따라서 퍼블릭 IP는 어떠한 경우에도 중복이 일어나면 정상적인 통신이 이루어지지 않는다.따라서 별도의 기관에서 퍼블릭 IP 주소 할당에 대해 관리를 하고, ISP(올레나 SK 브로드밴드 등등)에서 그런 기관으로부터 미리 IP 주소를 대량으로 임대를 하고인터넷 가입자들에게 제공해주는 것이다. 그리고 브로드캐스트 주소, 네트워크 주소와 별개로예약된 IP 주소가 하나 있는데 바로 자기 자신을 가리키는 127.0.0.1이라는 주소이다.자기 자신을 가리키는 주소이기 때문에 루프백 주소라고 부르기도 한다. 4-4. 라우팅이란?데이터를 목적지의 IP 주소까지 전달하는 경로를 탐색하는 과정을 라우팅이라고 부른다. 4-4-1. 라우팅과 경로 탐색라우팅을 통해 찾은 최적의 경로로 데이터를 전달하는데 만약 중간에 다음 라우터에 장애가 발생했으면 다른 라우터로 우회해서 데이터를 전달한다. 4-4-2. 라우팅 프로토콜데이터가 전송될 경로를 찾기 위해 네트워크 상의 각 라우터는 서로 어떤 라우터와 어떤 라우터가 연결돼있는지 정보를 교환한다.이 때 라우팅 프로토콜이 사용되는데 대표적으로 BGP, OSPF, RIP 등이 있다고 한다. 4-4-3. 자율 시스템ISP 같이 규모가 큰 네트워크에서는 몇 개의 네트워크를 하로 묶어 AS(Autonomous System, 자율 시스템)이라는 단위로 관리를 한다.네트워크 경로를 하나하나 찾는 것보다 AS 같은 큰 덩어리로 라우팅 하면 멀리있는 컴퓨터와도 더 빠른 속도로 통신할 수 있게 된다. 4-5. 라우터와 라우팅 프로토콜4-5-1. 라우터의 역할라우터는 네트워크 간의 패킷을 전달하는 역할을 한다.이 때 라우터는 자신이 가고자하는 목적지의 IP 주소로 가기위해 라우터의 정보를 파악해서 최적의 경로를 구성하게 되는데라우터는 자기 자신이 가야할 바로 다음 라우터의 주소만 알고 있으면 된다.그 이전의 라우터의 경로도 몰라도 되고, 다다음 라우터의 경로를 몰라도 된다.단지 바로 자기가 바로 당장 가야할 경로 그 하나만 알면 그 다음 책임은 그 다음 라우터에게 전가한다.마치 자기 다음 데이터에 대한 참조값만 알고 있는 자료구조인 링크드 리스트와 매우 유사한 느낌이 든다.그런 관점에서 링크드리스트의 노드를 라우터에 빗대어 생각해보면 도움이 많이 될 것이다. 그럼 일반적인 인터넷 공유기를 사용하는 가정집에서 네이버로 요청을 보내는 시나리오를 상상해보자. 우선 네트워크 내부에 호스트는 프라이빗 ip를 쓰니 192.1.0.3이 프라이빗 IP라고 가정해보자. 192.1.0.3 호스트에서는 자기와 제일 인접한 라우터인 인터넷 공유기로 패킷을 보낸다. 호스트와 공유기는 같은 네트워크에 속하므로 프라이빗 ip로 통신하고, 대부분 공유기(라우터)의 ip는 호스트 부분이 1인 경우가 많으니 192.168.0.1로 데이터를 보낸다. 공유기는 프라이빗 ip와 동시에 퍼블릭 ip도 가지고 있는데 그건 isp로부터 임대받은 ip이다. 프라이빗 IP를 퍼블릭 ip로 세탁(전문적으로는 NAT, Network Address Translation, 네트워크의 주소를 변환하는 걸 말한다.)해서 ISP에서 준 모뎀으로 패킷을 보낸다. 모뎀에서는 다시 ISP 쪽으로 라우팅을 하면 지지고 볶고 알아서 네이버로 패킷을 전달해서 네이버는 안전하게 데이터를 전달받을 것이다. 5번 과정을 보면 공유기에서 private ip를 public ip로 nat 시켰는데 이는 외부에서는 private ip를 알지 못하기 때문에 응답을 받기 위해선 public ip로 요청을 해야한다.그러면 공유기에 연결된 모든 private ip가 같은 public ip로 바인딩되서 나가나 생각할 수 있는데 별도의 설정이 없다면 내가 아는 한도 내에서는 그렇다. 4-5-2. 라우팅 테이블라우터는 라우팅을 위해서 목적지 ip 주소와 목적지로 가기 위한 바로 다음 라우터 주소를 저장한 라우팅 테이블을 들고 있다. 같은 VPC(네트워크) 내부인 10.2.0.0&#x2F;16에서는 private ip로 통신을 한다는 얘기이고,그 이외의 ip인 0.0.0.0&#x2F;0(모든 트래픽)에서는 인터넷 게이트웨이라는 문지기에게 패킷을 보내는데 얘가 라우터 역할까지 수행한다고 보면 된다.여담으로 aws에서 라우팅 테이블은 특정 서브넷에 적용시킬 수 있다. 4-5-3. 정적 라우팅과 동적 라우팅라우팅 테이블을 만드는 방법에는 크게 두 가지가 있는데 관리자가 수동으로 라우팅 테이블을 만드는 정적 라우팅과라우팅 프로토콜을 사용해서 자동으로 경로 정보를 수집해서 라우팅 테이블을 설정하는 게 동적 라우팅이다.aws의 라우팅 테이블 같은 경우에는 개발자가 직접 세팅하므로 정적 라우팅에 속한다.대부분의 네트워크는 경로가 매우 복잡하므로 동적 라우팅을 사용한다. 4-5-4. 라우팅 테이블에 목적지 정보가 없을 경우인터넷에는 수많은 네트워크가 연결돼있기 때문에 모든 네트워크의 통신 경로를 저장하는 건 사실상 불가능하다.그래서 한 라우터에 목적지에 대한 정보가 없다면 디폴트 라우터를 사용하는데 디폴트 라우터는 0.0.0.0&#x2F;0으로 세팅돼있다.디폴트 라우터도 설정돼있지 않고, 목적지에 대한 경로도 설정돼있지 않다면 아마 패킷을 제대로 전달하지 못하고 패킷은 혼자 사망할 것이다. 4-5-5. 동적 라우팅 알고리즘 거리 벡터형(RIP, Routing Information Protocol이 사용함.)목적지까지의 거리를 살펴보는데 이 거리는 지리상 거리가 아니라 라우터를 몇 개 거치느냐를 뜻하며라우터 하나를 거치는 단위를 1 홉(Hop)이라고 부른다.가장 홉이 낮은 경로로 라우팅 테이블을 설계한다. 링그 상태형(OSPF, Open Shortest Path First 프로토콜이 사용함.)단순히 거리만 보고 판단하는 게 아니라 어떤 네트워크가 고속이며 덜 혼잡한지까지 파악해서홉은 좀 높더라도 좀 더 빨리 전달할 수 있는 경로로 라우팅 테이블을 설계한다. 4-6. 네트워크 오류를 통보하는 ICMPICMP(Internet Control Message Protocol)은 주로 데이터 전송 중에 문제가 생길 경우,장애 상황을 통보해야할 때 사용한다.데이터가 제대로 동작하지 않았으면 3번 타입을 보내고,네트워크에 새로 연결된 장비가 라우터(공유기)를 찾기 위해 10번 타입으로 브로드캐스팅하고,그 요청을 받은 라우터는 새로운 호스트에게 9번 타입으로 자신의 정보를 알려준다.ICMP 헤더는 IP 헤더 + 타입 + 코드 + 체크섬으로 구성된다. 4-7. 어드레스 변환4-7-1. 네트워크 어드레스 변환(NAT)의 동작 방식내부 네트워크의 호스트가 외부의 네트워크가 통신을 하려면 퍼블릭 ip가 필요하므로 라우터(공유기)에서 퍼블릭 ip로 변환하고 그걸 통해 외부와 통신을 하게 된다.하지만 외부에서 봤을 때는 여러 호스트들을 하나의 퍼블릭 ip로 퉁쳐서 내보내기 때문에 정확히 어떤 호스트에게 응답을 해줘야하는지 모르게 된다.이런 상황을 방지하고자 라우터는 NAT 하기 전에 프라이빗 ip를 기억해두고 있다가 응답을 받으면 그 프라이빗 ip로 다시 요청을 전송하는 역할을 한다. AWS에서 NAT를 쓰는 이유는 주로 두 가지이다. 퍼블릭 IP가 없이 프라이빗 IP만 존재하는 서브넷(프라이빗 서브넷, 외부에서 접근 불가능)에서 외부와 통신을 해야할 일이 있을 때퍼블릭 IP가 존재해야 외부의 응답을 받을 수 있으므로 외부에 요청을 보내고 응답을 받기 위해 NAT Gateway를 사용한다. 외부로 나가는 IP(Outgoing IP)를 하나로 통제하고자 할 때 사용한다.외부 연동사에 IP 등록 요청을 해야하는데 네트워크 내의 모든 서버의 IP를 등록해달라고 하기 거시기 하기 때문에 outgoing ip를 하나로 통제할 때 쓰곤 한다.물론 상황에 따라 네트워크가 속한 지역이나 가용영역 등등에 따라 하나로 통일을 못 하기도 하기는 한다. 4-7-2. NAT에서 발생할 수 있는 제약 사항서버에서 요청에 대한 응답을 처리해줄 수 있는 것은 라우터에서 어떤 프라이빗 아이피가 퍼블릭 아이피로 매핑됐는지 정보를 기억하고 있기 때문이다.하지만 역으로 서버 쪽에서 클라이언트 쪽을 찌를 때 라우터는 퍼블릭 IP만을 가지고는 프라이빗 ip를 찾을 수 없어서 통신이 불가능한 상황이 발생한다. 4-7-3. 네트워크 어드레스 포트 변환공교롭게도 같은 네트워크 상의 호스트가 동일한 목적지로 요청을 보내는데 둘의 포트가 같아버리면private ip -&gt; public ip 과정에서 포트 충돌이 일어난다.이러한 상황을 대비해서 NAPT(Network Address Port Translation), 즉 포트까지 같이 변환해야한다.만약에 포트가 충돌나면 라우터는 포트까지 같이 변환하고 원래 포트를 기억하고 있다가 서버에 대한 응답을 올바르게 전달해준다. 4-7-4. 외부에서 접속이 가능하게 하기.4-7-4-1. 메시지의 자동 확인SNS 같은 경우에 보면 알림이 있으면 클라이언트 쪽으로 push notification을 준다.이는 서버가 클라이언트한테 바로 notification을 주는 게 아니라 내부적으로 클라이언트가 서버를 계속해서 호출해서 가능한 것이다.아니면 소켓을 하나 뚫어놓고(연결을 맺어놓고 끊지 않고), 알림을 줘야할 내용이 있을 때마다 알림을 주는 경우도 있다. 4-7-4-2. 포트포워딩포워딩이 가지는 느낌을 정확하게 모르겠는데 내가 가지고 있는 느낌을 어느 방향으로 향하게 하는 걸 포워딩이라고 부르는 것 같다.포트포워딩은 특정 포트를 어떤 포트 쪽으로 향하게 하는 그런 느낌이라고 이해하면 될 것 같다. 라우터(공유기)의 IP 주소를 입력해서 접속하자.간혹가다가 무선 인터넷을 통해서는 보안 때문인지 아예 접속조차 안 되고, 유선랜의 경우에만 접근을 허락하는 공유기들도 존재한다.공유기의 기본 ID&#x2F;PW는 메뉴얼이나 공유기 아랫 부분이나 어디 스티커로 붙어있거나 공유기 제조 홈페이지를 참고하며 된다. 그리고 또 메뉴얼을 참고해서 포트포워딩 메뉴로 오면 되는데 대부분 일반 유저들은 쓰지 않는 메뉴기 때문에 고급 쪽에 붙어있는 경우가 많다. 포트 포워딩을 보기 전에 몇가지 재밌는 메뉴들을 살펴보자.(공유기에 따라 정보를 노출하지 않거나 제공하지 않는 기능일 수도 있으니 그냥 재미로만 보자.) 직접 라우터의 IP 주소와 네트워크의 서브넷 마스크도 조절이 가능한 것 같은데 뭔가 무서워서 함부로 건들지 못하겠다 ㅋㅋ또한 이더넷 카드의 Physical Address인 Mac Address도 있다. IP 주소는 ISP로부터 할당받은 Public IP를 뜻하고,기본 게이트웨이는 모뎀(이자 라우터 역할도 함)의 퍼블릭 IP를 말하는 것 같다.기본&#x2F;보조 DNS는 URL 창에 IP &lt;-&gt; Domain을 하기 위해 도메인들이 각각 저장된 도메인 네임 서버를 의미하는 것 같다.그리고 고정 IP는 기본적으로 돈이 들기 때문에 IP 주소 변경에 민감한 웹서버에서 주로 사용한다. IP 주소 대역을 보아하니 호스트는 100~199까지 총 100대만 연결이 가능한 네트워크인 모양이다.또한 임대 시간이 나와있는데 해당 시간을 초과한다고 해서 무조건적으로 IP 주소가 바뀌는 건 아닐 것이다. 웬만하면 기본값인 1500바이트를 건들 일은 없어 보인다. 근거리 통신(LAN)에는 192.168.0.0&#x2F;24인 네트워크를 통해 통신이 되고,WAN의 경우에는 xxx.149.166.0&#x2F;25인 네트워크를 타고 통신이 된다.그 외의 경우에는 디폴트 라우팅 테이블에 있는 모뎀(라우터)의 IP 어드레스를 타고 나가게 된다. 만약 배틀넷 서버가 클라이언트(192.168.0.181)에게 8123 포트로 요청을 보낸다고 하면위와 같이 등록을 해두면 된다. 만약에 클라이언트(192.168.0.181)에서 웹서버를 8080 포트로 열었다고 할 때위와 같이 설정해놓으면 외부에서는 퍼블릭 ip만 입력하면 바로 내가 연 웹서버로 들어올 수 있다. (대표 포트는 생략 가능하기 때문) 하지만 이런 포트포워딩에도 단점이 존재하는데 포트의 충돌이 일어나기 때문에 하나의 포트는 하나의 호스트 밖에 사용하지 못한다. 4-8. 도메인명IP는 숫자로 구성돼있어서 인간 친화적이지 않으므로, 사람이 알아보기 편한 영단어들과 일부 기호들의 집합으로 이루어진 걸 도메인명이라고 한다. 4-8-1. 호스트명과 도메인명서로 다른 컴퓨터를 구분하는 식별자로 IP 어드레스와 호스트명이 있는데, 이걸 관리하기 위해 DNS(Domain Name System)이 등장했다. 우선 도메인을 보기 전에 URL이 어떻게 생겨먹었는지 보자.scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]scheme는 프로토콜이라고 보면 된다.그리고 나는 프로토콜 뒤에 무조건 :&#x2F;&#x2F;이 붙는 줄 알았는데 mailto 프로토콜의 경우에는 mailto:someone@example.com와 같이 &#x2F;&#x2F;이 붙지 않는 프로토콜도 존재한다.그리고 (s)ftp의 경우에는 ftp://testid:testpass@file.example.com처럼 인증에 필요한 user:password 정보가 URL에 포함돼있는 경우도 존재한다.ssh 프로토콜을 보면 대부분 터미널을 통해서 ssh 라는 명령어를 통해서 접속을 시작하지만 엄연히 URL을 가진다.ssh://ec2-user@52.178.112.131과 같은 형태로 접속이 가능하다.위 URL을 보면 user@host의 형태도 보인다.일반적인 웹의 경우에는 user, password, @가 빠진 https://js.org/와 같이 scheme:&#x2F;&#x2F;host&#x2F;만으로도 URL을 표현할 수도 있다.http://121.1.33.57:8080/board?no=1#notice와 같이 host 부분은 IP 주소가 돼도 되고, 해당 서비스를 대표하는 대표 포트가 아닐 경우에는 포트번호 생략이 불가능해진다.포트 뒤에 board라는 path가 나왔고, 그 뒤에 ?no&#x3D;1이라는 쿼리 스트링도 붙었다.그리고 #notice라는 fragment를 통해 현재 해당 리소스의 어느 부분?부터 리소스가 보이게 끔 하기도 한다. 4-8-2. DNS 서버에 질의하기도메인명에 대응하는 IP 정보가 알고 싶다면 DNS 서버에게 물어보면 된다.위에 라우터(공유기) 설정 스샷에서도 봤듯이 DNS 서버가 컴퓨터 혹은 라우터에 등록이 돼있어야한다. 4-8-3. 도메인의 계층 구조도메인 명은 아래와 같은 계층 구조를 가지고 있다. 루트 탑 레벨 도메인(TLD, 1차 도메인) - com, org, kr, uk 2단계 도메인(ANS, Authoritative Name Server, 2차 도메인) - co, go, ac, seoul, busan 3단계 도메인(3차 도메인) 위 구조는 예시일 뿐, 실제로는 더 복잡한 계층일 수도 있다. 4-8-4. DNS 서버의 계층 구조도메인이 계층 구조를 가지듯이 DNS 서버도 계층적인 구조를 가지고 있다. 루트 네임 서버 kr, uk 도메인을 관리하는 DNS 서버 ISP 등에서 관리하는 DNS 서버 위 구조는 예시일 뿐, 실제로는 더 복잡한 계층일 수도 있다. 도메인명 데이터를 직접 관리하는 서버를 DNS 콘텐츠 서버라고 부른다. 4-8-5. DNS 서버에 질의 처리하는 과정 우선 클라이언트는 DNS 캐시 서버에게 도메인을 던진다. DNS 캐시 서버는 자신에게 해당 도메인에 대한 IP가 등록돼있는지 확인한다. 있으면 바로 IP 주소를 리턴하고, 없으면 루트 네임 서버에 도메인을 던진다. 루트 네임 서버는 본인이 해당 도메인에 대한 IP가 등록돼있는지 확인한다. 있으면 IP 주소를 리턴하고, 없으면 해당 정보를 가지고 있는 탑 레벨 도메인 서버의 주소를 던진다. DNS 캐시 서버는 다시 탑 레벨 도에민 서버에게 도메인을 던진다. 있으면 IP 주소를 리턴하고, 없으면 해당 정보를 가지고 있는 다른 DNS 서버의 주소를 던진다. DNS 캐시 서버는 다시 응답받은 DNS 서버의 주소로 도메인을 던진다. DNS 서버는 자기가 해당 도메인에 대한 IP를 들고 있다면 IP를 리턴하고 없으면 또 다른 DNS 주소를 응답한다. DNS 캐시 서버는 도메인에 대한 IP 주소를 받아서 클라이언트에게 응답한다. 아래 링크와 동영상도 참고하자. How the DNS works DNS Explained DNS서버(네임서버)의 이해 Amazon Route 53 DNS 서비스 그리고 DNS에서 생략되는 게 하나 있는데 바로 루트를 의미하는 . 이다.http://d2.naver.com./helloworld/238638 으로 접속하면 com.뒤에 뭔가 올 거 같은데 입력하지 않고 바로 저렇게 입력해도 잘 접속이 된다.바로 루트를 의미하는 .은 있어도 되고, 없으면 자동으로 내부적으로 붙여주기 때문이다. DNS 캐시 서버는 하드웨어 단의 캐시 서버이고 자바 같이 소프트웨어 단에서도 DNS 캐시를 설정할 수 있다. Java VM 의 DNS caching TTL DNS Caching in JVM 운영체제 별로 hosts 파일이 존재한다.인터넷 초창기에는 도메인과 IP 주소를 매핑하기 위해 텍스트 형태의 파일인 hosts 파일을 사용해서 ip 주소를 변환했다.요즘 OS에도 이 파일이 있어 DNS에 등록하기 전의 서버나 DNS에 등록할 수 없는 서버에 접근해야할 때 이 파일을 사용한다.개발 중인 서버를 내부 테스트 할 때 사용하기도 하는데 자신의 컴퓨터에만 적용되기 때문에 테스트하는 모든 컴퓨터가 hosts 파일 자체를 수정하기가 번거로운 경우에는사설 DNS를 직접 구성하기도 하는 것 같다. 맥의 경우에는 /etc/에 해당 파일이 존재한다. 맨 밑에 IP와 asdf.com은 내가 테스트로 등록한 건데, 네이버의 IP이다.이제 내 컴퓨터에서 asdf.com을 입력하면 네이버로 접속이 된다. 4-8-6. DNS에 도메인 등록하기도메인은 IP와 마찬가지로 별도로 관리해주는 기관이 있다.ISP 업체가 IP를 임대받아서 개인에게 IP를 할당해주듯이도메인도 마찬가지로 큰 기관에서 전체적으로 관리하고, 등록 대행 업체(ISP 같은 애라고 보면 됨) 같은 사이트에서 관리를 하게 된다.GoDaddy, Route53 등등의 사이트에서 도메인을 등록할 수 있다.과정이 궁금한 사람은 (DNS) 1331원에 .com 도메인 사기 (feat. GoDaddy)을 참고하면 된다. DNS 서버에 등록되는 정보를 리소스 레코드라고 부르고, 리소스 레코드가 등록된 파일을 존 파일이라고 한다. 4-8-7. 리소스 레코드의 의미각각의 레코드에 대해서는 나도 아직 공부하는 중이므로 아래 링크를 참조하자 ㅠㅠDNS Zone 파일에 쓰이는 레코드 설명 SOA(Start of authority)해당 도메인을 관리하는 DNS 서버를 기술, 링크를 보면 1차 네임 서버(Primary), 2차 네임 서버(Secondary) 사이에 싱크를 맞추기 위한 시간 설정이나재시도를 위한 시간 등등의 설정도 할 수 있다. NS(Name Server)Primary, Secondary DNS 서버를 기술, 도메인에 대한 정보를 찾을 수 없으면 이 NS로 보내서 도메인에 대한 정보를 뒤지는 모양이다. A도메인과 IP 어드레스를 연결, Route53 같은 경우에는 IP 주소 대신에 AWS Resource에 대한 도메인을 등록할 수 있다. CNAME(Canonical Name)도메인에 별칭을 부여한다.해당 도메인을 부르는 이름이 따로 있는데 그거에 대한 별명을 쓴다고 생각하면 된다.내 블로그만 해도 원래는 perfectcle.netlify.com이라는 도메인이 있는데 이 도메인에 blog라는 별칭을 줬다.루트 도메인(Zone Apex, Naked Domain이라고 부르기도 한다.)인 perfectacle.com을 내 돈 주고 샀고, blog라는 서브 도메인을 등록한 것이다.루트 도메인만 돈 내고 쓰면 되고, 서브 도메인은 마음껏 쭉쭉 추가할 수 있고위와 같이 1뎁스가 아니라 dev.blog와 같이 몇 뎁스 씩 쭉쭉 늘려가면서 등록할 수 있다. MX(Mail eXchanger)xxx@domain 과 같은 형식의 메일 주소와 메일 서버를 연결할 때 사용한다. 4-9. IP 어드레스를 자동으로 할당하는 DHCPDHCP는 네트워크에 속한 호스트들에게 IP 어드레스를 자동으로 부여해 사람이 직접 IP를 설정하고 관리하는 수고를 덜어준다. 4-9-1. DHCP의 장점TCP&#x2F;IP가 제대로 동작하려면 네트워크에 속한 호스트의 IP 어드레스가 중복되면 안 된다.퍼블릭 IP는 ISP에서 알아서 할당해주고, 프라이빗 IP도 누군가가 할당을 해줘야한다.그래서 각 네트워크의 호스트한테 일일이 프라이빗 IP를 수동으로 등록해주는 건 매우 번거롭고 힘든 일이다.이걸 자동으로 해주는 게 DHCP인데 대부분의 공유기가 이 역할까지 수행해준다. 4-9-2. IP 어드레스 할당 방법공유기에 새로운 컴퓨터를 연결하면, 아직 IP 주소가 할당되지 않은 상태이고 DHCP 서버(공유기의 IP 주소) 조차 모르는 상황이다.따라서 DHCP 서버를 찾아서 IP 주소를 할당받기 위해 브로드캐스팅을 해야한다. 신규로 연결한 장비는 네트워크에 브로드캐스팅으로 자신의 새로 들어왔음을 알린다.이 때 자신의 IP 주소도 모르므로 IP 프로토콜로 통신하는 게 아니라 ICMP 프로토콜로 통신을 한다.ICMP 타입 10번(Router Solicitation)을 보낸다. 그럼 DHCP 서버가 아닌 애들은 자신과 무관한 내용이므로 해당 패킷을 버린다.그럼 그 요청을 받은 DHCP 서버는 브로드캐스팅으로 사용해야하는 IP 주소를 알려준다.이 때 라우터는 ICMP 타입 9번 메시지(Router Advertisement)를 응답한다. 그럼 그 요청을 받은 새로운 장비는 IP 주소가 할당되고, 나머지 애들은 자신과 상관 없으니까 또 패킷을 버린다. 4-10. ipconfig 명령과 ping 명령윈도우에서는 cmd에서 ipconfig 명령을 날리면 라우터 주소, 프라이빗 IP 주소, 서브넷 마스크 등등을 알 수 있다.유닉스 환경(linux, mac 등등)에서는 ifconfig를 때리면 된다.근데 맥에서 해당 명령어를 날려보니 보기가 매우 요상해서 Network Utility나 환경 설정의 네트워크 쪽에서 보는 게 더 보기는 편한 것 같다. 노트북의 경우에는 무선&#x2F;유선 이더넷 아마 두 개가 나올 것이고(아마 무선은 꼭 나올 것이다.),데스크탑의 경우에는 대부분 유선 이더넷 하나만 나올 것이다.무선 이더넷 카드가 없는 경우에는 와이파이로 연결이 안 되니 외&#x2F;내장 무선 이더넷 카드를 사야한다. ping 명령어는 서버와 통신할 수 있는지 없는지 알기 위한 명령어이다.해당 서버로부터 응답을 받는데까지 얼마나 알 수도 있기 때문에 네트워크의 혼잡도도 어느정도 파악이 된다.사실 ping 명령어는 ICMP 프로토콜을 사용한다.ICMP 타입 8번 메시지인 echo(수신 측 장비가 존재하는지 확인)를 서버에 날리고,에코 요청을 받은 서버는 0번 타입 메시지인 에코 응답(서버 측 장비가 존재함)을 응답한다. 4-11. tracert 명령으로 통신경로 확인하기unix 환경에서는 traceroute 명령어이다.백문이 불여일견 그냥 샘플을 봐보자. CNAME으로 blog를 등록했더니 원래 도메인인 perfectacle.netlify.com의 경로를 추적했고,최종적으로 54.250.174.92이런 IP를 찾아낸 것 같다. 공유기 (192.168.0.1) 모뎀(xxx.xxx.166.1) 루트(.) DNS 서버(172.21.1.253) .com DNS 서버(172.21.0.229) …이런 순서인 것 같다. 네이버는 IP가 여러 개 물려있고, 그 중에 www.naver.com.nheos.com이라는 도메인을 선택해서 추적한 것 같다. 공유기 (192.168.0.1) 모뎀(xxx.xxx.166.1) 루트(.) DNS 서버(172.21.1.253) .com DNS 서버(172.21.0.229) …이런 순서인 것 같다. 302 Moved Temporarily 응답을 받은 걸 볼 수 있다.그리고 실제로 210.89.160.88으로 접속해도 마찬가지의 응답을 볼 수 있다. tracert&#x2F;traceroute도 서버의 생존 여부를 파악하기 위해 ICMP 프로토콜을 이용한다.요청을 보낼 때 ICMP 타입 8번(에코)를 날리고, 만약 맥시멈 라우트 홉까지 가고도 경로를 찾지 못했으면ICMP 타입 11번(생존 기간이 지난 패킷이라 삭제됨) 응답을 알려준다. 꼭 도메인일 필요는 없고 IP 주소를 날려도 상관이 없다. 4-12. nslookup 명령으로 IP 어드레스 알아내기윈도우의 CMD나 유닉스 기반 운영체제의 터미널에서 nslookup domain을 입력하면 해당 IP 어드레스와 DNS 서버 정보도 표시해준다.위와 반대로 nslookup ip주소 를 입력해서 도메인 정보를 알아내는 reverse DNS Query라는 것도 있다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 3장 트랜스포트 계층","slug":"tcp-ip-book-index-3","date":"2018-03-31T14:56:08.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2018/03/31/tcp-ip-book-index-3/","link":"","permalink":"https://perfectacle.github.io/2018/03/31/tcp-ip-book-index-3/","excerpt":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다.","text":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다. 예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다. 백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다. 더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다. 목차 컴퓨터 네트워크 네트워크 서비스와 애플리케이션 계층 트랜스포트 계층 라우팅과 인터넷 계층 하드웨어와 네트워크 인터페이스 계층 보안 3장, 트랜스포트 계층컴퓨터로 들어온 데이터를 어떤 서비스에게 토스 할 지 포트를 보고 판단한다.트랜스포트 계층에서 사용하는 대표적인 프로토콜은 TCP와 UDP가 있다.OSI 7 Layer에서는 L4(Layer 4)에 해당하며 똑같이 Transport Layer이다. 3-1. 트랜스포트 계층의 역할(F&#x2F;B)컴퓨터에서 수많은 서비스가 돌아간다. (웹서비스, FTP 서비스, 이메일 서비스 등등)근데 어떻게 들어온 데이터를 보고 올바른 서비스에게 보내는지 그 기준이 바로 포트 번호이다.80 포트라면 웹 서비스(HTTP)에게, 443 포트여도 웹 서비스(HTTPS)에게, 21 포트라면 FTP에게 전달한다.하지만 80이고 443이고 그 서비스를 대표하는 포트지 80포트에 내가 FTP 서비스를 열어둘 수도 있다.그냥 디폴트로 설정하는 포트지 꼭 그 포트가 예약돼있는 건 아니다(일부는 시스템에 의해 얘약되는 경우도 있지만). 그리고 TCP와 UDP의 차이에 대해 설명하고 있는데 TCP는 데이터의 손실 없이 정확하게 전달되도록 설계된 프로토콜이라서서로 전송 속도라던지, 전송하는 크기라던지, 실패의 경우에 재전송이라던지, 바쁘면 잠시 멈추거나 속도나 크기를 줄인다던지 완급 조절이 가능하다.(그렇다고 모든 통신이 성공한다는 보장은 없지만…)UDP는 전송 속도를 위주로 설계된 프로토콜이라 마구잡이로 보낸다(뭐 망나니처럼 보내지는 않겠지만).그래서 중간에 패킷이 유실되는 경우가 발생한다. (음성 통화중 지지직 대거나 동영상을 보는데 화면이 가끔 깨져보인다거나)이런 경우에 이게 그렇게 크리티컬한 오류는 아니지만 전송 속도가 느려서 실시간성이 보장이 안 되는 게 더 크리티컬한 이슈로 판단되기 때문이다. 3-2. 포트번호(F&#x2F;B)포트 번호는 065535의 범위 내에서 할당할 수 있는데 01023은 Well known ports라고 부른다.주요 Well known ports는 아래와 같고 각 서비스별로 대표 포트를 사용하는 경우에는 포트 번호의 생략이 가능하다. 20 FTP(액티브 모드에서는 데이터 커넥션이고 패시브 모드에서는 다이나믹 포트 내의 랜덤한 포트가 할당되는 것 같다, 파일 주고받기) 21 FTP(컨트롤 커넥션, 명령어 날리기) 22 SSH, SCP, SFTP 23 Telnet 24 SMTP 53 DNS 80 HTTP 110 POP3 443 HTTPS 1024 ~ 49151번 포트는 Registered ports라고 해서 벤더 사에서 붙이는 포트들이다.생각 나는 게 3036 MySQL 뿐이다 ㅠㅠ…ElasticSearch, Logstash, Kibana, Redis, PostgreSQL 등등 각종 어플리케이션에서 쓰이는 기본 포트들이 다 Registered ports에 할당이 되며공식적인 게 아니므로 다른 어플리케이션과 충분히 충돌이 발생할 수 있다. 49152 ~ 65535번 포트는 다이나믹 포트라고 해서 대부분 클라이언트 측의 아웃바운드 트래픽에 포트를 할당할 때 쓰인다.아래 시나리오를 상상해보자. 웹 브라우저 클라이언트가 웹 서버에 요청을 보낸다. 웹 서버가 응답을 보낸다. 클라이언트 컴퓨터로 왔는데 클라이언트 컴퓨터에는 다양한 어플리케이션(메일 서비스, 웹 서비스, FTP 서비스 등등)이 실행되고 있다. 위 상황에서 어떤 서비스에게 요청에 대한 응답을 보내줘야할까?답은 1번의 과정에서 요청이 네트워크를 타고 밖으로 나갈 때 포트 번호를 달고 나간다.이 때 할당되는 포트가 바로 다이나믹 포트 내에 해당하는 포트가 랜덤하게 붙어서 나간다.HTTP의 경우에는 통신이 끝나면 다른 요청에 대한 연결을 맺기 위해서 이전 연결을 끊기 때문에동일한 서버라 하더라도 매번 다른 포트를 달고 나가게 된다.트랜스포트 계층에서 이제 그 포트를 보고 어떤 서비스에게 데이터를 보낼지 결정한다고 보면 된다. 3-3. TCP가 정확하게 데이터를 전달하는 방법3-3-1. TCP가 하는 일(F&#x2F;B)통신 속도, 데이터 크기, 서버&#x2F;클라가 바쁘면 완급 조절 등등을 한다.또한 서버나 클라가 데이터를 못 받았을 때 재전송까지 해준다. 3-3-2. TCP 헤더의 구조(B)TCP 헤더에는 송수신지 포트번호, 데이터의 크기, 데이터의 무결성 확인을 위한 정보나데이터 사이즈를 위해서 패딩을 넣기도 한다.대충 이 정도만 알고 넘어가자. 3-3-3. 컨트롤 비트(B)TCP 헤더에 포함돼있으며 통신 상태를 표현하는 플래그이다.전송량을 줄여달라거나 혼잡해서 받을 수 없다거나 이런 정보를 보고 통신 상태를 조절한다.TCP 3Way Handshake에서 SYN, ACK 같은 데이터도 컨트롤 비트 내의 플래그이다.1비트이기 때문에 8가지 플래그가 존재한다. 3-3-4. 통신 개시부터 통신 종료까지의 흐름(F&#x2F;B)그 유명한 TCP 3Way Handshake를 그림으로 표현했다.UDP에 비하면 3Way Handshake는 오버헤드(쓸 데 없는 행위, 비용 낭비)에 해당한다.하지만 이 3Way handshake를 통해 통신이 가능한 상태인지 알 수 있으므로 안정성 측면에서는 뛰어나다. 여담으로 HTTP 1.0 스펙과 HTTP 1.1 스펙과 HTTP 2 스펙을 아래와 같은 시나리오로 비교해보자. HTTP 1.0(총 3Way Handshake: 2회, 요청 횟수: 2회) 클라이언트에서 index.html 파일을 요청했고 그 안에 이미지 파일이 1개 있다. index.html 파일을 요청하기 위해 클라이언트&#x2F;서버가 TCP 3 Way Handshake를 한다. 연결이 맺어졌으면 요청을 보내고 index.html을 응답 받는다. 연결을 끊는다. html을 해석하다보니 이미지 파일이 필요하다. 이미지 파일을 요청하기 위해 다시 3way handshake를 한다. 연결이 맺어졌으면 요청을 보내고 이미지를 응답받는다. 연결을 끊는다. HTTP 1.1(총 3Way Handshake: 1회, 요청 횟수: 2회) 클라이언트에서 index.html 파일을 요청했고 그 안에 이미지 파일이 1개 있다. 요청을 보낼 때 헤더에 Keep-Alive를 설정해서 타임아웃과 타임아웃 내에서 수행할 수 있는 최대 요청갯수를 지정한다. Connection: Keep-Alive;Keep-Alive: timeout&#x3D;5, max&#x3D;1000 위와 같이 HTTP Request Headers에 지정을 했으면 최초 연결 이후 5초동안 이뤄지는 1000번의 요청까지는 연결을 끊지 않는다. index.html 파일을 요청하기 위해 클라이언트&#x2F;서버가 TCP 3 Way Handshake를 한다. 연결이 맺어졌으면 요청을 보내고 index.html을 응답 받는다. html을 해석하다보니 이미지 파일이 필요하다. 아직 Keep-Alive에 설정한 5초 이내이고 1000개의 요청을 보낸 적이 없으므로 TCP 커넥션은 아직 끊어져있지 않은 상태니 3 way handshake를 또 할 필요는 없다. 이미지를 요청하고 응답으로 받는다. 받을 데이터를 다 받았으므로 TCP 커넥션을 끊는다. HTTP 2(총 3Way Handshake: 1회, 요청 횟수: 1회) 클라이언트에서 index.html 파일을 요청했고 그 안에 이미지 파일이 1개 있다. 헤더에 실어 보내는 Connection과 Keep-Alive는 프로토콜 내에서 다른 메카니즘으로 처리되므로 헤더에 실어보낼 필요가 없다. 요청을 보내기 전에 TCP 3way handshake로 연결을 확립하고 요청을 보낸다. 응답 받을 때 필요한 리소스를 전부 받는다.(이미지 포함) 응답 받을 거 다 받았으니까 TCP 커넥션을 끊는다. 3-3-5. 일련번호와 최대 세그먼트 크기를 사전에 조율한다TCP의 경우에 클라이언트와 서버 사이에 통신 가능한 세그먼트의 크기(MSS, Max Segment Size)를 정하는 과정을 설명하고 있다. 3-3-6. 데이터 전송 과정에서 일련번호는 어떻게 변화하나?주고 받은 Segment Size에 따라 Sequence Number(일련 번호)가 증가한다.기본적으로 Sequence Number와 확인 응답번호(acknowledge number)는 커넥션을 맺는 과정에서 1로 세팅된다.그리고 내가 서버로 보내면 세그먼트 사이즈만큼 시퀀스 넘버가 올라간다.그러면 서버는 정상적으로 요청을 받았다면 응답번호를 세그먼트 사이즈만큼 올린다.그리고 다시 서버는 클라이언트로 요청을 보내는데 응답을 보내는 세그먼트 사이즈만큼 다시 서버측 시퀀스 넘버를 증가시킨다.그 응답을 받은 클라이언트는 응답받은 세그먼트 사이즈만큼 확인 응답번호를 올린다.이렇게 서버&#x2F;클라이언트 측은 요청&#x2F;응답 받은 TCP 헤더를 까서 상대 쪽에서 보낸 응답 번호와 자신의 시퀀스 넘버를 확인해서 일치하면제대로 통신이 이루어졌다고 판단하고 아니라면 통신이 제대로 이뤄지지 않았으므로 에러 처리를 어떻게든 하는 것 같다.정확하게 어떻게 하는지는 모르겠다. 3-3-7. 송신 실패 여부를 판단한다.소프트웨어 단에서 재전송 처리가 아닌 하드웨어 단에서 재전송 전략을 간단하게 설명하고 있다.가장 간단한 전략으로 데이터를 받으면 잘 받았다고 상대방에게 응답을 보내줘야하는데 내가 데이터 보냈는데상대는 받은 적이 없으니 응답이 오는 게 없다.따라서 일정시간이 지나도 응답이 오지 않으면 재전송한다는 그런 얘기다. 3-3-8. 연속된 데이터를 몰아서 보내면 전송 속도가 빨라진다.요청 보내고 상대방이 보내주는 응답번호 일일이 기다리면서 그 다음에 데이터를 전송하면 안정성 측면에선 좋지만성능 측면에서는 그닥 좋지 않다.따라서 응답번호를 일일이 기다리지 않고 MSS만 정하고 세그먼트를 계속해서 날리고 확인 응답번호가 어떻게 오는지에 따라서어떤 세그먼트부터 재전송할지 파악하면 된다. 3-3-9. 한번에 받을 수 있는 데이터 크기를 통보한다.위에 연속된 데이터를 몰아서 보내면 전송 속도가 빨라지는 장점이 있지만너무 몰아서 많이 보내다보면 서버가 바쁘면 데이터를 제대로 처리하지 못할 수도 있으므로서버 측에는 버퍼를 두고 그 버퍼에 모아두고 처리한다.이때 이 버퍼 사이즈는 TCP 헤더의 윈도우 사이즈 필드에 설정해서 데이터를 보내는 측(송신 측)에 통보를 하면송신 측은 아 MSS는 얼마고 윈도우 사이즈는 얼마니 최대 몇 개를 몰아서 보내면 될지 계산해서 적당히 보내게 된다. 3-3-10. 한 번에 받아낼 수 있는 데이터 양을 조절한다.수신 측은 받은 패킷들을 버퍼에 쌓아두면서 버퍼에 쌓인 데이터를 동시에 순차적으로 처리한다.근데 보내주는 애가 엄청 빨리 보내고 받는 애는 그걸 처리할 능력이 되지 않을 수 있으니보내는 애한테 현재 윈도우 사이즈(수용 가능한 버퍼 사이즈)를 수시로 알려준다.이 과정을 흐름 제어(Flow Control)이라고 한다. 3-3-11. 버퍼가 가득 찬 경우윈도우 사이즈가 0이면 윈도우 사이즈 0이라는 세그먼트와 함께 윈도우 프로브(Window Probe)라는 패킷을 응답한다.이 응답을 받으면 송신 측은 요청을 중단하고, 전송 재개 시점을 알기 위해 수신 측에 윈도우 프로브 패킷을 보내서 윈도우 사이즈를 알아낸다.윈도우 사이즈가 빈 공간이 생기면 그 때부터 다시 전송을 재개한다. 3-3-12. 네트워크의 혼잡 상태를 확인한다.버퍼에 여유 공간이 있어서 윈도우 사이즈가 0이 아니어도 그 아랫단인 인터넷 계층이나 네트워크 인터페이스 계층이 혼잡한 경우도 있다.이러한 경우에도 정상적인 통신이 불가능하므로 인터넷 계층의 패킷에서 헤더에 혼잡 플래그를 ON으로 달린 패킷이 넘어오게 된다.이 패킷을 받은 수신측은 송신측에게 컨트롤 비트에 ECE(통신 경로가 혼잡해서 수신할 수 없을 수도 있다) 플래그를 붙여서 응답을 해준다.그러면 송신측은 컨트롤 비트에 CWR(통신 경로가 혼잡해서 전송량을 줄이겠다) 플래그를 붙여서 패킷을 보내면서 통신 속도도 더불여 낮추게 된다. 중간에 누락된 패킷을 재전송하는 전략에는 여러가지가 있다.전송 속도를 높이기 위해 데이터를 연속해서 보내다보니 응답으로 온 응답번호와 내가 보낸 시퀀스 넘버가 일치하지 않아서 데이터 전송에 실패했다는 것을 깨달았으면패킷 재전송 시도를 해야하는데 가장 간단한 거는 처음부터 다시 보내는 건데 효율이 매우 떨어진다.아니면 그 다음으로 쉬운 방법은 시퀀스 넘버와 응답번호의 싱크가 깨진 패킷부터 다시 보내면 되는 전략이 있다.그 다음 전략은 누락된 패킷이 뭔지만 캐치해서 보내는 전략이 있는데 이를 SACK(Selective ACKnowledgement, 선택적 확인 응답)이라고 부른다.아래로 갈 수록 효율은 좋지만 비용(복잡도나 수행을 하기 위한 성능 등등)이 많이 드는 점도 있고 해서 절충안을 마련해야하는데 하드웨어가 짱짱해지면 이 정도 비용은 껌이 되는 시대가 올 것이다. 3-4. UDP가 고속으로 데이터를 전달하는 방법(B)UDP는 TCP에 비해 상당히 간단한 프로토콜이다.위의 TCP가 했던 흐름 제어(윈도우 사이즈를 수시로 주고받는 과정), 실패한 패킷 재전송, MSS 정하기, 네트워크 혼잡 상태 파악, 3way handshake 등등이 UDP에서는 무의미해진다.왜냐하면 안 하기 때문이다.그냥 빠르게 보내는 데에만 열중하게 된다.실시간성이 중요한 음성&#x2F;영상 프로토콜에 많이 쓰인다.음성&#x2F;영상 같은 경우에는 가끔 데이터 손실(왜곡)이 있어서 지지직 대거나 화면이 조금 깨져도 크리티컬한 문제는 아니다.따라서 헤더도 TCP에 비하면 매우 간단하다. 하지만 UDP의 성능을 유지하면서 TCP와 같은 신뢰도를 보장하고 싶은 그런 케이스도 존재한다.이런 경우에는 트랜스포트 계층에서는 UDP 프로토콜을 쓰지만, 애플리케이션 계층에서 흐름제어나 재전송 등등의 TCP의 역할을 어플리케이션 레벨에서 처리하기도 한다. 여기서 브로드캐스트와 멀티캐스트라는 중요한 개념이 등장한다.브로드캐스트는 네트워크에 속한 모든 호스트(컴퓨터와 같은 기기)에게 알림을 전파?하는 개념이다.예를 들면 공유기에 새로운 PC를 연결했을 때 사설 IP를 할당받아야하는데 어떤 IP가 비어있는지 모르니까모든 호스트를 다 찌르면서(브로드캐스팅을 해서) IP 주소를 알아내고 비어있는 IP를 알아내야할 때 브로드캐스트가 쓰인다.네트워크에 속한 호스트들은 거부 권한이 없다고 한다. (불쌍한 놈들 ㅠㅠ)거부 권한이 없기 때문에 브로드캐스트 트래픽을 받은 애들은 일제히 하던 일을 중단하고 브로드캐스팅에 집중해서 본인에게 유익한 정보인지 파악한다. (마치 인터럽트 당하듯이)그리고 본인에게 해당되는 정보가 없으면 하던 일을 마저하고, 자신에게 해당되는 내용이면 그에 맞게 처리를 한다.브로드캐스트는 네트워크 전체에게 트래픽을 보내는 것으로 네트워크를 혼잡하게 할 뿐 아니라 수신측의 성능 저하도 유발한다. 멀티캐스트는 네트워크 내의 특정 그룹에게만 데이터를 전송해야할 때 쓰는 방법이다.브로드캐스트로 전부 다한테 공지하려면 보안에 민감한 정보도 있을테고 오버헤드도 심하기 때문에 이런 방식을 쓴다.멀티캐스트로 그룹을 나누는 방법은 IP 클래스 중에 D 클래스를 이용하면 된다고 한다.브로드캐스트와는 달리 본인의 의지로 SUBSCRIBE 할 수 있으며 구독 해지도 할 수 있다. 그리고 책에는 나오지 않지만 유니캐스트(Unicast)라는 개념 또한 중요하다.유니캐스트는 상대방의 물리 주소(Physical Address, 네트워크 상에서는 MAC(Media Access Control) Address를 의미한다.)를 통해 1:1 통신하는 걸 의미 한다.대부분의 통신 방식이 유니캐스트 방식으로 진행된다.본인의 MAC Address와 일치하지 않는 패킷은 바로 버리면 되고 CPU까지 올라오지도 않으므로 PC 성능에 영향을 미치지 않는다. 아래 링크들을 보면 도움이 많이 된다. 삽질 왕국 :: ③ 유니캐스트, 브로드캐스트, 멀티캐스트 유니캐스트 VS 브로드캐스트 VS 멀티캐스트 3-5. netstat 명령으로 네트워크의 상태 확인하기(B)netstat 명령어로 서버와 커넥션이 제대로 맺어졌는지 어떤 상태인지 알 수 있다는 내용이다.만약 8080 포트 서버가 제대로 떠있는지 확인하고 싶다면 netstat -na | grep 8080을 입력하면 네트워크의 연결 상태들을 볼 수 있다.만약 해당 서버를 죽이고 싶다면 lsof -i:8080 명령어로 어떤 프로세스가 해당 포트를 물고있는지 보고 kill -9 PID 명령어(PID는 프로세스 ID)로 죽여버리면 된다. 책 마지막 부분에 패킷 캡처 도구로 Wireshark가 나오는데 크롬 개발자 도구를 쓸 수 없는 상황이나 크롬 개발자 도구에서 보이는 것보다더 아랫단의 패킷이나 실제 데이터 통신이 어떻게 되고 있는지 디버깅 하고 싶다면 이 툴을 쓰면 된다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 2장 네트워크 서비스와 애플리케이션 계층","slug":"tcp-ip-book-index-2","date":"2018-03-31T14:49:12.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2018/03/31/tcp-ip-book-index-2/","link":"","permalink":"https://perfectacle.github.io/2018/03/31/tcp-ip-book-index-2/","excerpt":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다.","text":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다. 예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다. 백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다. 더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다. 목차 컴퓨터 네트워크 네트워크 서비스와 애플리케이션 계층 트랜스포트 계층 라우팅과 인터넷 계층 하드웨어와 네트워크 인터페이스 계층 보안 2장, 네트워크 서비스와 애플리케이션 계층애플리케이션 계층은 TCP&#x2F;IP 스택의 최상단으로 사용자가 직접 체감을 느끼는 구간이고 프론트 개발자와 가장 밀접하다.바로 HTTP(S) 프로토콜이 속해있으니 이 부분은 집중해서 봐야한다.프론트가 알아야한다면 백엔드는 당연히 알아야한다.OSI 7 Layer 기준으로는 L7(Application Layer), L6(Presentation Layer), L5(Session Layer)에 해당한다. 2-1. 애플리케이션 계층의 역할(F&#x2F;B)애플리케이션 계층의 패킷에는 다양한 내용들이 들어갈테지만 핵심적인 건 데이터(html 소스 코드 등등)이 여기서 실리게 된다.어떤 데이터를 실어서 서버&#x2F;클라이언트가 통신할지 여기서 결정되는 것이다.HTTP 프로토콜 외에도 아래와 같은 애가 있다. 파일의 전송을 위한 (S)FTP((Secure) File Transfer Protocol) 원격지의 서버를 제어하는 SSH(Secure SHell) 메일 서버 관련된 POP3, SMTP, IMAP 등등이 존재 시스템 내부적으로 사용하는 것 중에는 아래와 같은 것들이 있다. ip ↔ domain(www.naver.com 같은 애) 역할을 하는 DNS(Domain Name System, 얘의 대표 포트가 53번 포트라 AWS에서 도메인 등록하는 서비스를 Route53이라고 지었다.) ip를 할당해주는 DHCP(Dynamic Host Configuration Protocol) 데이터를 암호화 할 때 쓰이는 SSL&#x2F;TLS(Secure Sockets Layer&#x2F;Transport Layer Security), HTTPS와 SFTP, SSH 프로토콜에서 데이터 암&#x2F;복호화 할 때 사용된다. 2-2. 웹 페이지를 전송하는 HTTP(F&#x2F;B)웹 페이지가 표시되는 과정이나 HTTP 메시지가 어떤 식으로 구성돼있는지 설명하고 있다.URL에 대한 설명과 HTTP 헤더, 바디, 요청과 응답, 그리고 status code에 대해서도 설명해주고 있다. 2-3. 웹 서비스와 웹 애플리케이션(F&#x2F;B)웹 서비스&#x2F;어플리케이션이 뭐고 서로 어떻게 정보를 교환하는지 설명하고 있다.사용성도 높여주고 서버의 부담을 줄여주는(html 전체를 내려주는 게 아니라 필요한 애만 내려주면 되니까) ajax에 대한 간단한 설명,GET&#x2F;POST 메소드의 차이에 대해 알려주고 있다.학부 시절에 GET은 URL에 요청의 내용이 노출되니 보안에 민감하지 않은 정보인 검색이나 게시판 페이지 등등에 쓰이고 URL 길이에 제약이 있다고 배웠는데 면접에서 이렇게 답변하면 탈탈 털릴 것이다.URL은 리소스의 경로를 나타내는 것이지 비밀번호, ID와 같은 정보는 리소스라고 보기에는 애매~한 것 같다.따라서 로그인 같은 건 POST를 사용한다.또한 POST라고 보안에 좋은 게 아니다.(패킷 캡쳐하면 다 보인다.)POST는 리퀘스트에 Body(json이나 파일 전송에 쓰이는 multipart&#x2F;form-data 등등)을 실어 보낼 때 쓰기도 하고,GET은 URL 입력만으로 요청이 전송되기 때문에 혹시나 유저가 실수로 URL을 입력할 수도 있으므로 데이터의 변경이 일어나는 작업은 웬만해서는(조회수를 늘리는 경우 등등 빼고) GET으로 하면 안 된다.또한 GET과 POST를 설명하려면 다른 HTTP Method인 PUT, DELETE, FETCH, OPTION 등등과 REST(FUL) API를 접목시켜서 설명해야하는데 책에서는 딱히 설명하고 있진 않다. 2-4. 세션을 유지하기 위한 쿠키(F&#x2F;B)세션은 뭘까?일반적으로 세션은 허용된 유저가 리소스 사용하는 걸 허락하게 해주는 기간이라고 보면 된다.세션은 API 마냥 어디에서 쓰이느냐에 따라 아주 다양한 의미를 가지지만 HTTP 프로토콜 내에서 위에 설명한 세션을 접목시켜보자면 유저가 로그인을 한다. 서버에서는 로그인에 성공하면 세션(A라는 유저는 2099년 1월 30일까지 로그인을 해야하만 하는 리소스에 접근이 가능하다는 정보를 담고 있는 파일)을 서버에 저장한다. 여기까지가 세션이 생성되는 과정이다.하지만 HTTP 프로토콜은 무상태 프로토콜(Stateless protocol)이라서 세션에 대한 정보를 통신에 실어 보내지 않는다. 그렇다면 무상태 프로토콜은 무엇이며 왜 쓸까?동일한 유저가 보낸 이전 요청과 다음 요청에 대한 상태(세션)을 가지지 않는 프로토콜을 말한다.즉 세션이 없기 때문에 요놈이 로그인 한 상태인지 아닌지 모르게 된다는 말이다.장점으로는 서버의 설계가 단순해진다고 한다. (여기서 말하는 서버가 백엔드가 개발하는 서버를 말하는 건지 다른 서버를 말하는 건지 모르겠다. 아마 내부적으로 알아서들 처리해주기 때문에 내가 잘 모르는 거일 수도 있다.) 그럼 HTTP 프로토콜에서는 세션을 어떻게 유지할까?(로그인 상태를 어떻게 유지할까?)바로 쿠키라는 것을 통해서 유지한다.쿠키에다가 세션에 대한 ID를 보내주고 매번 통신할 때마다 클라이언트는 서버로 쿠키를 보낸다.서버는 해당 쿠키로 유저를 식별하므로 쿠키가 탈취당하면 해킹을 당했다고 보면 된다. (이걸 보완한 방법도 있는데 아직 이건 공부를 안 했다.)또한 로그인이 필요치 않은 단순 이미지 파일 요청에 대해서도 요청에 쿠키를 실어 보내기 때문에 쿠키는 세션 유지에 필요한 최소한의 정보만 담고 있는 게 좋은 것 같다. 2-5. 이메일(B)사실 메일 서비스를 구현해보지 않고 항상 써드파티들을 이용하다보니 크게 ~ 와닿지는 않았다.하지만 메일을 보내는 프로토콜(SMTP, Simple Mail Transfer Protocol)과 메일을 받는 프로토콜(POP, Post Office Protocol)이 따로 있다는 사실은 신기했다. 2-6. PC끼리 파일 공유하기이거는 사실 뭐 웹개발 할 때는 필요없고 사내에서 그냥 파일 공유할 때 알아두면(사실 뭐 몰라도 사용하는 데는 문제 없지만) 좋은 것 같다.여기서 말하는 파일 공유는 같은 네트워크 상에 존재하는 PC끼리 파일 공유를 하는 P2P(Peer to Peer) 방식이기 때문에 중앙에서 관리해주는 서버가 없는 방식이다.따라서 새로 연결되는 컴퓨터는 브로드캐스팅(네트워크에 연결된 모든 PC에 데이터를 보냄)을 통해 입주 신고를 한다.그럼 원래부터 네트워크에 있던 모든 PC들이 파일 공유에 필요한 정보들을 새로 입주한 PC에게 주면 파일 공유 준비는 끝나게 된다.또한 OS 별로 파일 공유를 위한 프로토콜이 다르다. (윈도우는 SMB, 맥은 SMB, AFP, 리눅스는 SMB, NFS)예전에는 그래서 다른 OS간 파일 공유가 안 됐었는데 요새는 SMB로 대동단결 된 것인지 뭐 어떻게든 공유를 할 수 있는 모양이다. 2-7. 파일을 전송하는 FTP(B)파일 전송을 위한 프로토콜인데 보안에 취약해서 SSH 프로토콜을 이용하는 SFTP(SSH FTP 또는 Secure FTP)를 사용한다.그래서인지 대표 포트가 SSH와 똑같은 22번 포트를 사용한다.파일 전송만을 하는 SCP(Secure CoPy) 프로토콜(얘도 22번 포트를 사용한다)과는 달리 SFTP는 원격지의 파일의 제어를 어느정도 허용한다. FTP는 파일을 주고받기 위해서도 쓰이지만(이 때 데이터 커넥션이라는 접속 모드를 사용)명령어를 보내기 위해서도 사용한다.(이 때 컨트롤 커넥션이라는 접속 모드를 사용, 디렉토리&#x2F;파일의 생성&#x2F;이동&#x2F;삭제&#x2F;수정 등등)또한 HTTP 프로토콜과는 달리 허용된 유저만 접근을 허락하는 목적으로 설계된 프로토콜이라 요청과 응답이 끝났다고 해서 바로 연결을 끊는 게 아니다.기본적으로 HTTP 보다는 동접이 많지 않을 것이므로 바로 연결을 끊을 이유가 없다.또한 상태를 가지는 프로토콜이기 때문에 HTTP 처럼 매번 쿠키와 같이 접속에 대한 정보를 계속해서 보내줄 필요도 없다. 또 액티브 모드와 패시브 모드란 게 있는데액티브 모드를 사용하면 ftp 서버의 방화벽 중에 아웃바운드 트래픽에 걸려서 응답을 못 받는 경우가 존재한다.이럴 때 패시브 모드를 사용해서 서버에서 클라이언트로 데이터 커넥션을 만드는 게 아니라 역으로 클라이언트에서 서버로 데이터 커넥션을 만들어서 통신하면 된다. 2-8. 원격지의 컴퓨터 제어하기(B)원격지의 컴퓨터를 제어할 때는 GUI(Graphic User Interface) 방식으로 직접 마우스를 움직여서 컨트롤 하는 방법이 있지만,일반적인 컴퓨터와 달리 서버의 경우에는 CLI(Command Line Interface) 방식으로 마우스를 쓸 수 없는 환경의 OS를 사용하는 게 대부분이다.서버의 역할을 수행하는데 GUI를 쓸 필요가 없기도 하고 CLI로 간단하게 명령어만 날리면 되기 때문이다.이런 CLI OS(뭐 GUI도 마찬가지고)를 원격지에서 제어하기 위한 프로토콜로 SSH를 많이 쓴다. (과거에는 Telnet을 많이 썼지만 보안 상 이슈로 대부분 SSH로 통신한다.)사용해보면 마치 내 컴퓨터에서 명령어 내리는 거 마냥 신기하게 바로바로 명령어들을 수행할 수 있다.이걸 사용해서 서버의 설정을 바꾸고 배포하고 지지고 볶고 다 할 수 있다. (하지만 서버가 한 두대도 아니고, 짜치는 건 다 자동화하는 추세라서 직접 접속할 필요가 없기도 하다.) 2-9. Voice over IP와 영상 스트리밍(B)유선 통화와 핸드폰으로 통화 할 때 3G까지는 회선 교환 방식으로 통신이 일어났는데아마 4G인 LTE(Long Term Evolution)부터는 패킷 교환 방식 중에 데이터 그램 방식을 사용하고, VoIP 프로토콜을 사용하는 모양이다.데이터 그램 방식 중에도 UDP 방식(음성 일부가 지지직 대는 현상을 느꼈을텐데 아마 UDP 방식으로 통신을 하기 때문인 듯…?)을 사용하는 것 같다.왜냐하면 음성 중 일부가 유실 되어도 그렇게 크리티컬한 상황은 아니고 실시간성이 보장돼야하기 때문에 안정성 보다는 성능이 보장돼야하기 때문에 TCP 보다는 UDP 방식을 택한 것 같다. 동영상 스트리밍 같은 경우에도 위와 마찬가지의 이유로 UDP 프로토콜을 사용하는데 아직 동영상 프로토콜이 보편화 된 것이 아니라 일부 네트워크 환경에서 차단 될 가능성이 있다고 한다.따라서 HTTP 프로토콜에 동영상 데이터를 싣는데 일반적인 TCP + HTTP의 조합이 아닌 실시간 성이 어느정도 보장되는 UDP + HTTP의 조합으로 가는 거 같다. 2-10. 크롬 개발 도구로 HTTP 메시지 살펴보기(F&#x2F;B)엄청 엄청 중요하다.백엔드가 응답 잘 내려주고 있다는데 뻥치고 있을 수도 있으므로 응답을 어떻게 주는지 봐야한다.마찬가지로 프론트가 요청 잘 보내고 있다고 뻥치고 있을지도 모르므로 요청을 어떻게 주는지 봐야한다.이럴 때 실제 동작하는 코드 위에서 어떻게 데이터를 주고받는지 제일 간단하게 확인하는 방법은 크롬 개발자 도구의 네트워크 탭을 보는 것이다.아마 AJAX를 사용해서 API를 호출하는 경우가 가장 많으므로 XHR(AJAX로 통신하기 위해서는 XMLHttpRequest로 통신하기 때문에, XHR이라고 줄여 부르는 듯, Fetch API를 쓰는 경우에도 여기 뜸)탭을 눌러서 확인해보면 된다.그럼 메소드, URL, 헤더, 바디에 뭘 실어서 보내고 응답받는지 다 확인할 수 있다. MIME(Multipurpose Internet Mail Extensions)(F&#x2F;B)원래는 이메일을 위해서 나온 애이다.컴퓨터는 서구권에서 만들어져서 원래 영어 +@로 영미권에서만 사용하는 문자들의 집합인 ASCII 코드로 표현할 수 있는 데이터만 실어 보낼 수 있었다.하지만 첨부파일을 보내고 싶은데 이거는 텍스트가 아니라 보낼 수 없어서 텍스트 외의 데이터를 실어 보내기 위해서 MIME이 나왔다.한글의 경우에도 ASCII 코드에 해당하지 않기 때문에 MIME을 활용해서 이메일을 보내고 있다. 하지만 이걸 뛰어넘어서 이메일이 아닌 HTTP로 통신하는 경우에도 MIME을 활용하고 있다.내가 서버로 JSON 데이터를 보내고 싶으면 HTTP Body에 JSON을 실어보낸다고 끝이 아니다.이 정보가 JSON이니까 그거에 맞게 해석해야한다 라는 정보를 HTTP Request 어딘가에 실어야한다.그 정보를 HTTP Headers안에 Content-Type이라는 키(key) 안에 application&#x2F;json 이라는 값(value)로 실어서 보낸다.저 application&#x2F;json 이라는 문자를 MIME이라고 부르며 MIME Type이라고 부르기도 한다.MIME Tpye은 type&#x2F;subtype으로 구성된다. 가끔 이미지 확장자를 jpg만 받는 사이트가 있으면 확장자만 png 같은 확장자를 jpg로 바꿔서 올리는 경우도 있다.하지만 실제로 파일을 까보면 헤더에 image&#x2F;png라는 정보가 있어서 서버나 클라이언트에서 마임타입으로 체크를 하면 업로드에 실패할 것이다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(네트워크) TCP/IP 쉽게, 더 쉽게 목차 리뷰 - 1장 컴퓨터 네트워크","slug":"tcp-ip-book-index","date":"2018-03-30T23:11:15.000Z","updated":"2022-10-30T08:42:16.947Z","comments":true,"path":"2018/03/30/tcp-ip-book-index/","link":"","permalink":"https://perfectacle.github.io/2018/03/30/tcp-ip-book-index/","excerpt":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다.","text":"오래전에 이 책을 추천받았으나 최근에 읽어보게 되었다.백엔드 개발자로 일하면서 프론트 엔드 개발자와 의사소통을 원활히 하기 위해서는 서로 네트워크에 대한 기본 지식이 있어야하는 것 같다.이 글은 빠르게 목차를 리뷰하며 백엔드에게 필요한 내용인지, 프론트에게 필요한 내용인지, 공통적으로 알아야하는 내용인지 개인적인 기준에서 분류해봤다. 들어가기에 앞서내가 여태까지 봐왔던 네트워크 계층 설명글들은 대부분 OSI 7 Layer를 기준으로 설명을 풀어나가고 있다.OSI 7 Layer는 각 계층이 하는 역할이 명확해서 설명하기가 명쾌하다.하지만 이론과 현실 사이의 괴리감이랄까… OSI 7 Layer는 구현하기가 복잡하거나, 성능 등등의 이슈(굳이 여러 계층으로 쪼갤 필요 없이 하나의 장비가 여러 역할을 수행하는 게 더 나을 때도 있으므로)로 인해실제 구현된 건 대부분 4계층으로 구성된 TCP&#x2F;IP Stack으로 구현이 많이 돼있다.이 책은 신기하게도 TCP&#x2F;IP Stack에 기반해서 각 계층의 역할을 설명하고 있다.따라서 진짜 구현된 모델에 대한 이해를 증진시키는 데는 좋은 것 같으나 당장 AWS나 다른 글들을 보면 L4니 L2니 L7이니 해서 OSI 7 Layer로 설명된 글들이 많아서OSI 7 Layer와 책에 설명된 TCP&#x2F;IP Stack을 매핑시켜 이해하기 위해 책 앞 부분을 많이 왔다갔다 해야하는 단점이 존재하는 것 같다. 또한 책이 TCP&#x2F;IP Stack에 대한 전반적인 내용을 200페이지도 안 되는 분량으로 녹여내다보니 전반적인 흐름을 알기는 좋으나각각의 계층에 대해 딥하게는 다루지 않고, 그림도 아기자기 잘 설명돼있어서(+풀컬러) 입문 서적으로 좋은 것 같다.각 목차 뒤에 F(ront), B(ack)을 적어놨으니 자신의 직군에 맞춰 딥하게 볼지 그냥 흐름만 볼지, 아예 안 볼지 판단하길 바란다. 예를 들면 프론트는 클라이언트 측에 웹서비스를 제공해주는 일을 하는데 그 중에서 서버가 제공해주는 API로 통신을 해서 데이터를 땡겨와야 한다.웹서비스를 제공하기 위해서는 HTTP(S) 프로토콜을 사용하고, 서버의 API와 통신할 때도 HTTP(S)로 통신을 한다.HTTP 프로토콜은 정보 공유를 위해 만들어진 프로토콜이므로 엄청난 수의 클라이언트가 접속하게 된다.통신을 위한 통로에 수십만명이 한 번에 들어오게 끔 하면 가능한지도 모르겠고, 매번 그 만큼의 사람이 들어오는 것도 아니고, 비용 낭비도 엄청날 것이다.따라서 통신을 위한 통로를 독점하는 게 아니라 항상 연결을 맺고 끊어서 다른 사람들이 원활하게 접속을 하게 해준다.예를 들면 이 통로를 통해서는 동시에 100명만 들어올 수 있게 만들고 나한테 볼 일이 끝난 애들은 다 연결을 끊는 것이다.(사실 이런 설정은 백엔드가 한다.)이 때 연결을 위해 사용하는 프로토콜이 TCP 프로토콜이다. (UDP 프로토콜도 있지만 웹 서비스 내에서는 대부분 데이터를 손실없이 전달해주는 TCP 프로토콜을 사용한다.)따라서 프론트 엔드 개발자라면 HTTP 프로토콜은 물론이고 TCP 프로토콜까지 알아야 어떻게 하면 통신을 최적화 할 수 있을지 생각할 수 있게 된다. 백엔드의 경우에는 HTTP(S), TCP 프로토콜만 안다고 해서 끝나는 게 아니다.SSH 프로토콜을 이용해서 서버에 원격으로 붙어서 명령어를 날리기도 하고, FTP 프로토콜을 이용해서 파일 업로드&#x2F;다운로드가 가능한 서버를 설계해야할 수도 있기 때문이다.SSH 프로토콜을 사용하려면 여러 인증 방식 중에 키로 인증하는 방식이 있는데 그럼 공개키, 비공개키, 대칭키, 비대칭키 막 이런 내용이 나오는데 이런 보안적인 요소도 알아야한다.이 내용은 HTTPS에 사용되는 TLS 인증서의 암호화 방식에도 적용된다.또한 동영상 스트리밍 서버를 만든다고 하면 UDP 프로토콜을 사용한다.기본적으로 TCP 프로토콜은 해주는 일이 많으므로(데이터 전송에 실패하면 재전송 처리 등등) 성능이 안 받쳐주는데UDP 프로토콜(보내기만 할 뿐, 잘 받았는지 확인을 하지 않는다. 그래서 가끔 동영상이 깨져서 나오는 현상들이 나온다.하지만 크리티컬한 이슈는 아니고 매번 똑같은 부분에서 동영상이 깨져나오는 게 아니고 네트워크 상황에 따라 달라지기 때문이다.)은 그거보다 성능이 낫기 때문이다.또한 AWS를 사용하다보면 그 아랫단인 IP&#x2F;Router&#x2F;Subnet Mask 등등의 영역도 잘 알아야한다.보안을 위해 외부에서 접근이 가능한 요소(다양한 요청을 분산해주는 로드 밸런서)와 내부에서만 접근이 가능한 요소(웹서버, DB 등등)을 구성해야하는데…그러면 네트워크를 어떻게 구성해야할 것이며, 이 네트워크 안에 서버는 몇 대를 둘 것이며, 퍼블릭 요소들과 프라이빗 요소들은 어떻게 통신을 할 것이며어떤 요청들을 받고 말지 네트워크부터 보안에 대한 요소들을 직접 다뤄야하는 경우가 오는데 이럴 때 이 내용들을 알고 있으면 정말 무릎을 탁 치게 되는 날이 온다. 더 아랫단이나 부가적인 요소들은 알면 +@, 몰라도 그만인 것 같은데 호기심이 충만하면 알고 싶을 것이다.위에서 설명하지 않은 모뎀, 이더넷 카드, 랜선 등등은 사실 하드웨어 단으로 내려가는 거니 백엔드가 굳이 알 필요가 있나 싶다.(물론 알면 좋다.)또한 데이터 전송에 실패했을 때 어떤 전략으로 재전송시킬 것인지(어플리케이션 단이 아닌 하드웨어 단에서 패킷을 처음부터 전송할 건지, 실패한 부분을 알아내서 그거부터 전송할 것인지)이런 내용들은 내가 봤을 때는 굳이 알 필요가 있나 싶은데 분명 알아두면 어딘가는 써먹을 일이 있을테니 공부해둬야할 것 같긴 하다. 목차 컴퓨터 네트워크 네트워크 서비스와 애플리케이션 계층 트랜스포트 계층 라우팅과 인터넷 계층 하드웨어와 네트워크 인터페이스 계층 보안 1장, 컴퓨터 네트워크전반적으로 네트워크가 무엇이고 종류에 뭐가 있고, 그 네트워크를 구성하고 있는 계층이 뭔지 설명하고 있다.백엔드 개발자라면 다 알아야하는 내용이다. 1-1. 컴퓨터 네트워크의 종류(F&#x2F;B)간단하게 네트워크가 뭐하는 놈인지, 인터넷이 뭔지, 무선 네트워크엔 뭐가 있는지 간략하게 설명하고 있다. 1-2. 컴퓨터 네트워크 역할(F&#x2F;B)네트워크가 뭔 일들을 하는지 그림으로 설명하고 있으니 그냥 아 그런가보다 하고 훑어보면 된다. 1-3. 서버와 클라이언트(F&#x2F;B)이거 모르고 웹 개발 하면 안 된다.서버는 스펙(사양, 성능)을 보고 얘기하는 게 아니라 서비스를 제공하는 애인지(요청에 대한 응답을 하는 애인지)로 구분된다.간단하게 토렌트로 파일을 다운로드 받으면 내가 클라이언트이고, 다운받은 파일을 공유하면 내가 서버가 되는 거다.근데 대부분 웹 서버의 경우에 동접수 몇만명 찍으면 일반 스펙으로는 못 견디기 때문에 서버용 컴퓨터는 대부분 일반 컴보다는 스펙들이 좋다. 1-4. 패킷 교환 방식(F&#x2F;B)패킷은 그냥 데이터(html 소스 코드 등등)를 잘게 쪼개놓은 거라고 보면 된다.데이터를 하나로 통짜로 보내다가 전송 실패하면 그 큰 데이터를 다시 처음부터 보내야하므로데이터를 잘게 쪼개서 보내면 실패한 애만 재전송하면 되는 등 이점이 크니까 그냥 아 잘게 쪼갰나 보다, 그런 걸 패킷(킬로바이트 마냥 그냥 하나의 단위이다.)라고 보면 됨. 패킷 교환 방식과 함께 회선 교환 방식을 설명하고 있는데,회선 교환 방식은 통신 루트 하나 뚫어놓고 걔랑 주구장창 통신하면 돼서 통신 품질이 매우 좋다.(안정적)통화할 때는 내가 통화하려는 사람하고만 통신하면 되므로(남이 엿들으면 안 되므로) 회선 교환방식을 이용한다.하지만 해당 회선을 점유하고 있으므로 언제 통화가 올 지 모른다.무한정 대기하므로 idle time(쉬는 시간)이 길어지므로 효율적으로 사용하는 건 아니다.또한 연결 지향형이기 때문에 연결이 맺어지기 전까지는 데이터를 보낼 수 없다. 패킷 교환 방식은 그냥 회선 교환 방식이랑 정반대이다.회선을 공유하기 때문에 idle time이 적어 효율적이며이미 많은 애가 해당 통로로 통신중이면 딜레이가 발생하고(불안정), 누군가 엿들을지도 모른다. 패킷 교환 방식도 두 가지가 존재하는데 가상 회선 방식 - 연결 지향형이고, 회선 교환 방식이 물리적인 연결이라면 얘는 논리적인 연결을 함. (TCP) 데이터 그램 방식 - 비연결 지향형이고, 음… 잘 떠오르지 않는데 UDP에서 이 방식을 사용함(UDP의 이름 자체가 User Datagram Protocol, 데이터그램을 포함하고 있음.) 1-5-1. 컴퓨터 네트워크와 계층 모델(F&#x2F;B)계층 모델(각각의 역할에 맞게 분류하고 추상화한 것, 예를 들면 Windows(OS) 라는 레이어 위에 Chrome(Browser) 라는 레이어 위에 V8(JS Engine)이 있듯이…)에 대해 설명하고 있는데 일반적으로 네트워크를 설명할 때 사용하는 OSI 7 Layer가 아닌 TCP&#x2F;IP Stack으로 설명하고 있다.OSI 7 Layer는 Open Systems Interconnection의 줄임말로 다른 시스템(서로 다른 네트워크? 플랫폼? 장비?)끼리 어떻게 하면 잘 연결되게 만들까 고민하다가 나온 모델이다.7 Layer는 그 계층을 역할에 따라 7개로 쪼갠 것이다.브라우저는 운영체제가 잘 구현됐겠거니… 신뢰를 하고 구현을 해놓은 것이다.JS 엔진은 브라우저가 잘 구현돼겠거니… 신뢰를 하고 구현을 해놓은 것이다.이렇듯 서로 자신의 역할(단일책임? 관심사 분리?)만 수행하면 되니 다른 애가 무슨 일을 하는지는 신경도 쓰지 않는다.OSI 7 Layer도 마찬가지로 서로 무슨 역할을 하는지 관심은 없고 오로지 자기가 맡은 일을 잘 해서 상위, 혹은 하위 레이어로 잘 보내주기만 하면 된다.하지만 이 책에서는 OSI 7 Layer 대신 TCP&#x2F;IP Stack으로 구현된 게 대부분이다 보니 TCP&#x2F;IP Stack을 기준으로 설명을 한 것 같다. 1-5-2. 각 계층을 통과하는 데이터의 형태(B)데이터를 보낼 때는 상위 레이어에서 하위 레이어로 터널링(각 계층을 터널이라 생각하고 해당 터널을 하나하나 지나간다고 생각하면 됨)을 하며 지나가고터널링을 하면 할 수록 캡슐화(각 터널에서 헤더(데이터 통신에 필요한 정보들)을 하나씩 가져다 붙혀서 하나의 캡슐 알약을 만든다고 생각)가 진행이 되고,반대로 데이터를 받을 때는 하위 레이어에서 상위 레이어로 터널링하면서 캡슐을 하나하나씩 까서 실제 필요한 데이터만 전달받게 되는 것이다. 1-6. 4개 계층의 동작 방식(F&#x2F;B)사실 프론트는 뭐 가장 상위 레이어인 애플리케이션 계층과 그 아랫단인 트랜스포트 계층까지만 알면 되는 것 같다. 1-6-1. 애플리케이션 계층(F&#x2F;B)실질적으로 사용자가 바로 체감할 수 있는 영역이다.어떤 프로토콜을 사용할지(HTTP, FTP, SSH 등등), 요청은 대부분 URI를 통해서 진행된다. 1-6-2. 트랜스포트 계층(F&#x2F;B)여기서 TCP 프로토콜을 사용할지, UDP 프로토콜을 사용할지, 기타 등등을 사용할지가 결정된다.프론트 엔드는 대부분 HTTP(S)로 통신을 하고, HTTP는 대부분 TCP 프로토콜 위에서 도니 TCP 프로토콜이 어떻게 동작하는지까지만 알면 되는 것 같다.물론 백엔드는 그 아랫단까지 다 공부해야겠지만…port를 가지고 어떤 장비에게 가야할지 골라내는 역할을 한다. 1-6-3. 인터넷 계층(B)ip를 가지고 어떤 장비에 가야할지 골라내는 역할을 한다.사실 ip 프로토콜만 있는 게 아니라 IPSec(IPv6에서 지원해주는 듯… 패킷을 암호화)나 ICMP(서버 살아있나 핑 날릴 때 등등)도 존재한다. 1-6-4. 네트워크 인터페이스 계층(B)완전 아랫단에 속한다.아래와 같은 장비들이 여기에 속한다. 어느 장비(방향)으로 가야하는지 정보를 알려주는 Router, 아날로그 신호(광랜이라면 빛)를 디지털 신호(0과 1)로 encode 해주는 MOdulator,디지털 신호를 아날로그 신호로 decode 해주는 DEModulator.두 개의 역할을 모두 수행하는 Modem.모뎀이라고 하면 전화망을 통해서 연결돼서 굉장히 느린 장비 아닌가? 라고 생각할 수 있는데그런 애들을 Dialup Modem이라고 부른다.아날로그 신호 ↔ 디지털 신호의 기능만 수행한다면 전부 모뎀이다.ADSL, VDSL, FTTH(Fiber To The Home, 광랜) 등등도 전부 모뎀이라고 부를 수 있다. 서로 다른 장비끼리 통신이 가능하게 연결해주는 Lan Cable(랜선)랜선에도 규격(스펙)이 있는데 1기가 광랜을 설치했다고 하더라도 안 좋은 랜선을 쓰면 그 속도를 받춰주지 못한다. 컴퓨터가 통신이 가능하게 식별 가능한 주소를 부여해주는 Ethernet Card. (한국에선 랜카드라고 많이 불림.)모뎀, 랜선이 좋아봤자 이더넷 카드도 스펙이 꾸지면 제 속도를 내지 못한다. 1-7. 통신 규약과 프로토콜(F&#x2F;B)프로토콜은 서버와 클라이언트가 어떻게 통신을 할지 규약을 정의해놓은 것이다.여러가지 프로토콜(규약)이 존재하며 각 계층에서 사용하는 프로토콜이 다르다.대표적인으로 어플리케이션 계층에서 웹서비스를 제공해주는 HTTP 프로토콜, 트랜스포트 계층에서 신뢰성 있는 연결을 제공해주는 TCP 프로토콜 등등이 있다.이런 프로토콜들도 각각 스펙이 있고 그 스펙에 맞춰 브라우저를 구현하거나 OS를 구현한 것이다. 1-8. 인터넷의 영향(F&#x2F;B)인터넷의 특징과 나오기 전&#x2F;후에 대한 내용을 설명하고 있다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"}]},{"title":"(Java) 타임머신을 타고 시간 여행 떠나기","slug":"mock-time-with-time-machine","date":"2018-03-30T00:41:17.000Z","updated":"2022-10-30T08:42:16.867Z","comments":true,"path":"2018/03/30/mock-time-with-time-machine/","link":"","permalink":"https://perfectacle.github.io/2018/03/30/mock-time-with-time-machine/","excerpt":"문제의 발단가끔 현재 시간을 기준으로 코드를 짜야할 때가 있다.이런 경우에 자바의 경우에는 LocalDate, LocalTime, LocalDateTime 등등의 클래스에 있는 static 메서드인 now 메서드로 현재 시간을 구한다.아래와 같이 말이다. 12345678910111213141516171819public class App &#123; // 테스트 하기 어렵게 하기 위해서 일부러 메소드가 메소드를 계속해서 호출하는 형태로 작성함. // 현재 시간이 오전인지 알아내는 메소드 public static boolean isAM() &#123; return method(); &#125; private static boolean method() &#123; return method2(); &#125; private static boolean method2() &#123; return method3(); &#125; private static boolean method3() &#123; return LocalTime.now().isBefore(LocalTime.of(12, 0)); &#125;&#125; 하지만 이렇게 현재 시간에 의존하는 코드를 테스트하기란 매우 어렵다.","text":"문제의 발단가끔 현재 시간을 기준으로 코드를 짜야할 때가 있다.이런 경우에 자바의 경우에는 LocalDate, LocalTime, LocalDateTime 등등의 클래스에 있는 static 메서드인 now 메서드로 현재 시간을 구한다.아래와 같이 말이다. 12345678910111213141516171819public class App &#123; // 테스트 하기 어렵게 하기 위해서 일부러 메소드가 메소드를 계속해서 호출하는 형태로 작성함. // 현재 시간이 오전인지 알아내는 메소드 public static boolean isAM() &#123; return method(); &#125; private static boolean method() &#123; return method2(); &#125; private static boolean method2() &#123; return method3(); &#125; private static boolean method3() &#123; return LocalTime.now().isBefore(LocalTime.of(12, 0)); &#125;&#125; 하지만 이렇게 현재 시간에 의존하는 코드를 테스트하기란 매우 어렵다. 1234567public class AppTest &#123; @Test public void testAm() &#123; // 이 테스트는 오전에는 통과하고 오후에는 깨지는 테스트가 된다. assertTrue(App.isAM()); &#125;&#125; 만약 배포 스크립트에 테스트가 통과하지 못하면 배포가 실패하게 끔 구성돼있다면 오전에만 배포해야하거나 테스트를 끄고 배포를 수행해야할 것이다.가장 간단하게 떠오르는 해결 방안은 현재 시간을 파라미터로 받는 것이다. 1234567891011121314151617public class App &#123; public static boolean isAM(LocalTime now) &#123; return method(now); &#125; private static boolean method(LocalTime now) &#123; return method2(now); &#125; private static boolean method2(LocalTime now) &#123; return method3(now); &#125; private static boolean method3(LocalTime now) &#123; return now.isBefore(LocalTime.of(12, 0)); &#125;&#125; 이렇게 하면 현재 시간을 내 마음대로 컨트롤 해서 아래와 같이 항상 통과시키는 테스트를 작성할 수 있다. 123456public class AppTest &#123; @Test public void testAm() &#123; assertTrue(App.isAM(LocalTime.of(11, 59))); &#125;&#125; 하지만 위와 같이 하면 처음 메소드 도입부(isAM)부터 now를 쓸 때까지 계속해서 now를 던지는 의미없는 행위를 반복해야한다. 타임머신을 통해서 나이스하게 문제 해결하기우선 LocalTime, LocalDate, LocalDateTime의 now 메소드를 보면 아래와 같이 구현돼있다. 12345678910111213141516171819public static LocalDateTime now() &#123; return now(Clock.systemDefaultZone());&#125;public static LocalDateTime now(Clock clock) &#123; Objects.requireNonNull(clock, &quot;clock&quot;); final Instant now = clock.instant(); // called once ZoneOffset offset = clock.getZone().getRules().getOffset(now); return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);&#125;public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) &#123; Objects.requireNonNull(offset, &quot;offset&quot;); NANO_OF_SECOND.checkValidValue(nanoOfSecond); long localSecond = epochSecond + offset.getTotalSeconds(); // overflow caught later long localEpochDay = Math.floorDiv(localSecond, SECONDS_PER_DAY); int secsOfDay = (int)Math.floorMod(localSecond, SECONDS_PER_DAY); LocalDate date = LocalDate.ofEpochDay(localEpochDay); LocalTime time = LocalTime.ofNanoOfDay(secsOfDay * NANOS_PER_SECOND + nanoOfSecond); return new LocalDateTime(date, time);&#125; 일단 간단하게만 보면 now를 호출할 때 Clock만 모킹해서 넘겨주면 된다.Clock은 timezone(아마도 UTC일 것 같다.)을 기준으로 date와 time을 제공해준다.기본적으로 Clock을 고정(fix) 시키지 않으면 디폴트로 OS에 설정된 타임존과 시간을 기준으로 현재 시간을 반환한다. 다행히 Clock은 fixed 메서드를 통해 모킹할 수 있고, 모킹한 Clock을 가지고 현재 시간을 구하게 하면 문제는 깔끔하게 해결할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940public class TimeMachine &#123; // 디폴트로 운영체제에 설정된 타임존과 시간을 기준으로 Clock을 반환한다. private static Clock clock = Clock.systemDefaultZone(); // Clock을 모킹할 때 쓸 timezone인데 이 포스트에서는 timezone을 뛰어넘은 모킹은 다루지 않으므로 운영체제에 설정된 UTC 타임존을 사용하겠다. private static ZoneOffset zoneOffset = ZoneOffset.UTC; // 내가 모킹한, 혹은 현재 시간을 가진 Clock 인스턴스를 가지고 현재 시간을 구하게 된다. public static LocalDateTime dateTimeOfNow() &#123; return LocalDateTime.now(clock); &#125; public static LocalTime timeOfNow() &#123; return LocalTime.now(clock); &#125; public static LocalDate dateOfNow() &#123; return LocalDate.now(clock); &#125; // 지정한 날짜/시간으로 현재 시간을 고정시킨다. public static void timeTravelAt(LocalDateTime dateTime)&#123; clock = Clock.fixed(dateTime.atOffset(zoneOffset).toInstant(), zoneOffset); &#125; public static void timeTravelAt(LocalTime time) &#123; // 여기서 중요한 건 시간이고 날짜는 중요치 않다. clock = Clock.fixed(time.atDate(LocalDate.now()).atOffset(zoneOffset).toInstant(), zoneOffset); &#125; public static void timeTravelAt(LocalDate date) &#123; // 여기서 중요한 건 날짜고 시간은 중요치 않다. clock = Clock.fixed(date.atStartOfDay().atOffset(zoneOffset).toInstant(), zoneOffset); &#125; // 모킹한 현재 시간을 다시 원래 현재 시간으로 되돌리는 메소드이다. public static void reset() &#123; clock = Clock.systemDefaultZone(); &#125;&#125; 타임머신이란 이름이 매우 몽환적인 분위기를 풍기는 것 같기도 하고, 참 매력적이다. Clock.fixed 메소드의 예제는 아래를 참고하면 쉽게 이해할 수 있다. 12345678910111213141516public class ClockTest &#123; @Test public void testFixedClock() &#123; // 2011년 1월 1일 1시 1분 0초 LocalDateTime dateTime = LocalDateTime.of(2011, 1, 1, 1, 1); // UTC +09:00 서울/도쿄 기준 2011년 1월 1일 1시 1분 0초 Instant instant = dateTime.atOffset(ZoneOffset.ofHours(9)).toInstant(); // UTC +09:00 2011년 1월 1일 1시 1분 0초를 UTC ±00:00 기준으로 변환한 Clock Clock fixedClock = Clock.fixed(instant, ZoneOffset.ofHours(0)); // UTC +09:00 기준의 시간을 UTC ±00:00 기준의 시간으로 변경했으므로 9시간만 빼면 된다. assertThat(LocalDateTime.now(fixedClock), is(LocalDateTime.of(2010, 12, 31, 16, 1))); &#125;&#125; 그럼 우리가 만든 타임머신을 도대체 어떻게 써먹을지 아래 예제로 알아보자. 1234567891011121314151617public class App &#123; public static boolean isAM() &#123; return method(); &#125; private static boolean method() &#123; return method2(); &#125; private static boolean method2() &#123; return method3(); &#125; private static boolean method3() &#123; return TimeMachine.timeOfNow().isBefore(LocalTime.of(12, 0)); &#125;&#125; 쓸 데 없이 now를 매개변수로 넘기던 것에서 우리가 만든 타임머신에서 지정한 시간으로 현재 시간을 구해오고 있다.시간 여행(timeTravelAt 메소드)을 하지 않았다면 기본적으로 현재 시간을 반환한다. 그럼 시간 여행을 떠날 시간이다. 123456789101112131415public class AppTest &#123; @Test public void testAm() &#123; TimeMachine.timeTravelAt(LocalTime.of(11, 59)); assertTrue(App.isAM()); assertThat(TimeMachine.timeOfNow(), not(LocalTime.now())); TimeMachine.timeTravelAt(LocalTime.of(12, 59)); assertFalse(App.isAM()); assertThat(TimeMachine.timeOfNow(), not(LocalTime.now())); TimeMachine.reset(); assertThat(TimeMachine.timeOfNow(), is(LocalTime.now())); &#125;&#125; 시스템에 의존하지 않고 저렇게 나이스 하게 모킹한 코드를 보고 엄청난 센세이션을 느꼈다.앞으로도 어떠한 요소에도 의존하지 않는 이런 우아한 코드를 지향하도록 노력해야겠다. 참조링크Mocking time in Java 8’s java.time API","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"TDD","slug":"Middle-end/TDD","permalink":"https://perfectacle.github.io/categories/Middle-end/TDD/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Test","slug":"Test","permalink":"https://perfectacle.github.io/tags/Test/"}]},{"title":"(JPA) Embedded Type","slug":"jpa-embedded-type","date":"2018-02-20T00:52:00.000Z","updated":"2022-10-30T08:42:16.675Z","comments":true,"path":"2018/02/20/jpa-embedded-type/","link":"","permalink":"https://perfectacle.github.io/2018/02/20/jpa-embedded-type/","excerpt":"일반적인 테이블 구조의 문제점일반적인 DB 테이블 구조에 맞춰 엔티티를 만들다보면 아래와 같이 만들게 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Entitypublic class Deal &#123; @Id private Long id; @Column private LocalDate saleStartDate; @Column private LocalDate saleEndDate; @Column private int normalPrice; @Column private int discountPrice; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public LocalDate getSaleStartDate() &#123; return saleStartDate; &#125; public void setSaleStartDate(LocalDate saleStartDate) &#123; this.saleStartDate = saleStartDate; &#125; public LocalDate getSaleEndDate() &#123; return saleEndDate; &#125; public void setSaleEndDate(LocalDate saleEndDate) &#123; this.saleEndDate = saleEndDate; &#125; public int getNormalPrice() &#123; return normalPrice; &#125; public void setNormalPrice(int normalPrice) &#123; this.normalPrice = normalPrice; &#125; public int getDiscountPrice() &#123; return discountPrice; &#125; public void setDiscountPrice(int discountPrice) &#123; this.discountPrice = discountPrice; &#125;&#125; 객체 지향 관점에서 봤을 때 판매 시작&#x2F;종료 날짜와 일반가&#x2F;할인가는 전혀 관련이 없는 데이터이다.응집력이 낮은 데이터들끼리 모여있으므로 테이블을 아래와 같이 설계하는 게 더 응집도 높은 엔티티가 될 것 같다.","text":"일반적인 테이블 구조의 문제점일반적인 DB 테이블 구조에 맞춰 엔티티를 만들다보면 아래와 같이 만들게 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Entitypublic class Deal &#123; @Id private Long id; @Column private LocalDate saleStartDate; @Column private LocalDate saleEndDate; @Column private int normalPrice; @Column private int discountPrice; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public LocalDate getSaleStartDate() &#123; return saleStartDate; &#125; public void setSaleStartDate(LocalDate saleStartDate) &#123; this.saleStartDate = saleStartDate; &#125; public LocalDate getSaleEndDate() &#123; return saleEndDate; &#125; public void setSaleEndDate(LocalDate saleEndDate) &#123; this.saleEndDate = saleEndDate; &#125; public int getNormalPrice() &#123; return normalPrice; &#125; public void setNormalPrice(int normalPrice) &#123; this.normalPrice = normalPrice; &#125; public int getDiscountPrice() &#123; return discountPrice; &#125; public void setDiscountPrice(int discountPrice) &#123; this.discountPrice = discountPrice; &#125;&#125; 객체 지향 관점에서 봤을 때 판매 시작&#x2F;종료 날짜와 일반가&#x2F;할인가는 전혀 관련이 없는 데이터이다.응집력이 낮은 데이터들끼리 모여있으므로 테이블을 아래와 같이 설계하는 게 더 응집도 높은 엔티티가 될 것 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entitypublic class Period &#123; @Id private Long id; @OneToOne private Deal deal; @Column private LocalDate saleStartDate; @Column private LocalDate saleEndDate; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Deal getDeal() &#123; return deal; &#125; public void setDeal(Deal deal) &#123; this.deal = deal; &#125; public LocalDate getSaleStartDate() &#123; return saleStartDate; &#125; public void setSaleStartDate(LocalDate saleStartDate) &#123; this.saleStartDate = saleStartDate; &#125; public LocalDate getSaleEndDate() &#123; return saleEndDate; &#125; public void setSaleEndDate(LocalDate saleEndDate) &#123; this.saleEndDate = saleEndDate; &#125;&#125; 응집도가 높은(서로 관련이 있는) 판매 시작&#x2F;종료 날짜를 포함하는 Period라는 테이블을 따로 파서 엔티티로 만들고,외래키를 사용하여 Deal 테이블과 매핑하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Entitypublic class Price &#123; @Id private Long id; @OneToOne private Deal deal; @Column private int normalPrice; @Column private int discountPrice; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Deal getDeal() &#123; return deal; &#125; public void setDeal(Deal deal) &#123; this.deal = deal; &#125; public int getNormalPrice() &#123; return normalPrice; &#125; public void setNormalPrice(int normalPrice) &#123; this.normalPrice = normalPrice; &#125; public int getDiscountPrice() &#123; return discountPrice; &#125; public void setDiscountPrice(int discountPrice) &#123; this.discountPrice = discountPrice; &#125;&#125; 응집도가 높은 일반가&#x2F;할인가를 포함하는 Period라는 테이블을 따로 파서 엔티티로 만들고,외래키를 사용하여 Deal 테이블과 매핑하였다. 좀 더 객체지향 관점에서 바라본 Deal 엔티티는 아래와 같이 변경될 것이다. 1234567891011121314151617181920212223242526272829303132333435@Entitypublic class Deal &#123; @Id private Long id; @OneToOne(mappedBy = &quot;deal&quot;) private Period period; @OneToOne(mappedBy = &quot;deal&quot;) private Price price; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Period getPeriod() &#123; return period; &#125; public void setPeriod(Period period) &#123; this.period = period; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125;&#125; 외래키는 deal 테이블의 id로 잡아서 각각 period, price 테이블에 뒀다고 가정한다.위와 같이 테이블을 일일이 쪼개기란 매우 귀찮은 일이다.그리고 조인을 하기 때문에 쪼개기 전보다 성능상 좋지 않은 점도 많다. Embedded Type이럴 때 쓰는 게 바로 Embedded Type이다.백문이 불여일견, 코드로 바로 보자. 123456789101112131415161718192021222324@Embeddablepublic class Period &#123; @Column private LocalDate saleStartDate; @Column private LocalDate saleEndDate; public LocalDate getSaleStartDate() &#123; return saleStartDate; &#125; public void setSaleStartDate(LocalDate saleStartDate) &#123; this.saleStartDate = saleStartDate; &#125; public LocalDate getSaleEndDate() &#123; return saleEndDate; &#125; public void setSaleEndDate(LocalDate saleEndDate) &#123; this.saleEndDate = saleEndDate; &#125;&#125; EmbeddedType으로 응집도가 높은 판매 시작&#x2F;종료 날짜를 정의하였다.EmbeddedType을 정의할 클래스에 @Embeddable 어노테이션을 달아줘야하고,엔티티가 아니기 때문에 식별자나 조인을 위한 엔티티가 없어도 된다. 123456789101112131415161718192021222324@Embeddablepublic class Price &#123; @Column private int normalPrice; @Column private int discountPrice; public int getNormalPrice() &#123; return normalPrice; &#125; public void setNormalPrice(int normalPrice) &#123; this.normalPrice = normalPrice; &#125; public int getDiscountPrice() &#123; return discountPrice; &#125; public void setDiscountPrice(int discountPrice) &#123; this.discountPrice = discountPrice; &#125;&#125; 마찬가지로 EmbeddedType으로 응집도가 높은 일반가&#x2F;할인가를 정의하였다. 1234567891011121314151617181920212223242526272829303132333435@Entitypublic class DealEmbedded &#123; @Id private Long id; @Embedded private Period period; @Embedded private Price price; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Period getPeriod() &#123; return period; &#125; public void setPeriod(Period period) &#123; this.period = period; &#125; public Price getPrice() &#123; return price; &#125; public void setPrice(Price price) &#123; this.price = price; &#125;&#125; 필드를 일일이 나열하는 대신 응집도가 높은 EmbeddedType을 사용하면 되고,가져다 쓸 때는 @Embedded 어노테이션을 달아주면 된다.EmbeddedType을 null로 세팅하면 관련된 필드들이 모두 null로 세팅돼서 DB에 저장된다. EmbeddedType을 쓰면 테이블을 따로 만들어주지 않아도 되고, 조인을 사용하지 않으니 성능 상 이슈도 없고,응집도가 높은 클래스끼리 따로 빼놨으니 좀 더 보기 좋은(?) 형태가 됐다고 말할 수 있다. 엔티티 vs 값 타입@Entity가 안 붙은 걸 전부 값 타입이라고 말할 수 있다.둘의 차이점은 영속성 컨텍스트에서 추적이 가능하냐, 가능하지 않느냐이다.엔티티는 식별자(@Id가 붙은 필드)가 존재하여 엔티티의 변화 추적이 가능하지만,값 타입의 경우에는 해당 값이 바뀌어버리면 식별자를 가지고 있는 게 아니라 추적이 불가능하다.따라서 값 타입의 경우에는 엔티티에 의존적이고, 변화를 감지해야하는 경우에는 엔티티로 만들어야할 것이다. 간단하게 값 타입에 대해 정리하자면 다음과 같다. 기본 값 타입엄밀히 말하자면 primitive type(int, long, boolean 등등) 만을 뜻하는 것은 아니다.불변하는 타입(Integer, String 등등)까지 포함한 경우를 말한다. Embedded 타입위에서 많이 설명했다. 값 타입 컬렉션1과 2 타입을 컬렉션(List, Set, Map 등등)으로 가지고 있는 경우를 말한다.많이 쓸까… 싶기도 하고 나중에 자세히 알아봐야겠다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"DB","slug":"DB","permalink":"https://perfectacle.github.io/tags/DB/"}]},{"title":"(Jackson) LocalDate, LocalTime, LocalDateTime 뽀개기 - Serialize","slug":"jackson-local-date-time-serialize","date":"2018-01-16T10:54:25.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2018/01/16/jackson-local-date-time-serialize/","link":"","permalink":"https://perfectacle.github.io/2018/01/16/jackson-local-date-time-serialize/","excerpt":"잭슨은 JSON -&gt; Java 클래스로 Deserialize, Java 클래스 -&gt; JSON으로 Serialize 할 때 매우 유용한 라이브러리다. 하지만 잭슨이 나온 이후에 자바 8이 나왔는지 모르겠는데 LocalDate, LocalTime, LocalDateTime 등등의 클래스를 기본적으로 깔끔하게 처리해주지 못한다.따라서 이번에는 어렵지는 않지만 새로 프로젝트 구성할 때마다 매번 까먹어서 찾아 헤매던 케이스들을 정리해봤다.또한 예제의 설명은 스프링 부트를 기준으로 설명하겠다. 우선 Deserialize를 안 본 사람은 해당 내용에서 이어지는 포스트이기 때문에 보고 오도록 하자. 3줄 요약","text":"잭슨은 JSON -&gt; Java 클래스로 Deserialize, Java 클래스 -&gt; JSON으로 Serialize 할 때 매우 유용한 라이브러리다. 하지만 잭슨이 나온 이후에 자바 8이 나왔는지 모르겠는데 LocalDate, LocalTime, LocalDateTime 등등의 클래스를 기본적으로 깔끔하게 처리해주지 못한다.따라서 이번에는 어렵지는 않지만 새로 프로젝트 구성할 때마다 매번 까먹어서 찾아 헤매던 케이스들을 정리해봤다.또한 예제의 설명은 스프링 부트를 기준으로 설명하겠다. 우선 Deserialize를 안 본 사람은 해당 내용에서 이어지는 포스트이기 때문에 보고 오도록 하자. 3줄 요약 Serialize 한 형태가 요상하니 jackson-datatype-jsr310을 Dependency에 추가해두자. 모든 필드마다 @JsonFormat 어노테이션 달아주기 귀찮으니 LocalDate, LocalTime, LocalDateTime 등등에 대한 기본 Custom Serializer를 만들어주자. spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false를 쓰면 내용이 좀 상세하게 나오니 @JsonFormat을 애용하자. Serialize우선 아래와 같이 api를 만들자. 1234567@RestControllerpublic class Controller &#123; @GetMapping(&quot;/&quot;) public DateType get(DateType dateType) &#123; return new DateType(); &#125;&#125; 이제 JSON으로 Serialize할 클래스를 만들자. 1234567891011121314151617181920212223242526272829public class DateType &#123; private LocalDate date = LocalDate.now(); private LocalTime time = LocalTime.now(); private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 그럼 아래와 같이 응답이 드럽게(?) 온다. 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;date&quot;: &#123; &quot;year&quot;: 2018, &quot;month&quot;: &quot;JANUARY&quot;, &quot;dayOfMonth&quot;: 16, &quot;dayOfWeek&quot;: &quot;TUESDAY&quot;, &quot;era&quot;: &quot;CE&quot;, &quot;dayOfYear&quot;: 16, &quot;leapYear&quot;: false, &quot;monthValue&quot;: 1, &quot;chronology&quot;: &#123; &quot;id&quot;: &quot;ISO&quot;, &quot;calendarType&quot;: &quot;iso8601&quot; &#125; &#125;, &quot;time&quot;: &#123; &quot;hour&quot;: 11, &quot;minute&quot;: 4, &quot;second&quot;: 9, &quot;nano&quot;: 754000000 &#125;, &quot;dateTime&quot;: &#123; &quot;year&quot;: 2018, &quot;month&quot;: &quot;JANUARY&quot;, &quot;dayOfMonth&quot;: 16, &quot;dayOfWeek&quot;: &quot;TUESDAY&quot;, &quot;dayOfYear&quot;: 16, &quot;monthValue&quot;: 1, &quot;hour&quot;: 11, &quot;minute&quot;: 4, &quot;second&quot;: 9, &quot;nano&quot;: 754000000, &quot;chronology&quot;: &#123; &quot;id&quot;: &quot;ISO&quot;, &quot;calendarType&quot;: &quot;iso8601&quot; &#125; &#125;&#125; 혹시 @DateTimeFormat을 안 붙여서 그런가…?? 1234567891011121314151617181920212223242526272829303132public class DateType &#123; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date = LocalDate.now(); @DateTimeFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time = LocalTime.now(); @DateTimeFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 그래도 응답오는 건 똑같다…이번엔 @JsonFormat으로 바꿔보자. 1234567891011121314151617181920212223242526272829303132public class DateType &#123; @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date = LocalDate.now(); @JsonFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time = LocalTime.now(); @JsonFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 그래도 똑같이 응답이 온다…아마 잭슨이 LocalDate 보다 먼저 나와서 대응을 제대로 못하는 거 같다. JSR-310 (Java Specification Request - Date and Time API)이전 포스트에서 봤다 싶이 JSR-310을 잭슨에서 대응(?)한 Jackson Datatype: JSR310을 Dependency에 추가해주자.그리고 다시 java 클래스에는 어노테이션을 한 번 없애보자.그리고 다시 요청을 보내보면 아래와 같이 응답이 온다. 12345678910111213141516171819202122&#123; &quot;date&quot;: [ 2018, 1, 16 ], &quot;time&quot;: [ 11, 19, 9, 274000000 ], &quot;dateTime&quot;: [ 2018, 1, 16, 11, 19, 9, 274000000 ]&#125; 아까 보다는 보기 깔끔해졌지만 저렇게 배열로 담겨서 오는 건 우리가 원하는 형태가 아니다.@DateTimeFormat을 달아보면 위와 똑같은 응답이다…그렇다면 @JsonFormat을 달아보자. 1234567891011121314151617181920212223242526272829303132public class DateType &#123; @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date = LocalDate.now(); @JsonFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time = LocalTime.now(); @JsonFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 그럼 우리가 원하는 형태로 아래와 같이 응답이 온다. 12345&#123; &quot;date&quot;: &quot;2018-01-16&quot;, &quot;time&quot;: &quot;11:21:10&quot;, &quot;dateTime&quot;: &quot;2018-01-16 11:21:10&quot;&#125; @JsonFormat을 일일이 달아주기 귀찮은 경우에는 Custom Serializer를 만들기 전에 아래 내용도 고려해보자.Spring Boot의 profile에 아래 내용을 추가해주자. 1spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false 그리고 DateType 클래스에서 @JsonFormat 어노테이션을 제거하면 아래와 같이 응답이 온다. 12345&#123; &quot;date&quot;: &quot;2018-01-16&quot;, &quot;time&quot;: &quot;11:23:02.215&quot;, &quot;dateTime&quot;: &quot;2018-01-16T11:23:02.215&quot;&#125; 아무런 어노테이션을 안 썼을 때보다는 볼만하지만 그래도 저렇게 상세한 정보까지는 원치 않을 것이다.@DateTimeFormat 어노테이션을 달아도 마찬가지고, @JsonFormat 어노테이션을 달면 원하는 형태로 날아오지만 그럼 profile에 추가하나 마찬가지다.이 속성은 그냥 저렇게 상세한 시각이 필요할 때만 쓰면 될 거 같다. Custom Serializer이제 저번 포스트에 Custom Deserializer를 만들었 듯이 이번에는 Custom Serializer를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435363738@Configurationpublic class JacksonConfig &#123; @Bean public Module jsonMapperJava8DateTimeModule() &#123; SimpleModule module = new SimpleModule(); module.addSerializer(LocalDate.class, new JsonSerializer&lt;LocalDate&gt;() &#123; @Override public void serialize( LocalDate localDate, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; jsonGenerator.writeString(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;).format(localDate)); &#125; &#125;); module.addSerializer(LocalTime.class, new JsonSerializer&lt;LocalTime&gt;() &#123; @Override public void serialize( LocalTime localTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; jsonGenerator.writeString(DateTimeFormatter.ofPattern(&quot;kk:mm:ss&quot;).format(localTime)); &#125; &#125;); module.addSerializer(LocalDateTime.class, new JsonSerializer&lt;LocalDateTime&gt;() &#123; @Override public void serialize( LocalDateTime localDateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123; jsonGenerator.writeString(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd kk:mm:ss&quot;).format(localDateTime)); &#125; &#125;); return module; &#125;&#125; 이렇게 했을 때 아래와 같은 요소들이 없어도 우리가 원하는 대로 잘 작동한다. jackson-datatype-jsr310 spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS&#x3D;false @DateTimeFormat, @JsonFormat 하지만 특정 필드에 대해서는 다르게 Serialize 해야할 수 있으니 jackson-datatype-jsr310은 살려두자.이제 특정 필드에만 다른 Serializer를 적용해보자. 1234567891011121314151617181920212223242526272829303132public class DateType &#123; @JsonSerialize(using = LocalDateSerializer.class) private LocalDate date = LocalDate.now(); @JsonSerialize(using = LocalTimeSerializer.class) private LocalTime time = LocalTime.now(); @JsonSerialize(using = LocalDateTimeSerializer.class) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 사실상 @DateTimeFormat 어노테이션은 위에서 있으나 마나 한 사실을 알게 되었다.이렇게 했을 땐 잭슨의 기본 LocalDateTime Serializer를 쓰기 때문에 아래와 같이 나온다. 12345678910111213141516171819202122&#123; &quot;date&quot;: [ 2018, 1, 16 ], &quot;time&quot;: [ 11, 48, 25, 189000000 ], &quot;dateTime&quot;: [ 2018, 1, 16, 11, 48, 25, 189000000 ]&#125; profile에 spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false을 넣으면 아래와 같은 내용을 받게 된다. 12345&#123; &quot;date&quot;: &quot;2018-01-16&quot;, &quot;time&quot;: &quot;11:50:19.917&quot;, &quot;dateTime&quot;: &quot;2018-01-16T11:50:19.917&quot;&#125; 좀 더 깔끔하게 출력하기 위해 @DateTimeFormat을 써보자. 1234567891011121314151617181920212223242526272829303132333435public class DateType &#123; @JsonSerialize(using = LocalDateSerializer.class) @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date = LocalDate.now(); @JsonSerialize(using = LocalTimeSerializer.class) @DateTimeFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time = LocalTime.now(); @JsonSerialize(using = LocalDateTimeSerializer.class) @DateTimeFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 요청 응답 오는 건 전혀 다르지 않다. 완전 무쓸모넹… ㅠㅠ그럼 profile에서 spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false을 빼고 @JsonFormat 어노테이션으로 바꿔보자. 1234567891011121314151617181920212223242526272829303132333435public class DateType &#123; @JsonSerialize(using = LocalDateSerializer.class) @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date = LocalDate.now(); @JsonSerialize(using = LocalTimeSerializer.class) @JsonFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time = LocalTime.now(); @JsonSerialize(using = LocalDateTimeSerializer.class) @JsonFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime = LocalDateTime.now(); public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125;&#125; 그럼 우리가 원하는대로 응답이 온다. 12345&#123; &quot;date&quot;: &quot;2018-01-16&quot;, &quot;time&quot;: &quot;11:54:17&quot;, &quot;dateTime&quot;: &quot;2018-01-16 11:54:17&quot;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"JSON","slug":"JSON","permalink":"https://perfectacle.github.io/tags/JSON/"}]},{"title":"(Jackson) LocalDate, LocalTime, LocalDateTime 뽀개기 - Deserialize","slug":"jackson-local-date-time-deserialize","date":"2018-01-15T23:24:07.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2018/01/15/jackson-local-date-time-deserialize/","link":"","permalink":"https://perfectacle.github.io/2018/01/15/jackson-local-date-time-deserialize/","excerpt":"잭슨은 JSON -&gt; Java 클래스로 Deserialize, Java 클래스 -&gt; JSON으로 Serialize 할 때 매우 유용한 라이브러리다. 하지만 잭슨이 나온 이후에 자바 8이 나왔는지 모르겠는데 LocalDate, LocalTime, LocalDateTime 등등의 클래스를 기본적으로 깔끔하게 처리해주지 못한다.따라서 이번에는 어렵지는 않지만 새로 프로젝트 구성할 때마다 매번 까먹어서 찾아 헤매던 케이스들을 정리해봤다.또한 예제의 설명은 스프링 부트를 기준으로 설명하겠다. 이 글을 본 다음에는 후속작인 Serialize를 보도록 하자. 3줄 요약","text":"잭슨은 JSON -&gt; Java 클래스로 Deserialize, Java 클래스 -&gt; JSON으로 Serialize 할 때 매우 유용한 라이브러리다. 하지만 잭슨이 나온 이후에 자바 8이 나왔는지 모르겠는데 LocalDate, LocalTime, LocalDateTime 등등의 클래스를 기본적으로 깔끔하게 처리해주지 못한다.따라서 이번에는 어렵지는 않지만 새로 프로젝트 구성할 때마다 매번 까먹어서 찾아 헤매던 케이스들을 정리해봤다.또한 예제의 설명은 스프링 부트를 기준으로 설명하겠다. 이 글을 본 다음에는 후속작인 Serialize를 보도록 하자. 3줄 요약 모든 필드마다 @JsonFormat 어노테이션 달아주기 귀찮으니 LocalDate, LocalTime, LocalDateTime 등등에 대한 기본 Custom Deserializer를 만들어주자. 특정 필드는 잭슨의 기본 Deserializer를 써야할 수도 있으니 jackson-datatype-jsr310을 Dependency에 추가해두자. @DateTimeFormat은 제대로 안 먹히는 필드도 있으니 @JsonFormat을 애용하도록 하자. Parameter파라미터로 데이터를 각각 받을 때는 JSON 데이터를 받는 게 아니므로 Jackson의 Deserialize와는 무관하게 작동한다.우선 파라미터로 데이터를 받는 api를 만들어보자. 12345@RestControllerpublic class Controller &#123; @GetMapping(&quot;/&quot;) public void get(@RequestParam LocalDate date, @RequestParam LocalTime time, @RequestParam LocalDateTime dateTime) &#123;&#125;&#125; GET /?date=2011-11-11&amp;time=11:11:11&amp;dateTime=2017-11-11 11:11:11으로 요청을 날려보면 아래와 같은 응답을 받을 수 있다. 12345678&#123; &quot;timestamp&quot;: 1516027261943, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.web.method.annotation.MethodArgumentTypeMismatchException&quot;, &quot;message&quot;: &quot;Failed to convert value of type &#x27;java.lang.String&#x27; to required type &#x27;java.time.LocalDate&#x27;; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [@org.springframework.web.bind.annotation.RequestParam java.time.LocalDate] for value &#x27;2011-11-11&#x27;; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [2011-11-11]&quot;, &quot;path&quot;: &quot;/get&quot;&#125; 파라미터로 넘긴 값들을 String으로 인식해서 TypeMismatchException이 발생했다.이럴 땐 @DateTimeFormat 어노테이션을 파라미터에 달아주면 된다. 12345678910111213@RestControllerpublic class Controller &#123; @GetMapping(&quot;/&quot;) public DateType get(@RequestParam @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) LocalDate date, @RequestParam @DateTimeFormat(pattern = &quot;kk:mm:ss&quot;) LocalTime time, @RequestParam @DateTimeFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) LocalDateTime dateTime) &#123;&#125;&#125; DeserializeParameter(Command 객체)그럼 파라미터로 데이터를 받으면서 잭슨의 Deserializer를 태울려면 어떻게 해야할까?아래와 같이 컨트롤러를 수정해주면 된다. 123456@RestController@RequestMapping(&quot;/&quot;)public class Controller &#123; @GetMapping public void get(DateType dateType) &#123;&#125;&#125; @RequestParam으로 받던 데이터들을 하나의 클래스로 퉁쳤다.what is the command object in spring framework에 따르면 Command Object는 그냥 VO&#x2F;POJO&#x2F;JavaBean&#x2F;기타 등등을 일컫는 것 같다.이제 그 커맨드 객체를 만들어보자. 1234567891011121314151617181920212223242526272829303132333435public class DateType &#123; private LocalDate date; private LocalTime time; private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125;&#125; GET /?date=2011-11-11&amp;time=11:11:11&amp;dateTime=2017-11-11 11:11:11으로 요청을 날려보면 아래와 같은 응답을 받게 된다. 12345678&#123; &quot;timestamp&quot;: 1516036778600, &quot;status&quot;: 500, &quot;error&quot;: &quot;Internal Server Error&quot;, &quot;exception&quot;: &quot;org.springframework.beans.BeanInstantiationException&quot;, &quot;message&quot;: &quot;Failed to instantiate [com.example.demo.DateType]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.example.demo.DateType.&lt;init&gt;()&quot;, &quot;path&quot;: &quot;/&quot;&#125; 커맨드 객체로 받는 클래스에는 무조건 기본 생성자가 있어야한다.하지만 위에 매개변수를 3개 받는 생성자를 만들었기에 아무런 매개변수도 받지 않는 생성자를 만들어야한다. 12345678910111213141516171819202122232425262728293031323334353637public class DateType &#123; private LocalDate date; private LocalTime time; private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125; public DateType() &#123;&#125;&#125; 다시 동일한 요청을 보내면 아래와 같은 응답을 받게 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; &quot;timestamp&quot;: 1516036927928, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.validation.BindException&quot;, &quot;errors&quot;: [ &#123; &quot;codes&quot;: [ &quot;typeMismatch.dateType.date&quot;, &quot;typeMismatch.date&quot;, &quot;typeMismatch.java.time.LocalDate&quot;, &quot;typeMismatch&quot; ], &quot;arguments&quot;: [ &#123; &quot;codes&quot;: [ &quot;dateType.date&quot;, &quot;date&quot; ], &quot;arguments&quot;: null, &quot;defaultMessage&quot;: &quot;date&quot;, &quot;code&quot;: &quot;date&quot; &#125; ], &quot;defaultMessage&quot;: &quot;Failed to convert property value of type &#x27;java.lang.String&#x27; to required type &#x27;java.time.LocalDate&#x27; for property &#x27;date&#x27;; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.LocalDate] for value &#x27;2011-11-11&#x27;; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [2011-11-11]&quot;, &quot;objectName&quot;: &quot;dateType&quot;, &quot;field&quot;: &quot;date&quot;, &quot;rejectedValue&quot;: &quot;2011-11-11&quot;, &quot;bindingFailure&quot;: true, &quot;code&quot;: &quot;typeMismatch&quot; &#125;, &#123; &quot;codes&quot;: [ &quot;typeMismatch.dateType.dateTime&quot;, &quot;typeMismatch.dateTime&quot;, &quot;typeMismatch.java.time.LocalDateTime&quot;, &quot;typeMismatch&quot; ], &quot;arguments&quot;: [ &#123; &quot;codes&quot;: [ &quot;dateType.dateTime&quot;, &quot;dateTime&quot; ], &quot;arguments&quot;: null, &quot;defaultMessage&quot;: &quot;dateTime&quot;, &quot;code&quot;: &quot;dateTime&quot; &#125; ], &quot;defaultMessage&quot;: &quot;Failed to convert property value of type &#x27;java.lang.String&#x27; to required type &#x27;java.time.LocalDateTime&#x27; for property &#x27;dateTime&#x27;; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.LocalDateTime] for value &#x27;2017-11-11 11:11:11&#x27;; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [2017-11-11 11:11:11]&quot;, &quot;objectName&quot;: &quot;dateType&quot;, &quot;field&quot;: &quot;dateTime&quot;, &quot;rejectedValue&quot;: &quot;2017-11-11 11:11:11&quot;, &quot;bindingFailure&quot;: true, &quot;code&quot;: &quot;typeMismatch&quot; &#125;, &#123; &quot;codes&quot;: [ &quot;typeMismatch.dateType.time&quot;, &quot;typeMismatch.time&quot;, &quot;typeMismatch.java.time.LocalTime&quot;, &quot;typeMismatch&quot; ], &quot;arguments&quot;: [ &#123; &quot;codes&quot;: [ &quot;dateType.time&quot;, &quot;time&quot; ], &quot;arguments&quot;: null, &quot;defaultMessage&quot;: &quot;time&quot;, &quot;code&quot;: &quot;time&quot; &#125; ], &quot;defaultMessage&quot;: &quot;Failed to convert property value of type &#x27;java.lang.String&#x27; to required type &#x27;java.time.LocalTime&#x27; for property &#x27;time&#x27;; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.lang.String] to type [java.time.LocalTime] for value &#x27;11:11:11&#x27;; nested exception is java.lang.IllegalArgumentException: Parse attempt failed for value [11:11:11]&quot;, &quot;objectName&quot;: &quot;dateType&quot;, &quot;field&quot;: &quot;time&quot;, &quot;rejectedValue&quot;: &quot;11:11:11&quot;, &quot;bindingFailure&quot;: true, &quot;code&quot;: &quot;typeMismatch&quot; &#125; ], &quot;message&quot;: &quot;Validation failed for object=&#x27;dateType&#x27;. Error count: 3&quot;, &quot;path&quot;: &quot;/&quot;&#125; 역시나 String으로 인식해서 발생하는 문제다.@DateTimeFormat을 사용하자. 12345678910111213141516171819202122232425262728293031323334353637383940public class DateType &#123; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date; @DateTimeFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time; @DateTimeFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125; public DateType() &#123;&#125;&#125; 이제 다시 GET 요청을 보내면 정상적으로 Deserialize 돼서 오류가 나지 않는다. Body (JSON)Requset Body로 보낼 객체는 위에서 만든 커맨드 객체를 재활용해서 api를 만들어보자. 12345@RestControllerpublic class Controller &#123; @PostMapping(&quot;/&quot;) public void post(@RequestBody DateType dateType) &#123;&#125;&#125; POST / 12345&#123; &quot;date&quot;: &quot;2011-11-11&quot;, &quot;time&quot;: &quot;11:11:11&quot;, &quot;dateTime&quot;: &quot;2011-11-11 11:11:11&quot;&#125; 으로 요청을 날려보면 아래와 같은 응답을 받을 수 있다. 12345678&#123; &quot;timestamp&quot;: 1516031758629, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.http.converter.HttpMessageNotReadableException&quot;, &quot;message&quot;: &quot;JSON parse error: Can not construct instance of java.time.LocalDate: no String-argument constructor/factory method to deserialize from String value (&#x27;2011-11-11&#x27;); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of java.time.LocalDate: no String-argument constructor/factory method to deserialize from String value (&#x27;2011-11-11&#x27;)\\n at [Source: java.io.PushbackInputStream@405079af; line: 2, column: 10] (through reference chain: com.example.demo.DateType[\\&quot;date\\&quot;])&quot;, &quot;path&quot;: &quot;/&quot;&#125; 웬일인지 모르겠지만 문제가 발생한다. JSR-310 (Java Specification Request - Date and Time API)Spring Jpa java8 date (LocalDateTime) 와 Jackson을 참고했을 때Java8이 나오기 전에는 Date 클래스가 좀 허접했다고 한다.그 이전에는 Joda Time이라는 라이브러리를 사용했다고 한다.이 JSR-310 스펙은 조다 타임의 창시자도 같이 제정했다고 하니 아주 믿을만(?)한 스펙인 거 같다.이 스펙의 구현체가 LocalDate, LocalTime, LocalDateTime 등등인 것 같다. 잭슨에서 제대로 저런 날짜&#x2F;시간 관련 클래스를 (De)Serialize 하려면 Jackson Datatype: JSR310을 Dependency에 추가해줘야한다.Maven이나 Gradle에 추가해주자. 그리고 나서 다시 서버를 띄워보면 다음과 같은 응답이 날아온다. 12345678&#123; &quot;timestamp&quot;: 1516032507565, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.http.converter.HttpMessageNotReadableException&quot;, &quot;message&quot;: &quot;JSON parse error: Can not deserialize value of type java.time.LocalDateTime from String \\&quot;2011-11-11 11:11:11\\&quot;: Text &#x27;2011-11-11 11:11:11&#x27; could not be parsed at index 10; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize value of type java.time.LocalDateTime from String \\&quot;2011-11-11 11:11:11\\&quot;: Text &#x27;2011-11-11 11:11:11&#x27; could not be parsed at index 10\\n at [Source: java.io.PushbackInputStream@c126518; line: 4, column: 14] (through reference chain: com.example.demo.DateType[\\&quot;dateTime\\&quot;])&quot;, &quot;path&quot;: &quot;/&quot;&#125; 어떤 이유에선지 LocalDateTime만 제대로 Deserialize 못 하고 있다.아래와 같이 request body를 수정해주면 된다. 12345&#123; &quot;date&quot;: &quot;2011-11-11&quot;, &quot;time&quot;: &quot;11:11:11&quot;, &quot;dateTime&quot;: &quot;2011-11-11T11:11:11&quot;&#125; 하지만 날짜와 시간 사이에 존재하는 저 T가 꼴불견이다.저 T를 날리기 위해서는 잭슨의 어노테이션인 @JsonFormat을 쓰면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142public class DateType &#123; @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) private LocalDate date; @JsonFormat(pattern = &quot;kk:mm:ss&quot;) private LocalTime time; @JsonFormat(pattern = &quot;yyyy-MM-dd kk:mm:ss&quot;) private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125; public DateType() &#123; this.date = LocalDate.now(); &#125;&#125; 이렇게 하고 T를 뺀 상태로 응답을 보내면 아주 잘 날아온다. Custom Deserializer하지만 이렇게 되면 날짜&#x2F;시간 클래스에게 일일이 어노테이션을 달아줘야하니 귀챠니즘이 상당해진다.이럴 때 잭슨의 기본 Deserializer를 오버라이딩한 Custom Deserializer를 사용하게 설정을 수정해주면 된다. 123456789101112131415161718192021222324252627282930@Configurationpublic class JacksonConfig &#123; @Bean public Module jsonMapperJava8DateTimeModule() &#123; SimpleModule module = new SimpleModule(); module.addDeserializer(LocalDate.class, new JsonDeserializer&lt;LocalDate&gt;() &#123; @Override public LocalDate deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123; return LocalDate.parse(jsonParser.getValueAsString(), DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)); &#125; &#125;); module.addDeserializer(LocalTime.class, new JsonDeserializer&lt;LocalTime&gt;() &#123; @Override public LocalTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123; return LocalTime.parse(jsonParser.getValueAsString(), DateTimeFormatter.ofPattern(&quot;kk:mm:ss&quot;)); &#125; &#125;); module.addDeserializer(LocalDateTime.class, new JsonDeserializer&lt;LocalDateTime&gt;() &#123; @Override public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123; return LocalDateTime.parse(jsonParser.getValueAsString(), DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd kk:mm:ss&quot;)); &#125; &#125;); return module; &#125;&#125; 그리고 DateType 클래스에서 @JsonFormat 어노테이션을 빼주자. 123456789101112131415161718192021222324252627282930313233343536373839public class DateType &#123; private LocalDate date; private LocalTime time; private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125; public DateType() &#123; this.date = LocalDate.now(); &#125;&#125; 사실 Custom Deserializer를 쓰면 jackson-datatype-jsr310은 필요 없긴 하다.(하지만 나중에 Serialize를 위해서는 또 필요하기 때문에 지우진 말자.)이렇게 하면 이제 @DateTimeFormat이나 @JsonFormat은 무력화되는 것 같다. 만약 특정 필드만 오버라이딩한 Deserializer를 안 쓰려면 아래와 같이 하면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class DateType &#123; private LocalDate date; private LocalTime time; @JsonDeserialize(using = LocalDateTimeDeserializer.class) @JsonFormat(pattern = &quot;yyyy/MM/dd kk:mm:ss&quot;) private LocalDateTime dateTime; public LocalDate getDate() &#123; return date; &#125; public void setDate(LocalDate date) &#123; this.date = date; &#125; public LocalTime getTime() &#123; return time; &#125; public void setTime(LocalTime time) &#123; this.time = time; &#125; public LocalDateTime getDateTime() &#123; return dateTime; &#125; public void setDateTime(LocalDateTime dateTime) &#123; this.dateTime = dateTime; &#125; public DateType(LocalDate date, LocalTime time, LocalDateTime dateTime) &#123; this.date = date; this.time = time; this.dateTime = dateTime; &#125; public DateType() &#123; this.date = LocalDate.now(); &#125;&#125; @JsonFormat 대신에 @DateTimeFormat을 쓰면 아무런 효과가 없다. 이제 아래와 같이 요청을 보내보자.POST / 12345&#123; &quot;date&quot;: &quot;2011-11-11&quot;, &quot;time&quot;: &quot;11:11:11&quot;, &quot;dateTime&quot;: &quot;2011/11/11 11:11:11&quot;&#125; 정상적으로 요청이 들어갔다면 성공한 것이다. 이제는 Serialize를 보도록 하자.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"JSON","slug":"JSON","permalink":"https://perfectacle.github.io/tags/JSON/"}]},{"title":"(JPA) Entity와 EntityManager와 EntityManagerFactory","slug":"jpa-entity-manager-factory","date":"2018-01-14T15:24:15.000Z","updated":"2022-10-30T08:42:16.675Z","comments":true,"path":"2018/01/14/jpa-entity-manager-factory/","link":"","permalink":"https://perfectacle.github.io/2018/01/14/jpa-entity-manager-factory/","excerpt":"이미지 출처: &lt;박상문의 Photo &amp; Essay&gt;평양 육아원의 모습 EntityDB의 테이블과 매칭이 되는 개념이라고 보면 된다.그렇다면 왜 이름이 Table이 아니라 Entity일까…? 만약 DB에 member라는 테이블이 있고, 해당 테이블의 스키마가 아래와 같다고 해보자.","text":"이미지 출처: &lt;박상문의 Photo &amp; Essay&gt;평양 육아원의 모습 EntityDB의 테이블과 매칭이 되는 개념이라고 보면 된다.그렇다면 왜 이름이 Table이 아니라 Entity일까…? 만약 DB에 member라는 테이블이 있고, 해당 테이블의 스키마가 아래와 같다고 해보자. 123456CREATE TABLE `Member` ( `id` BIGINT(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) 그렇다면 엔티티는 아래와 같이 만들 수 있다. 12345678910111213141516171819202122232425262728293031323334353637@Entitypublic class Member &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(nullable = false) private long id; @Column(nullable = false) private String name; @Column(nullable = false) private int age; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 기본적으로 JPA는 모든 필드를 불러오게 끔 구현돼있다.하지만 모든 케이스에서 id, name, age 필드를 다 다루지 않는다.어떤 경우에는 id, name 필드만 다루는 경우도 있을 수 있다.그런 경우에 대비해서 다음과 같이 엔티티 클래스를 하나 더 만들 수 있다. 123456789101112131415161718192021222324252627@Entity@Table(name = &quot;Member&quot;)public class MemberOnlyName &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(nullable = false) private long id; @Column(nullable = false) private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 따라서 테이블은 한 개지만, 엔티티는 경우에 따라서 여러 개를 만들 수 있다.혹은 JPA를 좀 더 잘 다룬다면 하나의 엔티티로도 충분히 커버를 할 수 있기도 하다. EntityManager위에 언급한 엔티티를 관리하는 역할을 수행하는 클래스이다.그럼 어떤 방식으로 엔티티 매니저는 엔티티들을 관리할까?엔티티 매니저 내부에 **영속성 컨텍스트(Persistence Context)**라는 걸 두어서 엔티티들을 관리한다. 영속성 컨텍스트(Persistence Context) 영속성: 기본적으로 컴퓨터 공학에서 영속성이라고 하면 비휘발성이라고 보면 될 것 같다.휘발성은 프로그램이 꺼지거나 전원이 나가면 데이터가 날아가는 경우를 휘발성이라 하고, 그 반대가 비휘발성이다.하지만 휘발성과 비휘발성 이란 단어는 저장 장치(메인 메모리나 플래시 메모리 등등)의 특징을 나타낼 때 많이 쓰고,영속성이란 단어는 DB에 관해 설명할 때 많이 사용하는 것 같다. 컨텍스트: 직역하면 맥락, 문맥이란 뜻인데 프로그래밍 쪽에선 좀 다른 뜻으로 쓰이는 것 같다.내가 알기로는 하나의 환경, 공간? 쯤으로 이해하고 사용하고 있다. 영속성 컨텍스트는 엔티티를 영구히 저장하는 환경이다.출처: 자바 ORM 표준 JPA 프로그래밍(김영한 저) 92P, 3.2 영속성 컨텍스트란? 하지만 개발자가 직접 영속성 컨텍스트를 뜯어보거나 그 내부를 들여다 볼 수는 없어서 약간은 논리적이거나 추상적인 개념으로 바라봐야한다. 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유할 수도 있다고 한다.그리고 영속성 컨텍스트를 책의 저자는 엔티티를 영구히 저장하는 환경이라고 했는데 내가 봤을 때는영속성 컨텍스트를 관리하는 모든 엔티티 매니저가 초기화 및 종료되지 않는 한 엔티티를 영구히 저장하는 환경이라고 정정해야할 것 같다.그냥 영구히 저장 된다고 하면 프로그램을 껐다 켜도 영속성 컨텍스트는 항상 살아 있을 것 같다는 생각이 든다.하지만 프로그램을 끄기도 전에 엔티티 매니저를 초기화 및 종료 시키는 코드를 만나면 해당 영속성 컨텍스트는 소멸된다. 엔티티 매니저와 영속성 컨텍스트의 엔티티 관리그럼 엔티티 매니저와 영속성 컨텍스트는 어떻게 엔티티를 관리할까?우선 한 명의 멤버를 추가하는 코드를 살펴보자. 12345678910111213141516171819202122232425262728293031323334public class Join &#123; public void join(String name, int age) &#123; // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다. Member member = new Member(); member.setName(name); member.setAge(age); // 엔티티 매니저가 있다고 가정. // 추후에 엔티티 매니저 팩토리와 함께 엔티티 매니저를 어떻게 생성하는지 설명. EntityManager em; EntityTransaction tx = em.getTransaction(); try &#123; // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다. tx.begin(); // 이렇게 하면 해당 엔티티 매니저의 영속성 컨텍스트에 위에서 만든 member 객체가 저장된다. // 이제 member 엔티티는 엔티티 매니저의 관리 대상이 되고, 영속성을 가졌다고 말할 수 있다. em.persist(member); // 트랜잭션을 커밋한다. tx.commit(); &#125; catch(Exception e) &#123; // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다. tx.rollback(); &#125; finally &#123; // 엔티티 매니저를 종료시켜줘야 한다. // 아마 더 이상 사용하지 않는 자원이므로 더 이상 사용하지 않는 자원이라고 표시하는 것 같다. // 그럼 아마 GC가 해당 엔티티 매니저 자원을 수거해가서 메모리에 반환하지 않을까?? // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. em.close(); &#125; &#125;&#125; 여기서 두 가지 설명하지 않은 개념이 있다.엔티티가 영속성을 가졌을 때의 특징(엔티티의 생명주기)와 트랜잭션이다.엔티티의 생명 주기는 나중에 엔티티 매니저를 사용하는 이유와 관련해서 따로 정리해야겠다. 트랜잭션(Transaction)하나의 작업 단위라고 보면 될 것 같다.예를 들면 상품 구매라는 하나의 작업을 보면 아래와 같은 자잘한 작업들이 존재한다. 상품의 재고 조회 유저의 잔고 조회 상품의 재고 -1 유저의 잔고에서 돈을 뺌. 주문 생성 이런 5개의 작업은 중간에 하나라도 뻑나면 작업 전체가 뻑났다고 보고 아예 맨 처음 상태로 돌려야한다.4번에서 뻑났을 때 상품의 재고도 -1 했던 걸 원래 처음 상태로 돌려놔야 정상적인 작동이라고 말할 수 있다.이렇게 오류가 났을 때 처음 상태로 돌아가는(rollback) 작업의 단위를 트랜잭션이라고 한다.트랜잭션이 모두 정상적으로 수행됐을 때는 commit을 수행해서 작업 내용을 실제 DB와 엔티티 매니저에 반영한다. 그럼 JPA에서 모든 로직은 왜 트랜잭션 안에서 수행해야하는 것일까…?물론 조회 로직은 트랜잭션 안에서 수행해야 할 필요도 없고, 트랜잭션의 단위가 커지면 데드락 이슈에 봉착하기 때문에 최대한 트랜잭션의 단위를 작게 잡으면서 안정성을 가져가는 게 베스트다.그건 JPA가 쿼리를 한 방에 날리기 때문이다. 쓰기 지연 SQL 저장소 영속성 컨텍스트 안에는 쓰기 지연 SQL 저장소라는 공간이 따로 존재한다.만약 아래와 같은 코드가 있다고 보자. 1234567891011121314151617181920212223242526272829303132333435363738public class Join &#123; public void join(String name, int age) &#123; // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다. Member member = new Member(); member.setName(name); member.setAge(age); Member member2 = new Member(); member2.setName(name); member2.setAge(age); // 엔티티 매니저가 있다고 가정. // 추후에 엔티티 매니저 팩토리와 함께 엔티티 매니저를 어떻게 생성하는지 설명. EntityManager em; EntityTransaction tx = em.getTransaction(); try &#123; // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다. tx.begin(); // 쿼리는 전송되지 않는다. em.persist(member); em.persist(member2); // 커밋하는 시점에 쿼리가 전송된다. tx.commit(); &#125; catch(Exception e) &#123; // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다. tx.rollback(); &#125; finally &#123; // 엔티티 매니저를 종료시켜줘야 한다. // 아마 더 이상 사용하지 않는 자원이므로 더 이상 사용하지 않는 자원이라고 표시하는 것 같다. // 그럼 아마 GC가 해당 엔티티 매니저 자원을 수거해가서 메모리에 반환하지 않을까?? // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. em.close(); &#125; &#125;&#125; 트랜잭션을 생각하지 않고 의식의 흐름대로 코드의 동작을 추측해보면… 쿼리가 두 번 날아갈 것이다. 만약에 멤버 2를 저장하는 시점에서 롤백을 해야할 때는 날리지 않아도 될 멤버 1에 대한 삽입 쿼리를 날리게 된 격이다. 하지만 쓰기 지연 SQL 저장소 및 트랜잭션에 의해 아래와 같이 동작한다. 트랜잭션이 커밋 되기 직전까지 모든 쿼리문은 영속성 컨텍스트 내부의 쓰기 지연 SQL 저장소에 저장된다. 트랜잭션이 커밋되는 순간 모든 쿼리가 한 방에 날아간다. 만약 트랜잭션 내부에서 오류가 나서 롤백을 해야한다면 애초에 날리지도 않을 쿼리를 날리지도 않는다. 위와 같이 성능 이슈 때문에 모든 로직을 트랜잭션 내부에서 처리하게끔 하려는 것인 것 같다. EntityManagerFactory엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다. 동시성(Concurrency): 유저가 체감하기에는 동시에 수행하는 거 처럼 보이지만 사실은 유저가 체감할 수 없는 짧은 시간단위로 작업들을 번갈아가면서 수행하는 것이다.예를 들면 싱글 코어에서 멀티 스레드를 구현하기 위해서 쓰이는 기법?이다.각 스레드들이 동시에 동작하는 거 같지만 알고 보면 스레드들이 아주 짧은 시간마다 번갈아가면서 작업을 수행하고 있는 것이다.병렬(Parallelism): 우리가 생각하는 그 진짜 동시에 실행하는 개념을 생각하면 될 것 같다.실제로 동시에 여러 작업이 수행되는 개념이다.멀티 코어에서 멀티 스레드를 구현할 때 쓰이는 기법?이다.각 스레드들이 동시에 동작한다. 내가 과자 먹으려고 하는데 누가 와서 뺏어먹을 수도 있기 때문에…내가 데이터를 수정하고 있는데 다른 스레드에서 해당 데이터를 미리 수정해버리면 안 되기 때문…따라서 엔티티 매니저는 하나를 공유하면 안 되고, 상황에 따라서 계속해서 만들어줘야한다.그럼 이런 엔티티 매니저는 누가 만들어줄까?바로 엔티티 매니저 팩토리(공장)이다. 12345678910111213141516171819202122232425262728293031323334public class Join &#123; public void join(String name, int age) &#123; // 아직까지는 해당 엔티티를 엔티티 매니저가 관리하지 않는다. Member member = new Member(); member.setName(name); member.setAge(age); // META-INF/persistence.xml에서 이름이 db인 persistence-unit을 찾아서 엔티티 매니저 팩토리를 생성 EntityManagerFatory emf = Persistence.createEntityManagerFactory(&quot;db&quot;); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); try &#123; // 엔티티 매니저에서 수행하는 모든 로직은 트랜잭선 안에서 수행돼야 한다. tx.begin(); // 이렇게 하면 해당 엔티티 매니저의 영속성 컨텍스트에 위에서 만든 member 객체가 저장된다. // 이제 member 엔티티는 엔티티 매니저의 관리 대상이 되고, 영속성을 가졌다고 말할 수 있다. em.persist(member); // 트랜잭션을 커밋한다. tx.commit(); &#125; catch(Exception e) &#123; // 어떤 이유에서 오류가 났다면 트랜잭션을 롤백 시켜줘야한다. tx.rollback(); &#125; finally &#123; // 엔티티 매니저를 종료시켜줘야 한다. // 아마 더 이상 사용하지 않는 자원이므로 메모리에 자원을 반환하지 않으면 // 성능 상 문제가 있어서 이렇게 종료시켜줘야 하는 건지 모르겠다. em.close(); &#125; emf.close(); // 마찬가지로 엔티티 매니저 팩토리도 더이상 쓰지 않는다면 종료시켜줘야 한다. &#125;&#125; 공장(엔티티 매니저 팩토리)에서 제품(엔티티 매니저)를 찍어내는 개념이라고 보면 될 것 같다.엔티티 매니저 팩토리는 엔티티 매니저와 달리 여러 스레드가 동시에 접근해도 안전하다.단순히 엔티티 매니저만 찍어대는 녀석이기 때문이다. 비용도 보면 공장을 짓는 비용은 굉장히 크다.그래서 엔티티 매니저 팩토리는 DB 당 하나 밖에 사용하지 않는다.그에 비해 공장에서 제품을 찍어내는 것은 너무나도 당연하고 빈번하게 일어나는 일이기 때문에 비용이 엄청 크게 들지 않는다. 12345678public class EMF &#123; public static void main(String[] args)&#123; EntityManagerFatory emf = Persistence.createEntityManagerFactory(&quot;db&quot;); EntityManagerFatory emf2 = Persistence.createEntityManagerFactory(&quot;db&quot;); System.out.println(emf == emf2); // false &#125;&#125; 하지만 그냥 일반적으로 엔티티 매니저 팩토리를 사용하면 계속 새로운 엔티티 매니저 팩토리를 생성한다.따라서 동일한 엔티티 매니저 팩토리를 공유해서 사용하려면 싱글턴 인스턴스나 의존성 주입 등등을 통해 개발자의 의식적인 노력이 필요하다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"}],"tags":[{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"DB","slug":"DB","permalink":"https://perfectacle.github.io/tags/DB/"}]},{"title":"travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기","slug":"travis-ci-coveralls","date":"2017-12-10T21:21:07.000Z","updated":"2022-10-30T08:42:16.955Z","comments":true,"path":"2017/12/10/travis-ci-coveralls/","link":"","permalink":"https://perfectacle.github.io/2017/12/10/travis-ci-coveralls/","excerpt":"이 글은 Typescript + TSLint + Mocha + Chai + ts-node + NYC로 모던한 프론트 엔드 테스트 환경 구축하기,rollup.js를 통해 모듈 번들링하기에서 이어지는 내용이며, 여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 front-test-setting 저장소에서 확인 가능합니다. CI(Continuous Integration)","text":"이 글은 Typescript + TSLint + Mocha + Chai + ts-node + NYC로 모던한 프론트 엔드 테스트 환경 구축하기,rollup.js를 통해 모듈 번들링하기에서 이어지는 내용이며, 여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 front-test-setting 저장소에서 확인 가능합니다. CI(Continuous Integration)지속적인 통합이라고 직역이 되는데 그냥 뭔소린지 모르겠으니 영어의 느낌을 그대로 갖고 있는 게 좋은 것 같다.CI는 빌드, 테스트, 배포 등등의 잡다구레한 일을 자동화 해주는 도구 정도로 알고 있다.우리는 여기서 빌드와 테스트만 자동화 해볼 예정이다. Travis CI유사품으로 젠킨스라는 게 있는데 이거는 별도의 CI 서버를 구축해야해서 사내에서 많이 쓰고,Travis CI를 사용하면 별도의 서버를 구축하지 않고 바로 사용이 가능하기 때문에 오픈소스 진영에서 많이 사용한다.그럼 이 CI를 왜 써야할까…? 일단 내가 테스트 코드 매번 돌리기 귀찮음…(푸시하면 알아서 Travis CI가 돌고 결과를 알려줌.) 풀리퀘스트 받을 때 남이 내 코드를 어떤 식으로 깔아뭉갰을지 모르므로 테스트가 통과됐으면 내 코드에 대한 안전성도 보장됨. 여러가지 이유가 있겠지만 나는 주로 위 이유 때문에 Travis CI를 사용했다. 그리고 travis ci에 대한 설정 파일도 만들어줘야한다.우선 우리의 코드는 자바스크립트이기 때문에 Node.js 위에서 돌리면 된다..travis.yml 파일을 만들고 아래와 같이 설정해주면 된다. 1234language: node_jsnode_js: - &quot;node&quot; - &quot;lts/*&quot; 각 버전에 대한 자세한 설명은 Specifying-Node.js-versions을 참고하면 된다. 따라서 빌드가 성공하지 않은 풀리퀘는 적어도 확인해 볼 것도 없이 반려하면 되는 풀리퀘가 되는 것이다.(가끔 노드 버전에 따라 xx 맞게 설치도 실패하는 경우도 많아서 100% 신뢰할 만한 건 아니다.) CoverallsNYC(Istanbul)은 로컬에서 테스트 커버리지를 측정하는 도구였다.Coveralls는 깃헙 저장소와 연계해서 NYC로 측정한 테스트 커버리지를 알려준다. 우리 저장소는 public이라 해당 설정을 할 필요가 없지만 로컬에서 테스트 커버리지에 대한 결과도 coveralls로 전송하려면 위 과정을 진행해야한다.그리고 repo_token의 경우에는 저장소에 접근 가능한 토큰이므로 절대 외부로 공개해서는 안 된다. 우선 coveralls를 설치하자. 1npm i -S coveralls 그리고 프로젝트 디렉토리에 .coveralls.yml 파일을 만들자. 1touch .coveralls.yml 12service_name: travis-prorepo_token: &#123;token&#125; 해당 파일은 토큰을 가지고 있기 때문에 어디에도 공개해서는 안 되는 정보기 때문에 꼭 .gitignore에 등록해두자. 그리고 nyc의 테스트 커버리지의 정보를 전송하기 위해 package.json에 coveralls 스크립트를 추가하자. 12345&#123; &quot;scripts&quot;: &#123; &quot;coveralls&quot;: &quot;nyc report --reporter=text-lcov | coveralls&quot; &#125;&#125; npm test를 때리고 npm run coveralls를 때리고 나면 coveralls로 해당 테스트 커버리지 정보가 전송된다. 이제 Travis CI와 Coveralls를 연계해 볼 차례이다.설정은 간단하게 .travis.yml에 아래 코드만 추가해주면 된다. 12after_success: - npm run coveralls 빌드가 성공하면 테스트 커버리지를 coveralls로 전송하는 스크립트만 추가하면 된다. 이제 푸시&#x2F;풀리퀘를 날려도 coveralls가 자동으로 테스트 커버리지를 측정한다. 마치며Typescript, TSLint, Mocha, Chai, ts-node, nyc, rollup, Travis CI, Coveralls 등 다양한 주제를 다루려다보니포스팅 시간도 길었고 내용도 루즈해졌고, 깊이도 거의 없다 싶이 해서 아쉽긴 한 포스트입니다.하지만 뭔가 이제 오픈소스나 작업 환경을 좀 더 간지나게 세팅할 수 있다는 것에 뿌듯하긴 한데…이런 게 설레발 주도 개발인가 싶기도 하네요… ㅎㅎ","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"Travis CI","slug":"Travis-CI","permalink":"https://perfectacle.github.io/tags/Travis-CI/"},{"name":"Coveralls","slug":"Coveralls","permalink":"https://perfectacle.github.io/tags/Coveralls/"}]},{"title":"rollup.js를 통해 모듈 번들링하기","slug":"bundle-with-rollup","date":"2017-12-10T17:32:52.000Z","updated":"2022-10-30T08:42:16.187Z","comments":true,"path":"2017/12/10/bundle-with-rollup/","link":"","permalink":"https://perfectacle.github.io/2017/12/10/bundle-with-rollup/","excerpt":"이 글은 Typescript + TSLint + Mocha + Chai + ts-node + NYC로 모던한 프론트 엔드 테스트 환경 구축하기에서 이어지는 내용이며,이 글을 본 이후에 travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기를 보는 걸 추천드립니다.여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 rollup-umd 브랜치에서 확인 가능합니다. 모듈 번들러typescript 컴파일러나, ES2015+ to ES5 트랜스파일러인 바벨의 경우에는 모듈 간의 의존관계를 알지 못한다.따라서 Webpack이나 Rollup, parcel과 같은 모듈 번들러로 번들링해야한다.","text":"이 글은 Typescript + TSLint + Mocha + Chai + ts-node + NYC로 모던한 프론트 엔드 테스트 환경 구축하기에서 이어지는 내용이며,이 글을 본 이후에 travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기를 보는 걸 추천드립니다.여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 rollup-umd 브랜치에서 확인 가능합니다. 모듈 번들러typescript 컴파일러나, ES2015+ to ES5 트랜스파일러인 바벨의 경우에는 모듈 간의 의존관계를 알지 못한다.따라서 Webpack이나 Rollup, parcel과 같은 모듈 번들러로 번들링해야한다. 기존에 익숙했던 Webpack과 같은 모듈 번들러 대신에 Rollup을 사용한 이유는 Webpack and Rollup: the same but different이 글에서 Use webpack for apps, and Rollup for libraries이란 구문과 페이스북의 리액트가 rollup을 쓰고 있기 때문에 호기심이 생겨서예제로 만들어 볼 라이브러리를 말아보기 위해서 롤업을 선택해봤다. 라이브러리 완성하기전에는 util.ts 파일 하나만 있으니 의존 관계를 누가 봐도 알기 쉬웠다.따라서 이번에는 모듈 간의 의존 관계를 조금 복잡하게 해보자. src 폴더 안에 util2.ts 파일을 만들고 아래와 같이 만들어주자. 1touch src/util2.ts 123export const removedDigits = (numberContainsNotDigits: string): string =&gt; &#123; return numberContainsNotDigits.replace(/[\\d]/g, &#x27;&#x27;);&#125;; 해당 함수의 유닛테스트를 test&#x2F;util2.spec.ts에 만들어주자. 1touch test/util2.spec.ts 123456789import &#123;expect&#125; from &#x27;chai&#x27;;import &#123;removedDigits&#125; from &#x27;../src/util2&#x27;;describe(&#x27;util2&#x27;, () =&gt; &#123; it(&#x27;test removedDigits&#x27;, () =&gt; &#123; expect(removedDigits(&#x27;010-123-3333&#x27;)).to.be.equal(&#x27;--&#x27;); expect(removedDigits(&#x27;93/05/30&#x27;)).to.be.equal(&#x27;//&#x27;); &#125;);&#125;); 그리고 해당 모듈들을 하나로 뭉친 진입점(entry point)로 src 폴더에 index.ts를 만들자. 1touch src/index.ts 123456import &#123;removedDigits&#125; from &#x27;./util2&#x27;;import &#123;removedNotDigits&#125; from &#x27;./util&#x27;;export &#123; removedDigits, removedNotDigits&#125;; 그리고 index.ts는 테스트 커버리지에 포함시키지 않게 .nycrc 설정에 해당 내용을 추가해주자. 12345&#123; &quot;exclude&quot;: [ &quot;src/index.ts&quot; ]&#125; npm test를 때려서 테스트가 정상적으로 수행되는지 확인하자. Rollup우선 설치부터 해보자. 1npm i -S rollup rollup-plugin-typescript2 rollup-plugin-tslint rollup-plugin-uglify 우리 라이브러리는 타입스크립트로 만들 거고, tslint도 쓸 거고, 코드의 양을 줄이기 위해 minify 및 변수 난독화 진행을 위해서 uglify까지 설치했다. package.json 세팅하기package.json의 main과 name을 아래와 같이 바꾸고 빌드 스크립트를 추가하자.main은 require 혹은 import 했을 때 직접적으로 import 되는 파일이니 엔트리 포인트를 잘 정해놔야한다.또한 name은 npm에 올릴 생각이라면 npm repository에 올라간 라이브러리와 중복되면 안 된다.그냥 github repository에다가 올려놓고 설치하거나 로컬에 올려놓고 설치하려면 적당한 이름을 지으면 된다. 1234567&#123; &quot;name&quot;: &quot;utils&quot;, &quot;main&quot;: &quot;dist/index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;npm test &amp;&amp; rollup -c&quot; &#125;&#125; 테스트가 실패하면 빌드를 실행하지 않는다.만약 테스트를 돌리긴 하지만 테스트가 실패해도 빌드를 수행하고 싶은 경우에는 아래와 같이 빌드 스크립트를 구성하면 된다. 12345&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;npm test; rollup -c&quot; &#125;&#125; index.d.ts 만들기우리의 라이브러리에 대한 타입 정의 파일을 만들어야한다. 1touch index.d.ts 123456789101112131415declare module &#x27;utils&#x27; &#123; /** * 숫자를 포함한 문자열에서 숫자를 제외한 문자를 제거하는 함수 * @param numberContainsNotDigits 숫자 이외의 문자를 포함한 문자열 * @return 숫자만 포함한 문자열 */ export function removedNotDigits(numberContainsNotDigits: string): string; /** * 숫자를 포함한 문자열에서 숫자만 제거하는 함수 * @param numberContainsDigits 숫자를 포함한 문자열 * @return 숫자만 제외한 문자열 */ export function removedDigits(numberContainsDigits: string): string;&#125; 만약 index.d.ts를 만들어두지 않는다면 아래와 같은 현상이 발생한다. index.d.ts를 만들어두면 위 현상이 발생하지 않는다. 하지만 index.d.ts를 추가하고 테스트해보면 TypeError: Unable to require .d.ts file. 오류가 발생하니 .nycrc를 아래와 같이 수정해줘야한다. 123456&#123; &quot;exclude&quot;: [ &quot;src/index.ts&quot;, &quot;**/*.d.ts&quot; ]&#125; rollup.config.js 세팅하기 CommonJS 스펙을 준수한 모듈로 번들링하는 경우대부분 Node.js에서만 쓸 용도의 라이브러리를 만들 때 이 경우에 해당한다.rollup.config.js 파일을 아래와 같이 적어주자. 123456789101112131415import typescript from &#x27;rollup-plugin-typescript2&#x27;;import tslint from &#x27;rollup-plugin-tslint&#x27;;import pkg from &#x27;./package.json&#x27;;export default &#123; input: &#x27;src/index.ts&#x27;, output: &#123; file: pkg.main, format: &#x27;cjs&#x27; &#125;, plugins: [ typescript(), tslint() ]&#125; npm build 때리면 빌드된 commonjs 모듈 파일이 dist&#x2F;index.js에 나오게 된다. 설치는 아래와 같이 하면 된다. (자신의 상황에 맞게 설치하면 된다.) 1npm i -S git://github.com/perfectacle/front-test-setting.git#rollup-cjs 사용은 아래와 같이 하면 된다. 12const &#123;removedDigits, removedNotDigits&#125; = require(&#x27;utils&#x27;);console.log(removedDigits(&#x27;93-05&#x27;)); // - ES Module 스펙을 준수한 모듈로 번들링하는 경우import&#x2F;export 모듈로 사용하기 위해서 사용하는데 대부분 웹팩과 같은 번들러를 사용할 때 많이 사용한다.rollup.config.js 파일을 아래와 같이 적어주자.123456789101112131415import typescript from &#x27;rollup-plugin-typescript2&#x27;;import tslint from &#x27;rollup-plugin-tslint&#x27;;import pkg from &#x27;./package.json&#x27;;export default &#123; input: &#x27;src/index.ts&#x27;, output: &#123; file: pkg.main, format: &#x27;es&#x27; &#125;, plugins: [ typescript(), tslint() ]&#125; npm build 때리면 빌드된 ES 모듈 파일이 dist&#x2F;index.js에 나오게 된다. 설치는 아래와 같이 하면 된다. (자신의 상황에 맞게 설치하면 된다.) 1npm i -S git://github.com/perfectacle/front-test-setting.git#rollup-esm 사용은 아래와 같이 하면 된다. 12import &#123;removedDigits, removedNotDigits&#125; from &#x27;utils&#x27;console.log(removedDigits(&#x27;93-05&#x27;)); // - 브라우저 전용으로 모듈을 번들링하는 경우브라우저는 모든 리소스가 받아져있는 상태가 아니라서 좀 특수성을 가지기 때문에 CommonJS 스펙 모듈의 사용이 불가능하고,ES 모듈을 구현한 브라우저는 크롬 62+ 말고는 없는 것으로 알고 있다.따라서 브라우저를 지원하기 위해서는 아래와 같이 설정해야한다. 우선 package.json에 main 프로퍼티를 수정해주자. 123&#123; &quot;main&quot;: &quot;dist/util.min.js&quot;&#125; 롤업 설정은 아래와 같이 바꿔주자. 12345678910111213141516171819import typescript from &#x27;rollup-plugin-typescript2&#x27;;import tslint from &#x27;rollup-plugin-tslint&#x27;;import uglify from &#x27;rollup-plugin-uglify&#x27;;import pkg from &#x27;./package.json&#x27;;export default &#123; input: &#x27;src/index.ts&#x27;, output: &#123; file: pkg.main, format: &#x27;iife&#x27; &#125;, // name으로 만든 이름이 전역에 생길 객체의 이름이니 필수이다. name: &#x27;utils&#x27;, plugins: [ typescript(), tslint(), uglify() ]&#125; 설치는 아래와 같이 하면 된다. (자신의 상황에 맞게 설치하면 된다.) 1npm i -S git://github.com/perfectacle/front-test-setting.git#rollup-browser 그리고 html 파일에서 사용할 때는 아래와 같이 사용하면 된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 요렇게 쓰면 번거로우니 대부분 CDN을 지원한다. --&gt;&lt;script src=&quot;node_modules/utils/dist/util.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const &#123;removedDigits, removedNotDigits&#125; = utils; console.log(removedDigits(&#x27;93-05&#x27;)); // -&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 복합적인 상황우리가 만드려는 라이브러리가 범용적으로 사용됐으면 하는 바람이라면 아래와 같이 설정을 하면 된다.우선 package.json에 browser 프로퍼티를 추가해주자. 1234&#123; &quot;main&quot;: &quot;dist/index.js&quot;, &quot;browser&quot;: &quot;dist/util.min.js&quot;&#125; 롤업 설정은 아래와 같이 해주자. 1234567891011121314151617181920212223242526272829303132333435import typescript from &#x27;rollup-plugin-typescript2&#x27;;import tslint from &#x27;rollup-plugin-tslint&#x27;;import uglify from &#x27;rollup-plugin-uglify&#x27;;import pkg from &#x27;./package.json&#x27;;export default [ // Node and other module bulder for UMD build &#123; input: &#x27;src/index.ts&#x27;, output: &#123; file: pkg.main, format: &#x27;umd&#x27; &#125;, name: &#x27;utils&#x27;, plugins: [ typescript(), tslint() ] &#125;, // browser-friendly IIFE build &#123; input: &#x27;src/index.ts&#x27;, output: &#123; file: pkg.browser, format: &#x27;iife&#x27; &#125;, name: &#x27;utils&#x27;, plugins: [ typescript(), tslint(), uglify() ] &#125;,] umd는 es 모듈, commonjs, amd, iife 등등 모든 모듈 방식을 커버하는 모듈 방식이다.하지만 umd는 기본적으로 iife 모듈보다 용량이 크기 때문에 iife를 uglify 한 것을 브라우저에서 쓰고,나머지 환경에서는 umd 모듈 파일을 사용하는 게 좋다. 설치는 아래와 같이 하면 된다. (자신의 상황에 맞게 설치하면 된다.) 1npm i -S git://github.com/perfectacle/front-test-setting.git#rollup-umd 우선 node에서 사용할 때는 아래와 같이 하면 된다. 12const &#123;removedDigits, removedNotDigits&#125; = require(&#x27;utils&#x27;);console.log(removedDigits(&#x27;93-05&#x27;)); // - 다른 모듈 번들러에서 사용할 때는 아래와 같이 사용하면 된다. 12import &#123;removedDigits, removedNotDigits&#125; from &#x27;utils&#x27;console.log(removedDigits(&#x27;93-05&#x27;)); // - 브라우저에서 사용할 때는 아래와 같이 사용하면 된다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 요렇게 쓰면 번거로우니 대부분 CDN을 지원한다. --&gt;&lt;script src=&quot;node_modules/utils/dist/util.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const &#123;removedDigits, removedNotDigits&#125; = utils; console.log(removedDigits(&#x27;93-05&#x27;)); // -&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 마치며…저는 리액트를 써볼 때 웹팩을 써서 웹팩이 익숙했었는데 rollup을 써보고 나니 앱이 아닌 라이브러리의 경우에는 롤업이 더 적합한 것 같다는 느낌도 많이 들었네요.이 다음 번 시리즈에는 마지막 포스트인 travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기을 보시면 됩니다.오픈소스, 남들과 협업할 때 어떻게 내 코드의 안전성을 쉽고 빠르게 보장할 수 있을지에 대해 정리해놓았습니다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"}],"tags":[{"name":"Rollup","slug":"Rollup","permalink":"https://perfectacle.github.io/tags/Rollup/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://perfectacle.github.io/tags/CommonJS/"},{"name":"ESModule","slug":"ESModule","permalink":"https://perfectacle.github.io/tags/ESModule/"},{"name":"UMD","slug":"UMD","permalink":"https://perfectacle.github.io/tags/UMD/"}]},{"title":"Typescript + TSLint + Mocha + Chai + ts-node + NYC로 모던한 프론트 엔드 테스트 환경 구축하기","slug":"ts-node-mocha-chai","date":"2017-12-10T13:59:52.000Z","updated":"2022-10-30T08:42:16.991Z","comments":true,"path":"2017/12/10/ts-node-mocha-chai/","link":"","permalink":"https://perfectacle.github.io/2017/12/10/ts-node-mocha-chai/","excerpt":"이 글은 rollup.js를 통해 모듈 번들링하기, travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기을 읽기 전에 읽어야할 포스트이며여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 nyc 브랜치에서 확인 가능합니다. Typescript?ts 브랜치에 예제 파일이 올라가있습니다.","text":"이 글은 rollup.js를 통해 모듈 번들링하기, travis-ci와 coveralls를 이용하여 좀 더 안전하게 협업하기을 읽기 전에 읽어야할 포스트이며여러 주제를 다루다보니 깊게 다루지는 않고 각각이 무엇을 하는 것인지만 간단하게 설명과 예제를 곁들여 진행하고 있습니다.또한 예제 진행은 IntelliJ를 통해 진행했습니다.WebStorm으로 진행해도 상관 없고, VS Code와 진행하면 더 짱짱맨일지도 모르겠습니다. 각 단계 별 깃헙 저장소 브랜치를 제공하고 있고, 이 포스트의 최종 결과물은 nyc 브랜치에서 확인 가능합니다. Typescript?ts 브랜치에 예제 파일이 올라가있습니다. 기존 자바스크립트는 동적 타입이다. 12345678910// 변수 a에는 어떠한 값이든 들어갈 수 있다.let a = 1;a = &#x27;1&#x27;;a = &#123;&#125;;// 함수의 매개변수에 뭐가 들어가야할지, 리턴 타입은 무엇인지 함수 선언부를 가지 않는 이상은 알아차리기 힘들다.const b = val =&gt; +val;// 따라서 사용하는 측에서는 해당 코드가 에러인지 아닌지는 실행을 해보거나 함수 선언부를 보지 않는 이상은 힘들다.b(&#x27;1&#x27;).call(null, 1, 2, 3); // Uncaught TypeError: b(...).call is not a function 하지만 정적 타입인 타입스크립트에서는 위의 코드를 아래와 같이 런타임 전인 컴파일 에러로 체크해주기 때문에아예 실행 조차 되지 않는 다는 것을 알려주기 때문에 좀 더 안전하게 코드를 작성할 수 있다. Why Typescript?기존에 자바스크립트와 같이 동적 타입이 가지는 문제점을 위에서 지적하긴 했지만 그래도 왜 써야하는지 납득이 잘 가지 않는 경우를 대비해 간단하게 나마 비교를 해보았다. 이는 위에서 설명한 바와 같이 직접 함수 선언부를 찾아가야한다는 단점이 있다. 타입 추론은 맥 OS 기준 커맨드+P 키를 누르면 볼 수 있다. 이 메소드가 반환하는 게 무슨 타입인지 모르기 때문에 또 직접 함수 선언부를 봐야한다. 물론 아예 방법이 없는 것은 아니고 jsdoc을 이용하면 된다. 123456/** * 문자열을 숫자로 반환하는 함수 * @param val&#123;string&#125; 숫자 문자열 * @return &#123;number&#125; 숫자 */const b = val =&gt; [val]; 위처럼 return 타입에 number를 명시해놓고 배열을 리턴하게 짠 코드를 막지는 못한다. 맥 OS 기준 컨트롤+J 키를 누르면 doc을 볼 수 있다. 위 사진이 전적으로 왜 타입스크립트를 써야하는지 설명하고 있다.내가 아무리 함수마다 일일이 jsdoc 다느라 뻘짓을 했어도 사용자 측에서 다 무시하고 마이웨이로 코딩하면 런타임 에러로 뻗는다.아예 저런 코드는 실행 자체를 하게 하면 안 되는데 나 조차도 저렇게 코딩을 할지도 모르는 상황이고,오픈소스나 실무에서 협업을 하다보면 저런 현상은 빈번하게 겪게 된다.내가 일일이 다 확인하고 코드리뷰 할 수도 없는 노릇이고 일을 좀 더 효율적으로 하기 위해서 이런 노력을 줄여야한다. 그럼 타입스크립트는 어떤지 비교해보자. 어쨋든 ts를 다이렉트로 실행하지 못하기 때문에 js 파일로 컴파일 해야하는데 저런 코드는 컴파일 오류로 아예 js 파일로 컴파일 자체가 되질 않는다.따라서 아예 실행 조차 불가능한 코드가 되어버린다. 여기까지 봤을 때 js는 jsdoc을 일일이 달아줘야하고, 사용자의 인지적인 노력이 필요한데 ts는 그런 귀찮음이 전혀 사라지게 되는 것이다.물론 이 외에도 ts가 지원하는 기능들은 무궁무진하다. (ES2015+의 슈퍼셋 격이니…) Install그럼 직접 설치해보고 사용해볼 시간이다. 12npm init --ynpm i -S typescript 위와 package.json을 만들고 타입스크립트를 설정하면 인텔리제이가 알아서 타입스크립트 신택스를 지원해준다. ts 컴파일러도 자세한 설정이 가능한데 글의 범주를 넘어서므로 tsconfig.json을 프로젝트 루트 디렉토리에 아래와 같이 만들었다. 1234567891011121314&#123; &quot;compilerOptions&quot;: &#123; &quot;outDir&quot;: &quot;./dist/&quot;, &quot;sourceMap&quot;: true, &quot;strictNullChecks&quot;: true, &quot;module&quot;: &quot;umd&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;allowJs&quot;: false &#125;, &quot;include&quot;: [ &quot;./src/&quot; ]&#125; TSLinttslint 브랜치에 예제 파일이 올라가있습니다. 협업을 하게 되다보면 서로 코딩 스타일이 다르다.누가 맞고, 틀렸다는 게 아니라 서로 협업을 하는 입장에서는 코딩 컨벤션을 만들고 준수해야 가독성이나 남이 짠 코드에 대한 이해도도 분명히 높아지게 된다.누구는 문자열을 쓰는데 싱글 쿼테이션 쓰고, 누구는 더블 쿼테이션 쓰고, 누구는 들여쓰기를 탭으로 하고, 누구는 스페이스바 2칸으로 하고 그러다보면서로 협업한 코드는 엉망진창이 되고, 파일 별로도 중구난방인 코드가 될 것이다. Install그럼 직접 설치해보고 사용해볼 시간이다. 1npm i -S tslint tslint도 자세한 설정이 가능하고, 아래는 간단한 설정을 만들어 본 것이다. 1234567891011121314151617181920&#123; &quot;defaultSeverity&quot;: &quot;error&quot;, &quot;extends&quot;: [ &quot;tslint:recommended&quot; ], &quot;jsRules&quot;: &#123;&#125;, &quot;rules&quot;: &#123; &quot;quotemark&quot;: [true, &quot;single&quot;], &quot;indent&quot;: [true, &quot;spaces&quot;, 2], &quot;curly&quot;: [true, &quot;ignore-same-line&quot;], &quot;whitespace&quot;: [true, &quot;check-operator&quot;], &quot;no-trailing-whitespace&quot;: [true, &quot;ignore-blank-lines&quot;], &quot;max-line-length&quot;: [true, 150], &quot;trailing-comma&quot;: [true, &#123;&quot;multiline&quot;: &quot;never&quot;, &quot;singleline&quot;: &quot;never&quot;&#125;], &quot;ordered-imports&quot;: false, &quot;no-unused-expression&quot;: false, &quot;no-unused-variable&quot;: true, &quot;no-console&quot;: false &#125;&#125; Test Codemocha-chai 브랜치에 예제 파일이 올라가있습니다. 테스트 코드를 왜 짜야하는지는 구글링을 하면 쉽게 찾을 수 있는데 간단하게 내가 생각한 내용을 정리해봤다. 코드에 대한 신뢰도가 높아진다.내가 기존 코드를 수정해도 미리 작성해놓은 테스트 코드가 잘 작동한다면 안심하고 코드를 짤 수 있다.나 혼자 짜면 못 느낄텐데 협업을 하게 되다보면 내 코드 남이 깔아뭉개 놔서 테스트가 실패하는 경우가 빈번해서 사전에 오류를 잡을 수 있는데테스트 코드가 없다면 기존에 내가 짜놓은 로직이 제대로 잘 작동한다는 보장이 없어지게 된다. 테스트 해야할 포인트가 줄어든다.테스트를 돌려보고 어떤 테스트가 실패했는지 해당 테스트 코드의 구현부만 다시 손보면 된다.테스트 코드가 없다면 어디서부터 손을 봐야할지 난감한 상황이 많을텐데 이를 방지해준다. 물론 이 외에도 수두룩 빽빽한데 나는 아직 테스트 코드 짜는데 늅늅이니 이정도로… ㅠㅠ 테스트 코드를 짜는데도 테스트를 먼저 작성하고 코드를 후에 구현하는 TDD나ajax를 타야하는 테스트, DB를 거쳐야하는 테스트를 위한 Mocking이나UI 단을 위한 E2E 테스트 등등 많은데 우선 여기서는 간단하게 함수 단위의 유닛 테스트만 만들어보겠다. Mochamocha는 자바스크립트 코드를 테스트 해주는 도구이다.유사 도구로 Jasmine도 있다.바로 설치를 해보자. 1npm i -S mocha @types/mocha @types&#x2F;mocha는 mocha에 대한 타입 정의를 해놓은 것이다.ts 코드 내에서 모카를 쓰려면 모카에 대한 타입 정의가 있어야 오류 없이 사용 가능하다.그리고 mocha를 쓰기 전에 Chai에 대해서도 알아보고 같이 쓰자. Chaimocha를 바로 사용해도 되지만, mocha를 다양한 Assertion 라이브러리들과 사용하면 좀 더 테스트 코드의 가독성이 올라간다.물론 우리나라 문법이나 정서(?)하고는 맞지 않아 보이기도 하지만 영미권 문법으로 이해하기가 한층 수월해져서 많이 쓰이는 것 같다.그 중에 Chai라는 Assertion 라이브러리는 여러 스타일(should, expect, assert)의 Assertion을 지원해주는 라이브러리이다.바로 설치해서 간단한 사용 방법을 알아보자. 1npm i -S chai @types/chai 그리고 프로젝트에 src 디렉토리를 만들고 그 안에 util.ts를 만들어서 아래와 같이 코딩해주자.mocha의 디폴트 테스트 디렉토리가 test이고, spec은 자바스크립트 테스트 코드 파일 이름의 컨벤션 같다. 12mkdir srctouch src/util.ts 1234// 숫자를 제외한 문자들을 지워주는 함수이다.export const removedNotDigits = (numberContainsNotDigits: string): string =&gt; &#123; return numberContainsNotDigits.replace(/[^\\d]/g, &#x27;&#x27;);&#125;; 그리고 test 디렉토리를 만들고, util.spec.ts 라는 util 파일의 테스트 코드를 만들어주자. 12mkdir testtouch test/util.spec.ts 1234567describe(&#x27;util&#x27;, () =&gt; &#123; it(&#x27;test removedNotDigits&#x27;, () =&gt; &#123; expect(removedNotDigits(&#x27;0123&#x27;)).to.be.equal(&#x27;0123&#x27;); expect(removedNotDigits(&#x27;010-123-3333&#x27;)).to.be.equal(&#x27;0101233333&#x27;); expect(removedNotDigits(&#x27;93/05/30&#x27;)).to.be.equal(&#x27;930530&#x27;); &#125;);&#125;); 그럼 막 빨간줄이 쫙쫙 갈 것이다.여기서 갓텔리제이의 진가를 발휘할 시간이다. 그럼 util.ts의 removedNotDigits 함수가 제대로 임포트 된다. 그리고 test 디렉토리 안에 모카 설정 파일인 mocha.opts 파일을 만들어서 아래와 같이 테스트 코드의 디렉토리를 설정해주자. 1touch test/mocha.opts 12--recursivetest/**/*.spec.ts 그리고 package.json에서 test 스크립트를 다음과 같이 바꿔주면 된다. 12345&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot; &#125;&#125; 이제 터미널에서 다음 명령어를 실행하면 테스트 코드를 실행할 수 있다! 1npm test 그럼 아래와 같은 오류를 마주하게 될 것이다. 12(function (exports, require, module, __filename, __dirname) &#123; import &#123;removedNotDigits&#125; from &#x27;../src/util&#x27;;... ts-nodets-node 브랜치에 예제 파일이 올라가있습니다. Node.js는 javascript 런타임이지, Typescript 런타임이 아니다.따라서 Typescript 런타임인 ts-node를 설치해야한다. 1npm i -S ts-node 그리고 mocha.opts 파일에서 아래 한 줄을 추가해줘야한다.--require ts-node/register Test Coveragenyc 브랜치에 예제 파일이 올라가있습니다. 테스트 커버리지란 내 테스트 코드로 내가 만든 소스들을 얼마나 커버하고 있는지 를 나타내는 지표이다.테스트 커버리지가 100%면 모든 코드에 대한 테스트 코드가 작성해도 됐다고 보면 무방하다.100%가 되면 좋겠지만 나도 아직 테스트 코드 늅늅이라 어느 정도가 적당한 커버리지인지는 모르겠다. IstanbulIstanbul은 자바스크립트의 테스트 커버리지 도구이다.하지만 여기서는 Istanbul을 사용하지 않을 것이다. NYCNYC는 Istanbul의 CLI이다.New York City의 줄임말이라는데 참 지명을 좋아한다.나중에 Seoul.js도 나왔으면 ㅎㅎㅎ… 여튼 NYC x Mocha를 하면 테스트 커버리지를 자동으로 측정할 수 있다.바로 설치해보자. 1npm i -S nyc 그리고 .nycrc 파일을 만들어서 간단하게 세팅해보자. 1touch .nycrc 12345678910111213141516171819&#123; &quot;require&quot;: [ &quot;ts-node/register&quot; ], &quot;include&quot;: [ &quot;src/**/*.ts&quot; ], &quot;extension&quot;: [ &quot;.ts&quot; ], &quot;exclude&quot;: [ &quot;**/*.d.ts&quot; ], &quot;reporter&quot;: [ &quot;text-summary&quot;, &quot;html&quot; ], &quot;all&quot;: true&#125; 그리고 mocha.opts에서는 아래 설정을 제거해주자. 1--require ts-node/register 그리고 package.json의 test 스크립트를 다음과 같이 수정해주자. 12345&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;nyc mocha&quot; &#125;&#125; 마치며…저도 수박 겉핥기로 예제를 따라하며 정리해본 내용이고, 정리해야할 내용이 방대해서 좀 깊이없이 다뤄서 이 부분은 직접 찾아보셔야할 겁니다.이 글의 목적은 그런 것에 대한 디테일 한 설명이 아니라 이런 것도 있다~ 정도의 소개 정도니 자세한 것은 직접 찾아보시길 바랍니다.그리고 지금까지 진행항 내용만으로는 우리가 만든 ts 파일을 외부 사람들이 직접 사용하지 못하니다음 시리즈인 rollup.js를 통해 모듈 번들링하기를 통해 실제 사람들이 쓸 수 있는 js 파일 형태로 만들어보도록 하겠습니다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://perfectacle.github.io/tags/Typescript/"},{"name":"TSLint","slug":"TSLint","permalink":"https://perfectacle.github.io/tags/TSLint/"},{"name":"Mocha","slug":"Mocha","permalink":"https://perfectacle.github.io/tags/Mocha/"},{"name":"Chai","slug":"Chai","permalink":"https://perfectacle.github.io/tags/Chai/"},{"name":"ts-node","slug":"ts-node","permalink":"https://perfectacle.github.io/tags/ts-node/"},{"name":"NYC","slug":"NYC","permalink":"https://perfectacle.github.io/tags/NYC/"}]},{"title":"(CD(N)) Netlify로 github page에서 jekyll 마냥 hexo(hugo, etc.)을 이용해보자","slug":"netlify","date":"2017-11-21T09:51:11.000Z","updated":"2022-10-30T08:42:16.867Z","comments":true,"path":"2017/11/21/netlify/","link":"","permalink":"https://perfectacle.github.io/2017/11/21/netlify/","excerpt":"이 포스트는 2017 GDG Seoul에서 Github와 CloudFlare를 이용한 무료 고성능 웹 어플리케이션 호스팅을주제로 발표하신 박병진 님의 세션을 듣고 삘이 꽂혀서 바로 실행에 옮긴 삽질을 포스팅했습니다. 깃헙 페이지의 문제점기본적으로 github page는 지킬이 내장돼있다.따라서 지킬에서 사용한 템플릿들은 별도의 static html 파일로 빌드하지 않아도 서비스가 가능하다.하지만 지킬을 설치하기 어려운 환경이거나 윈도우 유저(과거엔 윈도우에서 지킬 설치가 좀 힘들었다.), 비 지킬 유저(hexo, hugo, etc.)의 경우에는 빌드 된 정적인 파일 빌드 되기 전인 템플릿 파일","text":"이 포스트는 2017 GDG Seoul에서 Github와 CloudFlare를 이용한 무료 고성능 웹 어플리케이션 호스팅을주제로 발표하신 박병진 님의 세션을 듣고 삘이 꽂혀서 바로 실행에 옮긴 삽질을 포스팅했습니다. 깃헙 페이지의 문제점기본적으로 github page는 지킬이 내장돼있다.따라서 지킬에서 사용한 템플릿들은 별도의 static html 파일로 빌드하지 않아도 서비스가 가능하다.하지만 지킬을 설치하기 어려운 환경이거나 윈도우 유저(과거엔 윈도우에서 지킬 설치가 좀 힘들었다.), 비 지킬 유저(hexo, hugo, etc.)의 경우에는 빌드 된 정적인 파일 빌드 되기 전인 템플릿 파일 두 벌을 관리해야했다. (별도의 브랜치 혹은 저장소에서 관리를 해야했다.)심지어 자신의 저장소에 빌드 된 파일이 아닌 템플릿 파일이 올라갔다고 착각한 사람들도 많다.컴퓨터를 포맷해서 낭패보기 전에 얼른 다른 브랜치나 저장소에 백업을 해두자.또한 깃헙 페이지의 경우에는 CDN을 제공하지 않아 글로벌 서비스에는 제약이 따르고,소스의 최적화(minify 및 uglify, 이미지 압축 등등)를 직접 빌드 도구를 돌려야했다. Netlifynetlify는 CI(빌드 및 배포)+CDN의 개념으로 볼 수 있다.그리고 위의 단점들을 고스란히 해결해줬다.물론 커스텀 도메인이 없다면 *.netlify.com 이란 허접스러운 도메인을 써야해서 github.io라는 간지나는 도메인을 눈물을 머금으며 버릴 수 밖에 없다.그나마 닷컴 도메인을 싸게 살 수 있으므로 관심이 있는 사람은 (DNS) 1331원에 .com 도메인 사기 (feat. GoDaddy)를 참고하자. 당연히 회원가입부터 진행해야한다.요즘은 소셜 로그인이 활성화가 돼있어서 좀 덜 귀찮은 편인 것 같다.이 포스트에서는 깃헙 페이지+hexo를 netlify로 마이그레이션(?) 할 거기 때문에 github으로 로그인을 진행했다. CD(Continuous Deploy)깃헙 페이지와 마찬가지로 무중단 배포를 지원한다.로그인을 하고 나서는 New site from Git 버튼을 클릭해서 netlify에 빌드+배포 할 깃헙 리파지토리를 선택해주자. 아마 요 설정에서 어떻게 해야할지 막막(?)할 것이다.github.io를 버리고 갑자기 도메인 이전을 하면 이전 사용자가 혼란을 겪을 수 있으므로 우선 master 브랜치는 냅두고, 별도의 브랜치(나의 경우엔 netlify)를 팠다.만약 신규로 깃헙 페이지를 파는 경우에는 master 브랜치를 바라보게 하면 될 것이다. 그리고 빌드 명령어도 어떻게 넣어야할지 애매할텐데 나의 경우에는 hexo clean &amp; hexo deploy; exit 0 명령을 때리는 npm 스크립트를 집어넣었다.hexo clean &amp; hexo deploy; exit 0를 넣어도 상관 없는데 뒤에 exit 0를 빼면 Build script returned non-zero exit code: 2라면서 빌드에 실패하게 된다.퍼블리시 디렉토리는 플랫폼(지킬, 헥소, 휴고, 등등) 별로 다를 가능성이 크니 직접 로컬에서 테스트 해보자.위 설정을 다 마쳤다면 deploy를 하자. 혹시 배포 중에 빌드 오류 등등이 일어날 지 모르니 배포 중인 항목을 선택해서 로그를 유심히 살펴보자.나의 경우에는 빌드하는데 2~3분 가량 걸렸고, CDN의 각 엣지 포인트에 배포되기까지는 5분 가량 걸린 것 같다. Setting 배포를 성공적으로 마쳤으면 저 해괴망측한 도메인으로 접속이 가능하다.우선 저 도메인부터 바꾸기 위해 site settings를 누르자.그리고 change site name을 눌러서 도메인 및 사이트 이름을 변경해주면 된다.하지만 여전히 *.netlify.com으로 세팅되기 때문에 커스텀 도메인을 사용하고 싶은 사람은 도메인 세팅 파트를 참조하자. 빌드와 배포 설정사이트 세팅을 통해서 들어온 페이지에서 좌측 탭을 보면 Build &amp; deploy가 있으니 그걸 클릭해서 들어가자. Deploy settings - 빌드 관련해서 브랜치, 배포 명령어 등등을 설정할 수 있다. Build environment variables - 귀찮으니 문서를 참고하자. Build hooks - 빌드하고 나서 incomming, outgoing web hook을 설정할 수 있다. Single page apps - 구글은 지원하지만 네이버는 지원하지 않는검색 엔진이 자바스크립트를 해석하지 못하는 경우 SEO 측면에서 SPA는 큰 결함을 가지는데 서버사이드 렌더링을 지원해주는 것 같다. Post processing - 가끔 보면 google analytics 등등의 경우에 헤드에 스크립트 등등을 삽입해야하는데 요런 코드들을 여기다가 심어놓으면 된다. Asset optimization - 사이트를 최적화해주면 된다고 보면 된다, 안 할 이유가 없으니 enable 시켜주자. Deploy notifications - 빌드 이벤트가 발생할 때 웹훅을 등록해놓는 설정이다. 도메인 세팅허접한 netlify 도메인에서 탈출할 시간이다.단돈 1331원이면 가능하니 (DNS) 1331원에 .com 도메인 사기 (feat. GoDaddy)를 참고해서 닷컴 도메인을 사두고 진행하자.이번엔 좌측 탭에서 Domain management를 클릭해주자. Custom domain에서 add custom domain을 선택하고 자신의 도메인을 등록하자. 아마 위와 같은 오류를 마주치게 될 것이다.오류 문구를 읽다보면 다음과 같은 문장과 마주하게 된다. Warning! With your current configuration, you won’t benefit from the full advantages of a CDN if you use an A record. We recommend changing your site’s custom domain to www.*.com, or switching to a DNS provider that supports ANAME or ALIAS records. GoDaddy의 경우에는 dns 관리에서 alias 레코드가 없고 a 레코드만 존재해서 뭔가 CDN의 이점을 충분히 못 받는 것 같아서 찜찜하고,www.*.com과 같이 사용하는 걸 권장한다는 것 같아서 뭔가 좀 그렇다. 따라서 Use Netlify DNS를 눌러서 CDN의 이점을 최대한(?) 누려보자!그러면 오류 메세지가 바뀌면서 어떤 네임서버를 추가해야하는지 알려준다.도메인의 DNS관리(GoDaddy의 경우 도메인 관리 - 해당 도메인의 DNS 관리로 들어와야 함)로 가서 네임서버를 변경하자. 저장을 누르고 약 5분이 지난 후 새로고침을 해보면 아래와 같이 해당 도메인으로 정상적인 접근이 가능하다는 것을 볼 수 있다. 아래로 내려서 HTTPS 탭에서 TLS(a.k.a SSL) 인증서를 붙이자.별도의 인증서가 없다면 Verify DNS configuration - Let’s Encrypt certificate를 클릭하자. (Let’s Encrypt 만만세)원래 Let’s Encrypt에서 발급한 인증서의 경우에는 30일 마다 주기적으로 갱신해줘야하는 귀챠니즘이 존재하는데 알아서 해주는 것 같다. Force HTTPS 탭에서는 http to https(reverse proxy)가 가능하다.당연히 안 해줄 이유가 없으므로 enable 시키자. 나머지 설정은 알아서 하자… 포스트 작성 시 주의사항깃헙 페이지로 포스트를 작성할 때 마크다운 문법으로 작성하고 포스트의 날짜도 정할 수 있는데빌드된 로그를 보면 zone.offset has been deprecated in favor of zone.utcOffset 이런 로그가 엄청 찍혀있고,실제 포스트 작성 날짜보다 하루 일찍 URL에 박혀서 배포가 나가는 경우가 있다.우리나라는 UTC+09:00를 쓰기 때문인지 가끔씩 포스트 작성 시간이 09시를 넘어가지 않으면 전날로 URL이 박혀서 배포가 나가게 된다.github page에 직접 운영할 때는 별 이슈가 없었지만, 앞으로 포스트 쓸 때는 각별히 주의를 해야할 것 같다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Web Server","slug":"Middle-end/Web-Server","permalink":"https://perfectacle.github.io/categories/Middle-end/Web-Server/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://perfectacle.github.io/tags/CDN/"},{"name":"CD","slug":"CD","permalink":"https://perfectacle.github.io/tags/CD/"}]},{"title":"(DNS) 1331원에 .com 도메인 사기 (feat. GoDaddy)","slug":"domain-register-godaddy","date":"2017-11-21T09:10:12.000Z","updated":"2022-10-30T08:42:16.379Z","comments":true,"path":"2017/11/21/domain-register-godaddy/","link":"","permalink":"https://perfectacle.github.io/2017/11/21/domain-register-godaddy/","excerpt":"웹 개발을 배울 때 항상 나만의 도메인을 가지고 싶었다.github.io 라는 간지나는 도메인을 가지고 있긴 했지만, 지킬 내장이라 hexo를 쓰는 나로선 조금의 불편함이 존재했다.따라서 io 도메인을 사려고 했지만 6만원이 넘어갔다…그래서 값은 싸지만 나름 구리지 않은 닷컴 도메인을 사기로 마음 먹고 가장 저렴한 곳을 찾았다. GoDaddy우선 기본적으로 회원가입을 진행해야 한다.나는 귀찮아서 소셜 로그인(페북)을 이용했다.그 이후에 메인 페이지로 가서 도메인을 검색하자.똑같은 도메인이라 하더라도 사람들이 많이 찾는 단어일 수록 가격이 높으니 적당한 단어(자신을 알릴 수 있는?)를 선택하자.","text":"웹 개발을 배울 때 항상 나만의 도메인을 가지고 싶었다.github.io 라는 간지나는 도메인을 가지고 있긴 했지만, 지킬 내장이라 hexo를 쓰는 나로선 조금의 불편함이 존재했다.따라서 io 도메인을 사려고 했지만 6만원이 넘어갔다…그래서 값은 싸지만 나름 구리지 않은 닷컴 도메인을 사기로 마음 먹고 가장 저렴한 곳을 찾았다. GoDaddy우선 기본적으로 회원가입을 진행해야 한다.나는 귀찮아서 소셜 로그인(페북)을 이용했다.그 이후에 메인 페이지로 가서 도메인을 검색하자.똑같은 도메인이라 하더라도 사람들이 많이 찾는 단어일 수록 가격이 높으니 적당한 단어(자신을 알릴 수 있는?)를 선택하자. 메인 페이지에서 도메인을 검색했다면 이런 페이지가 나온다.닷컴 도메인이 현재 가장 싸고 그나마 덜 구리므로 유니크한 닷컴 도메인이 나올 때까지 검색을 하고 카트에 추가를 클릭하고 카트로 이동하자.그리고 나서 뭔 필요없는 옵션들을 막 선택하라고 하는데 다 필요없다고 하자, 다 돈 든다. 그리고 최소 구매 단위인 1년을 선택하면 아마 12,800원이 찍힐 것이다.1331원에 구매했다면서 어그로 끌었다고 생각할 수도 있는데 프로모션 코드에 cjcgroupc를 넣자.만약 유효하지 않다고 나오면 GoDaddy 쿠폰 모음에서 쿠폰을 새로 받으면 된다. 가격이 1299원까지 떨어졌고 마스터&#x2F;비자 등등 해외 사이트 결제가 가능한 카드로 진행하면 된다. 아마 또 별도의 수수료가 있거나 해서 1331원까지 올라간 것 같다. 여기서 끝난 건 아니다. 도메인 관리 등등의 페이지로 가면 아래와 같이 이메일 인증해야 도메인을 관리할 수 있다고 한다. 그런데 이 버튼 눌러도 오는 이메일이라곤 결제 내역이나 지들 서비스 홍보하는 메일 뿐이다.이거 때문에 한시간 가까이 뻘짓을 했지만 이메일 전송을 누르고 1시간 정도 기다리면 된다.나도 이걸 몰라서 주말에 혼자서 돈날렸나 안절부절 했지만 1시간 후에 이메일 폭탄을 받았다. 이메일을 큐에다 쌓아 놓고 일괄 발송 처리하는 것 같은데 그 주기가 1시간 정도 걸리나보다.그리고 1년 단위로 도메인 자동 갱신(결제)이 걸려 있는데 이걸 풀어야 다음 번에도 싼 값에 갱신이 가능한 것 같다. 여기까지 마쳐야 도메인 관리가 가능해진다!","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Web Server","slug":"Middle-end/Web-Server","permalink":"https://perfectacle.github.io/categories/Middle-end/Web-Server/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://perfectacle.github.io/tags/DNS/"}]},{"title":"(DB) MySQL의 데이터를 Elasticsearch로 마이그레이션하기","slug":"mysql-to-elasitcsearch","date":"2017-11-06T14:40:55.000Z","updated":"2022-10-30T08:42:16.867Z","comments":true,"path":"2017/11/06/mysql-to-elasitcsearch/","link":"","permalink":"https://perfectacle.github.io/2017/11/06/mysql-to-elasitcsearch/","excerpt":"MySQL의 데이터를 Elasticsearch로 마이그레이션 할 때 다음과 같은 방법이 존재한다. 일일이 노가다로 집어넣기 Logstash의 logstash-input-jdbc 플러그인 사용하기. go-mysql-elasticsearch 사용하기. logstash-input-jdbc 같은 경우에는 다음과 같은 단점이 존재한다. 테이블 명 일일이 입력 테이블 별 프라이머리 키 일일이 입력 메모리도 많이 잡아먹고, 엄청나게 오래 걸림(성공해본 적이 단 한 번도… ㅜㅜ)","text":"MySQL의 데이터를 Elasticsearch로 마이그레이션 할 때 다음과 같은 방법이 존재한다. 일일이 노가다로 집어넣기 Logstash의 logstash-input-jdbc 플러그인 사용하기. go-mysql-elasticsearch 사용하기. logstash-input-jdbc 같은 경우에는 다음과 같은 단점이 존재한다. 테이블 명 일일이 입력 테이블 별 프라이머리 키 일일이 입력 메모리도 많이 잡아먹고, 엄청나게 오래 걸림(성공해본 적이 단 한 번도… ㅜㅜ) 하지만 단점만 존재하는 것은 아니고 SQL 쿼리문을 써서 사용할 데이터를 뽑아올 수 있다는 점이 큰 메리트라고 할 수 있다. go-mysql-elasticsearch의 장단점은 logstash-input-jdbc와 반대가 아닐까 싶다.따라서 go-mysql-elasticsearch를 토대로 마이그레이션하는 방법을 설명하겠다.(내가 Mac을 쓰므로 맥 기반으로 설명을…) 사전 설치 사항 MySQL Elasticsearch Git MySQL bin log 설정하기기본적으로 go-mysql-elasticsearch는 MySQL의 bin log를 토대로 싱크를 맞추기 때문에 설치하기 전에 bin log를 세팅해주자.기존적이르 replication DB(혹은 Slave DB) 말고 Master 쪽에 bin log를 만들어주자.replication DB(혹은 Slave DB)는 Master DB의 bin log를 토대로 싱크를 맞추기 때문에 Master DB 쪽에 bin log를 세팅해주는 게 정신 건강에 좋다. 먼저 MySQL의 설정을 고쳐야하는데 다음 커맨드로 설정 파일을 찾아낼 수 있다. 1234mysql --verbose --help | grep my.cnf# 그럼 아마 다음과 비슷한 결과가 나올 것이다.# /etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf 왼쪽에 있는 파일부터 순차적으로 참조하여 하나라도 걸리는 게 있으면 그 녀석이 설정 파일이 되는 것이다. 나의 경우에는 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf 파일을 제외하고 아무런 설정파일이 미존재 파일이라 해당 파일을 다음과 같이 수정해주었다. 12345[mysqld]bind-address = 127.0.0.1log-bin = mysql-binserver-id = 1001binlog_format = ROW log-bin은 bin log가 만들어질 경로이고, server-id는 go-mysql-elasticsearch와 맞춰줘야한다.또한 go-mysql-elasticsearch가 binlog_format &#x3D; ROW만 지원하므로 위와 같이 적어주자. 설정 파일을 바꿨으므로 MySQL을 다시 시작하자. 1mysql.server restart 서버가 재시작 됐다면 아래 쿼리를 입력해서 bin log가 제대로 생성되고 있는지 알아보자. 1SHOW VARIABLES LIKE &#x27;log_bin&#x27;; golang 설치하기우선 go-mysql-elasticsearch는 golang으로 만들어져있으므로 golang부터 설치해보자.설치는 다양한 방법이 있지만 가장 간단한 brew로 진행을 하겠다. 1brew install go Setting GOPATH를 참고하여 GOPATH를 지정해주자.본인이 bash를 쓰는지 zsh를 쓰는지 잘 판단해서 GOPATH를 지정해주자.그리고 해당 설정 파일에 다음과 같은 내용을 추가해주자.아래는 brew를 이용하여 설치한 GOPATH이니 버전과 본인이 설치한 버전에 맞춰서 GOPATH를 알맞게 지정해줘야한다. 1export GOPATH=/usr/local/Cellar/go/1.9.2 그리고 터미널을 새로 띄우거나 껐다 켜야 GOPATH가 제대로 잡히는데 아래 커맨드를 입력하면 새로고침(?) 효과가 있다. 123source ~/.zshrc# 또는 아래와 같이...# source ~/.bash_profile go-mysql-elasticsearch 설치하기해당 저장소의 Install을 보고 따라하면 된다.아래 명령어들을 따라 치자.혹시나 실험적 기능을 이용해보고 싶은 사람은 깃헙 주소를 github.com/perfectacle/go-mysql-elasticsearch과 같이 고쳐서 설치하자. 12345678# package github.com/siddontang/go-mysql-elasticsearch: no Go files in ... 이런 에러가 나면 무시해주자.go get github.com/siddontang/go-mysql-elasticsearch# cd: no such file or directory: ... 이런 에러가 나면 GOPATH가 제대로 설정되지 않은 것이니 PATH를 다시 잡거나 터미널을 다시 열고 시도해보자.$GOPATH/src/github.com/siddontang/go-mysql-elasticsearch# Makefile에 있는 스크립트들을 실행하는 커맨드이다. 코드를 수정하고 컴파일하려면 해당 커맨드를 실행해야한다.make 사용하기대충 문서 보고, 설정 예제 파일 보면 어떻게 해야할지 각이 나온다.DB와 테이블 관련 내용은 Source를 만지면 되고, 특정 컬럼만 싱크를 맞추는 등등의 복잡한 설정을 하려면 Rule를 만져야한다.또한 기본적으로 go-mysql-elasticsearch는 하나의 인덱스(RDS로 치면 DB)에 여러 타입(RDS로 치면 테이블)을 두는 게 아니라한 인덱스에 하나의 타입(테이블 명과 일치하게끔)을 넣는 걸 디폴트 동작으로 두었으니 하나의 인덱스에 다 때려박고 싶거나 한다면 위의 Rule 파트를 참조해야한다.또한 Wildcard table을 이용하면 테이블 이름을 일일이 입력해야하는 수고를 줄일 수 있는데, 아직은 그 기능이 좀 미약하다.혹시나 데이터베이스 내에 존재하는 모든 테이블의 싱크를 맞추고자 한다면 포크 뜬 저장소를 다시 go get 메소드로 받아서*.toml 파일에서 tables = [&quot;*&quot;]로 설정해주면 된다.모든 설정을 마쳤으면 아래 커맨드를 입력해서 123# 반드시 go-mysql-elasticsearch가 저장된 곳으로 이동 후에 아래 커맨드를 입력해야한다.# toml 파일의 디렉토리도 꼭 설정해주자../bin/go-mysql-elasticsearch -config=*.toml server_id를 모르는 경우AWS RDS의 경우 my.cnf를 수정하는 대신 Parameter Group를 정하게 되는데 거기서 server_id를 직접 지정하는 게 아니라 generate 되는 값이다.따라서 우리가 직접 지정하는 것이 아니기 때문에 어떤 값으로 generation 됐는지 확인하기 위해서는 아래 쿼리문을 실행해보고 *.toml 파일에 적용시켜주면 된다. 1SELECT @@server_id 리셋하기go-mysql-elasticsearch를 맨 처음에 켰을 때는 싱크가 아주 잘 맞는다.하지만 실수(?)로 해당 프로그램을 종료했다가 재시작하면 빈로그가 종료된 시점 이후의 데이터에 대해서만 싱크를 맞추기 시작한다.이럴 땐 *.toml 파일의 data_dir로 설정한 디렉토리로 가서 master.info 파일을 삭제한 후 프로그램을 재시작하면 된다. 실험적 기능go-mysql-elasticsearch 저장소로 풀리퀘를 날렸지만 나의 실력 미숙으로 인해 컨벤션이나 테스트 코드 등등의 부분이 부족하여 아직 머지되지 않은 기능들이다.그렇기 때문에 글을 작성하는 17&#x2F;11&#x2F;06에는 최신버전임을 장담하지만 그 이후에는 디프리케잇 된 버전이 될 가능성도 높다. 데이터베이스 내에 존재하는 모든 테이블을 싱크하는 기능간단하게 아래와 같이 tables에 *를 넣는 것만으로 가능하다. 123456[[source]]schema = &quot;test&quot;tables = [&quot;*&quot;]# *을 쓰면 테이블을 2개 이상 넣으면 오류가 난다.# tables = [&quot;*&quot;, &quot;table&quot;] Primary Key가 없는 테이블 싱크 안 맞추기만약 Primary Key가 없는 테이블이 있는 경우, *으로 모든 테이블과 동기화를 맞추는데 다음과 같은 에러와 마주치게 될 것이다..../go-mysql-elasticsearch/river/river.go:244: schema.table must have a PK for a column그럼 또 일일이 PK가 존재하는 테이블을 입력해야한다.이런 수고를 미연에 방지하고자 *.toml 파일에서 아래 속성만 true로 바꿔주면 PK가 없는 테이블은 자동 무시하게 된다. 12# Primary Key가 없는 테이블은 무시skip_non_pk = true","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"Elasticsearch","slug":"Back-end/DB/Elasticsearch","permalink":"https://perfectacle.github.io/categories/Back-end/DB/Elasticsearch/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://perfectacle.github.io/tags/MySQL/"},{"name":"DB","slug":"DB","permalink":"https://perfectacle.github.io/tags/DB/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://perfectacle.github.io/tags/Elasticsearch/"}]},{"title":"(자알쓰) call by value vs call by reference","slug":"js-014-call-by-value-vs-call-by-reference","date":"2017-10-30T21:43:03.000Z","updated":"2022-10-30T08:42:16.691Z","comments":true,"path":"2017/10/30/js-014-call-by-value-vs-call-by-reference/","link":"","permalink":"https://perfectacle.github.io/2017/10/30/js-014-call-by-value-vs-call-by-reference/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 네 번째 시리즈는 call by value vs call by reference를 주제로 진행하겠다. call by 뭐시기…?Call by 뭐시기 하는 것은 평가 전략(Evaluation Strategy) 중에 하나이며 위키피디아에서는 아래와 같이 서술하고 있다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 네 번째 시리즈는 call by value vs call by reference를 주제로 진행하겠다. call by 뭐시기…?Call by 뭐시기 하는 것은 평가 전략(Evaluation Strategy) 중에 하나이며 위키피디아에서는 아래와 같이 서술하고 있다. 프로그래밍 언어에서 함수 호출의 아규먼트(argument)의 순서를 언제 결정하고 함수에 어떤 종류의 값을 통과시킬지 결정하는 것 즉 함수에 인자로 뭘 던지느냐에 따라서 함수가 어떻게 실행될지에 대한 방법?을 결정하는 것이라고 보면 된다.여러가지 호출 방법들이 있지만 오늘은 대표적인 call by value와 call by reference에 대해 살펴보도록 하자. parameter vs arguments우선 call by value에 들어가기에 앞서서 parameter(매개변수)와 arguments(인자)에 대해 짚고 넘어가자.parameter는 formal parameter(형식 매개변수)로 인식하면 되고, arguments는 actual parameter(실인자)로 받아들이면 된다.간단하게 예제로 살펴보자. 123456var a = 1;var func = function(b) &#123; // parameter, formal parameter, 매개변수, 형식 매개변수 // code...&#125;;func(a); // arguments, actual parameter, 인자, 실인자 parameter, formal parameter, 매개변수, 형식 매개변수는 b가 되는 것이고,실제로 넘어가는 값인 arguments, actual parameter, 인자, 실인자는 1이 되는 것이다. parameter는 함수 선언부에 정의되고, arguments는 함수 호출부에서 사용된다. call by value위키피디아에서는 call by value를 다음과 같이 설명하고 있다. Call by value (also referred to as pass by value) is the most common evaluation strategy, used in languages as different as C and Scheme. In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). If the function or procedure is able to assign values to its parameters, only its local copy is assigned—that is, anything passed into a function call is unchanged in the caller’s scope when the function returns. 영어가 잘 안 되니 대충 call by value의 설명을 요약해보자면 다음과 같다. arguments로 값이 넘어온다. 값이 넘어올 때 복사된 값이 넘어온다. caller(호출하는 녀석)가 인자를 복사해서 넘겨줬으므로 callee(호출당한 녀석)에서 해당 인자를 지지고 볶아도 caller는 영향을 받지 않는다. 간단한 예제로 살펴보자. 123456var a = 1;var func = function(b) &#123; // callee b = b + 1;&#125;func(a); // callerconsole.log(a); // 1 기본적으로 자바스크립트는 원시값을 arguments로 넘겨주면 call by value의 형태로 작동한다.따라서 caller가 1을 arguments로 넘겨줘도 그 값은 복사되어 넘어오기 때문에 callee 내부에서 지지고 볶고 해도 전혀 영향을 받지 않아서 결과적으로 a 값은 원래 값인 1이 찍히게 된다. call by reference위키피디아에서는 call by reference를 다음과 같이 설명하고 있다. Call by reference (also referred to as pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value. This typically means that the function can modify (i.e. assign to) the variable used as argument—something that will be seen by its caller. Call by reference can therefore be used to provide an additional channel of communication between the called function and the calling function. A call-by-reference language makes it more difficult for a programmer to track the effects of a function call, and may introduce subtle bugs. 역시나 영어가 부족하니 대충 call by reference를 요약해보자면 다음과 같다. arguments로 **reference(값에 대한 참조 주소, 메모리 주소를 담고있는 변수)**를 넘겨준다. reference를 넘기다 보니 해당 reference가 가리기는 값을 복사하지는 않는다. caller(호출하는 녀석)가 인자를 복사해서 넘기지 않았으므로 callee(호출당한 녀석)에서 해당 인자를 지지고 볶으면 caller는 영향을 받는다. 간단한 예제로 살펴보자. 123456var a = &#123;&#125;;var func = function(b) &#123; // callee b.a = 1;&#125;func(a); // callerconsole.log(a.a); // 1 기본적으로 자바스크립트는 참조 타입을 arguments로 넘겨주면 call by reference의 형태로 작동한다.따라서 caller가 객체 a를 parameter로 넘겼을 때 실제 arguments로 넘어오는 값은 객체 a에 대한 reference이지 복사된 객체 a가 아니다.따라서 callee 내부에서 지지고 볶고 하면 영향을 받기 때문에 조심해서 사용해야한다.라고들 오해하고 있다. call by sharingcall by reference에서 끝날 줄 알았는데 뜬금없이 sharing까지 나와버렸다.이게 왜 나왔는지는 아래 예제를 한번 봐보자. 123456var a = &#123;&#125;;var func = function(b) &#123; // callee b = 1;&#125;func(a); // callerconsole.log(a); // &#123;&#125; 참조 타입을 넘겼는데 값이 변하지 않았다.바로 자바스크립트에서는 무조건 call by value로 작동하기 때문이다.사람들이 참조 타입을 넘기면 call by reference로 작동한다고 알고 있고, 위 코드가 그 생각이 오해임을 명백하게 밝혀주고 있다.자바스크립트(자바, 루비, 파이썬 등등도 마찬가지…)에서는 참조 타입을 인자로 넘기면 참조값에 대한 복사본을 만들어서 넘긴다. 이해하기 쉽게 도식화 하면 다음과 같다. 메모리 주소는 임의로 지정. 변수 a에 담기는 것은 객체 {}가 담겨있는 메모리 주소 0x12이다. (원시값이 아닌 참조 타입이기 때문) a에 대한 참조값을 복사한 value(b)가 새로 생성된다.아직까지는 이 참조된 값이 {} 객체를 가리키고 있다. = 연산자로 참조값을 재할당하기 때문에 기존에 참조하던 {}에서 1로 참조 대상이 변경되었다. C++을 배웠던 사람이라면 알고있던 call by value와는 다르단 느낌에 매우 혼동을 하게 된다.따라서 이런 혼동을 줄이고자 call by sharing이 등장한 것 같다. Quiz(댓글 유도 작전)그렇다면 아래 예제의 결과는 무엇일까?그 이유까지 한 번 적어보도록 하자! (제발 ㅠㅠ) 1234567var a = &#123;&#125;;var func = function(b) &#123; b = (b.a=1); b.b = 2;&#125;func(a);console.log(a); // ?? 결론 자바스크립트에서 call by reference는 존재하지 않고 call by value만 존재한다. 참조 타입을 인자로 넘기면 참조값에 대한 복사본이 넘어간다. 이러한 혼동을 줄이고자 call by sharing이란 용어로 부르기도 한다. 참조 링크 Is Java “pass-by-reference” or “pass-by-value”? 자바의 아규먼트 전달 방식 Java 인자 전달 방식: Call-by-{Value | Reference}?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"}]},{"title":"(HTTP) 상태 코드 - 307 vs 308","slug":"http-status-code-307-vs-308","date":"2017-10-16T20:29:58.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2017/10/16/http-status-code-307-vs-308/","link":"","permalink":"https://perfectacle.github.io/2017/10/16/http-status-code-307-vs-308/","excerpt":"redirect를 위한 HTTP 상태 코드 301과 302에 대해 잘 모르겠다면 아래 링크를 참고하고 글을 읽도록 하자.301리디렉션 &amp; 302리디렉션의 차이(사용법) 307 Temporary Redirect vs 308 Permanent Redirect307은 302와 유사하고, 308은 301과 유사하다.다만 차이점이 있다면 전송 받은 HTTP Method를 유지한다는 것이다.301과 302는 redirect 시킬 때 method를 get으로 바꿔서 전송한다.따라서 get 요청을 보낼 때는 문제가 없지만 post 메소드를 요청했을 때 문제가 발생할 수 있다.http to https redirect를 구현할 때 301 또는 302 상태 코드를 쓰게 되면http 프로토콜을 통해 post 메소드로 날아온 게 https 프토토콜을 통해 get 메소드로 변경되면서 컨트롤러나 라우터에 매핑되는 URI가 없어서 오류가 나게 된다.따라서 301 대신에 308을, 302 대신에 307을 쓰면 좀 더 안전하게 redirect 시킬 수 있다.또한 이제 301과 302를 redirect라는 명칭으로 부를 수도 없다.301은 Moved Permanently로, 302는 Found로 명칭이 변경되었다. 지금 당장 쓸 수 있나?","text":"redirect를 위한 HTTP 상태 코드 301과 302에 대해 잘 모르겠다면 아래 링크를 참고하고 글을 읽도록 하자.301리디렉션 &amp; 302리디렉션의 차이(사용법) 307 Temporary Redirect vs 308 Permanent Redirect307은 302와 유사하고, 308은 301과 유사하다.다만 차이점이 있다면 전송 받은 HTTP Method를 유지한다는 것이다.301과 302는 redirect 시킬 때 method를 get으로 바꿔서 전송한다.따라서 get 요청을 보낼 때는 문제가 없지만 post 메소드를 요청했을 때 문제가 발생할 수 있다.http to https redirect를 구현할 때 301 또는 302 상태 코드를 쓰게 되면http 프로토콜을 통해 post 메소드로 날아온 게 https 프토토콜을 통해 get 메소드로 변경되면서 컨트롤러나 라우터에 매핑되는 URI가 없어서 오류가 나게 된다.따라서 301 대신에 308을, 302 대신에 307을 쓰면 좀 더 안전하게 redirect 시킬 수 있다.또한 이제 301과 302를 redirect라는 명칭으로 부를 수도 없다.301은 Moved Permanently로, 302는 Found로 명칭이 변경되었다. 지금 당장 쓸 수 있나?MDN - 307 Temporary RedirectMDN - 308 Permanent Redirect클라이언트 측에서는 문제가 없어보인다. 308 응답 코드는 nginx 1.13.0에 추가되었다.하지만 aws ec2에서 nginx 버전을 확인하면 아래와 같이 나온다. 12nginx -v# nginx version: nginx/1.12.1 또한 yum으로 업데이트 때려봐도 이게 최신버전이라고 나온다.설치하려면 복잡하고 불안해서 못하겠다… Apache는 2부터 지원하는 것 같은데 정확히 몇 부터 지원하는지는 모르겠다…yum 으로 설치해도 사용이 가능한지는 모르겠다. (절대 귀찮아서 그러는 게 아님…) 마무으리의외로 클라이언트는 지원을 잘 하는데 웹서버가 지원을 안 해서 의외였다.What’s difference between HTTP 301 and 308 status codes?에 더 자세한 답변이 있고,Why doesn’t HTTP have POST redirect?도 참고하자.그리고 아래 그림이 정말 잘 정리가 돼있는 것 같다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Web Server","slug":"Middle-end/Web-Server","permalink":"https://perfectacle.github.io/categories/Middle-end/Web-Server/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://perfectacle.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://perfectacle.github.io/tags/HTTPS/"},{"name":"GET","slug":"GET","permalink":"https://perfectacle.github.io/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://perfectacle.github.io/tags/POST/"},{"name":"Web Server","slug":"Web-Server","permalink":"https://perfectacle.github.io/tags/Web-Server/"}]},{"title":"(ELB) HTTPS 서버를 열어보자","slug":"https-with-elb","date":"2017-10-05T17:50:29.000Z","updated":"2022-10-30T08:42:16.659Z","comments":true,"path":"2017/10/05/https-with-elb/","link":"","permalink":"https://perfectacle.github.io/2017/10/05/https-with-elb/","excerpt":"ELB가 요청 분산 및 오토 스케일링을 위한 것도 있지만 SSL 암호화 지원도 해줘서인스턴스에 SSL 인증서를 물리면 인스턴스에서 암&#x2F;복호화 등등의 리소스 낭비가 이뤄지지만 ELB에 물리면 ELB에서 다 처리되기 때문에서버 입장에서는 부담이 더 줄어들게 된다.하지만 역시 공짜는 아니니 Elastic Load Balancing 요금 파트를 참조하자.돈이 없거나(ㅜㅜ) 공부 목적이 있는 사람은 직접 EC2 인스턴스(서버)에 HTTPS 서버 열기를 참고하자. Certificate Manager(SSL 인증서)L4를 생성하기 전에 HTTPS 프로토콜을 위한 SSL 인증서를 만들어야한다.공짜라고 하니 걱정하지말고 만들자. Certificate Manager 서비스로 이동한다. 상단에 있는 인증서 요청 클릭 도메인 이름 입력(유효한 도메인인지 체크하지 않으므로 일단 원하는 도메인 입력) 검토 및 요청 클릭 후 확인 및 요청 클릭 후 계속 클릭. 인증서 검증 보류 상태인데 관리자 이메일로 인증서를 유효하게 만들 수 있는 이메일이 갔을 것이고, 그 이메일을 확인해서 인증서를 확인시켜주자. 상태가 발급완료로 뜨면 끝.","text":"ELB가 요청 분산 및 오토 스케일링을 위한 것도 있지만 SSL 암호화 지원도 해줘서인스턴스에 SSL 인증서를 물리면 인스턴스에서 암&#x2F;복호화 등등의 리소스 낭비가 이뤄지지만 ELB에 물리면 ELB에서 다 처리되기 때문에서버 입장에서는 부담이 더 줄어들게 된다.하지만 역시 공짜는 아니니 Elastic Load Balancing 요금 파트를 참조하자.돈이 없거나(ㅜㅜ) 공부 목적이 있는 사람은 직접 EC2 인스턴스(서버)에 HTTPS 서버 열기를 참고하자. Certificate Manager(SSL 인증서)L4를 생성하기 전에 HTTPS 프로토콜을 위한 SSL 인증서를 만들어야한다.공짜라고 하니 걱정하지말고 만들자. Certificate Manager 서비스로 이동한다. 상단에 있는 인증서 요청 클릭 도메인 이름 입력(유효한 도메인인지 체크하지 않으므로 일단 원하는 도메인 입력) 검토 및 요청 클릭 후 확인 및 요청 클릭 후 계속 클릭. 인증서 검증 보류 상태인데 관리자 이메일로 인증서를 유효하게 만들 수 있는 이메일이 갔을 것이고, 그 이메일을 확인해서 인증서를 확인시켜주자. 상태가 발급완료로 뜨면 끝. 쫀쫀(?)하게도 다운로드는 지원하지 않는다.AWS 내에서만 쓸 수 있는데 SSL 인증서를 요구하는 서비스들이 대부분 유료기 때문에 노림수로 만든 거 같다. ELB (L4, Load Balancer)L4로 요청을 보내면 로드 밸런싱 전략에 맞게 각각의 요청을 각 인스턴스에 맞게 분배시켜주는 역할을 한다.L4는 Layer 4, OSI 7계층의 4계층인 Transport Layer를 뜻하는 것 같다. EC2 서비스로 이동한다. 좌측 메뉴 중에 LOAD BALANCING - Load Balancers 메뉴로 이동한다. Create Load Balancer 버튼을 클릭하자. 세 가지가 나오는데 우리는 Application Load Balancer를 Create하면 된다.잘은 모르겠지만, Network Load Balancer는 대용량 처리를 위한 것 같고,Classic Load Balancer는 과거 방식(물리적인 서버를 구성해서 해당 서버를 로드 밸런서로 활용, 아마도 트래픽을 감당 못해서 그렇게 한 듯?)인데현재는 소프트웨어(nginx 같은 웹서버 등등)로 처리할 수 있을 정도로 많은 발전이 이뤄진 것 같다. Name은 L4를 식별하기 위한 이름,Scheme에서 internet-facing은 외부에서도 접근 가능한 것이고, internal은 내부에서만 사용하는 것인데 우리는 외부 접속을 위해서도 쓰므로 internet-facing을 선택.IP address type은 IPv4로도 충분하니 내비두자. 리스너 프로토콜은 보안을 위해 HTTP는 HTTPS로 리다이렉트를 위해 내비두고,Add Listener를 클릭해서 HTTPS(443 포트)도 추가해주. Availability Zones에서 VPC(IDC 같은 역할)어느 IDC에 존재하는 인스턴스를 이용할지 모르므로(확장성 고려?) Availability Zone을 모두 체크하고 Next! Certificate type &gt; Choose a certificate from ACM (recommended)를 선택하고(기본적으로 선택돼있긴 하지만…) SSL 인증서를 선택하고 Next! Security Group을 선택하고 Next! New Target Group으로 내비두고 이름 설정하고, Protocol은 HTTP로 target type은 instance로 하고 Next!실제 인스턴스에는 HTTPS를 위한 SSL 인증서를 물려놓은 게 아니므로 HTTP로 선택해야한다. 인스턴스 선택하고 80번 포트로 Add to registered 버튼 클릭으로 추가하고 Next하고 Create로 마무리 하자. 다시 로드 밸런서 서비스로 이동해서 해당 로드밸런서의 DNS Name을 카피해두자. Route 53 (도메인 등록)DNS용으로 사용하는 TCP&#x2F;UDP 포트로 53번 포트를 사용하는데 그것에 유래해서 Route 53이란 이름을 지은 것 같다. Route 53 서비스로 이동하자. Hosted zones로 이동해서 원하는 도메인 네임이 없으면 새로 생성하고, 도메인 네임을 클릭해서 들어가자. Name에 서브 도메인을 입력하고, Alias를 Yes로 체크한 후에 ELB의 DNS Name을 입력하고 Create를 클릭하면 된다. 웹서버 설정여기서는 nginx를 사용하지만 다른 서버도 비슷할 것으로 예상된다. 터미널을 이용해서 ELB에 물려놓은 EC2 인스턴스로 접속을 한다. nginx 서버에서 다음와 같이 설정을 해주어야한다.기본적인 설정 파일은 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;virtual.conf에 있다. 123456789101112131415161718192021server &#123; listen 80; server_name ~.; # ELB stores the protocol used between the client # and the load balancer in the X-Forwarded-Proto request header. # Check for &#x27;https&#x27; and redirect if not if ($http_x_forwarded_proto != &#x27;https&#x27;) &#123; rewrite ^ https://$host$request_uri? permanent; &#125; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header HOST $http_host; proxy_set_header X-NginX-Proxy true; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; proxy_redirect off; &#125;&#125; 이제 브라우저로 접속해서 http to https 및 SSL 인증서가 제대로 적용됐는지 확인해보면 된다. 마무리끝이다.혹시 공부 목적이거나 과금이 부담된다면 EC2 인스턴스(서버)에 HTTPS 서버 열기를 참고하자.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://perfectacle.github.io/tags/HTTPS/"},{"name":"ELB","slug":"ELB","permalink":"https://perfectacle.github.io/tags/ELB/"},{"name":"CertificateManager","slug":"CertificateManager","permalink":"https://perfectacle.github.io/tags/CertificateManager/"},{"name":"EC2","slug":"EC2","permalink":"https://perfectacle.github.io/tags/EC2/"},{"name":"Route53","slug":"Route53","permalink":"https://perfectacle.github.io/tags/Route53/"},{"name":"Nginx","slug":"Nginx","permalink":"https://perfectacle.github.io/tags/Nginx/"}]},{"title":"(Certbot) 공짜로 HTTPS 서버를 열어보자. (feat. AWS)","slug":"letsencrypt-with-certbot-feat-aws","date":"2017-10-05T15:47:46.000Z","updated":"2022-10-30T08:42:16.839Z","comments":true,"path":"2017/10/05/letsencrypt-with-certbot-feat-aws/","link":"","permalink":"https://perfectacle.github.io/2017/10/05/letsencrypt-with-certbot-feat-aws/","excerpt":"기본적으로 서버와 도메인(SSL 인증서에 넣을)은 확보가 돼있는 상태로 진행을 해야한다.자본이 빵빵하고(?) 좀 더 간단한 걸 원한다면 AWS ELB로 HTTPS 서버 열기를 보자.해당 포스트는 ELB 말고 인스턴스에 직접 도메인을 달고, 인스턴스에서 직접 HTTPS 서버를 서비스 하고자 하는 포스트이다. HTTPSHTTP 통신은 데이터를 암호화하지 않아서 보안에 취약하다.따라서 HTTPS 프로토콜로 통신을 해야하는데 암&#x2F;복호화를 하려면 키가 존재해야하고,그 키는 인증된 기관에서 만든 게 아니면 신뢰할 수 없는 키가 된다.이 키에 대한 정보가 SSL 인증서에 들어가있는 것이고 이 SSL 인증서를 발급해주는 기관들이 따로 있다.(사실 SSL의 이름은 TLS로 바뀌었지만 계속해서 SSL로 쓰이는 듯…)그런데 그 인증서를 발급해주는 기관에서는 돈을 받고 SSL 인증서를 발급해주고 일정 기간마다 돈을 추가로 내서 갱신해야한다. 공짜 SSL 인증서 발급기관","text":"기본적으로 서버와 도메인(SSL 인증서에 넣을)은 확보가 돼있는 상태로 진행을 해야한다.자본이 빵빵하고(?) 좀 더 간단한 걸 원한다면 AWS ELB로 HTTPS 서버 열기를 보자.해당 포스트는 ELB 말고 인스턴스에 직접 도메인을 달고, 인스턴스에서 직접 HTTPS 서버를 서비스 하고자 하는 포스트이다. HTTPSHTTP 통신은 데이터를 암호화하지 않아서 보안에 취약하다.따라서 HTTPS 프로토콜로 통신을 해야하는데 암&#x2F;복호화를 하려면 키가 존재해야하고,그 키는 인증된 기관에서 만든 게 아니면 신뢰할 수 없는 키가 된다.이 키에 대한 정보가 SSL 인증서에 들어가있는 것이고 이 SSL 인증서를 발급해주는 기관들이 따로 있다.(사실 SSL의 이름은 TLS로 바뀌었지만 계속해서 SSL로 쓰이는 듯…)그런데 그 인증서를 발급해주는 기관에서는 돈을 받고 SSL 인증서를 발급해주고 일정 기간마다 돈을 추가로 내서 갱신해야한다. 공짜 SSL 인증서 발급기관Let’s Encrypt라는 사이트에서 공짜로 SSL 인증서를 발급해준다.과거에는 어떻게 했는지 모르겠지만 지금은 Certbot이라는 프로그램을 통해서Let’s Encrypt의 SSL 인증서를 발급받을 수 있다.또한 Let’s Encrypt는 90일 동안만 유효한 SSL 인증서를 발급해주는데 Certbot을 이용하면 갱신이 매우 쉬워진다. Route 53(도메인) 설정하기기본적으로 도메인을 확보한 이후에 또 해야하는 게 있다.바로 해당 도메인에 대한 CAA(Certificate Authority Authorization) Record를 추가해야한다.SSLMate’s CAA Record Generator에 들어가면 만들 수 있다지만 들어가봐도 네트워크 지식이 없다보니 그냥 아래 스샷과 같이 만들었다. name에는 당연히 발급을 위한 도메인이 들어가야한다. CertbotCertbot 사이트에 들어가면 어떻게 설치하는지 나오지만 나도 헷갈려서 직접 정리해보았다.이 포스트에서는 OS는 Amazon Linux AMI와 웹서버는 nginx를 사용하였다. 혹시 커맨드를 입력했을 때 권한이 없다고 하면 귀찮으니까 root 유저로 진행하자. 1sudo su SSL 인증서를 발급받기 전에 nginx와 같은 웹서버는 무조건 중단해야한다. 1service nginx stop 이제 아래 커맨드를 입력해서 certbot 설치를 하자. 123curl -O https://dl.eff.org/certbot-autochmod +x certbot-automv certbot-auto /usr/bin/certbot-auto 그리고 실제 SSL 인증서를 발급받아보도록 하자.현재 AWS Linux는 아직 정식 지원이 아닌지 –debug를 붙여줘야한다. 12345678910111213certbot-auto certonly --standalone -d 발급받을도메인# 위 과정에서 이메일을 물어볼 수도 있다.# 아래와 같은 메시지가 나온다면 발급에 성공한 것이다.# IMPORTANT NOTES:# - Congratulations! Your certificate and chain have been saved at# /etc/letsencrypt/live/example.com/fullchain.pem. Your cert will# expire on 2018-mm-dd. To obtain a new version of the certificate in# the future, simply run Certbot again.# - If you like Certbot, please consider supporting our work by:# # Donating to ISRG / Let&#x27;s Encrypt: https://letsencrypt.org/donate# Donating to EFF: https://eff.org/donate-le 12There were too many requests of a given type :: Error creating new authz :: Too many invalid authorizations recently.Please see the logfiles in /var/log/letsencrypt for more details. 위와 같은 오류를 만났다면 단시간 내에 SSL 발급 요청을 너무 많이 했는데 모두유효하지 않은 요청이라 악의적이라 판단해서 해당 도메인에 대해 발급 요청이 일시 중단된 상태이다.1시간 가량 기다린 후에 진행하면 다시 되는 것 같다. 1234-- The following errors were reported by the server:Domain: &lt;my_domain&gt;Type: connectionDetail: CAA record for &lt;my_domain&gt; prevents issuance 위와 같은 오류는 도메인에 CAA record가 제대로 등록되지 않았다는 것이다.도메인명과 CAA 레코드에 제대로 된 값들이 들어갔는지 다시 확인해보자. 적용하기nginx 서버에서 다음와 같이 설정을 해주어야한다.기본적인 설정 파일은 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;virtual.conf에 있다. 12345server &#123; listen 80; server_name ~.; return 301 https://$host$request_uri;&#125; 80번 포트로 들어오면 다시 https로 리다이렉트 시키는 부분이다.301 redirect는 영구적으로 옮겼을 때 사용한다. 그리고 아래 부분에는 HTTPS 서버를 리스닝 하는 부분을 추가해주자. 123456789101112131415161718192021222324server &#123; server_name ~.; listen 443; ssl on; ssl_certificate /etc/letsencrypt/live/도메인/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/도메인/privkey.pem; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP; ssl_prefer_server_ciphers on; # 특정 포트로 다시 보내고 싶을 때 # location / &#123; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header HOST $http_host; # proxy_set_header X-NginX-Proxy true; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_pass http://127.0.0.1:8080; # proxy_redirect off; # &#125;&#125; 도메인 부분에 SSL 인증서를 발급받은 도메인을 입력하면 된다.그리고 실제 톰캣과 같은 WAS나 서버가 띄워져있는 포트로 보내려면 주석을 지우고 포트를 바꿔주면 된다.그리고 아래와 같이 nginx 서버를 재구동 하고 브라우저에서 도메인을 입력하고 http to https와 ssl 인증서가 제대로 적용됐는지 확인해보자. 123service nginx start# 혹시 재시작이 안 됐다면 아래 커맨드를 입력하자./etc/init.d/nginx restart 자동 갱신하기Certbot으로 발급 받았다 하더라도 Let’s Encrypt의 SSL 인증서를 발급받은 것이기 때문에 유효기간은 90일이다.따라서 수동으로 갱신할 때 명령어는 다음과 같다. 1certbot-auto renew 하지만 갱신일이 30일 이상 남은 경우에는 아래와 같은 오류를 보게될 것이다. 1Cert not yet due for renewal 따라서 테스트를 위해서는 –dry-run 옵션을 추가해야한다. 1certbot-auto renew --dry-run 하지만 이번에는 아래와 같은 오류가 나게 된다. 12produced an unexpected error: Problem binding to port 443: Could not bind to IPv4 or IPv6.. Skipping.All renewal attempts failed. The following certs could not be renewed 갱신하려는 인증서를 이미 nginx 서버에서 사용중이기 때문에 갱신이 불가능하다는 내용이다.따라서 nginx를 스탑하고 갱신하고 다시 start 해야하는데 귀찮으므로 hook 옵션을 제공해서 아래와 같이 사용하면 된다. 1certbot-auto renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot; --dry-run 드디어 아래와 같은 성공 메시지를 보게 될 것이다. 1Congratulations, all renewals succeeded. The following certs have been renewed: 하지만 아직 테스트 단계이므로 실제로 갱신이 이루어지지는 않는다.갱신일이 궁금하다면 아래 커맨드를 입력하면 된다. 1echo | openssl s_client -connect localhost:443 2&gt;/dev/null | openssl x509 -noout -dates 30일 남았는지 일일이 체크해서 갱신하기란 매우 귀찮다.따라서 매달 1일에 갱신하는 커맨드를 실행하게 끔 crontab을 사용하자. 12345678# 잡을 등록crontab -e# 그리고 아래 잡을 추가하고 저장하자.0 0 1 * * certbot-auto renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot;# 등록된 잡 목록 보기crontab -l crontab 규칙은 crontab.guru에서 확인할 수 있고, 직접 만들거나 결과를 예측해볼 수도 있다. 마무리끝이다.아직 나도 갱신일이 30일 넘게 남아서(사실 오늘 만들어봤지만…) 테스트를 해보지 않았다.나중에 시간이 지나면 잘 되는지 보고 다시 수정해봐야겠다.이 과정이 좀 어렵고 자본이 빵빵하다면(?) AWS ELB로 HTTPS 서버 열기를 보자.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://perfectacle.github.io/tags/HTTPS/"},{"name":"EC2","slug":"EC2","permalink":"https://perfectacle.github.io/tags/EC2/"},{"name":"Route53","slug":"Route53","permalink":"https://perfectacle.github.io/tags/Route53/"},{"name":"Nginx","slug":"Nginx","permalink":"https://perfectacle.github.io/tags/Nginx/"},{"name":"LetsEncrypt","slug":"LetsEncrypt","permalink":"https://perfectacle.github.io/tags/LetsEncrypt/"},{"name":"Certbot","slug":"Certbot","permalink":"https://perfectacle.github.io/tags/Certbot/"}]},{"title":"지도 API 성능 개선기","slug":"map-api-performance-improvement","date":"2017-09-28T23:29:16.000Z","updated":"2022-10-30T08:42:16.843Z","comments":true,"path":"2017/09/28/map-api-performance-improvement/","link":"","permalink":"https://perfectacle.github.io/2017/09/28/map-api-performance-improvement/","excerpt":"문제점 Time은 데이터 전체를 파싱하는데 걸린 시간이니 무시하고…트래픽이 13MB 남짓…사용자가 조건을 바꿔서 검색을 한다면 데이터 광탈범이 될 가능성이 다분한 상황이었다.","text":"문제점 Time은 데이터 전체를 파싱하는데 걸린 시간이니 무시하고…트래픽이 13MB 남짓…사용자가 조건을 바꿔서 검색을 한다면 데이터 광탈범이 될 가능성이 다분한 상황이었다. 응답 시간이 22초 남짓… 원인 파악쿼리 숙박 연동 최저가는 jooq로 불러오고 있고, 숙박 연동사 테이블은 jpa로 불러오고 있음.순수 네이티브 쿼리가 아닌 이상 퍼포먼스가 제대로 나오지 않을 것으로 판단됨. 실제로 필요한 건 특정 필드 뿐인데 모든 필드를 다 긁어오고 있어서 쿼리 실행속도가 느려진 것임. 용량 이 응답값에는 세 가지 문제점이 존재한다. 이 데이터를 줄였을 때 1MB 정도 가량이 줄어들었다. treeAllId라던지, clusterName이나 빈 배열 등등 다른 값들을 가지고 유추할 수 있는 값들을 제거하였다.딱히 이 부분에서는 데이터를 크게 줄일 수가 없었다. 이미지의 URL을 담고 있는 컬럼을 불러와서 필요한 정보만 뿌려주는 게 아니라 모든 데이터를 가공없이 뿌려주고 있었다.이 컬럼의 데이터가 하나의 딜에 대한 데이터의 3&#x2F;4 이상을 차지하고 있었다.대부분의 쓸 데 없는 데이터가 여기서 낭비되고 있었다. 문제 해결아예 API 서버로 따로 분리맵 API는 방대한 양의 데이터를 가져오므로 서버의 리소스 사용이 많아 아예 별도의 서버로 구축하기로 판단했다. 빠른 응답속도 보장클러스터와 딜을 함께 내려주다보니 초기에 유저가 기다려야하는 속도는 15~20초 남짓 대기해야한다. 굳이 딜 목록까지 내려 줄 필요가 없다고 판단이 들어서 클러스터(갯수 포함) 따로 딜 따로 내려주게 끔 API를 두 개로 분리하였다. 12/api/v4/map/hotel (클러스터)/api/v4/map/hotel/deals (딜, 기존 API) 클러스터를 그리기 위한 클러스터 API는 응답 속도가 1~2초 남짓이라 유저가 불편을 느끼지 못할 수준이다.유저가 방심(?)하는 사이에 몰래(?) 딜을 뿌려주는 API를 호출하고 있으면 웬만한 유저들에게는 불편함을 주지 않을 것이다. 중간 점검 아직 이정도 시간 가지고는 서비스 하기에는 무리가 있어 보였다. 캐싱하기딜들과 카테고리 ID를 매핑하는 부분과 숙박 딜의 실제 가격을 주입하는 부분은 애초부터 판매 중인 모든 딜에 대한 정보만 들고있으면 된다.즉, 조건에 구애받지 않는다는 뜻이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class Job &#123; private HotelDealMinPricesMapper hotelDealMinPricesMapper; private DealPartnersMapper dealPartnersMapper; private TreeDealMapMapper treeDealMapMapper; private CategoryIds categoryIds; private HotelPartnersAndPrices hotelPartnersAndPrices; @Inject public Job( HotelDealMinPricesMapper hotelDealMinPricesMapper, DealPartnersMapper dealPartnersMapper, TreeDealMapMapper treeDealMapMapper, CategoryIds categoryIds, HotelPartnersAndPrices hotelPartnersAndPrices ) &#123; this.hotelDealMinPricesMapper = hotelDealMinPricesMapper; this.dealPartnersMapper = dealPartnersMapper; this.treeDealMapMapper = treeDealMapMapper; this.categoryIds = categoryIds; this.hotelPartnersAndPrices = hotelPartnersAndPrices; &#125; /** crontab 1.Seconds 2.Minutes 3.Hours 4.Day-of-Month 5.Month 6.Day-of-Week 7.Year (optional field) */ @PostConstruct @Scheduled(cron = &quot;0 0 */2 * * ?&quot;) public void setLeisureAndHotelCategoryIds() &#123; categoryIds.setLeisureCategoryIds(treeDealMapMapper.selectLeisureCategoryId()); categoryIds.setHotelCategoryIds(treeDealMapMapper.selectHotelCategoryId()); &#125; @PostConstruct @Scheduled(cron = &quot;0 0 */2 * * ?&quot;) public void setPricesAndPartners() &#123; hotelPartnersAndPrices.setPartners(dealPartnersMapper.selectDealPartnersAll()); hotelPartnersAndPrices.setPrices(hotelDealMinPricesMapper.selectMinPricesAll()); &#125;&#125; 서버를 띄웠을 때 최초 1회, 2시간 마다 캐싱하도록 설정하였다. 또 다시 중간 점검 또 다시 캐싱 전략 세우기따라서 모든 딜의 LIST_IMAGE_JSON 컬럼 또한 캐시하도록 하였다. 123456@PostConstruct@Scheduled(cron = &quot;0 0 */2 * * ?&quot;)public void setDealsThumbnail() &#123; thumbs.setLeisureThumbs(dealMMapper.selectLeisureThumbnail()); thumbs.setHotelThumbs(dealMMapper.selectHotelThumbnail());&#125; 그리고 캐시한 썸네일과 DB에서 불러온 딜 목록을 매핑하도록 변경하였다. 123456public void mappingDealAndThumbnail(List&lt;DealInMap&gt; dealList, Map&lt;Long, String&gt; thumbs) &#123; for (DealInMap deal : dealList) &#123; String thumb = thumbs.get(deal.getId()); if(thumb != null) deal.setThumb(thumb); &#125;&#125; 하지만 여전히 2~4초 가량 걸리는 상황이었고, 숙박 연동사의 가격을 주입하는 부분은 쿼리문을 쓰지도 않는데 왜 이렇게 오래 걸리는지 한번 파보았다. 기본적으로 List에서 데이터를 검색할 때는 입력되는 데이터의 양에 따라 비례하여 처리시간이 증가하는 알고리즘 -O(N)- 이고,(ArrayList는 인덱스를 가지고 순차적으로 탐색하지 않지만 순차적인 숫자 이외에 인덱스를 가지지 않으므로 순서를 모르면 말짱꽝이다.)Map의 경우에는 key, value의 쌍으로 이루어져있어서 입력되는 데이터의 크기에 상관없이 항상 같은 처리 시간을 보장 받는 알고리즘 -O(1)- 이다.Big-O 표기법에 관해서는 초보자를 위한 Big O 표기법 따라잡기을 참고하자.따라서 해당 자료구조를 전부 해시맵으로 바꿔주었다. 딜 카운트를 세는 것까지 포함하다보니 빨간 박스 안에서 distinct를 쓰게 되었고 그로 인해 속도가 매우 느려졌다.따라서 클러스터 목록을 불러오는 부분도 다음과 같이 캐싱을 했다. 처음부터 모든 클러스터 목록을 다 불러온다. 12345678910SELECT ct.id treeId, cts.sub_category_tree_id treeAllId, ct.tree_code, cts.boundary_n, cts.boundary_e, cts.boundary_w, cts.boundary_sFROM DEAL_M dJOIN TREE_DEAL_MAP tdm ON d.id = tdm.deal_idJOIN CATEGORY_TREE ct ON tdm.category_tree_id = ct.id AND ct.tree_group_id = 27 AND 3 &gt; ct.depthJOIN CATEGORY_TREE_SPATIAL cts ON ct.id = cts.category_tree_idWHERE deal_status = &#x27;IN_SALE&#x27; AND d.display_yn = &#x27;Y&#x27; AND display_standard_yn = &#x27;Y&#x27; AND del_yn = &#x27;N&#x27; AND d.lat IS NOT NULL AND d.lon IS NOT NULL AND deal_type != &#x27;DEAL&#x27; 모든 딜들도 함께 다 불러온다. 123456789SELECT d.id, d.deal_nm, d.`STANDARD_PRICE`, d.zeropass_price, d.group_price, d.lat, d.lon, ct.`tree_code`, d.deal_typeFROM DEAL_M dJOIN TREE_DEAL_MAP tdm ON d.id = tdm.deal_idJOIN `CATEGORY_TREE` ct ON tdm.`CATEGORY_TREE_ID` = ct.id AND ct.tree_group_id = 27 AND ct.depth = 2WHERE deal_status = &#x27;IN_SALE&#x27; AND d.display_yn = &#x27;Y&#x27; AND display_standard_yn = &#x27;Y&#x27; AND del_yn = &#x27;N&#x27; AND d.lat IS NOT NULL AND d.lon IS NOT NULL AND deal_type != &#x27;DEAL&#x27; 1과 2를 일정 시간 간격으로 캐싱한다. 123456789@PostConstruct@Scheduled(cron = &quot;0 0 */2 * * ?&quot;)private void setLeisureCache() &#123; List&lt;Cluster&gt; clusters = Cluster.group(clusterAndDealMapper.selectForClusters(true)); List&lt;DealInMap&gt; deals = clusterAndDealMapper.selectForClustersWithDeals(true); clusterCache.setLeisureClusters(clusters); clusterCache.setLeisureClustersWithDeals(clustersWithDeals);&#125; 요청이 들어오면 필터링 조건에 부합하는 딜의 ID만 구한다.distinct나 group by로 중복된 딜을 제거할 수 있으나 성능 이슈가 있어서 자바에서 중복 딜을 제거하는 방향으로 개발함. 12SELECT deal_id FROM HOTEL_DEAL_MIN_PRICESWHERE expire_at &gt; now() AND ymd BETWEEN &#x27;2017-10-11&#x27; AND &#x27;2017-10-14&#x27; AND max_capacity &gt;= 1 캐싱한 딜 목록과 조건에 부합하는 딜 ID 목록을 비교하여 조건에 맞는 딜들만 남긴다. 딜과 클러스터를 매핑하고 딜의 갯수를 구한다. 조건에 구애 받지 않는 모든 쿼리를 캐싱하고 최소한의 쿼리만 날리고 데이터들을 매핑하게 끔 하다보니 0.5초 내외로 시간을 단축시킬 수 있었다. 차후 개선 사항 (시간 문제 및 공수와 효율성 문제) 2MB로 줄였다 하더라도 필터를 계속해서 바꾸다 보면 유저 입장에서는 부담되는 용량일 수도 있다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Dev","slug":"Note/Dev","permalink":"https://perfectacle.github.io/categories/Note/Dev/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://perfectacle.github.io/tags/Performance/"},{"name":"API","slug":"API","permalink":"https://perfectacle.github.io/tags/API/"}]},{"title":"(Spring Boot) Gradle의 Profile(dev/production)을 구분지어보자.","slug":"Spring-boot-gradle-profile","date":"2017-09-23T09:06:20.000Z","updated":"2022-10-30T08:42:16.115Z","comments":true,"path":"2017/09/23/Spring-boot-gradle-profile/","link":"","permalink":"https://perfectacle.github.io/2017/09/23/Spring-boot-gradle-profile/","excerpt":"메이븐은 기본적으로 빌드할 때 프로필을 지정할 수 있는 것 같은데 gradle은 직접 삽질을 하면서 깨달았다.다음의 글들을 보고 Spring boot 1.5.7과 Gradle 3.x(아마)? 에 맞게, 내 입맛에 맞게 각색해보았다. Gradle 배포 환경 별 설정파일 분리 Gradle에서 서버별 패키징 하기 Profile 구성하기기본적인 스프링 부트 프로젝트는 다음과 같은 구조를 가질 것이다.","text":"메이븐은 기본적으로 빌드할 때 프로필을 지정할 수 있는 것 같은데 gradle은 직접 삽질을 하면서 깨달았다.다음의 글들을 보고 Spring boot 1.5.7과 Gradle 3.x(아마)? 에 맞게, 내 입맛에 맞게 각색해보았다. Gradle 배포 환경 별 설정파일 분리 Gradle에서 서버별 패키징 하기 Profile 구성하기기본적인 스프링 부트 프로젝트는 다음과 같은 구조를 가질 것이다. 123456789101112+ project명 + src + main + java + package명 - Application.java + resources - application.properties + test- build.gradle- gradlew- gradlew.bat 이를 다음과 같이 나눠보자. 1234567891011121314151617+ project + src + main + java + package - Application.java + resources - application-core.properties + resources-env + dev - application.properties + prod - application.properties + test- build.gradle- gradlew- gradlew.bat …&#x2F;resources에는 공통적으로 쓰는 설정들이 들어가면 된다.application-core.properties에는 테스트 삼아서 다음과 같이 저장해주자. 12spring.profiles.active=corecore=core …&#x2F;resources-env&#x2F;dev에는 개발에 필요한 파일들만 들어가면 된다.application.properties에는 테스트 삼아서 다음과 같이 지정해주자. 1test=dev …&#x2F;resources-env&#x2F;prod에는 개발에 필요한 파일들만 들어가면 된다.application.properties에는 테스트 삼아서 다음과 같이 지정해주자. 1test=prod build.gradle 수정하기123456789ext.profile = (!project.hasProperty(&#x27;profile&#x27;) || !profile) ? &#x27;dev&#x27; : profilesourceSets &#123; main &#123; resources &#123; srcDirs &quot;src/main/resources&quot;, &quot;src/main/resources-env/$&#123;profile&#125;&quot; &#125; &#125;&#125; profile 속성의 기본값은 dev이고 그 값에 따라서 리소스 폴더를 지정하는 것이다.resources 폴더는 공통적으로 쓰이는 설정 파일들이기 때문에 공통적으로 들어가면 된다. 샘플 예제는 다음과 같다. 12345678910111213141516171819202122232425262728293031323334353637383940buildscript &#123; ext &#123; springBootVersion = &#x27;1.5.7.RELEASE&#x27; &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;apply plugin: &#x27;java&#x27;apply plugin: &#x27;eclipse&#x27;apply plugin: &#x27;org.springframework.boot&#x27;// 이 위치 전에 profile을 구분하는 구문이 오면 오류가 난다.group = &#x27;com.example&#x27;version = &#x27;0.0.1-SNAPSHOT&#x27;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile(&#x27;org.springframework.boot:spring-boot-starter&#x27;) testCompile(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125;ext.profile = (!project.hasProperty(&#x27;profile&#x27;) || !profile) ? &#x27;dev&#x27; : profilesourceSets &#123; main &#123; resources &#123; srcDirs &quot;src/main/resources&quot;, &quot;src/main/resources-env/$&#123;profile&#125;&quot; &#125; &#125;&#125; properties를 사용하는 스프링 빈 만들기project&#x2F;src&#x2F;main&#x2F;java&#x2F;package명 아래에 Bean.java를 만들어주자. 123456789101112131415@Componentpublic class Bean &#123; @Value(&quot;$&#123;core&#125;&quot;) private String core; @Value(&quot;$&#123;test&#125;&quot;) private String test; @PostConstruct private void method() &#123; System.out.println(&quot;--------------------------------&quot;); System.out.println(core); System.out.println(&quot;--------------------------------&quot;); System.out.println(test); System.out.println(&quot;--------------------------------&quot;); &#125;&#125; @PostConstruct 어노테이션을 사용해서 간단하게 스프링 컨텍스트?가 로딩된 이후에 메소드를 실행하게 했다.또한 스프링 빈으로 등록해야 profile에 있는 값을 불러올 수 있으므로 @Component 어노테이션을 사용했다.@Value 어노테이션은 profile에 등록된 값을 얻어오는 녀석이다. 실행하기당연히 터미널에서 프로젝트 디렉토리로 이동해야한다. Gradle CLI 사용하기 1234#! prodSPRING_PROFILES_ACTIVE=core gradle clean bootRun -Pprofile=prod#! devSPRING_PROFILES_ACTIVE=core gradle clean bootRun …&#x2F;resources 디렉토리 내의 properties 파일을 뒤져서 spring.profiles.active가 core인 녀석을 찾아서 적용시킨다는 내용이다.또한 profile이라는 매개변수에 prod를 인자로 넘긴다는 뜻이다.profile의 기본값을 dev로 지정해줬기 때문에 dev용 bootRun에서는 빼줘도 된다. Gradlew 사용하기 1234#! prodSPRING_PROFILES_ACTIVE=core ./gradlew clean bootRun -Pprofile=prod#! devSPRING_PROFILES_ACTIVE=core ./gradlew clean bootRun graldew는 Gradle CLI 설치 안 한 사람, 혹은 Gradle의 버전에 의존하지 않고 항상 동일한 Gradle 버전으로 빌드&#x2F;실행고 싶을 때 매우 유용하다.gradlew를 이용하기 위해서는 gradle&#x2F;wrapper 디렉도리에 있는 gradle-wrapper.properties와 gradle-wrapper.jar 파일이 필요하다.따라서 해당 디렉토리를 .gitignore에 등록하는 불상사를 일으키지 말자. IDE 사용하기IDE를 사용하면 GUI라는 친숙한 환경, 클릭 한 번으로 여러 환경 변수와 설정을 넣어서 실행할 수 있다는 장점이 있다.물론 AWS나 CLI만 지원하는 환경이라면 위의 두 방법을 활용해야할 것이다.인텔리제이(갓텔리제이)를 찬양 경배하므로 갓텔리제이로 설명. Name에는 프로덕션용으로 bootRun prod를 넣어주고, Gradle project에 project 이름(자동완성 됨)을 입력하고,우측 상단의 Single instance only를 체크해서 서버는 하나만 뜨게 하자.(중복 실행 방지, 포트 충돌 방지)tasks에는 실행할 태스크를 입력하면 되는데 bootRun이 spring boot를 실행하는 태스크이다.그리고 Arguments에 해당 인자를 넘겨야 prod profile이 적용되고,Environment Variables에 SPRING_PROFILES_ACTIVE&#x3D;core까지 지정해줘서 core profile까지 사용하도록 하자.또한 task가 실행되기 전에 clean task를 실행해야하므로 좌하단에 보이는 노란색 박스에 있는 + 버튼을 눌러주자. production과 동일한데 Arguments에 인자를 넘길 필요가 없다.왜냐하면 dev profile이 기본값이기 때문이다. 위 방법으로 실행해보면 prod&#x2F;dev에 따라 다른 결과가 나오는 부분도 있고 core에서 불러온 값은 항상 동일하다. 빌드하기SPRING_PROFILES_ACTIVE&#x3D;core가 빠진 이유는 빌드할 때는 리소스(profile이 담긴) 디렉토리는 지정할 수 있지만profile 파일 자체를 지정할 수는 없기 때문이고, 실행할 때 넘겨줘야한다. Gradle CLI 사용하기 1234#! prodgradle clean build -Pprofile=prod#! devgradle clean build Gradlew 사용하기(Gradle CLI 설치 안 한 사람) 1234#! prod./gradlew clean build -Pprofile=prod#! dev./gradlew clean build IDE 사용하기 실행하기의 IDE 사용하기 파트를 참고해서 내용을 채워넣자. 실행하기의 IDE 사용하기 파트를 참고해서 내용을 채워넣자. 왜 이렇게 빌드해야하는 걸까? 다른 방식으로 하게되면 개발용&#x2F;프로덕션용 리소스(+코어 리소스는 필수이므로 제외) 두 개 다 포함되게 된다.그럼 개발 서버의 jar 파일이 털렸을 때 압축파일만 풀면 프로덕션 DB 정보 등등까지 알아낼 수 있게 된다.따라서 보안 측면에서 이렇게 좀 귀찮게(?) 빌드해야하는 것이다. 빌드한 결과물을 실행하기서버에 jar(던 war던) 파일을 배포해서 실행을 할 때는 다음과 같이 하면 된다. 1java -jar -Dspring.profiles.active=core application.jar 테스트 코드 작성하기test 디렉토리로 가서 기본적으로 만들어진 테스트 클래스를 다음과 같이 수정해주자. 123456789101112131415@ActiveProfiles(&quot;core&quot;)@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; @Value(&quot;$&#123;core&#125;&quot;) private String core; @Value(&quot;$&#123;test&#125;&quot;) private String test; @Test public void contextLoads() &#123; assertThat(core, is(&quot;core&quot;)); assertThat(test, is(&quot;dev&quot;)); &#125;&#125; class 이름은 본인이 만든 거에 맞게 설정하고, 테스트 툴은 JUnit4를 사용하였다.(스프링 부트 기본 내장)@ActiveProfiles를 넣어서 spring.profiles.active&#x3D;core인 profile을 찾는 것이다.또한 테스트를 실행할 때 profile 매개변수를 넘기지 않았으므로(모든 테스트에 다 넘기려면 ㅎㄷㄷ…) 기본값인 dev profile이 적용된다.스프링 컨텍스트가 제대로 로드됐는지 확인하기 위해 @Value 어노테이션으로 profile에 저장된 값을 불러오고 그걸 검증하는 테스트 코드를 짜봤다. 이거 때문에 총 삽질한 시간만 8시간 이상은 되는 것 같다.또 정리만 3시간 이상을… 또르르… ㅠㅠ","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"https://perfectacle.github.io/tags/Gradle/"}]},{"title":"(Spring Boot) get/post 리퀘스트를 다뤄보자.","slug":"Spring-boot-get-post-mapping","date":"2017-09-19T09:50:51.000Z","updated":"2022-10-30T08:42:16.111Z","comments":true,"path":"2017/09/19/Spring-boot-get-post-mapping/","link":"","permalink":"https://perfectacle.github.io/2017/09/19/Spring-boot-get-post-mapping/","excerpt":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. 컨트롤러를 만들자Node.js(+Express)의 Router와 매우 유사한 것 같다.URI와 http method, parameter만 매핑해주는 녀석이다. 1234567891011121314151617181920212223242526import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value = &quot;/api&quot;)public class Controller &#123; @GetMapping(&quot;/&quot;) public Person sayHello( @RequestParam String name, @RequestParam int age, @RequestParam(required = false) String hobby ) &#123; Person person = new Person(); person.setHobby(hobby); person.setName(name); person.setAge(age); return person; &#125; @PostMapping(&quot;/&quot;) public void sayHello( @RequestBody Person person ) &#123; System.out.println(person.getAge()); System.out.println(person.getHobby()); &#125;&#125;","text":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. 컨트롤러를 만들자Node.js(+Express)의 Router와 매우 유사한 것 같다.URI와 http method, parameter만 매핑해주는 녀석이다. 1234567891011121314151617181920212223242526import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value = &quot;/api&quot;)public class Controller &#123; @GetMapping(&quot;/&quot;) public Person sayHello( @RequestParam String name, @RequestParam int age, @RequestParam(required = false) String hobby ) &#123; Person person = new Person(); person.setHobby(hobby); person.setName(name); person.setAge(age); return person; &#125; @PostMapping(&quot;/&quot;) public void sayHello( @RequestBody Person person ) &#123; System.out.println(person.getAge()); System.out.println(person.getHobby()); &#125;&#125; @RestController에 대한 설명은 링크를 참조하자. get일 때는 파라미터를 URI에 실어서 보내고, post일 때는 body에 실어보내면 된다.나는 큰 착각을 한 게 post로 보낼 때는 대부분 json으로 보내는 경우가 많다보니json의 프로퍼티와 컨트롤러에 매핑된 함수의 파라미터가 유사할 줄 알았다.하지만 요청 json과 유사한 형태의 VO(Value Object)? TO(Transfer Object)? DO(Domain Object)?를 만들어야하는데 셋 중에 뭐가 맞는 말인지 모르겠다. VO? TO? DO?여튼 만들어보자.Person이라는 클래스를 만들면 된다. 12345678910111213141516171819202122232425public class Person &#123; private String name; private int age; private String hobby; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getHobby() &#123; return hobby; &#125; public void setHobby(String hobby) &#123; this.hobby = hobby; &#125;&#125; 이와 매핑되는 리퀘스트 json은 다음과 같을 것이다. 12345&#123; &quot;name&quot;: &quot;양간장&quot;, &quot;age&quot;: 20, &quot;hobby&quot;: &quot;자전거 타기&quot;&#125; 요청&#x2F;응답하기실제 서버를 띄우고 이제 포스트맨을 가지고 장난질을 해보자. 요청 헤더: get http://localhost:8080/api/?name=양권성&amp;age=22응답: 1234&#123; &quot;age&quot;: 22, &quot;hobby&quot;: null&#125; 왜 name은 안 뜨는 걸지 골똘히 고민해보자. 요청 헤더: post http://localhost:8080/api/ Content-Type=application/json요청 바디: 12345&#123; &quot;name&quot;: &quot;양간장&quot;, &quot;age&quot;: 20, &quot;hobby&quot;: &quot;자전거 타기&quot;&#125; 결론Request Body에 json으로 데이터를 실어 보낼 때 주의해야한다.무조건 DO(아니면 VO 또는 TO)를 만들고 그걸 파라미터로 받자.multipart나 FormData로 전송하는 경우는 나중에 다뤄봐야겠다.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"}]},{"title":"(Spring Boot) properties 값을 불러와보자","slug":"Spring-boot-properties-use","date":"2017-09-18T09:15:10.000Z","updated":"2022-10-30T08:42:16.119Z","comments":true,"path":"2017/09/18/Spring-boot-properties-use/","link":"","permalink":"https://perfectacle.github.io/2017/09/18/Spring-boot-properties-use/","excerpt":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. propertiesNode.js로 서버를 구성하다보면 포트 등등의 설정 정보를 json으로 저장하듯이 스프링 부트에서는 properties 파일을 사용하는 것 같다.물론 YAML 파일로도 만들 수 있는 것 같은데 일단 아는 게 properties 파일이다보니 그걸로 진행해보겠다.우선 스프링 부트를 만들면 기본 파일인 application.properties 파일을 아래와 같이 구성해보자. 1key=&quot;asdf&quot;","text":"근본없이 궁금한 부분만 찾아서 공부하다보니 아직 정리가 덜 된 글이다 보니 그 점은 감안하고 보길 바란다. propertiesNode.js로 서버를 구성하다보면 포트 등등의 설정 정보를 json으로 저장하듯이 스프링 부트에서는 properties 파일을 사용하는 것 같다.물론 YAML 파일로도 만들 수 있는 것 같은데 일단 아는 게 properties 파일이다보니 그걸로 진행해보겠다.우선 스프링 부트를 만들면 기본 파일인 application.properties 파일을 아래와 같이 구성해보자. 1key=&quot;asdf&quot; properties 사용하는 클래스 만들기이제 이걸 사용하는 클래스를 만들어보자. 12345678910111213141516import org.springframework.stereotype.Component;import org.springframework.beans.factory.annotation.Value;@Componentpublic class Tests &#123; @Value(&quot;$&#123;key&#125;&quot;) private String key; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125;&#125; 눈여겨 볼 어노테이션이 두 개 있다. Component스프링에서 관리하는 빈이라는 걸 알려주기 위한 어노테이션인 것 같다.자바 빈과 스프링 빈은 차이가 있다.자바 빈은 기본 생성자가 있고, getter, setter 메소드가 있고 등등의 특징이 있는 클래스인 것 같다.스프링 빈은 스프링 컨테이너(?)에 의해 관리되는 객체들을 스프링 빈이라고 부르는 것 같다.(자세한 설명은 Difference JavaBean and Spring bean을 참고하자.)여튼 properties에 있는 값을 사용하려면 둘이 스프링에 의해 같이 관리돼야하기 때문에클래스를 스프링 빈으로 등록해야하는 것 같다.자세하게는 모르겠다 ㅠㅠ@Bean vs @Component을 보면 둘 사이에도 명확한 차이가 있는 것 같은데 링크를 참조해보자. (나도 잘 모르니 ㅠㅠ) Valueproperties의 어느 속성을 적용할지 정하는 것 같다. 테스트 코드로 테스트 하기1234567891011121314151617import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.inject.Inject;import static org.hamcrest.core.Is.is;import static org.junit.Assert.*;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestsTest &#123; @Inject private Tests tests; @Test public void test() &#123; assertThat(&quot;asdf&quot;, is(tests.getKey())); &#125;&#125; Test test = new Test();와 같은 방식 대신에 @Inject 어노테이션을 사용했다.@Autowired와 동일한 역할을 한다고 한다.다만 Inject는 자바에서 지원하는 표준 어노테이션이고, Autowired는 스프링에서 지원해주는 것 같다.build.gradle의 dependency에 compile(&#39;javax.inject:javax.inject:1&#39;) 을 추가하면 된다.자세한 설명은 아래 링크를…Spring MVC 어노테이션 기반 설정 - 2 . @Autowired 결론중요한 것은 @Component, @Value, @Inject(@Autowired) 라는 점을 생각하자!","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - property 태그","slug":"spring-di-v2","date":"2017-09-05T09:35:53.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2017/09/05/spring-di-v2/","link":"","permalink":"https://perfectacle.github.io/2017/09/05/spring-di-v2/","excerpt":"beans.xml 파일을 수정해보자. 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;koreanTire&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;&gt; &lt;property name=&quot;tire2&quot; ref=&quot;koreanTire&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; beans의 property는 getter&#x2F;setter와 매핑이 된다.Car.java를 수정해보자. 1234567891011121314// Car.javapublic class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire2() &#123; return tire; &#125; public void setTire2(Tire tire) &#123; this.tire = tire; &#125;&#125;","text":"beans.xml 파일을 수정해보자. 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;koreanTire&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;&gt; &lt;property name=&quot;tire2&quot; ref=&quot;koreanTire&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; beans의 property는 getter&#x2F;setter와 매핑이 된다.Car.java를 수정해보자. 1234567891011121314// Car.javapublic class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire2() &#123; return tire; &#125; public void setTire2(Tire tire) &#123; this.tire = tire; &#125;&#125; Driver.java를 수정해보자. 123456789101112// Driver.javaimport org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Driver &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;/src/beans.xml&quot;); Car car = (Car)context.getBean(&quot;car&quot;); car.getTire2().wheel(); &#125;&#125; property를 지정했기 때문에 koreanTire가 DI됐다. 참조 블로그 - 스프링을 통한 의존성 주입 - 스프링 설정 파일(xml)에서 속성 주입","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - @Autowired","slug":"spring-di-v3","date":"2017-09-05T09:02:25.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2017/09/05/spring-di-v3/","link":"","permalink":"https://perfectacle.github.io/2017/09/05/spring-di-v3/","excerpt":"Car 클래스를 수정해보자. 12345678910public class Car &#123; @Autowired private Tire tire33; public Tire getTire() &#123; return tire33; &#125; public void setTire(Tire tire) &#123; this.tire33 = tire; &#125;&#125; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;bean id=&quot;tire33&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;/&gt;&lt;/beans&gt; @Autowired 한 멤버 변수와 bean의 id가 매칭되는 걸 볼 수 있다.또한 &lt;context:annotation-config &#x2F;&gt;을 추가해줘야하고, property 태그의 생략이 가능하다.","text":"Car 클래스를 수정해보자. 12345678910public class Car &#123; @Autowired private Tire tire33; public Tire getTire() &#123; return tire33; &#125; public void setTire(Tire tire) &#123; this.tire33 = tire; &#125;&#125; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;bean id=&quot;tire33&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;/&gt;&lt;/beans&gt; @Autowired 한 멤버 변수와 bean의 id가 매칭되는 걸 볼 수 있다.또한 &lt;context:annotation-config &#x2F;&gt;을 추가해줘야하고, property 태그의 생략이 가능하다. 참조 블로그 - 스프링을 통한 의존성 주입 - @Autowired 를 통한 속성 주입","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"(Spring) 자바 빈즈 객체를 XML 파일로 관리하면서 DI하기 - 기본","slug":"spring-di-v1","date":"2017-09-04T09:35:22.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2017/09/04/spring-di-v1/","link":"","permalink":"https://perfectacle.github.io/2017/09/04/spring-di-v1/","excerpt":"일반 자바를 가지고 DI를 해본 v3에서는 Car 클래스를 자바 빈즈 스펙을 제대로 준수해서 만들지 않았다.따라서 한 번 자바 빈즈 스펙에 맞춰 바꿔보자. 12345678910111213public class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire() &#123; return tire; &#125; public void setTire(Tire tire) &#123; this.tire = tire; &#125;&#125; getter&#x2F;setter와 기본 생성자가 있어야 자바 빈즈 스펙을 준수한 것이었는데 저번에는 기본 생성자가 없어서 추가했다.그럼 이제 beans.xml 파일을 만들고 자바 빈즈 객체들을 등록해보자. 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;tire&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;/&gt;&lt;/beans&gt;","text":"일반 자바를 가지고 DI를 해본 v3에서는 Car 클래스를 자바 빈즈 스펙을 제대로 준수해서 만들지 않았다.따라서 한 번 자바 빈즈 스펙에 맞춰 바꿔보자. 12345678910111213public class Car &#123; private Tire tire; public Car() &#123;&#125; public Car(Tire tire) &#123; this.tire = tire; &#125; public Tire getTire() &#123; return tire; &#125; public void setTire(Tire tire) &#123; this.tire = tire; &#125;&#125; getter&#x2F;setter와 기본 생성자가 있어야 자바 빈즈 스펙을 준수한 것이었는데 저번에는 기본 생성자가 없어서 추가했다.그럼 이제 beans.xml 파일을 만들고 자바 빈즈 객체들을 등록해보자. 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;tire&quot; class=&quot;KoreanTire&quot;/&gt; &lt;bean id=&quot;americanTire&quot; class=&quot;AmericanTire&quot;/&gt; &lt;bean id=&quot;car&quot; class=&quot;Car&quot;/&gt;&lt;/beans&gt; id 부분에는 식별할 수 있는 이름을 적고, class에는 패키지와 클래스명 포함 풀 경로를 적어주면 된다. 1234567891011121314// Driver.javaimport org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Driver &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;/src/beans.xml&quot;); Car car = (Car)context.getBean(&quot;car&quot;); Tire tire = (Tire)context.getBean(&quot;tire&quot;); car.setTire(tire); car.getTire().wheel(); &#125;&#125; xml에서 id가 tire인 애만 바꾸면 컴파일을 다시 하지 않아도 타이어의 교체가 가능해진다.하지만 여기서 코드가 더 줄어들을 수 있다.v2에서 확인해보자~ 참조 블로그 - 스프링을 통한 의존성 주입 - XML 파일 사용","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - 생성자 함수","slug":"di-v2","date":"2017-09-04T09:20:46.000Z","updated":"2022-10-30T08:42:16.375Z","comments":true,"path":"2017/09/04/di-v2/","link":"","permalink":"https://perfectacle.github.io/2017/09/04/di-v2/","excerpt":"v1에는 재사용 가능한 코드가 있음에도 불구하고 미묘(?)한 차이 때문에 계속 각국의 타이어를 장착한 자동차 클래스를 만들어야하는 단점이 있었다.이는 자동차를 만들 때 이미 타이어를 만드는 방법이 결정되어 있기 때문에 발생하는 문제이다.(**자동차(전체)**가 **타이어(부분)**에 의존하고 있는 코드)즉, 자동차를 만들 때 타이어를 만드는 방법을 결정하면 되는 사항이다.(**의존하는 부분(타이어)**을 **전체(자동차)**에 주입시키는 패턴) 1234// Tire.javapublic interface Tire &#123; void wheel();&#125; 123456// KoreanTire.javapublic class KoreanTire implements Tire &#123; public void wheel() &#123; System.out.println(&quot;구르다&quot;); &#125;&#125; 123456// AmericanTrie.javapublic class AmericanTire implements Tire &#123; public void wheel() &#123; System.out.println(&quot;wheel&quot;); &#125;&#125;","text":"v1에는 재사용 가능한 코드가 있음에도 불구하고 미묘(?)한 차이 때문에 계속 각국의 타이어를 장착한 자동차 클래스를 만들어야하는 단점이 있었다.이는 자동차를 만들 때 이미 타이어를 만드는 방법이 결정되어 있기 때문에 발생하는 문제이다.(**자동차(전체)**가 **타이어(부분)**에 의존하고 있는 코드)즉, 자동차를 만들 때 타이어를 만드는 방법을 결정하면 되는 사항이다.(**의존하는 부분(타이어)**을 **전체(자동차)**에 주입시키는 패턴) 1234// Tire.javapublic interface Tire &#123; void wheel();&#125; 123456// KoreanTire.javapublic class KoreanTire implements Tire &#123; public void wheel() &#123; System.out.println(&quot;구르다&quot;); &#125;&#125; 123456// AmericanTrie.javapublic class AmericanTire implements Tire &#123; public void wheel() &#123; System.out.println(&quot;wheel&quot;); &#125;&#125; 1234567// Car.javapublic class Car &#123; Tire tire; Car(Tire tire) &#123; // 매개변수의 다형성을 사용 this.tire = tire; &#125;&#125; 12345678910111213public class Driver &#123; public static void main(String[] args) &#123; KoreanTire koreanTire = new KoreanTire(); AmericanTire americanTire = new AmericanTire(); Car car = new Car(koreanTire); car.tire.wheel(); // 구르다 car.tire = americanTire; // 아래와 같은 것도 되니 바로 멤버 변수에 접근해서 설정하는 것은 추천하지 않는다. // car.tire = null; car.tire.wheel(); // wheel &#125;&#125; 이렇게 되면 Tire 클래스들만 쭉쭉 추가하면 되고 Car 클래스는 각국 별로 만들 필요가 없어지게 된다.또한 tire 교체도 가능하지만 올바른 값이 들어왔는지 유효성 검사할 방법이 없다.그럼 v3에서는 이러한 문제점을 개선해보도록 하자. 참조 블로그 - 생성자를 통한 의존성 주입","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"https://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - setter","slug":"di-v3","date":"2017-09-04T09:20:46.000Z","updated":"2022-10-30T08:42:16.379Z","comments":true,"path":"2017/09/04/di-v3/","link":"","permalink":"https://perfectacle.github.io/2017/09/04/di-v3/","excerpt":"v2에는 자동차를 생산할 때 어떤 타이어를 만들지 정할 수 있고 새로운 타이어로 교체도 가능했다.하지만 올바른 값이 들어왔는지 유효성 검사할 방법이 없다.사실 변경할 수는 있지만 안전하지 않고 그닥 권장하는 방법이 아니다. 123456789101112131415161718// Car.javapublic class Car &#123; private Tire tire; Car(Tire tire) &#123; this.tire = tire; &#125; // setter로 유효성 검사를 위해선 어쩔 수 없이(?) tire를 얻기 위해선 getter를 써야함. public Tire getTire() &#123; return tire; &#125; // setter로 다음과 같이 유효성 검사가 가능해짐. public void setTire(Tire tire) &#123; if(tire == null) throw new NullPointerException(); this.tire = tire; &#125;&#125; 1234567891011// Driver.javapublic class Driver &#123; public static void main(String[] args) &#123; KoreanTire koreanTire = new KoreanTire(); AmericanTire americanTire = new AmericanTire(); Car car = new Car(koreanTire); car.getTire().wheel(); // 구르다 car.setTire(americanTire); car.getTire().wheel(); // wheel &#125;&#125; setter를 사용해 좀 더 안전하게(?) 타이어를 교체할 수 있게 되었다.대부분 getter&#x2F;setter를 사용하는 이유는 아마 다음과 같을 것이다.","text":"v2에는 자동차를 생산할 때 어떤 타이어를 만들지 정할 수 있고 새로운 타이어로 교체도 가능했다.하지만 올바른 값이 들어왔는지 유효성 검사할 방법이 없다.사실 변경할 수는 있지만 안전하지 않고 그닥 권장하는 방법이 아니다. 123456789101112131415161718// Car.javapublic class Car &#123; private Tire tire; Car(Tire tire) &#123; this.tire = tire; &#125; // setter로 유효성 검사를 위해선 어쩔 수 없이(?) tire를 얻기 위해선 getter를 써야함. public Tire getTire() &#123; return tire; &#125; // setter로 다음과 같이 유효성 검사가 가능해짐. public void setTire(Tire tire) &#123; if(tire == null) throw new NullPointerException(); this.tire = tire; &#125;&#125; 1234567891011// Driver.javapublic class Driver &#123; public static void main(String[] args) &#123; KoreanTire koreanTire = new KoreanTire(); AmericanTire americanTire = new AmericanTire(); Car car = new Car(koreanTire); car.getTire().wheel(); // 구르다 car.setTire(americanTire); car.getTire().wheel(); // wheel &#125;&#125; setter를 사용해 좀 더 안전하게(?) 타이어를 교체할 수 있게 되었다.대부분 getter&#x2F;setter를 사용하는 이유는 아마 다음과 같을 것이다. 자바 빈즈 스펙이기 때문 유효성 검사나 get 하기 전에 처리할 내용이 있기 때문아마 생각 없이 1번 때문에, 아니면 getter와 setter가 그냥 습관이 된 경우가 대부분일 것이다.순수 자바라면 여기서 끝냈을테지만, 이 방법도 타이어를 교체하려면 계속 컴파일 해야한다는 단점이 있다.스프링으로 이런 자바 빈즈 객체를 XML 파일로 관리해서 DI 하는 방법을 쓰면 컴파일 하지 않고 타이어를 교체할 수 있다. 참조 블로그 - 속성을 통한 의존성 주입","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"https://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"Dependency Injection(의존성 주입)을 알아보자 - 막코딩 하기","slug":"di-v1","date":"2017-09-04T09:05:54.000Z","updated":"2022-10-30T08:42:16.375Z","comments":true,"path":"2017/09/04/di-v1/","link":"","permalink":"https://perfectacle.github.io/2017/09/04/di-v1/","excerpt":"이 글은 의존성 주입을 전혀 적용하지 않은, 의존성 주입이 뭔지 모르는 상태로 짠 코드이다.우선 문제점을 먼저 파악해봐야 뭐가 되지 않을까 싶어서 막코딩을 해봤다고 가정해보자.우선 미국산 타이어가 장착된 자동차, 한국산 타이어가 장착된 자동차를 만들어야한다고 생각해보자.그럼 우선 미국산, 한국산 타이어 클래스 두 개가 필요할 것이다. 123456// KoreanTire.javapublic class KoreanTire &#123; public void wheel() &#123; System.out.println(&quot;구르다&quot;); &#125;&#125; 123456// AmericanTire.javapublic class AmericanTire &#123; public void wheel() &#123; System.out.println(&quot;wheel&quot;); &#125;&#125; 그리고 각각 미국산 타이어를 장착한 자동차, 한국산 타이어를 장착한 자동차 클래스 두 개를 만들면 끝난다.","text":"이 글은 의존성 주입을 전혀 적용하지 않은, 의존성 주입이 뭔지 모르는 상태로 짠 코드이다.우선 문제점을 먼저 파악해봐야 뭐가 되지 않을까 싶어서 막코딩을 해봤다고 가정해보자.우선 미국산 타이어가 장착된 자동차, 한국산 타이어가 장착된 자동차를 만들어야한다고 생각해보자.그럼 우선 미국산, 한국산 타이어 클래스 두 개가 필요할 것이다. 123456// KoreanTire.javapublic class KoreanTire &#123; public void wheel() &#123; System.out.println(&quot;구르다&quot;); &#125;&#125; 123456// AmericanTire.javapublic class AmericanTire &#123; public void wheel() &#123; System.out.println(&quot;wheel&quot;); &#125;&#125; 그리고 각각 미국산 타이어를 장착한 자동차, 한국산 타이어를 장착한 자동차 클래스 두 개를 만들면 끝난다. 12345678// KoreanCar.javapublic class KoreanCar &#123; KoreanTire koreanTire; KoreanCar() &#123; koreanTire = new KoreanTire(); &#125;&#125; 1234567// AmericanCar.javapublic class AmericanCar &#123; AmericanTire AmericanTire; AmericanCar() &#123; AmericanTire = new AmericanTire(); &#125;&#125; 그리고 이제 이 차를 운전할 사람들을 만들어보자.(한국차를 구매한다고 가정) 1234567// Driver.javapublic class Driver &#123; public static void main(String[] args) &#123; KoreanCar koreanCar = new KoreanCar(); koreanCar.koreanTire.wheel(); // 구르다 &#125;&#125; 프로그램은 완성됐고 개발은 끝났다.하지만 영국, 일본, 중국, 태국, 방글라데시, 보스니아 헤르체고비나 등등의 타이어를 장착한 자동차를 만들어야한다면…?클래스는 기하 급수적으로 늘어날 것이고 동일한 코드들이 반복되는데도 불구하고 재사용이 불가능한 코드이므로 계속 자동차, 드라이버 클래스들을 만들어야한다.이런 코드를 보고 유연하지 못하다고 한다. (사교성이 안 좋은 코드이기도 하다 ㅎㅎ…)그럼 v2에서는 이러한 문제점을 개선해보도록 하자. 참조 블로그 - 프로그래밍에서 의존성이란?","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"https://perfectacle.github.io/categories/Middle-end/Pattern/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"}]},{"title":"(JazzHop) redpest - Sleepy time beats","slug":"jazz-hop-sleepy-time-beats","date":"2017-08-28T22:07:11.000Z","updated":"2022-10-30T08:42:16.667Z","comments":true,"path":"2017/08/28/jazz-hop-sleepy-time-beats/","link":"","permalink":"https://perfectacle.github.io/2017/08/28/jazz-hop-sleepy-time-beats/","excerpt":"","text":"봄의 향그러운 느낌을 한껏 품은 비트다.들으면 잠이 쏟아질 것 같지만 1시간을 넘게 들어도 잠이 안 올 때는 잘 안 온다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"음악","slug":"기타/음악","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9D%8C%EC%95%85/"}],"tags":[{"name":"Jazz","slug":"Jazz","permalink":"https://perfectacle.github.io/tags/Jazz/"},{"name":"Hiphop","slug":"Hiphop","permalink":"https://perfectacle.github.io/tags/Hiphop/"},{"name":"JazzHop","slug":"JazzHop","permalink":"https://perfectacle.github.io/tags/JazzHop/"},{"name":"Lofi","slug":"Lofi","permalink":"https://perfectacle.github.io/tags/Lofi/"},{"name":"Chill","slug":"Chill","permalink":"https://perfectacle.github.io/tags/Chill/"},{"name":"Sleepy","slug":"Sleepy","permalink":"https://perfectacle.github.io/tags/Sleepy/"}]},{"title":"자바 vs 자바스크립트","slug":"java-vs-javascript","date":"2017-08-19T20:43:58.000Z","updated":"2022-10-30T08:42:16.663Z","comments":true,"path":"2017/08/19/java-vs-javascript/","link":"","permalink":"https://perfectacle.github.io/2017/08/19/java-vs-javascript/","excerpt":"이 글은 자바와 자바스크립트를 혼동하는 사람, 차이점이 궁금한 사람 등을 위하여 쓴 글입니다.또한 자바스크립트는 다른 언어에 비해 어떤 단점이 있으며 그 단점들을 어떻게 극복해야할지에 대해 다뤄봤습니다. 하고 싶은 말 세 줄 요약. 자바스크립트 !&#x3D;&#x3D; 자바(자바 !&#x3D; 자바스크립트), 자바와 자바스크립트는 같지 않다.두 언어 간에는 접점이 크지 않고, 자바스크립트는 자바의 인기에 편승할 목적(마케팅 목적)으로 이름을 지은 것 뿐입니다. 자바 커뮤니티 가서 자바스크립트 질문하거나 자바스크립트 커뮤니티 가서 자바 질문을 하는 건 자제해주세요.하지 말라는 건 아닌데 질문자 분께서 원하시는 답(틀린 답을 얻을 수도 있고), 양질의 답을 얻을 가능성, 그리고 빠른 응답을 받기가 힘드실 수 있습니다. 제발 자바 스크립트(Java Script)라고 적어서 혼란을 초래하지 말아주세요.제발 제발 부탁드립니다. 가끔 보면 화(…)가 날 때도 있습니다.위와 같이 쓰시는 분들 때문에 이런 혼란이 더 초래되는 것 같습니다.새로 배우시는 분들께 잘못된 인식을 심어주는 것도 굉장히 위험하다고 보니 제발 부탁드리겠습니다. 목차","text":"이 글은 자바와 자바스크립트를 혼동하는 사람, 차이점이 궁금한 사람 등을 위하여 쓴 글입니다.또한 자바스크립트는 다른 언어에 비해 어떤 단점이 있으며 그 단점들을 어떻게 극복해야할지에 대해 다뤄봤습니다. 하고 싶은 말 세 줄 요약. 자바스크립트 !&#x3D;&#x3D; 자바(자바 !&#x3D; 자바스크립트), 자바와 자바스크립트는 같지 않다.두 언어 간에는 접점이 크지 않고, 자바스크립트는 자바의 인기에 편승할 목적(마케팅 목적)으로 이름을 지은 것 뿐입니다. 자바 커뮤니티 가서 자바스크립트 질문하거나 자바스크립트 커뮤니티 가서 자바 질문을 하는 건 자제해주세요.하지 말라는 건 아닌데 질문자 분께서 원하시는 답(틀린 답을 얻을 수도 있고), 양질의 답을 얻을 가능성, 그리고 빠른 응답을 받기가 힘드실 수 있습니다. 제발 자바 스크립트(Java Script)라고 적어서 혼란을 초래하지 말아주세요.제발 제발 부탁드립니다. 가끔 보면 화(…)가 날 때도 있습니다.위와 같이 쓰시는 분들 때문에 이런 혼란이 더 초래되는 것 같습니다.새로 배우시는 분들께 잘못된 인식을 심어주는 것도 굉장히 위험하다고 보니 제발 부탁드리겠습니다. 목차 자바스크립트의 어원 자바스크립트의 탄생 목적 자바의 탄생 배경 Oak 자바 자바스크립트는 인터프리트 언어이다?? 자바는 컴파일 언어다?? 자바스크립트 언어와 자바의 공통점?? 왜 자바스크립트 보고 구리다고 할까?? 자바스크립트는 멀티 패러다임 언어이다. 객체 지향 프로그래밍 관점에서의 자바스크립트 함수형 프로그래밍 관점에서의 자바스크립트 자바스크립트는 더 이상 예전의 자바스크립트가 아니다. 자바스크립트를 배우기 전에 잘 만들어진 프로그래밍 언어를 먼저 배우는 것을 추천하는 이유 자바스크립트의 어원자바스크립트가 처음 개발할 때부터 자바스크립트였던 건 아니었다.초기에 자바스크립트는 Mocha라는 이름으로 개발되다 추후에 Livescript라는 이름으로 변경되었다.그러다 자바라는 언어가 인기가 많아지자 그 인기에 편승할 목적, 즉 마케팅 목적으로 자바스크립트라는 이름으로 변경 후 세상에 나오게 되었다.당시 자바의 개발사인 썬 마이크로시스템과 자바스크립트의 개발사인 넷 스케이프 사는 ‘자바 라이센스’를 공동으로 소유하고 있어서 이런 일이 가능하였다. 자바스크립트의 탄생 목적해당 언어의 탄생 목적을 보면 어떤 경우에 해당 언어를 써야할지가 명확해진다. 과거 웹사이트는 사용자와 상호 작용이 불가능했으며, 페이지가 상당히 정적인 모습을 띄었다.따라서 다음과 같은 것들이 불가능하였다. 자바스크립트의 탄생 목적은 이렇듯 페이지의 동적 제어였다.다른 프로그래밍 언어(Java, C 등등)의 경우 하나의 완성된 프로그램을 만들 목적으로 만들어진 언어에 비해 그 목적 자체가 달랐다.하지만 자바스크립트라는 언어에서 보듯이 자바스크립트는 스크립트 언어이다.스크립트 언어는 일반적인 프로그래밍 언어와 달리 하나의 완성된 프로그램보다는 프로그램 사이에 들어가는, 기존의 프로그램들을 제어하거나 보조하는 용도로 많이 쓰인다. 자바의 탄생 배경Oak(오크)가전제품에 탑재될 소프트웨어를 만들어야해서 C++을 확장해서 사용하려 했지만 C++로는 부적합하였다.따라서 C++의 장점을 도입, 단점을 보완한 Oak라는 언어를 만들게 되었다.Oak는 운영체제에 독립적이라는 장점이 있어 멀티 플랫폼을 지원할 수 있었다.따라서 가전제품이나 PDA와 같은 소형 기기에 탑재될 목적으로 Oak라는 언어를 만들고 있었다. 자바여러 종류의 운영체제를 사용하는 컴퓨터들이 통신하는 인터넷이 등장하자운영체제에 독립적인 Oak가 이에 적합하다고 판단하여 Oak를인터넷에 적합하도록 그 개발 방향을 바꾸면서 이름을 Java로 변경하였다.따라서 백엔드, 서버 쪽 진영을 보면 그렇게 자바를 많이 쓰는 이유가 자바가 웹에 적합한 언어이기 때문이다.또한 오래 전 만들어졌기 때문에 안정성과 다양한 커뮤니티가 형성된 것도 한 몫하는 것 같다. 자바스크립트는 인터프리트 언어이다??(자알쓰) JIT 컴파일을 참조하자. 자바는 컴파일 언어다??컴파일하면 소스 코드를 기계어로 변환하는 과정이라고 알고 있는데, 엄밀히 말하면 자바는 소스코드를 기계어로 변환하지 않는다.자바는 소스 코드를 각 자바 바이트 코드로 변환한다.그 이후 JVM(Java Virtual Machine)이 그 자바 바이트 코드를 기계어로 변환한다.즉 실행할 때 마다 매번 자바 바이트 코드를 기계어로 변환하는 JIT 컴파일 방식을 취한다. 자바스크립트 언어와 자바의 공통점??자바와 자바스크립트가 공통점이 많아서 자바스크립트라고 이름을 붙였다고 주장을 할 수도 있다.하지만 그 정도 공통점은 C와 Java 사이에도 있는 공통점과 같이 다른 프로그래밍 언어 사이에서도 존재하는 프로그래밍 언어라면 가지고 있어야할 당연한 개념들이다.자바스크립트는 하나의 특정 언어보다는 여러 언어 사이에서 다양한 개념을 차용한 언어이다. 자바에서는 문법과 ‘원시 값 vs 객체 관계’ 스키마와 오크에서는 일급 객체인 함수 셀프에서는 프로토타입 상속 펄과 파이썬에서는 문자열, 배열, 정규표현식을 빌려왔다. 왜 자바스크립트 보고 구리다고 할까??기존에 다른 프로그래밍 언어(Java, C 등등)을 배웠던 사람은 자바스크립트를 배울 때 매우 어려워한다.개념이 어렵다기 보다는 다른 프로그래밍 언어와 공통된 규칙을 어기는 경우, 당연히 그렇게 동작할 것이라고 생각한 경우를 **배신(?)**한 경우가 많다.그래서 깊은 공부 없이 자바스크립트를 학습 후 기존의 프로그래밍 언어와 같이 사용했을 때는 다음과 같은 문제점이 존재한다. 함수 단위의 스코프아래 글도 참고해보자.(자알쓰) Scope Part. 1(자알쓰) Scope Part. 2 12345var i = 2;for(var i=1; i&lt;10; i++) &#123; console.log(i);&#125;console.log(i); // 2가 아니라 10 기존 프로그래밍 언어에서는 당연히 변수의 스코프는 {}블록 단위였다.즉 당연하다고 생각한 변수 스코프를 무심코 썼다간 큰 코 다치기 쉽상이다.이를 위해서는 아래와 같이 작업해야한다. 12345678910111213141516171819202122232425// Solution #1// 변수 이름을 다르게 하기var i = 2;for(var j=1; j&lt;10; j++) &#123; console.log(j);&#125;console.log(i); // 2// Solution #2// 즉시 실행 함수(IIFE)를 활용하여 별도의 함수 스코프를 생성var i = 2;(function() &#123; for(var i=1; i&lt;10; i++) &#123; console.log(i); &#125;&#125;());console.log(i); // 2// Solution #3// ES2015에 도입된 개념인 블록 단위의 스코프를 지원하는 const/let을 사용const i = 2;for(let i=1; i&lt;10; i++) &#123; console.log(i);&#125;console.log(2); 하지만 이와 반대로 자바는 블록 단위의 스코프이다. 모듈화 미지원아래 글도 참고해보자.(자알쓰) 모듈화 Part. 1(자알쓰) 모듈화 Part. 2JavaScript 표준을 위한 움직임: CommonJS와 AMD자바스크립트의 모든 코드는 전역 스코프를 사용한다.따라서 아래와 같은 경우에는 다음과 같은 문제점이 존재한다. 123456789&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678// a.jsvar a = &#x27;as&#x27;;// b.jsvar a = &#x27;df&#x27;;// c.jsconsole.log(a[0]); // &#x27;d&#x27; 스크립트 태그 삽입 순서에 따라 a 값이 바뀌게 되고 a 값의 안정성을 보장할 수 없다.저 값이 어디로 어떻게 튈지 몰라서 에러를 유발하는 코드가 될 수도 있다.만약 누군가가 a에 3이라는 값을 넣었으면 3은 숫자이고 인덱스로 접근이 불가능하니 오류가 나기 마련이다.따라서 다음과 같이 해결해야한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Solution #1// 네임스페이스 패턴을 활용하기// a.jsvar a = a || &#123;&#125;;a.a = &#x27;as&#x27;;// b.jsvar b = b || &#123;&#125;;b.a = &#x27;df&#x27;;// c.jsconsole.log(a.a[0]); // &#x27;a&#x27;// Solution #2// ES2015의 모듈 문법인 import/export Syntax 사용하기// 지원하는 브라우저/Node가 없으므로 Webpack 등등의 Module Bundler의 사용이 필수적임.// a.jsexport const a = &#x27;as&#x27;;// b.jsexport const a = &#x27;df&#x27;;// c.jsimport &#123;a&#125; from &#x27;a.js&#x27;;console.log(a[0]); // &#x27;a&#x27;// Solution #3// Node.js에서는 CommonJS 방식으로 모듈화를 구현할 수 있음.// a.jsexports.a = &#x27;as&#x27;;// b.jsexports.a = &#x27;df&#x27;;// c.jsconst &#123;a&#125; = require(&#x27;a.js&#x27;);console.log(a[0]); // &#x27;a&#x27;// Solution #4// 브라우저에서는 모든 파일을 다운로드 받아야한다는 특수성 때문에 비동기로 모듈을 로딩해야한다. // 이를 위한 모듈화 방법으로는 AMD 방식이 있으며 이를 구현한 라이브러리는 RequireJS가 있다. // http://requirejs.org 를 참조하자. 1번 솔루션인 네임스페이스 패턴은 전역 스코프를 더럽힌다는 단점(전역 스코프에 변수 a와 b가 두둥실 떠다니게 됨.)이 존재한다.외부에서 참조하려면 어쩔 수 없이 전역 스코프에서 모듈을 구현해야하지만 외부에서 참조할 일 없는 변수는자바스크립트의 함수 단위의 스코프를 활용한 즉시 실행 함수 패턴(IIFE, Immediately Invoked Function Expressions)를 사용하면 된다. 12345678910// a.js(function() &#123; var a = 2; console.log(a);&#125;());// b.js(function() &#123; console.log(a); // Uncaught ReferenceError: a is not defined&#125;()); 즉 a.js와 b.js는 서로 다른 스코프를 가지게 된다는 의미이고 전역 스코프가 아닌 로컬 스코프(함수는 별도의 스코프를 형성하므로)를 사용하게 되는 격이다.위에서 보이는 문제점들은 전부 스코프가 너무 넓다는 문제점들이다.스코프가 너무 넓으면 여러 곳에서 접근이 가능하고, 여러곳에서 접근이 가능하다는 소리는 내가 작성한 코드를 다른 개발자가 쉽게 수정이 가능하단 뜻이며그 코드로 인해 프로그램이 뻗을 수도 있으므로 스코프는 좁은 것이 최대한 코드의 안정성을 보장할 수 있는 길이라고 할 수 있을 것 같다. 하지만 자바에서는 모듈화를 클래스나 패키지를 통해 구현할 수 있는 것으로 알고 있다. 호이스팅(자알쓰) Hoisting을 참고하자.자바에서는 호이스팅이란 개념이 존재하지 않는다.&amp;nbsp; 동적 타입자바스크립트는 기본적으로 변수를 만들 때 변수의 타입을 지정하지 않는다.따라서 해당 변수에는 문자열이 담겼다가 숫자가 담길 수도 있다.처음에는 이러한 유연함 때문에 변수의 타입을 생각하지 않고 코딩하기 때문에 코딩이 더 빨리 되는 것 같아서 좋다.하지만 몇 달 후, 내가 짠 코드도 보기 이해하기 힘든데 남이 짠 코드를 유지보수 해야하는 경우,혹은 앱의 규모가 대규모로 커지는 경우에는 과연 변수에 어떤 값이 담겼는지 잘 알아낼 수 있을까?? 12345678910111213// 3개월 전에 작성한 util.jsvar util = util || &#123;&#125;;util.a = function(a) &#123; return +a; // 숫자로 변환하여 반환&#125;// 3개월 후에 내가 수정하거나 작성해야할 app.jsvar b = util.a(&#x27;aa&#x27;);// 나는 util.a의 결과가 배열인 줄 알고 splice 메소드를 썼다.// 하지만 util.a의 결과는 숫자이고 숫자에는 splice 메소드가 존재하지 않으니 에러가 뜰 것이다.// 만약 정적 타입 언어였다면 util.a의 반환값이 숫자인 것을 알고 당연히 에러라고 에디터에 밑줄을 그어줄테지만// 변수의 타입이 존재하지 않는 자바스크립트 같은 경우에는 실행했을 때만, 즉 런타임 시에만 오류를 알 수 있다는 단점이 존재한다.console.log(a.splice(0)); 자바는 정적 타입의 언어, 즉 변수를 생성할 때 어떤 타입의 변수인지 선언해야하고 죽었다 깨어나도 변수의 타입은 바뀌지 않는다. var 없이 변수 선언하기이런 코드 보면 조금 극혐하는 편이다.스코프는 좁을 수록 코드가 안전해진다고 알고 있는데 오히려 스코프를 넓히는 코딩 패턴이다.다음 코드를 살펴보자. 123456789101112131415161718var a = function() &#123; // 변수 a를 var 없이 선언했다. // 일단 현재 스코프에 변수 a가 없으므로 상위 스코프로 이동한다. // 그리고 그 스코프에 존재하는 변수 a의 값을 재할당한다. a = 3; var b = function() &#123; // 변수 b를 var 없이 선언했다. // 일단 현재 스코프에 변수 b가 없으므로 상위 스코프로 이동한다. // 그리고 그 스코프에 존재하는 변수 b의 값을 재할당한다. b = 2; &#125;; b(); console.log(b); // 함수 b 실행 이후 b는 더이상 함수가 아닌 숫자 2이다.&#125;;var b = 3;a();console.log(a); // 함수 a 실행 이후 a는 더이상 함수가 아닌 숫자 3이다.console.log(b); // 얘는 3 그대로이다. 어떤 글들을 보면 var 없으면 전역에 변수를 생성한다고 하는데 그게 아니라 스코프 하나씩 위로 타고 올라가서 있는지 없는지 파악 후해당 변수가 존재하는 스코프(없으면 전역까지 가서 생성)에 변수를 재할당 하는 것이다.여튼 이런 실수를 방지하려면 Strict Mode를 무조건 사용하자.ES2015+라면 Strict Mode를 사용할 필요가 없다. 자바는 이렇게 변수를 생성하는 키워드를 생략해서 변수를 생성할 수 없다. 자바스크립트는 멀티 패러다임 언어이다.자바스크립트는 여러 언어로부터 개념을 빌려온 언어이다.셀프에서는 프로토타입 상속 개념을 빌려왔기 때문에 객체 지향 언어에서 말하는 상속의 개념도 구현할 수 있다.따라서 자바스크립트는 객체 지향 프로그래밍이 가능하다.또한 스키마와 오크에서는 일급 객체인 함수 개념을 빌려왔기 때문에 함수형 프로그래밍도 가능하다. 객체 지향 프로그래밍 관점에서의 자바스크립트123456789101112131415161718var Parent = function(name) &#123; if(!name) throw &#x27;이름을 입력하시오&#x27;; this.name = name;&#125;;Parent.prototype.sayMyName = function() &#123; console.log(this.name);&#125;;var Child = function(name, age) &#123; if(!name) throw &#x27;이름을 입력하시오&#x27;; if(!age) throw &#x27;나이를 입력하시오&#x27;; Parent.call(this, name); // 부모의 생성자 함수 호출 this.age = age;&#125;;Child.prototype = new Parent();var c = new Child(&#x27;양권성&#x27;, 99);c.sayMyName(); // &#x27;양권성&#x27; 하지만 이마저도 다음과 같은 문제점이 존재한다.여기서 말하는 멤버는 변수+메소드를 뜻한다. static 멤버가 존재하지 않는다.인스턴스(객체)를 생성하기 이전에 사용 가능한 static 멤버가 존재하지 않는다.ES2015의 class syntax(말이 class지, 그 내부를 들여다보면 여전히 함수를 통해 객체를 생성하고 있다.)가 도입되면서 static 멤버의 사용도 가능해졌다. 123456789const Person = class &#123; static sayHello() &#123; console.log(&#x27;hello&#x27;); &#125; // static 변수는 아직 Stage-2 단계이다. // static b = &#x27;b&#x27;;&#125;;Person.sayHello(); // hello private 멤버를 만들지 못한다.private 멤버가 없다면 아래와 같은 문제점들이 존재하게 된다. 1234567891011var Person = function(name, age) &#123; if(!name) throw &#x27;이름을 입력하시오&#x27;; if(!age) throw &#x27;나이를 입력하시오&#x27;; this.age = age; this.name = name;&#125;;var p = new Person(&#x27;양권성&#x27;, null); // 정상적으로 오류를 뿜어냄.var p2 = new Person(&#x27;양권성&#x27;, 25);p2.age = null; // age를 재할당 했을 때는 오류를 잡아낼 수가 없음. 이를 위해서는 ES2015의 class, 유일한 값을 만들어내는 Symbol, 외부에서 접근 불가능한 별도의 스코프를 만들어냄과 동시에 실행하는 즉시 실행 함수 패턴,내부 스코프에 있는 변수(private 변수)들을 접근하기 위해 클로저 사용, private 변수들에 대한 유효성 검사(?)를 위한 getter&#x2F;setter 메소드가 사용되었다.사실 Reflect.ownKeys나 Object.getOwnPropertySymbols를 이용하면 Symbol로 만든 private 변수에 접근이 가능하지만,private 접근 지정자가 존재하는 자바에도 Reflect를 사용하면 Private Filed에 접근하기가 가능하다고 한다.Reflect를 사용 했을 때도 private 멤버들을 숨기고 싶다면 ES6 Class에서 private member를 정의하는 방법를 참조하자. 12345678910111213141516171819202122232425262728293031323334353637383940const Person = (() =&gt; &#123; // 즉시 실행 함수 패턴을 사용하여 별도의 스코프를 생성함과 동시에 함수를 실행. // 리턴문 밖에 있는 애들은 getter와 setter를 제외하고는 직접적인 접근이 불가능해서 private이라고 말할 수 있음. // 클로저를 사용한 것임. const _name = Symbol(&#x27;name&#x27;); const _age = Symbol(&#x27;age&#x27;); return class &#123; constructor(name, age) &#123; if(!name) throw &#x27;이름을 입력하시오&#x27;; if(!age) throw &#x27;나이를 입력하시오&#x27;; this[_name] = name; this[_age] = age; &#125; get name() &#123; return this[_name]; &#125; set name(name) &#123; if(!name) throw &#x27;이름을 입력하시오&#x27;; this[_name] = name; &#125; get age() &#123; return this[_age]; &#125; set age(age) &#123; if(!age) throw &#x27;나이를 입력하시오&#x27;; this[_age] = age; &#125; &#125;;&#125;)();const p = new Person(&#x27;양권성&#x27;, null); // 정상적으로 오류를 뿜어냄.const p2 = new Person(&#x27;양권성&#x27;, 25);p2.age = null; // age를 재할당 했을 때 또한 오류를 잡아냄.// 아래 방법으로 private 멤버에 접근이 가능하긴 하다.console.log(Object.getOwnPropertySymbols(p2));console.log(Reflect.ownKeys(p2)); 자바는 이런 static 멤버, private 접근 지정자, 메소드 오버라이딩, 오버로딩 등등과 같이 자바스크립트에서 지원하는 것은 물론 지원하지 않는 객체 지향 개념들도 모두 지원하고 있는 언어이다. 함수형 프로그래밍 관점에서의 자바스크립트두말하면 입아프니 함수형 프로그래밍(JS)이란…?을 참고하자.자바에서는 자바8에 Lambda가 출현한 이후 함수형 프로그래밍이 가능해졌는지 모르겠지만 그 이전에는 불가능한 것으로 알고 있다.왜냐하면 자바에서는 함수가 일급 객체가 아니기 때문에 함수의 매개변수로 넘길 수 없기 때문이다. 자바스크립트는 더 이상 예전의 자바스크립트가 아니다.예전에 자스의 출현 목적은 페이지의 동적 제어였지만 브라우저를 탈출한 JS(Node.js)의 출현과 ES2015의 탄생 이후로**이런 걸 자바스크립트로 할 수 있다고??**와 같은 걸 많이 할 수 있게 되었다. 서버 구현(Node.js) 파일 읽고 쓰기(Node.js) CLI 프로그램 만들기 (예) babel, webpack 등등) 모바일 앱 만들기(Ionic2, React Native) 데스크탑 앱 만들기(Electron) 크롤링 하기(PhantomJS, JSDom 등등) 기타 등등 이제 자바스크립트는 어엿한 프로그래밍 언어의 반열에 올랐다고 볼 수 있고, 그 목적도 이제 페이지의 동적 제어에 벗어나서 프로그래밍 언어 관점으로 바라보고 학습할 자세가 필요하다. 자바스크립트를 배우기 전에 잘 만들어진 프로그래밍 언어를 먼저 배우는 것을 추천하는 이유ES2015의 출현으로 자바스크립트의 많은 단점들이 보완됐지만 여전히 단점들(동적 타입, 인터페이스의 부재, 다른 언어의 좋은 개념들 등등)이 존재한다.ES5 시절에는 아주 홍수 같이 많았다.(호이스팅, 모듈화, 함수단위 스코프 등등)이런 문제점은 누가 짚어주지 않는 이상 모르는 경우가 허다하다.하지만 만약 자바나 C 같은 이런 단점들이 존재하지 않는 언어들을 먼저 배웠다면 어? 동적 타입 언어네? 정적 타입으로 도와주는 라이브러리가 없나?모듈화는 어떻게 구현해야할까? 등등과 같은 고민들을 누가 말해주지 않더라도 혼자서라도 해볼 가능성이 조금이라도 올라가며 누군가 설명을 해주면 쉽게 이해가 가능하다.또한 자바 등등과 같이 잘 만들어지지 않은 언어를 배우지 않다보면 캡슐화, private 멤버의 필요성을 느낄 수가 없게 된다.정통 프로그래밍 언어를 배웠다면 이게 없으면 당연히 문제라고 생각해볼만한 개념들이 자바스크립트에는 상당히 많다.물론 그 배경에는 짧은 개발 기간과 페이지 동적 제어라는 목적 때문이었겠지만…","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"}]},{"title":"자바스크립트 학습 방법","slug":"js-how-to-learn","date":"2017-08-08T21:30:06.000Z","updated":"2022-10-30T08:42:16.699Z","comments":true,"path":"2017/08/08/js-how-to-learn/","link":"","permalink":"https://perfectacle.github.io/2017/08/08/js-how-to-learn/","excerpt":"이 포스트는 제가 다년간 자바스크립트를 설렁 설렁 공부하다 작년 1년동안 빡시게 공부해온 경험을 토대로 작성한 글입니다.따라서 이 글을 읽으시는 분들께서는 본인과 맞지 않는 부분도 존재할 수 있으니 그 점은 참고하고 적절한 필터링을 하시면 되겠습니다. 목차 들어가기에 앞서 역사를 먼저 알아보자 자바스크립트는 자바가 아니다 HTML, CSS의 연장선 상으로 자바스크립트를 바라보지 말자 JS를 브라우저와 떼놓고 생각하자 JS는 더이상 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니다. 어떻게 공부해야할까? 1. 잘 만들어졌다고 알려진 언어들을 먼저 공부하자 1-1. 그게 싫다면 쉽게 쉽게 쓰여진 책을 먼저 읽자 2. 소문난 책들을 위주로 읽자, 단 jQuery 빼고 2-1. MDN, Stackoverflow와 친해지자 2-2. ES5를 끝내고 ES2015+를 할 필요가 없다 3. NPM과 Babel을 배우자 4. ES2015+가 익숙해졌다면 Typescript를 공부해보자 번외편 1. 코드 검사 도구를 사용하자. 2. Task Runner를 배우자 3. Module Bundler를 배우자 4. TDD를 공부하자 마치며 들어가기에 앞서","text":"이 포스트는 제가 다년간 자바스크립트를 설렁 설렁 공부하다 작년 1년동안 빡시게 공부해온 경험을 토대로 작성한 글입니다.따라서 이 글을 읽으시는 분들께서는 본인과 맞지 않는 부분도 존재할 수 있으니 그 점은 참고하고 적절한 필터링을 하시면 되겠습니다. 목차 들어가기에 앞서 역사를 먼저 알아보자 자바스크립트는 자바가 아니다 HTML, CSS의 연장선 상으로 자바스크립트를 바라보지 말자 JS를 브라우저와 떼놓고 생각하자 JS는 더이상 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니다. 어떻게 공부해야할까? 1. 잘 만들어졌다고 알려진 언어들을 먼저 공부하자 1-1. 그게 싫다면 쉽게 쉽게 쓰여진 책을 먼저 읽자 2. 소문난 책들을 위주로 읽자, 단 jQuery 빼고 2-1. MDN, Stackoverflow와 친해지자 2-2. ES5를 끝내고 ES2015+를 할 필요가 없다 3. NPM과 Babel을 배우자 4. ES2015+가 익숙해졌다면 Typescript를 공부해보자 번외편 1. 코드 검사 도구를 사용하자. 2. Task Runner를 배우자 3. Module Bundler를 배우자 4. TDD를 공부하자 마치며 들어가기에 앞서먼저 들입다 자바스크립트 공부를 하지 말고 아래 내가 열거한 사항들을 먼저 보고 공부를 해보자.나의 다년간의 노하우가 녹아있으니 쏙쏙 빼먹길 바란다.이러한 노하우들을 보고 실제 자바스크립트를 어떻게 공부해야할지에 대해 알아보자.또한 에이전시&#x2F;쇼핑몰에 종사하는 분들은 ES2015+를 실무에서 접할 기회가 적기 때문에 2-1. MDN, Stackoverflow와 친해지자 파트까지만 공부해도 실무에서는 전혀 무리가 없을 것이다.하지만 스타트업, 자사 서비스&#x2F;대규모 JS 앱을 개발하는 환경에 종사하는 분들은 ES2015+를 실무에서 매우 빈번하게 사용하고 있을 것이므로 그 이후 챕터까지 모두 공부하는 걸 추천한다. 역사를 먼저 알아보자해당 프로그래밍 언어가 어떤 문제를 해결하기 위해 나왔는지 등등에 대해 파악을 하게 되면 좀 더 해당 언어를 잘 쓸 수 있게 된다.먼저 초기 브라우저에는 페이지를 보여주기만 할 뿐, 유저와 상호작용을 하지 못했다.유저가 값을 입력하는게 불가능하다보니 그에 대한 응답도 불가능했던 것이다.따라서 페이지의 동적인 처리를 위해서 자바스크립트가 나왔다고 해도 과언이 아니다.당시에 자바스크립트는 하나의 프로그램을 만드는 목적 보다도 ID에 공백을 넣은 경우, 메뉴에 마우스를 올린 경우 등등의 동적인 처리가 주된 목적이었다.따라서 하나의 완성된 프로그램을 만들기에는 다소 부족한 점도 많았고, 10일이라는 짧은 개발 시간 탓에 설계 상 버그 등등이 많다.이러한 점들은 자알쓰에서 하나하나 정리하고 있으니 해당 포스트를 참고해보자. 자바스크립트는 자바가 아니다가끔 보면 자바스크립트 커뮤니티에 자바 질문을 올리는 사람들이 있다.자바 스크립트(Java Script)가 아니라 자바스크립트(Javascript)다. 둘은 엄연히 다르다.왜 이런 이름이 붙었는지에 대해서 간단히 알아보자.자바스크립트의 이름의 변천사는 모카(Mocha) - 라이브스크립트(Livescript) - 자바스크립트(Javascript)이다.자바스크립트는 다음과 같은 언어에서 영향을 받았다. 자바에서는 문법과 ‘원시 값 vs 객체 관계’ 스키마와 오크에서는 일급 객체인 함수 셀프에서는 프로토타입 상속 펄과 파이썬에서는 문자열, 배열, 정규표현식을 빌려왔다. 또한 워낙 여러 언어로부터 영향을 받은 덕에 함수형 프로그래밍(일급 객체인 함수)과 객체지향 프로그래밍(객체, 상속)을 함께 사용하곤 한다. 따라서 자바스크립트는 자바와 직접적인 연관 관계가 커서 그렇게 이름이 붙은 게 아니라 자바의 인기에 탑승하려는 노이즈마케팅 전략을 사용한 게 아닐까 싶다. HTML, CSS의 연장선 상으로 자바스크립트를 바라보지 말자많은 사람들이 HTML, CSS를 배우고 그 이후에 홈페이지를 동적으로 제어할 목적으로 자바스크립트를 배운다.자바스크립트는 프로그래밍 언어이다.C언어와 같은 프로그래밍 언어를 배운다고 하면 C언어를 배우지 그 전에 컴퓨터 사이언스를 굳이 배우고 시작할 필요는 없다.배우면 좋지만 배우지 않고 시작해도 상관이 없다는 뜻이다.즉, 그 말은 병행해도 된다는 뜻이며 HTML을 배우지 않고 JS를 먼저 배워도 된다는 뜻이다. JS를 브라우저와 떼놓고 생각하자브라우저에서 제공하는 JS는 크게 세 파트로 나눌 수가 있다. DOM(Document Object Model)자바스크립트에 자주 사용하는 document.getElementById()와 같이 document 객체에 해당하는 내용들을 지칭한다. BOM(Browser Object Model)자바스크립트에서 자주 사용하는 window.alert()와 같이 window 객체에 해당하는 내용들을 지칭한다. ES(ECMAScript) 오잉? 브라우저에서 제공하는 JS? 그럼 다른 곳에서도 JS를 쓸 수 있단 말인가?그렇다. Node.js에서도 JS를 쓸 수 있으며 브라우저에서는 할 수 없었던 여러가지를 할 수 있게 되었다. File I&#x2F;O파일의 입&#x2F;출력과 관련된 내용이다. 서버 API서버를 구축하는 것 등등에 관한 내용이다. ES(ECMAScript) 기타 등등 너무 많음. 따라서 우리는 먼저 ES를 마스터해야한다.Node.js와 Browser라는 플랫폼에서 공통적으로 쓸 수 있는 내용이기도 하며 ES에 해당하는 내용들이여타 프로그래밍 언어들(C, Java 등등)이 가지고 있어야할 내용들(변수, 함수, 자료형, 조건문, 반복문 등등)이 포함된 내용이기 때문에프로그래밍 언어 관점에서 자바스크립트를 배우려면 ES를 먼저 파야한다. 자바스크립트를 브라우저와 절친 먹여놓고 공부하기 시작하다보면 다음과 같은 함정에 빠지게 된다.일반적인 수학에서 함수는 입력 값이 있으면 출력 값이 있다라는 개념이다.프로그래밍 세계에서 함수의 입력 값은 매개변수, 출력 값은 반환하는 값과 연결이 된다.따라서 두 수의 합을 반환하는 함수를 만들라고 하면 다양한 결과가 나오게 된다. 12345678910111213141516171819202122232425262728// 아래 두 케이스가 모범 답안function add(x, y) &#123; return x+y;&#125;var add2 = function(x, y) &#123; return x+y;&#125;;// 결과를 확인하려고자 하는 의지function add3(x, y) &#123; console.log(x+y);&#125;// 브라우저와 짱친 먹은 JS들function add4(x, y) &#123; alert(x+y);&#125;function add5(x, y) &#123; document.body.innerHTML += x+y;&#125;function add6() &#123; var x = parseInt(prompt(&quot;숫자를 입력해주세요.&quot;)); var y = parseInt(prompt(&quot;숫자를 입력해주세요.&quot;)); document.body.innerHTML += x+y;&#125; 사람들이 입력이라고 하면 어느 정도는 함수의 매개변수로 이해를 하는 경향이 있다.(일부는 prompt 함수로 입력받는다.)하지만 반환의 의미를 (화면에)출력으로 받아들이는 경우도 존재하고, 그 화면에 출력하는 방법도 로그창, 경고창, 브라우저에 보여주는 방법 등이 존재한다.이는 모두 브라우저에 의존하고 있는 것이다. JS는 더이상 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니다.과거에 어쨌든 간에 현재 자바스크립트는 계속해서 새로운 스펙이 나오고 이제 어엿한 프로그래밍 언어의 반열에 올랐다고 할 수 있다.여전히 동적 타입, typeof 버그 등등의 단점이 존재하지만 이전 자바스크립트 버전으로 작성한 코드와의 호환 때문에 고칠 수 없는 점도 존재해서 여전히 문제는 존재한다.하지만 예전의 Toy Language(장난감 가지고 놀듯 쉽고 깊이 없이 배워도 되는 언어)가 아니란 뜻이며 진지하고 깊숙하게 시간을 내서 배울 가치가 있는 언어이다. 어떻게 공부해야할까?아직 들어가기에 앞서를 보지 않았다면 꼭 보고 오자.공부에 임하기 전에 자바스크립트를 어떠한 자세로 바라보고 공부해야할지에 대해 적어놓았다.이제 본격적으로 자바스크립트를 어떻게 정복해야할지 스텝 바이 스텝으로 적어보겠다. 1. 잘 만들어졌다고 알려진 언어들을 먼저 공부하자사람은 아는만큼 보인다.자바스크립트는 애초에 목적 자체가 프로그램을 만들기 보다는 페이지의 동적 제어였고, 10일이라는 짧은 개발 기간 덕분에 설계 상 문제점이 많은 언어이다.이걸 다른 프로그래밍 언어를 모르는 사람은 그 설계 사항들이 왜 안 좋고 어떤 문제점들이 존재하는지 모른다.그런 걸 친절하게 일일이 다 설명해주는 책이 있으면 모르겠지만 없었던 것 같고, 다 인터넷을 통해 파편화된 지식을 조각 조각 모아야했던 것 같다.혹은 너무 어렵게 설명이 돼있거나…하지만 잘 만들어졌다고 알려진 C나 Java와 같은 언어(동의를 안 하더라도 확실히 예전의 JS보다는 잘 만들어졌다는 데는 동의할 것이다.)를 먼저 공부하고 자바스크립트를 바라보면**이거 왜 이렇게 만들었어?, 이렇게 짜면 이런 사항들이 문제가 되겠는데?, 예전에 봤을 때는 못 알아 먹겠는 것들이 이제는 조금씩 보이네?**하고 동일한 내용을 보아도 이해하는 관점이 깊이가 깊어진다.따라서 나는 자바스크립트를 접하기 전에 그런 언어들을 먼저 접하는 걸 추천한다. 1-1. 그게 싫다면 쉽게 쉽게 쓰여진 책을 먼저 읽자나는 시간이 별로 없거니와 C언어와 Java는 너무 어렵다(알레르기가 있다)고 생각되는 사람들은 사람들이 말하는 잘 쓰여진 책들 말고 서점에 가서 자신의 눈으로 직접 보고 이해할만한 수준의 책을 골라보자.왜 잘 쓰여진 책보다 쉽게 쓰여진 책을 추천하냐면 일단 뇌를 말랑말랑하게 만들어서 자바스크립트와 친밀도를 높이게 하기 위함이다.처음부터 잘 쓰여진 책을 보다보면 자신이 이해할 수 없는 수준으로 얘기하는 경우가 많다.하지만 쉽게 쉽게 쓰여진 책은 다소 설명이 부족하더라도 이해하는데는 큰 무리가 없고 술술 넘어갈 것이다.이런 책은 깊이 없이 그냥 술술 넘어가며 봐야한다. 그냥 ‘JS가 이런 거구나~’하고 맛보기만 하는 것이지 그렇게 깊이 있게 볼만한 책은 아니다.주로 따라해볼만한 예제가 많고 브라우저와 짱친 먹은 예제들(눈에 바로 바로 결과가 보여지니 학습 유도에는 좋았다) 위주의 책이 보기 좋을 것이다.나의 경우에는 HTML+CSS+JS 무따기 시리즈로 JS를 처음 접했는데 지금은 없어진 것 같다. 2. 소문난 책들을 위주로 읽자, 단 jQuery 빼고여기서 말하는 소문난 책(내 기준)은 다음과 같다. 인사이드 자바스크립트 자바스크립트를 말하다 러닝 자바스크립트 코뿔소 책이나 노란책도 유명하다고들 하나 솔직히 1독이라도 끝낸 사람이 얼마나 될까 싶을 정도라서 그닥 추천하지 않았다.그리고 아직 읽어보지 않았지만 You Don’t Know JS 시리즈도 좋은 것 같다. 여기서 jQuery를 뺀 이유는 적어도 ES5까지는 알고 나서 제이쿼리를 접하는 걸 추천한다.자바스크립트는 엄연히 프로그래밍 언어인데 중간에 jQuery(DOM 조작 라이브러리+@)를 먼저 접하면 프로그래밍 언어 관점 보다는 DOM을 조작하는데 너무 혈안이 될 수도 있다.또 JS를 제대로 모르는 상태에서 jQuery를 접하게 되면 Javascript를 몰라서 나오는 질문을 jQuery를 모르기 때문이라고 생각할 수도 있으며,Javascript로 해결해야하는 상황들을 jQuery의 메소드로 해결하는 상황도 초래할 수 있다.jQuery는 Javascript로 만들어져있기 때문에 절대 VanillaJS(Pure JS)보다 성능 측면에서 좋을 수가 없다.따라서 jQuery를 배우더라도 아직은 그 쪽에 힘을 싣지 않고 Javascript 쪽에 힘을 더 싣는 것을 추천한다.jQuery를 사용하지 않는 곳을 찾기 힘들 정도로 jQuery는 많은 곳에서 사용 중이지만 아래와 같은 글이 있을 정도로 jQuery가 그렇게 짱짱맨인 것 만은 아니다. You Don’t Need jQuery 이제와서 JQUERY를 쓰면 안되는 이유, 혹은 JQUERY와 웹개발의 역사 2-1. MDN, Stackoverflow와 친해지자 MDN은 파이어폭스라는 브라우저를 만든 모질라 재단에서 만든 개발자를 위한 사이트이다.Javascipt 내장 API(Array 관련 메소드 등등)들의 자세한 설명 등등이 나와 있다.ECMAScript Spec을 보고 이해하기 힘든 내용들은 이 곳에서 자주 참고하자. Stackoverflow는 개발자 계의 지식 IN이라고 보면 될 것 같다.검색은 네이버(카페)에 의존하기 보다는 구글링(구글에 검색하는 행위)을 통해 Stackoverflow와 같은 사이트 올라온 글들을 참고하자.네이버의 수 백 배에 달하는 글들과 더 좋은 정보들이 있다보니 더 빨리 문제 해결을 할 수 있는 가능성이 높아진다.한 발 더 나아가서 직접 질문과 답변까지 해보면 금상첨화일 것이다. w3schools라는 사이트가 있지만 w3fools란 사이트가 있을 정도로 잘못된 내용 및 업데이트가 늦다보니 간단한 예제 정도만 참고하자. 2-2. ES5를 끝내고 ES2015+를 할 필요가 없다웹 에이전시나 쇼핑몰 등등에 근무하는 사람들은 ES5까지(2-1 챕터)까지만 공부하셔도 업무를 보는데는 크게 지장이 없을 것이다.웹 에이전시나 쇼핑몰에 근무하는 사람들이라면 ES2015+는 고사하고 ES3를 사용하고 있을 가능성이 크다.(IE8 때문)그래도 IE8도 곧 사장될 거 같기 때문에(아마도…?) ES5를 미리미리 공부해두는 게 좋다.또한 협업하는 사람이 ES2015+를 모른다면 다음과 같은 문제점이 존재한다. 협업하는 사람이 ES2015+를 공부해야한다. 협업하는 사람이 공부할 의지가 없으면 큰일이다. 추후에 사람을 뽑을 때 ES2015+를 알고 있는 사람으로 뽑아야한다. 이 외에도 다른 문제점들이 존재하겠지만 당장 떠오르는 것은 이게 끝이다. 해당 챕터부터는 스타트업이나 자사 서비스&#x2F;대규모 앱을 JS로 개발하는 환경에 종사하는 사람들이라면 반드시 거쳐야하는 과정일 것이다. 과거 나도 ‘ES5를 끝내고 ES2015+를 공부해야하지 않나?’라는 생각 때문에 반년동안 ES5에만 목을 메달다가 어느 스터디에서 ES6(ES2015)와 ES5를 간단하게 비교해주는 내용을 들었는데 정말 혁명이었고 별 거 없었다.ES6 들어서 새로 생긴 Promise, Generator, Iterator 등등의 내용을 다룬 것은 아니고 간단한const&#x2F;let, Rest Parameter, Default Parameter, Spread Operator, for-of 등등은 정말 금방 배울 수 있다.따라서 내 생각은 똑같은 코드를 ES5로 짜보고 ES2015+로 짜보고 점점 익숙해지면 그 이후에 Promise, Generator, Iterator 등등의 내용을 공부하면 될 것 같다.또한 요즘 프론트 엔드 개발을 할 때 ES5로 짜는 것보다 ES2015+로 짜는 경우가 훨씬 많다.따라서 ES5를 공부할 필요가 없다고 주장하는 사람도 있는데 나는 그 견해와는 입장이 다르다.ES2015+로 짠 코드를 브라우저(특히 MS 계열)에서 정상적으로 지원해주지 않는다.따라서 ES5로 바꿔주어야하는데 결국 브라우저 위에서 도는 것은 ES5 코드이다.그러니까 ES2015+로 짜면서 어느 정도는 ES5로 어떻게 변환될지 상상(?)을 조금 하면서 짤 필요는 있다.ES2015+의 코드를 ES5로 바꿔주는 애가 100% 커버를 해주지 못한다. (그 도구가 꾸진 게 아니라 언어 설계상 오는 차이 때문에…)따라서 대부분은 커버하지만 혹시 모를 에러가 발생할 수도 있으니 ES5 정도는 알아야한다는 게 내 생각이다. 3. NPM과 Babel을 배우자.우선 ES2015+의 코드를 브라우저에서 100% 지원해주지 않는다.따라서 ES5로 변환(트랜스파일)해줘야 하는데 그 중에 제일 많이 쓰고 좋다고 생각되는 것은 Babel이다.이 Babel을 사용하는 가장 쉬운 방법은 Babel REPL을 이용하는 것이다.그런데 매번 소스를 복붙 해서 트랜스파일하는 귀찮은 과정을 반복할 것인가?그리고 우리는 바벨이 ES5로 트랜스파일 한 코드를 보고 이해하지 못한다.따라서 우리가 소스 유지보수를 하기 위해서는 ES2015+로 짠 코드 하나, ES5로 트랜스파일 된 코드 하나, 총 두 개를 들고 있어야한다.이런 귀찮은 작업을 줄여주기 위한 것이 babel-cli이다.MS-DOS 유저라면 익숙할 법한 시꺼먼 창인 터미널(윈도우의 CMD)에서 트랜스파일을 해주는 도구이다.하지만 이 babel-cli를 설치는 npm을 통해서만 가능하다. (왜냐면 babel-cli가 Node.js 위에서 돌기 때문…)npm은 Node.js를 설치하면 자동으로 설치된다.이 때 우리가 배워야할 것은 두 가지이다. npm 사용 방법(package.json에 대해 공부하기, 모듈 설치 삭제 해보기) babel-cli 사용 방법 4. ES2015+가 익숙해졌다면 Typescript를 공부해보자ES2015+가 아무리 좋아졌다고 하더라도 다음과 같은 걸 해결하지 못했다. 정적 타입 사용자가 직접 인터페이스 구현 private 접근 지정자등등이 있는데 이 ES2015+의 모든 특성들을 포함한 Superset 격인 Typescript란 게 존재한다. 나도 타입스크립트는 잘 모르기 때문에 1번을 토대로 장점을 설명해보겠다. 코드의 안정성앱의 규모가 커지면 커질 수록 코드를 파악하기 힘들어지는 경향이 존재한다.또 오랜 시간이 지난 코드를 유지보수 할 때도 마찬가지이다.이럴 때 어떤 메소드를 써야할 때 첫 번째 매개변수로 문자열이 와야하는지, 숫자가 와야하는지, 매개변수를 몇 개를 넘겨야하는지, 생략이 가능한지기존 동적 타입에서는 체크할 수 없었던 내용 등등을 체크하므로 어떻게 메소드를 사용해야하는지 직접 메소드 구현부로 가서 파악할 필요가 없어진다. 코드의 자동완성어떤 함수로부터 값을 반환 받았는데 이게 배열인 줄 알고 forEach 메소드를 썼는데 알고보니 Object가 반환되는 경우였다고 생각해보자.기존 동적 타입에서는 어떤 자료형이 반환되는지 모르니 자동완성에 배열의 메소드, 문자열의 메소드 등등이 전부 뜰 것이다.하지만 정적인 타입으로 딱 Object가 반환된다는 게 확정된 메소드라면 자동완성에 배열의 메소드도 뜨지 않을 것이며 배열의 메소드를 사용하면에디터 상에서 오류로 표시되기 때문에 이런 것도 어찌보면 코드의 안정성과 연결이 되는 점이기도 하다. 하지만 장점이 있으면 단점이 있듯, 내 기준에서 단점을 서술해보겠다. 생산성이 떨어진다(초기에)동적 타입인 js는 코드를 대충 빨리 짜도 돌아간다.따라서 생산성이 높다고 볼 수 있다. (하지만 나중을 생각한다면…)하지만 타입스크립트는 타입 체크가 매우 빡빡하다.따라서 동일한 코드를 짤 때도 더 오래 걸릴 수도 있다.하지만 나중에 되면 아마 타입스크립트가 훨씬 빠를 것이다. 외부 라이브러리에 대한 타입 정의도 모두 해줘야한다.이게 제일 사람 미치게 한다.유명한 라이브러리의 경우 미리 다 타입 정의 파일이 있는데 없는 경우에는 직접 만들거나 적폐 세력(any)를 사용해야한다.또한 라이브러리의 버전과 타입 정의한 파일의 버전이 불일치하는 경우도 있고 골칫거리다.이러한 단점 때문에 타입스크립트를 포기하는 경우가 많다. (나도… ㅠㅠ) 번외편해당 파트는 자바스크립트와 직접적으로 관련이 있다고는 말할 수 없다.하지만 나는 자바스크립트로 개발을 한다면(특히 ES2015+) 당연히 알면 좋다고 생각하는 내용들을 정리해봤다. 1. 코드 검사 도구를 사용하자.코드를 짤 때 항상 일관성 있게 짜야한다.하물며 한 사람이 짤 때도 문자열을 표시하는데 “”나 ‘’을 혼용한다던지들여쓰기를 위해 탭과 들여쓰기를 혼용한다던지 등등의 경우에 놓이게 되는데다른 사람들과 협업하다보면 하나의 소스 파일의 가독성은 똥망진창이 될 것이다.하지만 사람의 눈으로 꼼꼼히 체크한다 해도 꼭 놓치기 마련이다.이렇게 코딩 컨벤션을 지켰는지와 에러 등등을 체크해주는 툴로 JS에서는 JSLint, JSHint, ESLint 등등이 있다.각자 장단점을 파악해보고 마음에 드는 걸 사용하면 좋은데 ESLint를 추천한다.또한 TS 진영에서는 TSLint를 사용하면 된다. 2. Task Runner를 배우자기존의 자바스크립트 소스 코드를 개발하던 방식에는 다음과 같은 문제가 존재한다. 유저에게 불필요한 데이터를 전송하여 LTE 데이터를 낭비하게 만들고, 그 데이터들로 하여금 로딩 속도를 느리게 만듦으로써 사용자에게 최적화된 UX를 제공해주지 못하고 있다.이게 뭔소린가 싶으면 우리의 소스 코드를 보면 공백과 기나긴 변수명 등등을 가지고 있다.이거는 사람 입장에서 가독성을 높여 유지보수하기 편하게 한 것이지, 컴퓨터 입장에서는 이런 애들은 불필요하다.따라서 공백을 줄이고(minify), 변수명을 난독화(a, b와 같은 걸로 줄이는 작업, uglify)시키는 작업을 해야한다. 우리가 사용하는 웹 브라우저는 HTTP 프로토콜 위에서 통신을 한다.요즘 HTTP 2도 나왔지만 아직까지 브라우저&#x2F;서버의 호환 때문에 많은 사람들이 HTTP 1.1을 사용 중이다.HTTP&#x2F;1.1는 기본적으로 Connection당 하나의 요청을 처리 하도록 설계 되어있다.그래서 동시전송이 불가능하고 요청과 응답이 순차적으로 이루어 지게된다.그렇다 보니 HTML 문서안에 포함된 다수의 리소스 (Images, CSS, Script)를 처리하려면 요청할 리소스 개수에 비례해서 Latency(대기 시간)는 길어지게 된다.SPA(Single Page Application)의 경우 다수의 스크립트 파일을 로딩하나 하나로 합친(concat) 스크립트 파일을 로딩하나 동일하게 작동한다.다수의 파일은 대기 시간이라는 오버헤드(쓸 데 없는 비용(여기서 시간도 비용으로 측정함))가 발생하기 때문에 다수의 스크립트 파일을 하나로 합쳐주는 작업도 해야한다. 이런 작업을 하는 방법은 여러 가지가 있는데 UglifyJS를 이용하는 것이 가장 간단하다.하지만 이는 Babel REPL과 마찬가지로 수동으로 해줘야한다는 단점이 존재한다.이러한 Minify 작업(Task), Uglify 작업, concat 작업 등등 무수한 최적화 작업을 소스 코드가 수정될 때마다 일일이 하고 싶을까?이러한 작업(Task)들을 실행(Run)을 하나의 단위로 묶어서 한 번에 실행시켜주는 Task Runner란 게 존재한다.그 중에서도 Grunt와 Gulp가 있는데 둘 중에 아무거나 해도 상관이 없을지 모르겠는데 나는 Gulp를 배웠다. 3. Module Bundler를 배우자.자바스크립트에서 스코프는 함수 단위(const와 let은 블록 단위)이고, 모듈이란 게 존재하지 않았다.따라서 네임스페이스 패턴과 같은 꼼수를 사용해서 모듈화를 구현하곤 하였다. 시간이 흘러 Node.js 진영에서는 CommonJS 스펙을 준수해서 모듈화를 구현하였다.하지만 웹 브라우저는 사용자들이 파일을 내려받아야한다는 특수한 상황이 존재해서 비동기적으로 모듈을 로딩해야한다는 특수한 상황에 놓여있다.이를 위한 AMD(Asynchronous Module Definition) 스펙이 있고, 이를 구현한 RequireJS라는 라이브러리가 있다.자세한 내용은 JavaScript 표준을 위한 움직임: CommonJS와 AMD를 참고하자. 하지만 ES2015에 들어와서 Module을 언어단에서 지원해주는 import와 export 문법이 존재한다.하지만 현재 이를 지원하는 브라우저&#x2F;Node는 없다.따라서 브라우저 진영에서는 여전히 A 모듈, B 모듈 등등을 각각 로딩해야하는 사태가 발생했는데 이 때 구세주처럼 등장한 게 Module Bundler이다.Bundle은 ‘꾸러미’라는 의미로 하나로 합친다는 의미를 지니고 있다.Task Runner의 concat은 단순히 소스 코드 자체만을 합치지만 이 Module Bundler는 모듈 간의 관계를 전부 파악해서 단일 모듈(소스 파일)로 Bundling 해준다.따라서 Task Runner에서는 불가능한데 Module Bundler에서는 다음과 같은 것들이 가능하다. (설명은 Webpack 기준) Code Splitting(코드 분할) 변경률이 적은 서드파티(제이쿼리, 리액트 등등의 라이브러리나 프레임워크)들을 따로 빼서 사용자의 임시 파일에 저장시켜놓고 방문할 때마다 해당 내용을 캐싱하게 끔 해서 좀 더 로딩 속도를 높이기. SPA라고 해도 사용자가 모든 URI를 방문하는 게 아니니 URI 별로 소스 코드를 빼기. 그런데 URI 별로 소스 코드를 빼도 파일의 크기가 너무 작은 경우에는 오히려 요청&#x2F;응답에 대한 오버헤드가 클 수 있으므로 소스 코드의 최소한의 크기 정하기. Tree Shaking(나무의 가지를 흔들어 썩은 열매를 떨어뜨리 듯, 필요없는 코드들을 삭제하기)쓰지 않는 코드(변수 함수 등등)들이 있는 경우에 자동으로 번들링 할 때는 없애기. 파일의 크기가 작은 경우에는 Data URL로 리소스를 표현하기(폰트, 이미지, svg 등등)웹팩에서는 js 소스만 모듈로 보는 게 아니라 정적인 리소스들(이미지, 폰트, svg 등등)을 모두 모듈로 보고 있다.그래서 이 모듈(정적인 리소스)들을 컨트롤 할 수 있게 된다.그런데 이미지 크기가 너무 작은 경우에는 요청&#x2F;응답에 대한 오버헤드를 줄이기 위해 sprite image를 이용할 수도 있고, Data URL을 이용할 수도 있다.하지만 sprite image를 만드는 것은 귀찮고 사용하기도 불편할 때가 있다. (이를 위한 플러그인들도 많지만)그래서인지 모던 브라우저에서는 이런 Data URL을 통해서도 그런 오버헤드를 줄일 수 있다.물론 성능은 sprite image가 Data URL보다 더 뛰어난 것으로 알고 있다. 원래 Module Bundler 성격은 모듈과 관련된 것만 다루는 것이었는데 이제는 Task Runner의 기능까지 삼켜서 minify, uglify 등등의 기능까지 흡수를 해서 어지간하면 Module Bundler만 사용해도 될 정도이다.하지만 Module Bundling 이전에 처리해야하는 특수한 경우에는 Task Runner에서 작업들을 처리한 이후에 Module Bundler를 돌려야할 것이다.Module Bundler로는 Webpack, browserify, rollup 등등이 있는데Webpack이 제일 사용자도 많고, github start도 많고, 커뮤니티 활성화도 잘 돼있으므로 Webpack을 공부하는 걸 추천한다. 4. TDD를 공부하자.TDD(Test Driven Development)는 다음과 같은 개발 행위를 말한다. 테스트 코드를 먼저 짠다. 테스트 코드가 통과하게 앱의 코드를 짠다. 이를 통해 얻을 수 있는 장점은 다음과 같다. 내가 구현해야 하는 코드(테스트 통과)가 무엇인지 명확해진다. 코드를 수정해도 잘 돌아갈 거라는 안심이 된다.테스트 코드를 작성하지 않았으면 코드를 수정하고 해당 메소드를 사용하는 부분을 전부 다시 테스트해봐야한다.하지만 테스트 코드들을 작성했다면 해당 테스트를 통과했다면 수정한 메소드를 사용한 부분들이 정상적으로 동작한다고 볼 수 있으므로 심신에 안정이 찾아오게 된다. TDD는 아니더라도 앱의 코드를 먼저 짜더라도 테스트 코드는 반드시 짜는 습관을 들이자.(나부터라도…)하지만 많은 사람들이 아래와 같은 상황 때문에 TDD를 못하는 것 같다. 테스트 코드 짜는데 시간이 더 걸린다.초기에는 그럴지 몰라도 앱의 규모가 커지거나 유지보수를 생각한다면 TDD가 더 오래 걸리지는 않을 것이다. (더 적게 걸리지 않을 지도…) 어디서부터 어디까지를 테스트해야할지 모르겠어요.저도 모르겠어요… 누가 좀 알려주신다면 ㅠㅠ E2E(End to End) Test는 어떻게 하죠?저도 UI 단 테스트는 안 해봐서 누군가 피드백을 주신다면 수정하겠습니다. 이 TDD를 도와주는 프레임워크로는 jasmine, mocha, chai 등등이 있다.그리고 이러한 테스트를 자동으로 돌려주는 등 위 프레임워크들을 도와주는 Test Runner인 karma가 있다. 마치며내가 컴공을 전공하다 보니 비전공자나 입문자에게는 다소 딱딱하게 들리거나 어렵게 들린 내용이 많을 것이다.다 내가 모르는 게 많아 이런 내용들을 쉽게 풀어내는 능력이 부족하기 때문이다 ㅠㅠ…여튼 글을 보고 궁금한 점, 부족한 점, 잘못된 점 등등은 전부 댓글로 피드백 부탁드립니다~~","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"독학","slug":"독학","permalink":"https://perfectacle.github.io/tags/%EB%8F%85%ED%95%99/"}]},{"title":"(자알쓰) 클로저","slug":"js-013-closure","date":"2017-08-07T11:53:42.000Z","updated":"2022-10-30T08:42:16.691Z","comments":true,"path":"2017/08/07/js-013-closure/","link":"","permalink":"https://perfectacle.github.io/2017/08/07/js-013-closure/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 세 번째 시리즈는 클로저를 주제로 진행하겠다. 들어가기 전에프로그래밍 언어에는 지역 변수란 게 존재한다.이 지역변수는 변수의 스코프에 의존적이다.여타 프로그맹 언어에서 변수의 스코프는 {} 블록 단위지만,자바스크립트의 변수의 스코프는 함수 단위이다. (물론 ES6의 const와 let의 스코프는 블록 단위)","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 세 번째 시리즈는 클로저를 주제로 진행하겠다. 들어가기 전에프로그래밍 언어에는 지역 변수란 게 존재한다.이 지역변수는 변수의 스코프에 의존적이다.여타 프로그맹 언어에서 변수의 스코프는 {} 블록 단위지만,자바스크립트의 변수의 스코프는 함수 단위이다. (물론 ES6의 const와 let의 스코프는 블록 단위) 1234567891011121314// 글로벌 스코프 시작var global = 2;var func = function() &#123; // 로컬 스코프 func 시작 var local = 1; // 로컬 스코프에서는 로컬 스코프와 글로벌 스코프에 접근 가능 console.log(global); console.log(local); // 로컬 스코프 끝&#125;// 글로벌 스코프에서는 글로벌 스코프만 접근 가능console.log(global);console.log(local); // Uncaught ReferenceError: local is not defined// 글로벌 스코프 끝 스코프의 접근 가능한 스코프는 자기 자신을 포함한 상위 스코프이다.글로벌 스코프의 접근 가능한 범위는 글로벌 스코프가 최상위 스코프이므로 글로벌 스코프 자기 자신 밖에 없고,로컬 스코프 func의 접근 가능한 스코프는 자기 자신인 func와 자신의 상위 스코프인 global 스코프가 된다. 왜 이런 현상이 발생할까?이는 전역 변수와 지역 변수가 메모리(RAM)의 어느 영역(Code, Data, Stack, Heap)에 적재되는지와 관련이 있다.전역 변수는 메모리의 Data라는 영역에 적재돼서 프로그램의 종료 시까지 계속 적재돼있다.따라서 어디서나 사용이 가능하다.지역 변수는 메모리의 Stack이라는 영역에 적재되고, 지역 변수의 생명주기(Lifecycle)는 함수 호출 시 생성되고 함수가 종료되면 시스템에 의해 반환된다. 클로저는 왜 쓸까?위와 같이 지역변수는 함수 호출 시 메모리에 할당되고, 함수가 종료되면 메모리에서 해제된다.따라서 지역변수는 호출할 때마다 항상 같은 값으로 초기화된다.하지만 가끔 함수를 호출할 때 이전에 존재했던 값을 유지하고 싶어질 때가 있다.그러려면 함수가 종료됐을 때 해당 지역 변수가 메모리에서 해제되면 안 된다. 클로저는 어떻게 구현해야할까?함수가 종료돼도 지역 변수가 메모리에서 해제되지 않으려면 어떻게 해야할까?이를 위해서는 자바스크립트의 GC(Garbage Collector, 메모리 상에 쓸 데 없는 녀석 수거해가는 녀석)가 어떻게 동작하는지 간단하게나마 알아봐야한다. 123var obj = &#123;name: &#x27;양간장&#x27;&#125;;var obj2 = &#123;name: &#x27;간장냥&#x27;&#125;;obj = obj2; 3번 라인에서 obj는 &#123;name: &#39;간장냥&#39;&#125;을 참조하게 만들었다.그럼 &#123;name: &#39;양간장&#39;&#125;이라는 데이터는 참조가 불가능 해졌으므로 사용할 방법이 없는 쓸 데 없는 녀석이 된다.이때 저 &#123;name: &#39;양간장&#39;&#125;은 GC(Garbage Collecting) 대상이 되며 GC(Garbage Collector)가 적절한 시점(개발자 도구 열닫 혹은 일정 시간 이후?)에 수거해간다.따라서 메모리 상에서 데이터가 해제되지 않게 하려면 누군가는 해당 녀석을 참조하게 만들어서 GC(Garbage Collecting) 대상에서 제외시켜야한다.이를 위해서는 다음과 같은 조건 제약이 따른다. 조건 1. 참조하는 대상이 참조하는 녀석과 접근 가능한 스코프에 있어야 한다.가령 예를 들어 참조하는 대상(&#123;name: &#39;양간장&#39;&#125;)과 참조하는 녀석(obj)이 접근 가능한 스코프에 있어야한다는 소리이다.접근 가능한 스코프 상에 존재해야 오류 없이 해당 데이터를 참조할 수 있기 때문이다. 1234567var a = function() &#123; var b = 1;&#125;;var c = function() &#123; console.log(b); // Uncaught ReferenceError: b is not defined&#125;;c(); 로컬 스코프 c의 접근 가능한 스코프는 자신을 포함한 상위 스코프이다. 로컬 스코프 c 전역 스코프따라서 로컬 스코프 c에서 로컬 스코프 b로 접근이 불가능하다. 12345678var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); // 1 &#125;; c();&#125;;a(); // 1 위 예제에서 로컬 스코프 c가 접근 가능한 스코프는 자신을 포함한 상위 스코프이다. 로컬 스코프 c 로컬 스코프 a 전역 스코프위 코드는 참조하는 대상(b)이 로컬 스코프 a에 있고, 참조하는 녀석(console.log(b))이 로컬 스코프 c에 있다.참조하는 대상(로컬 스코프 a)이 참조하는 녀석(로컬 스포크 c)과 접근 가능한 스코프에 있어야 한다는 조건을 만족하고 있다. 조건 2. 참조하는 대상이 존재하는 함수를 호출하는 게 아니라 참조하는 녀석이 존재하는 함수를 직접 호출해야한다. 12345678910var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); // 1 &#125;; c();&#125;;a(); // 1a(); // 1a(); // 1 기껏 위와 같이 로컬 스코프와 그 내부 스코프로 나누어서 b의 값을 유지하고자 했는데 함수 a를 호출할 때마다 계속해서 1이 출력된다.우리는 b의 값이 유지돼서 b++을 하고 있으므로 호출할 때마다 1이 상승된 값을 원했는데 그게 아니다.그러기 위해서는 조건 2를 만족시켜주면 된다.즉 참조하는 대상(b)이 존재하는 함수 a를 호출할 게 아니라 참조하는 녀석(console.log(b))이 존재하는 함수 c를 호출해야한다.함수 a를 백날 호출해봤자 지역변수 b를 초기화 시켜주는 구문이 매번 실행되기 때문에 참조를 아무리 한들 b의 값이 유지되는 게 아니다.하지만 스코프의 접근 가능한 스코프는 자신을 포함한 상위 스코프인데 전역 스코프에서 어떻게 로컬 스코프 a에 존재하는 c를 호출할 수 있을까?이는 자바스크립트의 특성인 함수는 first-class-citizen임을 활용하면 된다.전역 스코프에서 c를 호출할 수 있게 하려면 전역 변수와 함수 c 사이에 어떠한 매개체를 뚫어줘야한다.이는 위에서 말한 일급 객체의 특성을 살려 함수 a를 호출했을 때 함수 c(를 호출하는 게 아님)를 리턴함으로써 전역 스코프와 함수 c 사이에 다리를 놔준다고 보면 된다. 123456789101112var a = function() &#123; var b = 1; var c = function() &#123; console.log(b++); &#125;; return c;&#125;;a = a();a(); // 1a(); // 2a(); // 3a(); // 4 함수 a를 호출한 결과(내부 함수 c)를 다시 a에 담는 과정이 불필요하다고 생각되니 IIFE(즉시 실행 함수, Immediately Invoked Function Expressions)를 이용하면 아래와 같이 줄일 수 있다. 1234567891011var a = (function() &#123; var b = 1; var c = function() &#123; console.log(b++); &#125;; return c;&#125;)();a(); // 1a(); // 2a(); // 3a(); // 4 함수 c를 리턴할 수도 있지만, 아래와 같이 익명함수로 리턴하는 게 대부분이다. 12345678910var a = (function() &#123; var b = 1; return function() &#123; console.log(b++); &#125;;&#125;)();a(); // 1a(); // 2a(); // 3a(); // 4 함수 c와 같이 기명 함수를 리턴하는 경우는 함수 내에서 자기 자신을 호출하는 재귀 함수를 구현할 때 뿐인 것 같다. 123456789101112var a = (function() &#123; var b = 1; var c = function() &#123; console.log(b++); if(b &lt; 10) c(); &#125;; return c;&#125;)();a(); // 1 2 3 4 5 6 7 8 9a(); // 10a(); // 11a(); // 12 조건 3. 참조하는 대상이 전역 스코프가 아니어야한다.전역 스코프는 어차피 프로그램 종료 시까지 메모리에 계속 할당돼있으므로 상관이 없는 이야기이다. 그래서 클로저가 뭔데?먼저 클로저를 설명하기 보다는 적절한 사용 사례를 설명하고 클로저가 뭔지를 풀어 놓는 게 독자의 흥미를 유발할 거 같아서 일부러 뒤로 배치하였다.클로저는 다음과 같이 정의하고 있다.인사이드 자바스크립트 책에서는 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수,한 블로그에서는 생성 당시의 스코프에 대한 연결을 갖는 블록이라고 정의하고 있다.즉, 위에서 c가 클로저이다.변수 b는 지역 변수이므로 a 함수 종료와 동시에 죽어야하는 변수이다.하지만 그 생명 주기가 끝난 변수(b)를 참조하는 c라는 함수를 사용해서 클로저를 구현하였다. 클로저의 장점 위에서 본 바와 같이 함수를 호출할 때마다 기존에 생성했던 값을 유지할 수 있다. 외부에 해당 변수(참조하고 있는 변수)를 노출시키지 않는다.이게 무슨 장점이냐고 생각한다면 코드의 안정성을 보장해준다는 뜻이다.이는 캡슐화(encapsulation)와도 관련이 있는데 알약을 먹는 사람이 알약만 먹어서 병이 치료만 되면 되지, 그 내부의 내용물은 중요하지 않다는 개념이다.근데 만약 환자가 캡슐을 까서 내용물을 바꾸고 다시 캡슐을 씌우고 그 알약을 먹는다면?? 과연 환자의 상태를 보장할 수 있을까?이렇듯 프로그래밍에서 말하는 캡슐화는 환자가 내용물을 바꾸지 못하게(클로저에서 참조하는 변수를 변경하지 못하게 해서),즉 내가 개발한 소스를 사용하는 입장(내가 될 수도 있고 내가 만든 라이브러리를 사용하는 제 3자가 될 수도 있고)에서 코드의 안정성을 보장받게 되는 것이다.123456789101112// 개발자(약사) 입장에서 짠 코드var a = function() &#123; var b = 1; // 개발자가 변수에 값을 넣었다. (약사가 약의 내용물을 넣었다.) var c = function() &#123; // 클로저를 이용하여 내용을 캡슐화 하였다. (약사가 약들을 캡슐로 감쌌다.) console.log(b++); &#125;; return c; // 사용자(환자)가 해당 변수를 참조만 가능하고(약의 복용만 가능하고), 변경은 불가능하게(캡슐을 까서 그 안의 약물들을 못 갈아치우게) 했다.&#125;;// 실제 사용자(환자)는 해당 변수(약물)을 변경할 수 있는 방법이 없어서 코드의 안정성(환자의 상태)를 보장받을 수 있다.var d = a();d(); 클로저의 단점클로저는 위와 같이 좋은 점도 존재하는데 역시 신은 공평하듯 모든 걸 주시지 않았는데 바로 아래와 같은 단점이 존재하기 때문이다. 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당돼있다. 그게 뭐 어때서? 라고 생각하는 경우가 있을 수도 있고 위 경우가 크게 문제가 되지 않을 수도 있다.하지만 사용 가능한 메모리(브라우저마다 다르겠지만…)를 초과하는 사태가 발생할 수도 있고, 성능 상 좋다고 말할 수 있는 사항은 아니다.위와 같은 현상이 발생하는 이유는 계속해서 참조를 하고 있으므로 GC(Garbage Collecting) 대상이 되지 않기 때문이다.따라서 클로저는 이러한 성능 이슈를 가지고 있기 때문에 항상 주의를 기울여 사용을 최소화해야하며 오남용해서는 안 된다. 마치며클로저를 알아야 자바스크립트 고수니 중급으로 넘어가느니 등등의 얘기가 많이 들리는 것 같은데 실상 제대로 파고들어가 보면 별 거 아니란 사실을 알 수 있다.하지만 이와 같은 사항들을 알기 위해서는 아래와 같은 사항은 반드시 짚고 넘어가야 할 것이다. 변수의 스코프 변수의 생명주기(Lifecycle) GC(Garbage Collector)가 GC(Garbage Collecting)하는 대상 First Class Citizen","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Closure","slug":"Closure","permalink":"https://perfectacle.github.io/tags/Closure/"}]},{"title":"(자알쓰) JIT 컴파일","slug":"js-jit-compile","date":"2017-08-07T11:53:42.000Z","updated":"2022-10-30T08:42:16.699Z","comments":true,"path":"2017/08/07/js-jit-compile/","link":"","permalink":"https://perfectacle.github.io/2017/08/07/js-jit-compile/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 쉬어가는 타임으로 번외편 격인 JIT 컴파일에 대해 간단히 다뤄보았다. 자바스크립트는 인터스크립트 언어이다?책을 보면 위와 같이 말하는 경우가 존재한다.인터스크립트가 뭔데?에서 부터 막힌다면 아래 내용을 봐보자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 쉬어가는 타임으로 번외편 격인 JIT 컴파일에 대해 간단히 다뤄보았다. 자바스크립트는 인터스크립트 언어이다?책을 보면 위와 같이 말하는 경우가 존재한다.인터스크립트가 뭔데?에서 부터 막힌다면 아래 내용을 봐보자. 컴퓨터는 우리의 소스코드를 어떻게 이해할까?기본적으로 컴퓨터는 기계어(2진수(0과 1)로 이루어진 코드) 밖에 해석하지 못한다.바보 녀석 ㅎㅎ왜 10진수가 아닌 2진수를 사용하게 됐는지 궁금한 사람은 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유를 참고하자. 따라서 우리가 작성한 var a = &#39;a&#39;라는 코드를 기계어로 바꿔주는 행위를 해야한다. 이걸 사람이 직접 바꿔줘야할까…?매우 비효율적이므로 당연히 이를 도와주는 도구가 있는데 그 중 하나가 인터프리터이다. 인터프리트란…?(Interpret)코드를 실행하면서 한 줄 한 줄 기계어로 변환 후 실행하는 걸 인터프리트(Interpret)라고 한다.이 인터프리트하는 녀석을 인터프리터라고 부른다.자바스크립트는 이런 인터프리트 방식을 채택한 프로그래밍 언어였었다. 자바스크립트는 이런 인터프리트 방식을 채택한 프로그래밍 언어였었다라고…?그럼 과거에는 그렇고 지금은 아니라는 말인가…? 모던 브라우저의 자바스크립트 엔진은 모두 JIT 컴파일 방식으로 Javascript 코드를 해석하고 있다. 구글에서 개발한 V8(크롬, 오페라와 Node.js) 모질라에서 개발한 TraceMonkey(파이어폭스 3.5+부터 탑재) MS에서 개발한 Chakra(IE9+부터 탑재) Webkit 엔진에 탑재된 JavascriptCore(Safari에 탑재) 컴파일이란…?(Compile)이 JIT 컴파일에 대해 알아보기 이전에 컴파일에 대해 알아보도록 하자.우리가 짠 코드 전체를 한 번에 기계어로 변환해주는 걸 말한다.이러한 일을 컴파일러(Compiler)가 대신해준다. JIT 컴파일이란…?(Just in Time Compile)컴파일 방식과 인터프리트 방식의 장점을 짬뽕한 녀석이라고 보면 된다.컴파일 방식은 기계어로 컴파일 된 코드를 바로 실행하므로 빠른 실행 속도를 보장 받는다.인터프리트 방식은 소스가 수정돼도 귀찮게 매번 컴파일을 하지 않아도 된다는 장점이 존재한다.이 JIT 컴파일 방식은 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 컴파일하는 방식이라 동적 컴파일(Dynamic Compile)이라고도 부른다.당연히 과거 인터프리트 방식보다 성능 측면에서 향상이 있어서 사용한다고 보면 될 것 같다.인터프리트는 한줄씩 해석 - 실행 - 해석 - 실행의 반복인데JIT 컴파일은 실행할 때 한번에 해석 - 실행이기 때문이다. 결론적으로 자바스크립트가 인터프리트 언어라는 것은 과거에나 먹힐 법한 말이고 모던 브라우저(최신 브라우저)와 Node에서는 JIT 컴파일 언어라로 부르는 것이 맞다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"JIT","slug":"JIT","permalink":"https://perfectacle.github.io/tags/JIT/"}]},{"title":"(상식) 컴퓨터는 어떻게 우리가 작성한 코드를 이해할까?","slug":"how-can-computer-understand-our-source","date":"2017-08-07T10:02:39.000Z","updated":"2022-10-30T08:42:16.655Z","comments":true,"path":"2017/08/07/how-can-computer-understand-our-source/","link":"","permalink":"https://perfectacle.github.io/2017/08/07/how-can-computer-understand-our-source/","excerpt":"기본적으로 컴퓨터는 기계어(2진수(0과 1)로 이루어진 코드) 밖에 해석하지 못한다.바보 녀석 ㅎㅎ왜 10진수가 아닌 2진수를 사용하게 됐는지 궁금한 사람은 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유를 참고하자. 따라서 우리는 우리가 짠 코드를 기계어로 바꾸는 행위를 해야한다. 우리의 뇌는 이렇게 좋지도 않고, 효율성 측면에서 이러한 행위를 도와주는 도구가 세 가지가 있다.","text":"기본적으로 컴퓨터는 기계어(2진수(0과 1)로 이루어진 코드) 밖에 해석하지 못한다.바보 녀석 ㅎㅎ왜 10진수가 아닌 2진수를 사용하게 됐는지 궁금한 사람은 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유를 참고하자. 따라서 우리는 우리가 짠 코드를 기계어로 바꾸는 행위를 해야한다. 우리의 뇌는 이렇게 좋지도 않고, 효율성 측면에서 이러한 행위를 도와주는 도구가 세 가지가 있다. 1. 컴파일(Compile)우리가 짠 코드 전체를 기계어로 변환해주는 걸 말한다.이러한 일을 컴파일러(Compiler)가 대신해준다.언어에 의존적이므로 C언어 컴파일러, Java 컴파일러 이렇게 따로 따로 존재한다. 링크(Link)우리의 프로그램은 여러 모듈들의 조합으로 이루어져있다.하지만 컴파일러는 각 모듈들을 컴파일만 해줄 뿐, 합쳐주는 역할을 하진 않는다.따라서 이 링크는 여러 모듈들을 단일 프로그램으로 합치는 걸 말한다.링크 하는 프로그램을 링커(Linker)라고 부른다.링커가 링크한 결과로 단일 실행 파일인 *.exe 등등이 만들어진다. 로드(Load)단일 실행 파일을 메모리에 적재(Load)시키는 걸 말한다.로더(Loader)가 이런 일을 한다. 컴파일 언어의 동작 방식코딩 - 컴파일(컴파일러에 의해) - 링크(링커에 의해) - 로드(로더에 의해) 2. 인터프리트(Interpret)컴파일 방식은 실행 이전에 컴파일 과정을 거쳐야하므로 시간이 더 소요된다.또한 내용을 바꿀 때마다 계속 컴파일을 해줘야한다는 단점이 존재한다.하지만 인터프리트 방식은 소스 코드가 바뀌어도 컴파일 해주지 않아도 된다.실행하면서 한 줄 한 줄 해석해(인터프리트, Interpret)나가기 때문이다.이 인터프리트 해주는 녀석을 인터프리터(Interpreter)라고 부른다.Javascript가 이에 속했다. (모던한 환경이라면 아니라는 소리다.)하지만 단점으로 한 줄 한 줄 해석하고 실행하기 때문에 컴파일 된 파일을 실행하는 것보다는 느리다는 문제점이 존재한다. 3. JIT 컴파일(Just in Time Compile)컴파일 방식과 인터프리트 방식의 장점을 짬뽕한 녀석이라고 보면 된다.컴파일 방식은 기계어로 컴파일 된 코드를 바로 실행하므로 빠른 실행 속도를 보장 받는다.인터프리트 방식은 소스가 수정돼도 귀찮게 매번 컴파일을 하지 않아도 된다는 장점이 존재한다.이 JIT 컴파일 방식은 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 컴파일하는 방식이라 동적 컴파일(Dynamic Compile)이라고도 부른다.자바의 경우 소스코드(*.java) 파일을 JVM(Java Virtual Machine)이 이해할 수 있는 자바 바이트 코드(*.class)로 변환한다.하지만 컴퓨터는 자바 바이트 코드를 해석하지 못한다.따라서 JVM에서는 실행될 때 자바 바이트 코드를 기계어로 해석해주는 JIT 컴파일 방식을 채택했다.또한 Javascript에서도 JS 엔진(Javascript 코드를 해석해주는 역할을 담당하며 브라우저에 의존적이다.) 중에서는 아래와 같은 녀석들이 JIT 컴파일 방식을 채택했다. 구글에서 개발한 V8(크롬, 오페라와 Node.js) 모질라에서 개발한 TraceMonkey(파이어폭스 3.5+부터 탑재) MS에서 개발한 Chakra(IE9+부터 탑재) Webkit 엔진에 탑재된 JavascriptCore(Safari에 탑재)","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"JIT","slug":"JIT","permalink":"https://perfectacle.github.io/tags/JIT/"},{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"기계어","slug":"기계어","permalink":"https://perfectacle.github.io/tags/%EA%B8%B0%EA%B3%84%EC%96%B4/"},{"name":"컴파일","slug":"컴파일","permalink":"https://perfectacle.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC/"},{"name":"인터프리터","slug":"인터프리터","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/"}]},{"title":"(상식) 컴퓨터에서 2진수, 8진수, 16진수를 쓰게 된 이유","slug":"computer-number-making-reason","date":"2017-08-07T09:02:39.000Z","updated":"2022-10-30T08:42:16.363Z","comments":true,"path":"2017/08/07/computer-number-making-reason/","link":"","permalink":"https://perfectacle.github.io/2017/08/07/computer-number-making-reason/","excerpt":"여러 책을 보고 혼자서 내린 결론이기 때문에 틀릴 가능성이 있으니 지적해주면 감사하겠습니다 ^^ 최초의 컴퓨터는 10진수를 사용했다.나는 처음부터 2진수를 사용한 줄 알았는데 최초의 컴퓨터인 에니악은 10진수를 사용했다고 한다.아마도 우리의 손가락이 10개이고 평상시에 연산을 할 때도 10진수를 주로 사용하기 때문에 익숙해서 10진수를 사용했던 게 아닐까? 그럼 왜 컴퓨터는 2진수를 사용하게 됐을까?","text":"여러 책을 보고 혼자서 내린 결론이기 때문에 틀릴 가능성이 있으니 지적해주면 감사하겠습니다 ^^ 최초의 컴퓨터는 10진수를 사용했다.나는 처음부터 2진수를 사용한 줄 알았는데 최초의 컴퓨터인 에니악은 10진수를 사용했다고 한다.아마도 우리의 손가락이 10개이고 평상시에 연산을 할 때도 10진수를 주로 사용하기 때문에 익숙해서 10진수를 사용했던 게 아닐까? 그럼 왜 컴퓨터는 2진수를 사용하게 됐을까?전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는데 한계가 있다.따라서 에니악과 에드삭은 10진수를 이용했던 데 반해그 후속 시리즈인 에드박은 전압을 2단계로 나누어 처리하는 2진수를 사용하였다.즉, 전기가 흐르면 1, 전기가 흐르지 않으면 0만으로 동작하게 설계하게 된 것이다.결론을 내리자면 전기회로는 전압이 불안정해서 전압을 두 단계로 나누어 처리하는 게 안정적이다 보니 2진수를 사용하게 된 것이다. 8진수, 16진수는 왜 생겼을까? 4진수는 왜 안 쓰이는 것일까?2진수는 숫자를 표현하기 위해 상당히 많은 자릿수를 차지한다.코딩할 때도 이렇게 많은 자릿수는 가독성을 해칠 수 있다.따라서 이런 단점을 보완하기 위해 8진수와 16진수가 등장했다.그렇다면 왜 8진수와 16진수일까?2진수 2자리로는 4진수를2진수 3자리로는 8진수를2진수 4자리로는 16진수를 표현할 수 있다.2진수 2자리는 그닥 많은 자릿수를 절약할 수 없어서 사용을 안 하게 된 게 아닐까 싶다…8진수를 사용하는 대표적인 예는 리눅스나 FTP 등에서 파일이나 폴더에 관한 권한을 표현하기 위해 많이 쓰인다.777 을 예로 들면r 읽기 허용(4) w 쓰기 허용(2) x 실행 허용(1) 을 다 더하면 7이 나오고u 사용자(소유자) g 그룹 o 기타(사용자와 그룹을 제외한 사람) 순서로 기술하면 된다.16진수를 사용하는 대표적인 예는 rgb 컬러 코드(#ff00ff), 유니코드(\\u0061, U+0061, 0x0061 등등)에서 쓰인다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"진법","slug":"진법","permalink":"https://perfectacle.github.io/tags/%EC%A7%84%EB%B2%95/"}]},{"title":"(상식) 왜 1byte는 8bit일까?","slug":"why-1byte-is-8bit","date":"2017-08-07T09:02:39.000Z","updated":"2022-10-30T08:42:17.019Z","comments":true,"path":"2017/08/07/why-1byte-is-8bit/","link":"","permalink":"https://perfectacle.github.io/2017/08/07/why-1byte-is-8bit/","excerpt":"과거에는 1byte가 7bit, 9bit 등등이던 시절이 있다고 하지만 현재는 8비트로 거의 표준이 된 것 같다.왜일까?이 포스트는 아래 링크를 참조하여 제 머릿 속을 바탕으로 글을 썼기 때문에 틀린 점이 있다면 댓글로 적어주길 바랍니다~ 아스키(Ascii) 메모리 하나당 차지하는 바이트 수에 대해 궁금한 점이 있습니다. 메모리 주소당 데이터용량이 1바이트인 이유가 먼가요?? 1바이트는 왜 8비트일까? 컴퓨터는 미국에서 개발했다.따라서 미국 특화(+유럽권과의 통신 등등을 고려하여 유렵권까지 특화)해서 만들었다.따라서 아시아나 아프리카 등등에는 별로 특화돼있지 않았다. (지금은 많이 완화된 것 같지만…)1byte의 bit 수를 결정 짓는 결정적인 요인은 아마 ASCII라는 문자 인코딩 때문일 것이다.ASCII는 미국권 문자를 표현하는 문자 인코딩(문자의 집합)인데 통신을 위한 기호와 특수기호 + 숫자 + 알파벳 대소문자를 표현할 수 있다.당연히 미국에서 개발했으니 미국에서 쓰이는 문자만 표현하면 되는 것이었다.이 ASCII를 표현하는데는 7bit(128자)로 충분했고, 이 ASCII를 베이스로 byte(하나의 문자를 담는 단위)가 결정된 게 아닐까 싶다.","text":"과거에는 1byte가 7bit, 9bit 등등이던 시절이 있다고 하지만 현재는 8비트로 거의 표준이 된 것 같다.왜일까?이 포스트는 아래 링크를 참조하여 제 머릿 속을 바탕으로 글을 썼기 때문에 틀린 점이 있다면 댓글로 적어주길 바랍니다~ 아스키(Ascii) 메모리 하나당 차지하는 바이트 수에 대해 궁금한 점이 있습니다. 메모리 주소당 데이터용량이 1바이트인 이유가 먼가요?? 1바이트는 왜 8비트일까? 컴퓨터는 미국에서 개발했다.따라서 미국 특화(+유럽권과의 통신 등등을 고려하여 유렵권까지 특화)해서 만들었다.따라서 아시아나 아프리카 등등에는 별로 특화돼있지 않았다. (지금은 많이 완화된 것 같지만…)1byte의 bit 수를 결정 짓는 결정적인 요인은 아마 ASCII라는 문자 인코딩 때문일 것이다.ASCII는 미국권 문자를 표현하는 문자 인코딩(문자의 집합)인데 통신을 위한 기호와 특수기호 + 숫자 + 알파벳 대소문자를 표현할 수 있다.당연히 미국에서 개발했으니 미국에서 쓰이는 문자만 표현하면 되는 것이었다.이 ASCII를 표현하는데는 7bit(128자)로 충분했고, 이 ASCII를 베이스로 byte(하나의 문자를 담는 단위)가 결정된 게 아닐까 싶다. 그렇다면 왜 1byte는 7bit가 아닌 8bit일까?내가 내린 추측은 아래 두 가지이다. 데이터 송수신의 오류를 검출하기 위한 패리티 비트로 1비트가 추가됐다. 유럽권을 고려해서 확장 아스키 코드를 베이스로 정했다.유럽권 문자까지 표현하는데 8bit(256자)면 충분하다고 여겨서 정한 것 같다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"}]},{"title":"(자료구조) Queue를 만들어보자!","slug":"queue-making","date":"2017-08-06T12:03:03.000Z","updated":"2022-10-30T08:42:16.879Z","comments":true,"path":"2017/08/06/queue-making/","link":"","permalink":"https://perfectacle.github.io/2017/08/06/queue-making/","excerpt":"큐는 스택과 반대로 선입선출(FIFO, First In First Out)의 구조를 가지는 자료구조이다.먼저 들어온 놈이 먼저 나가는 구조이니 입력 순서에 따른 처리를 위한 자료에서 많이 사용한다. (OS의 프로세스 스케쥴링)스택과 비교해보면 push 대신에 offer, pop 대신에 offer를 메소드를 사용한다. 만들어보자!기본적으로 큐를 만들어보기 전에 먼저 링크드리스트에 대해 알아야한다.기존에 스택처럼 생각했을 때 두 가지 데이터를 들고 있어야했다. 인덱스(몇 번째에 데이터를 삽입하고 뽑아낼지) 실제 데이터 덩어리이 경우에는 데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어졌다.하지만 큐의 경우에는 스택과 같이 두 개의 데이터만 들고 있다고 가정했을 때데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어지는 건 당연하고,데이터를 꺼낼 때 처음 인덱스의 데이터를 꺼내야하는데 그렇게 되면 이가 빠진 것처럼 왼쪽이 비기 때문에 전부 한 칸씩 땡겨야한다.즉, 데이터를 삽입&#x2F;삭제(추출?) 할 때 모두 큰 비용을 들이게 된다.따라서 큐를 구현할 때는 스택에서 출발할 게 아니라 링크드리스트에서 출발을 해야한다.링크드리스트의 구조 대로 구현하면 삽입&#x2F;삭제가 용이하기 때문이다.","text":"큐는 스택과 반대로 선입선출(FIFO, First In First Out)의 구조를 가지는 자료구조이다.먼저 들어온 놈이 먼저 나가는 구조이니 입력 순서에 따른 처리를 위한 자료에서 많이 사용한다. (OS의 프로세스 스케쥴링)스택과 비교해보면 push 대신에 offer, pop 대신에 offer를 메소드를 사용한다. 만들어보자!기본적으로 큐를 만들어보기 전에 먼저 링크드리스트에 대해 알아야한다.기존에 스택처럼 생각했을 때 두 가지 데이터를 들고 있어야했다. 인덱스(몇 번째에 데이터를 삽입하고 뽑아낼지) 실제 데이터 덩어리이 경우에는 데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어졌다.하지만 큐의 경우에는 스택과 같이 두 개의 데이터만 들고 있다고 가정했을 때데이터를 기존의 스택 크기보다 많이 삽입했을 때만 복사가 이루어지는 건 당연하고,데이터를 꺼낼 때 처음 인덱스의 데이터를 꺼내야하는데 그렇게 되면 이가 빠진 것처럼 왼쪽이 비기 때문에 전부 한 칸씩 땡겨야한다.즉, 데이터를 삽입&#x2F;삭제(추출?) 할 때 모두 큰 비용을 들이게 된다.따라서 큐를 구현할 때는 스택에서 출발할 게 아니라 링크드리스트에서 출발을 해야한다.링크드리스트의 구조 대로 구현하면 삽입&#x2F;삭제가 용이하기 때문이다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"https://perfectacle.github.io/categories/Middle-end/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Queue","slug":"Queue","permalink":"https://perfectacle.github.io/tags/Queue/"}]},{"title":"(자료구조) List - LinkedList를 만들어보자!","slug":"linked-list-making","date":"2017-08-06T11:03:03.000Z","updated":"2022-10-30T08:42:16.843Z","comments":true,"path":"2017/08/06/linked-list-making/","link":"","permalink":"https://perfectacle.github.io/2017/08/06/linked-list-making/","excerpt":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다.또한 여기서 말하는 노드는 하나의 데이터 덩어리라고 보면 될 것 같다. LinkedList란…?LinkedList는 스택의 다음과 같은 단점을 극복하고자 만들어졌다. 노드의 끝 부분을 제외한 곳에 데이터 삽입스택은 끝 부분에만 데이터를 삽입할 수 있으므로 중간에 데이터를 삽입할 방법이 존재하지 않았다.LinkedList는 배열의 이러한 단점을 노드(배열의 각 요소)가 다음 주소지를 알게 함으로써 그 단점을 극복하였다.","text":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다.또한 여기서 말하는 노드는 하나의 데이터 덩어리라고 보면 될 것 같다. LinkedList란…?LinkedList는 스택의 다음과 같은 단점을 극복하고자 만들어졌다. 노드의 끝 부분을 제외한 곳에 데이터 삽입스택은 끝 부분에만 데이터를 삽입할 수 있으므로 중간에 데이터를 삽입할 방법이 존재하지 않았다.LinkedList는 배열의 이러한 단점을 노드(배열의 각 요소)가 다음 주소지를 알게 함으로써 그 단점을 극복하였다. 하지만 신은 공평하듯, 이 LinkedList에도 다음과 같은 장&#x2F;단점이 있다. 데이터의 접근 속도가 느리다.LinkedList는 다음 노드에 대한 참조만을 가지고 있다.따라서 255 번째 노드의 데이터를 불러오려면 처음부터 순차적으로 255 번째 노드까지 접근해야한다.배열에 비해 이러한 접근 속도가 매우 느리다. 다음 노드에 대한 참조만 있을 뿐, 이전 노드에 대한 데이터는 없다.따라서 이전 노드의 값을 가져올 수는 없다.이는 Doubly Linked List라는 이중 링크드 리스트라는 자료구조를 만들어 해결하였다. 처음 노드에서 마지막 노드로, 혹은 마지막 노드에서 처음 노드로 가려면 시간이 오래 걸린다.Doubly Linked List를 이용해도 순차적인 접근 밖에 되지 않기 때문에 어쨌든 계속해서 노드들을 타고 타고 끝이나 처음으로 이동해야 한다.이러한 단점을 극복하기 위해 처음 노드에 대한 이전 참조를 마지막 노드로, 마지막 노드에 대한 다음 참조를 처음 노드로 이어줘 원형 구조로 만든 Doubly Circular Linked List가 있다. 따라서 이 LinkedList를 잘 살리려면 중간에 삽입&#x2F;삭제가 빈번하며 검색을 자주 하지 않는 자료를 담을 때 사용해야한다. 만들어보자!먼저 기본적인 Node부터 만들어보았다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Node &#123; private Object value; private Node next; Node(Object o) &#123; this.value = o; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object o) &#123; this.value = o; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; boolean isLast() &#123; // 마지막 노드인지 return this.next == null; &#125; public boolean equals(Node node) &#123; // 내용물과 참조하는 애가 같은지 return value.equals(node.getValue()) &amp;&amp; next == node.getNext(); &#125;&#125;class NodeTest &#123; public static void main(String[] args) &#123; Node n = new Node(2); Node n2 = new Node(2); Node n3 = new Node(2); Node n4 = new Node(3); n.setNext(n4); // n 다음에 n4 n2.setNext(n4); // n2 다음에 n4 n3.setNext(n); // n3 다음에 n System.out.println(n.equals(n2)); // true System.out.println(n.equals(n3)); // false System.out.println(n.isLast()); // false System.out.println(n4.isLast()); // true // 지금 구조(List)는 n3(2) 다음에 n(2) 다음에 n4(3) 순으로 연결(Linked)돼있다. // 초기 노드를 지정해주고, 계속해서 다음 노드를 참조하는 걸 증감식에 적어줌, for(Node node = n3; true; node = node.getNext()) &#123; // 탈출 조건이 있는 무한 반복문 // 마지막 노드여도 출력까지는 해줘야함. System.out.println(node.getValue()); // 2 2 3 if(node.isLast()) break; &#125; &#125;&#125; 그 다음엔 LinkedList를 만들어보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class LinkedList &#123; private Node[] nodes; private int idx; // 현재 리스트의 몇 번째 요소까지 노드가 들어왔는지 확인하는 변수 LinkedList() &#123; this(10); // 기본적으로 10개를 만들어주자, 너무 작게 만들면 복사하는 처리 비용이 많이 들테니... &#125; LinkedList(int size) &#123; nodes = new Node[size]; &#125; void add(Object o) &#123; // 맨 끝에 삽입하는 경우 int size = size(); Node node = new Node(o); // 꽉차지 않았다면 if(idx != size) nodes[idx] = node; // 현재 인덱스에 노드 삽입. else &#123; // 꽉 찼으면 Node[] tmpNodes = new Node[size+10]; // 나중에 또 금방 복사하지 않게 적절하게 큰 배열을 만들자. for(int i=0; i&lt;size; i++) tmpNodes[i] = nodes[i]; // 기존의 값들을 새로운 배열에 복사 tmpNodes[idx] = node; // 새로운 값 삽입 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 &#125; if(idx == 0) &#123; idx++; return; // 하나만 넣은 거면 참조 관계를 수정할 필요가 없음. &#125; nodes[idx-1].setNext(nodes[idx++]); // 이전 노드의 참조를 현재 노드로 변경 &#125; void add(int idx, Object o) &#123; // 인덱스를 지정해 해당 지점에 삽입하려는 경우 // List는 선형구조이므로 데이터를 삽입해야할 인덱스보다 더 뒤에 노드를 삽입하는 것은 불가능하다. // 당연히 배열의 인덱스를 벗어나는 음수도 불가능하다. if(this.idx &lt; idx || idx &lt; 0) throw new ArrayIndexOutOfBoundsException(&quot;올바른 인덱스를 입력해주세요!&quot;); // 배열의 중간에 노드를 삽입하는 게 아닌 경우 if(idx == this.idx) this.add(o); else &#123; // 배열의 중간에 노드를 삽입하는 경우 int size = size(); Node node = new Node(o); // 꽉 차지 않았다면 기존과 동일한 사이즈의 배열 생성, 아니라면 넉넉히 길이가 10 더 긴 배열 생성. Node[] tmpNodes = idx != size ? new Node[size] : new Node[size+10]; // 복사할 배열을 직접 넘겨줘서 추가하기. for(int i=0; i&lt;idx; i++) tmpNodes[i] = nodes[i]; // idx 이전까지는 그대로 복사 for(int i=idx; i&lt;this.idx; i++) &#123; // last까지 복사 tmpNodes[i+1] = nodes[i]; // idx 이후는 한 칸씩 밀어서 복사 &#125; tmpNodes[idx] = node; // 새로운 배열에 지금 들어온 노드 삽입 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 nodes[idx].setNext(nodes[idx-1].getNext()); // idx 노드는 중간에 끼어들었으므로 idx 노드 이전 노드의 참조를 가리켜야함. nodes[idx-1].setNext(nodes[idx]); // idx 이전 노드의 참조는 idx 노드를 가리키고 있어야함. this.idx++; &#125; &#125; void remove() &#123; nodes[--idx] = null; // 마지막 노드 삭제 후 인덱스 1 낮춤. nodes[idx-1].setNext(null); // 이전 노드가 마지막 노드이므로 참조할 노드가 없음. &#125; void remove(int idx) &#123; Node[] tmpNodes = new Node[size()]; // 배열을 한 칸씩 땡겨야하므로 새롭게 배열 생성. Node node = getNode(idx).getNext(); // idx 번째 노드가 갖고 있는 참조 노드 for(int i=0; i&lt;idx; i++) tmpNodes[i] = nodes[i]; // idx 이전까지 복사 for(int i=idx+1; i&lt;this.idx; i++) tmpNodes[i-1] = nodes[i]; // idx 이후로 또 복사 nodes = tmpNodes; // 복사한 배열을 원본 배열 변수로 갈아치우기 nodes[idx-1].setNext(node); this.idx--; &#125; Object get(int idx) &#123; Node node = getNode(idx); return node == null ? null : node.getValue(); &#125; Node getNode(int idx) &#123; Node node=nodes[0]; // idx까지 계속 다음 참조 노드를 구함. for(int i=0; i&lt;idx; i++, node=node.getNext()); return node; &#125; int size() &#123; return nodes.length; &#125;&#125;class LinkdedListTest &#123; public static void main(String[] args) &#123; LinkedList l = new LinkedList(); l.add(1); l.add(&quot;a&quot;); System.out.println(l.get(0)); // 1 // 0번째 노드를 구하고 그 참조 노드를 구하고 값을 얻기 System.out.println(l.getNode(0).getNext().getValue()); // a for(int i=0; i&lt;10; i++) l.add(i); // 1 a 0 1 2 3 4 6 7 8 9 System.out.println(l.get(11)); // 9 l.add(11, 22); System.out.println(l.get(11)); // 22 LinkedList l2 = new LinkedList(); l2.add(1); l2.add(2); l2.add(3); l2.add(4); System.out.println(l2.get(3)); // 4 l2.remove(); System.out.println(l2.get(3)); // null System.out.println(l2.get(1)); // 2 l2.remove(1); System.out.println(l2.get(1)); // 3 &#125;&#125; 틀린 게 많을지는 모르겠지만…일단은 구현을 했다는 것에 의의를 두고 나중에 다시 수정해야겠다.","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"https://perfectacle.github.io/categories/Middle-end/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://perfectacle.github.io/tags/LinkedList/"},{"name":"List","slug":"List","permalink":"https://perfectacle.github.io/tags/List/"}]},{"title":"(자료구조) List - Stack(Pushdown List)을 만들어보자!","slug":"stack-making","date":"2017-08-05T18:44:56.000Z","updated":"2022-10-30T08:42:16.919Z","comments":true,"path":"2017/08/05/stack-making/","link":"","permalink":"https://perfectacle.github.io/2017/08/05/stack-making/","excerpt":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다. 스택이란…?스택은 후입선출(LIFO, Last In First Out)의 구조를 가지는 자료구조이다.기본적으로 배열이 스택의 구조로 이루어져있고, CPU가 연산을 할 때 연산자에 우선순위 메겨놓고 연산할 때도 스택을 이용하는 것으로 알고 있다.그리고 프로그래밍을 배우다 보면 콜스택이라고 해서 함수의 실행 컨텍스트(EC, Execution Context)가 계속해서 쌓이는데 그 콜스택도 스택이라는 자료구조를 이용하고 있다.몇 번째에다가 데이터를 넣어야하고, 몇 번째에서 데이터를 빼야할지에 대한 인덱스(포인터)를 가지고 있어야한다.데이터 처리를 먼저하고 인덱스를 바꾸는 경우와 인덱스를 바꾸고 데이터를 처리하는 방식이 있다.기본적으로 push()라는 메소드로 데이터를 넣고 pop()라는 메소드로 데이터를 뺀다. 만들어보자!","text":"List는 데이터를 순차적으로 저장하므로 선형 구조(한 줄로 계속 되며, 데이터가 끊어지지 않음)이다. 스택이란…?스택은 후입선출(LIFO, Last In First Out)의 구조를 가지는 자료구조이다.기본적으로 배열이 스택의 구조로 이루어져있고, CPU가 연산을 할 때 연산자에 우선순위 메겨놓고 연산할 때도 스택을 이용하는 것으로 알고 있다.그리고 프로그래밍을 배우다 보면 콜스택이라고 해서 함수의 실행 컨텍스트(EC, Execution Context)가 계속해서 쌓이는데 그 콜스택도 스택이라는 자료구조를 이용하고 있다.몇 번째에다가 데이터를 넣어야하고, 몇 번째에서 데이터를 빼야할지에 대한 인덱스(포인터)를 가지고 있어야한다.데이터 처리를 먼저하고 인덱스를 바꾸는 경우와 인덱스를 바꾸고 데이터를 처리하는 방식이 있다.기본적으로 push()라는 메소드로 데이터를 넣고 pop()라는 메소드로 데이터를 뺀다. 만들어보자!아직은 쉬운 자료구조라 그런지 만드는데 재미있었다 ㅎㅎArray도 스택 구조로 이루어져있는 만큼 자바로 구현하면 ArrayList를 상속 받으면 쉽게 구현이 가능하다.또한 기존에 만들었던 스택의 크기보다 더 많은 데이터를 삽입할 경우에는 더 큰 스택을 만들고 기존의 스택을 복사해야하는데 이 때도 자바의 내장 API를 사용하면 매우 쉽게 구현이 가능하다.하지만 자료구조를 만드는 것은 알고리즘을 향상 시키기 위한 목적도 있기 때문에 최대한 이런 내장 API나 라이브러리들은 배제하고 만들어보았다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Stack &#123; Object[] objs; int idx = 0; // 현재 스택이 몇 번째 인덱스를 가리키고 있는지(넣고 올린다, 올리고 넣는 게 아니라) public Stack() &#123; this(10); // 기본적으로 10개를 만들어주자, 너무 작게 만들면 복사하는 처리 비용이 많이 들테니... &#125; public Stack(int i) &#123; if(i &lt; 1) throw new ArrayIndexOutOfBoundsException(&quot;스택의 크기는 자연수여야합니다!&quot;); objs = new Object[i]; &#125; void push(Object obj) &#123; int len = objs.length; // 꽉 차지 않았다면 if(idx != len) objs[idx++] = obj; else &#123; // 꽉 찼으면 Object[] tmpObjs = new Object[len+10]; // 나중에 또 금방 복사하지 않게 적절하게 큰 배열을 만들자. for(int i=0; i&lt;len; i++) tmpObjs[i] = objs[i]; tmpObjs[idx++] = obj; objs = tmpObjs; &#125; &#125; Object pop() &#123; if(idx == 0) throw new ArrayIndexOutOfBoundsException(&quot;스택에 들어와있는 값이 없습니다!&quot;); Object obj = objs[--idx]; objs[idx] = null; return obj; &#125; int size() &#123; return objs.length; &#125; void setSize(int i) &#123; int len = objs.length; int copyLen = i &gt; len ? len : i; // 몇 개를 복사해야할지 if(i &lt; 1) throw new ArrayIndexOutOfBoundsException(&quot;스택의 크기는 자연수여야합니다!&quot;); if(i == len) return; Object[] tmpObjs = new Object[i]; for(int j=0; j&lt;copyLen; j++) tmpObjs[j] = objs[j]; objs = tmpObjs; &#125; boolean empty() &#123; return objs[0] == null; &#125;&#125;class StackTest &#123; public static void main(String[] args) &#123; Stack s = new Stack(); System.out.println(s.size()); // 10 s = new Stack(20); System.out.println(s.size()); // 20 // 자연수가 아니라 ArrayIndexOutOfBoundsException 예외를 뱉게 했는데 맞을라나 ㅠㅠ // s = new MyStack(0); s.setSize(4); System.out.println(s.size()); // 4 // 자연수가 아니라 ArrayIndexOutOfBoundsException 예외를 뱉게 했는데 맞을라나 ㅠㅠ // s.setSize(-1); // 들어와 있는 값이 없으므로 예외 던짐 // s.pop(); for(int i=0; i&lt;9; i++) &#123; // 스택의 길이보다 긴 데이터를 넣어보자. s.push(i%3); &#125; // 0 1 2 0 1 2 0 1 2 while(!(s.empty())) System.out.print(s.pop() + &quot; &quot;); System.out.println(); System.out.println(s.empty()); // true &#125;&#125; 심심하니까 자스로도 만들어보자 ㅎㅎ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Stack = class &#123; constructor(size=10) &#123; if(size &lt; 1) throw RangeError(&quot;스택의 크기는 자연수여야합니다!&quot;); this.objs = new Array(size); this.idx = 0; &#125; push(obj) &#123; const len = this.objs.length; // 꽉 차지 않았다면 if(this.idx !== len) this.objs[this.idx++] = obj; else &#123; // 꽉 찼다면 const tmpObjs = new Array(len+10); for(let i=0; i&lt;len; i++) tmpObjs[i] = this.objs[i]; tmpObjs[this.idx++] = obj; this.objs = tmpObjs; &#125; &#125; pop() &#123; if(this.idx === 0) throw RangeError(&quot;스택에 들어와있는 값이 없습니다!&quot;); const obj = this.objs[--this.idx]; this.objs[this.idx] = null; return obj; &#125; size() &#123; return this.objs.length; &#125; setSize(i) &#123; const len = this.objs.length; const copyLen = i &gt; len ? len : i; // 몇 개를 복사해야할지 // const copyLen = Math.min(i, len); if(i &lt; 1) throw RangeError(&quot;스택의 크기는 자연수여야합니다!&quot;); if(i === len) return; const tmpObjs = new Array(i); for(let j=0; j&lt;copyLen; j++) tmpObjs[j] = this.objs[j]; this.objs = tmpObjs; &#125; empty() &#123; return this.objs[0] === null; &#125;&#125;;let s = new Stack();console.log(s.size()); // 10s = new Stack(20);console.log(s.size()); // 20// s.setSize(0);s.setSize(2);console.log(s.size()); // 2for(let i=0; i&lt;9; i++) s.push(i%3);while(!(s.empty())) console.log(s.pop()); // 2 1 0 2 1 0 2 1 0console.log(s.empty()); // true","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"https://perfectacle.github.io/categories/Middle-end/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Stack","slug":"Stack","permalink":"https://perfectacle.github.io/tags/Stack/"}]},{"title":"(Java) 자바의 정석 3판 015일차 - 유용한 클래스, 날짜와 시간 & 형식화, 컬렉션","slug":"Java-study-015day","date":"2017-08-05T15:17:49.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/08/05/Java-study-015day/","link":"","permalink":"https://perfectacle.github.io/2017/08/05/Java-study-015day/","excerpt":"java.util 패키지Random 클래스12345678910111213import java.util.Random;class Test &#123; public static void main(String[] args) &#123; // 두 코드는 일치 double r = Math.random(); double r2 = new Random().nextDouble(); // 두 코드는 일치 double r3 = (Math.random() * 6) + 1; double r4 = new Random().nextInt(6) + 1; &#125;&#125; Random 클래스도 내부적으로 Math.random() 메소드를 사용하고 있다.또 Random 클래스는 seed를 지정해 동일한 난수를 반환받을 수 있다.","text":"java.util 패키지Random 클래스12345678910111213import java.util.Random;class Test &#123; public static void main(String[] args) &#123; // 두 코드는 일치 double r = Math.random(); double r2 = new Random().nextDouble(); // 두 코드는 일치 double r3 = (Math.random() * 6) + 1; double r4 = new Random().nextInt(6) + 1; &#125;&#125; Random 클래스도 내부적으로 Math.random() 메소드를 사용하고 있다.또 Random 클래스는 seed를 지정해 동일한 난수를 반환받을 수 있다. 1234567891011class Test &#123; public static void main(String[] args) &#123; // 동일한 seed를 지정 double r = new Random(122).nextInt(3); double r2 = new Random(122).nextInt(3); // Random 클래스를 썼지만 두 난수는 동일하고, 항상 같은 2.0이란 결과가 나온다. System.out.println(r); System.out.println(r2); &#125;&#125; 기본적으로 seed를 지정해주지 않으면 다음과 같은 생성자를 호출한다. 123public Random() &#123; this(System.currentTimeMillis());&#125; seed 값으로 현재 컴퓨터 시간을 밀리세컨드 단위로 넘겨주고 있다. regex 패키지정규식(Regular Expression)을 위한 패키지이다.정규식은 Unix에서 사용했었고, Perl의 강력한 기능이었는데 요즘엔 웬만한 언어에서는 지원하는 것 같다. 12345678910class Test &#123; public static void main(String[] args) &#123; String[] data = &#123;&quot;bat&quot;, &quot;baby&quot;, &quot;bonus&quot;, &quot;cA&quot;, &quot;ca&quot;, &quot;co&quot;, &quot;c.&quot;&#125;; Pattern p = Pattern.compile(&quot;c[a-z]&quot;); // c로 시작하고 그 뒤에 소문자가 오는 문자열 찾기. for(String dat : data) &#123; Matcher m = p.matcher(dat); if(m.matches()) System.out.println(dat); // ca co &#125; &#125;&#125; Pattern은 정규식을 정의하는데 사용되고, Matcher는 정규식 패턴을 데이터와 비교하는 역할을 한다.matcher의 매개변수로는 CharSequence 인터페이스의 구현체인 CharBuffer, String, StringBuffer가 있다. 12345678910111213class Test &#123; public static void main(String[] args) &#123; String source = &quot;HP:011-1111-1111, HOME:02-999-9999&quot;; String pattern = &quot;(0\\\\d&#123;1,2&#125;)-(\\\\d&#123;3,4&#125;)-(\\\\d&#123;4&#125;)&quot;; // ()로 그룹핑이 가능하다. Pattern p = Pattern.compile(pattern); Matcher m = p.matcher(source); while(m.find()) &#123; // group 메소드가 있어서 몇 번째 그룹에 속했는지도 출력이 가능하다. System.out.println(m.group() + &quot; -&gt; &quot; + m.group(1) + &quot;, &quot; + m.group(2) + &quot;, &quot; + m.group(3)); &#125; &#125;&#125; StringTokenizer 클래스문자열을 구분자(delimiter)를 기준으로 토큰이라는 여러 개의 문자열로 잘라내는 데 사용한다. 123456789class Test &#123; public static void main(String[] args) &#123; String source = &quot;100,200 300&quot;; StringTokenizer t = new StringTokenizer(source, &quot;, &quot;); // 쉼표와 공백 하나 하나가 구분자가 된다. while(t.hasMoreTokens()) &#123; System.out.println(t.nextToken()); &#125; &#125;&#125; java.math 패키지아래 두 클래스는 String 클래스와 마찬가지로 immutable이다. BigInteger 클래스int 배열을 통해 값을 다뤄서 long 보다 크지만 성능은 떨어진다. BigDecimal 클래스부동소수점이 정밀도에 따른 오차를 가지고 있어서 실수 연산은 정수로 변환 후 계산하는 게 더 낫다.이 BigDecimal 클래스도 정수를 이용해서 실수를 표현해 그 오차를 줄였다. 형식화소수점 n 번째 자리에서 반올림 하려면 곱하고 나누고 뻘짓을 하고 쿵짝쿵짝 덩기덕 쿵더러러러를 해야했다.매우 귀찮은데 이런 것들을 형식화해서 보여주는 클래스가 형식화 클래스이며 java.text 패키지 안에 존재한다.엑셀에서 % 붙이고 원화 붙이고 1,000처럼 보여주기 등등의 경우에 해당한다. DecimalFormat: 십진수 형식화 클래스, 실수 정수 다 가능하다. 123456789101112131415161718class Test &#123; public static void main(String[] args) throws ParseException &#123; // 기존 방법 double d = 1.235678; int i = (int)(d * 1000)+5; d = i / 1000.0; System.out.println(d); // 1.24 // 방법 1 DecimalFormat df = new DecimalFormat(&quot;#.##&quot;); System.out.println(df.format(d)); // 1.24 // 방법 2 Number n = df.parse(&quot;&quot;+d); double d2 = n.doubleValue(); System.out.println(d2); &#125;&#125; SimpleDateFormat: 날짜와 시간 관련 형식화 클래스. 12345678910class Test &#123; public static void main(String[] args) throws ParseException &#123; Date today = new Date(); SimpleDateFormat sd = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); System.out.println(sd.format(today)); // 2017-08-05 Date d = sd.parse(&quot;2017-08-05&quot;); System.out.println(d); // Sat Aug 05 00:00:00 KST 2017 &#125;&#125; ChoiceFormat: 특정 범위에 속하는 값을 문자열로 변환해준다. MessageFormat: 데이터를 정해진 양식에 맞게 출력할 수 있도록 도와준다. 1234567891011121314class Test &#123; public static void main(String[] args) throws ParseException &#123; String msg = &quot;Name: &#123;0&#125;, Age: &#123;1&#125;&quot;; Object[] arg = &#123;&quot;양간장&quot;, 25&#125;; String res = MessageFormat.format(msg, arg); System.out.println(res); // Name: 양간장, Age: 25 MessageFormat mf = new MessageFormat(msg); Object[] arg2 = mf.parse(res); for(Object arg3:arg2) &#123; System.out.println(arg3); // 양간장 25 &#125; &#125;&#125; 날짜와 시간JAVA8부터는 java.time 패키지의 등장으로 인해 Date와 Calendar 클래스를 배울 필요가 없다고 생각하지만…이미 그 클래스를 쓴 레거시 코드들이 많아서 배워야한다 ㅠㅠDate는 JAVA1부터 나와서 굉장히 허접해서 Calendar 클래스가 나왔고 Date 클래스도 많이 발전했다고는 한다.필요하면 찾아서 보자~ java.time 패키지Calendar 클래스는 immutable이 아니라 멀티 쓰레드 환경에서 안전하지 못했다.또한 java.time이 나왔다 하더라도 레거시 코드 때문에 여전히 Date나 Calendar 클래스는 쓰일 것이다 ㅠㅠ 핵심적인 클래스는 다음과 같다.참고로 Calendar 클래스는 ZonedDateTime과 같이 다 들고 있다. LocalDate(날짜) LocalTime(시간) LocalDateTime(날짜 + 시간) ZonedDateTime(날짜 + 시간 + Timezone) InstantDate와 유사한 클래스인데 날짜와 시간을 (나노)초 단위로 표현한다.이렇게 초단위로 표현한 걸 타임스탬프라고 부르고, 하나의 정수로 다룰 수 있어서 DB나 시간 차를 구할 때 많이 사용한다. Period(날짜 - 날짜): 두 날짜 간의 차이를 표현 Duration(시각 - 시각): 두 시각 간의 차이를 표현 객체 생성하기now()와 of()라는 static 메소드를 사용하면 된다.now는 인자 없이 그냥 호출해서 지금 시간의 정보를 구하고, of()는 매개변수를 지정해서 해당 날짜의 정보를 구한다. Temporal 인터페이스와 TemporalAmount 인터페이스LocalDate, LocalTime, LocalDateTime, ZonedDateTime 클래스 등은 Temporal, TemporalAccessor, TemporalAdjuster 인터페이스의 구현체이고,Period, Duration 클래스는 TemporalAmount 인터페이스의 구현체이다.매개변수의 다형성을 이용해 Temporal 인터페이스와 TemporalAmount 인터페이스를 매개변수의 타입으로 지정한 것들이 있는데 잘 보고 쓰면 될 것 같다. Unix Time1970-01-01 00:00:00 UTC로부터 현재 얼마나 시간이 흘렀는지를 초로 환산하여 정수로 표현한 것이다.UTC는 국제 표준으로 시행되는 시간을 표현하는 기준인 것 같은데 1972년 1월 1일부터 시행되다 보니 1970년으로 퉁쳐버린 것 같다.또한 UTC는 Coordinated Universal Time의 약자인데 CUT가 아니라 UTC가 된 이유는 영어와 프랑스어의 표기 방식 중 중립 형태를 취한 것 같다.이는 32비트 메모리 상으로 표현했을 때 오버플로우 때문에 2,147,483,647((231 - 1) 지난 후인 2038년 1월 19일 03:14:08 UTC에 오류를 일으킨다고 한다.64비트를 쓰면 죽기 전에는 뭐 문제 없을라나… 또한 한국은 UTC+09:00으로 9시간을 더해줘야한다는 단점이 있다. (LocalTime과 호환되지 않음)이를 위해서는 OffsetDateTime 클래스를 이용하면 될 것 같다.서로 다른 시간대의 지역(AWS와 한국의 클라 등등)에서 날짜 데이터를 주고 받을 때는 OffsetDateTime을 이용하면 된다. 뭐 기타 파싱이나 데이터 얻어오는 건 정리하기 귀챠니즘… 나중에 책을 다시 보던가 하자. 컬렉션(Collection)다수의 데이터, 데이터 그룹을 컬렉션이라고 부른다.프레임워크는 표준화된 프로그래밍 방식, 단일화된 구조(Architecture) 정도로 보면 될 것 같다.자바에서는 이런 컬렉션 클래스들을 정리해서 프로그래머가 개발하기 편하게 만들어줬다. 핵심 인터페이스는 아래 세 가지이다.(Map 인터페이스는 독자적이며 List와 Set은 Collection 인터페이스를 상속받은 인터페이스들이다.) List: 순서가 있는 데이터의 집합이며 중복을 허용한다.구현체로는 ArrayList, LinkedList, Stack, Vector 등 Set: 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.구현체로는 HashSet, TreeSet Map: Key와 Value의 Pair(쌍)으로 이루어진 데이터의 집합니다.순서는 유지되지 않으며, 키의 중복을 허용하지 않고 값의 중복은 허용한다.구현체로는 HashMap, TreeMap, HashTable, Properties 등이 있다. Vector, Stack, HashTable, Properties는 이름만 봐서는 누구를 구현한 건지 알기 힘들다.이는 컬렉션 인터페이스가 생기기 전인 JAVA1에 생긴 것이라서 레거시 코드들과의 호환을 위해 이름을 바꾸지 않았다.이런 녀석들보다는 다소 최근에 생긴 ArrayList나 HashMap을 사용하도록 하자~ 컬렉션의 사이즈를 정할 때는 생각한 것보다 여유를 좀 줘서 생성해주는 게 좋다.어차피 공간이 부족하면 자동적으로 늘리긴 하지만 성능 상 좋지는 않기 때문이다.또한 ArrayList나 Vector는 배열로 값을 다스리기 때문에 공간이 부족하면새로운 배열(더 큰 배열)을 만들고 기존의 값을 복사 후 기존의 값들과의 참조 관계를 끊어서 가비지 컬렉팅 대상이 되게 한 후 새로운 배열과 참조관계를 맺는다.이렇게 계속해서 새로운 배열을 만들면 계속해서 메모리 공간 이곳 저곳을 차지해서 단편화가 발생하지 않을까…? ListVector vs ArrayListVector를 개선한 게 ArrayList라니까 웬만하면 ArrayList를 쓰자.ArrayList는 검색에는 빠르나 삽입&#x2F;삭제에 불리하다.(복사하고 앞뒤로 땡겨야하는 처리가 필요하기 때문) ArrayList vs LinkedListLinkedList는 다음 노드에 대한 참조만 바꿔주면 되므로 삽입&#x2F;삭제에 용이하다.하지만 다음 노드에 대한 참조로 순차적인 조회 밖에 불가능하므로 검색을 할 때 처음부터 순차적으로 접근해야해서 느리다.ArrayList는 접근(읽기) 속도가 빠르고, 추가&#x2F;삭제가 느리다.순차적인 추가 삭제도 더 빠르다고 하는데 뭐 JVM이나 컴퓨터 환경에 많이 좌지우지 되는 것 같다.LinkedList는 접근(읽기) 속도가 느리고 추가&#x2F;삭제가 느리다.그리고 데이터가 많아지면 처음부터 접근해야하는 갯수가 훨씬 늘어나므로 데이터가 많을 수록 접근성이 떨어진다.데이터의 변경(삽입&#x2F;삭제)가 잦다면 LinkedList를, 잦지 않다면 ArrayList를 쓰자. LinkedList vs Doubly Linked List링크드 리스트는 다음 노드에 대한 참조는 가능한데 이전 노드에 대한 참조는 불가능하다.그래서 나온 게 이중 링크드 리스트이다.이중 링크드 리스트는 이전&#x2F;다음 노드에 대한 참조와 값으로 이루어져있다.이중 링크드 리스트를 더 많이 쓴다고 한다. Doubly Linked List vs Doubly Circular Linked Listed이중 링크드 리스트는 처음부터 끝까지 갔다가 다시 끝에서 처음부터 올 수 있다.하지만 처음 노드에서 맨 끝 노드로 가려면 순차적으로 접근해야한다는 단점이 있다.(링크드 리스트도 마찬가지다.)이러한 문제점을 해결하기 위해 이중 원형 링크트 리스트가 나왔다.이중 원형 링크드 리스트는 단순히 이중 링크드 리스트에서 처음 노드와 마지막 노드의 참조를 연결한 것 뿐이다. Stack vs QueueStack은 후입선출(LIFO, Last In First Out), 즉 배열이 스택을 이용한 구조이다.(push와 pop의 전형적인 사용 사례)Queue는 선입선출(FIFO, First In First Out), 데이터가 입력된 시간 순서에 따라서 처리해야하는 경우(프로세스 스케쥴링?)에 사용한다고 한다. Stack은 전형적인 배열과 같은 자료구조를 띄므로 ArrayList와 같은 배열 리스트 기반의 클래스로 구현하기 쉽다.하지만 Queue는 앞에 있는 놈부터 나가서 앞에 있는 놈을 땡기기 위해 새로운 배열 만들어서 복사하는 수 밖에 없다.배열 관련 클래스로 Queue를 구현하면 이런 복사에 대한 처리 비용이 많이 들기 때문에 삽입&#x2F;삭제가 잦을 때 쓰는 LinkedList를 이용하여 구현하면 된다. Java에서 Stack은 클래스로 제공해주고 있지만, Queue는 인터페이스로만 제공해주고 있어서 그 구현체를 가져다 쓰면 된다. 1234567public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125;public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125;public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; 위와 같이 LinkedList는 Deque(데크, Double Ended Queue)를 구현한 구현체이고,Deque 인터페이스는 Queue 인터페이스를 상속받은 인터페이스이다. 12345678910111213141516171819public class StackQueue &#123; public static void main(String[] args) &#123; Stack s = new Stack(); Queue q = new LinkedList(); s.push(0); s.push(1); s.push(2); q.offer(0); q.offer(1); q.offer(2); System.out.println(&quot;Stack&quot;); while(!s.empty()) System.out.println(s.pop()); // 2 1 0 System.out.println(&quot;Queue&quot;); while(!q.isEmpty()) System.out.println(q.poll()); // 0 1 2 &#125;&#125; Queue는 Queue의 인터페이스의 구현체인 LinkedList를 통해 만들 수 있고, push 대신 offer, pop 대신에 poll을 쓴다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"https://perfectacle.github.io/tags/%EB%82%B4%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"날짜와 시간","slug":"날짜와-시간","permalink":"https://perfectacle.github.io/tags/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84/"},{"name":"형식화","slug":"형식화","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EC%8B%9D%ED%99%94/"}]},{"title":"(Java) 자바의 정석 3판 014일차 - 오류(에러와 예외), 유용한 클래스","slug":"Java-study-014day","date":"2017-08-04T15:17:49.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/08/04/Java-study-014day/","link":"","permalink":"https://perfectacle.github.io/2017/08/04/Java-study-014day/","excerpt":"프로그램 오류 컴파일 에러 - 컴파일 시에 발생하는 에러(오타, 타입 불일치 등등) 런타임 에러 - 실행 시에 발생되는 에러(파일을 열어야하는데 없는 파일을 인자로 넘겼을 때 등등) 논리적 에러 - 의도와 다르게 동작하는 것(돈이 음수가 된다거나 적에게 부딪혀도 죽지않는 것 등등) 오류의 두 가지 종류 에러(Error) - 발생하면 복구할 수 없는 심각한 오류(StackOverflowError, OutOfMemoryError 등등) 예외(Exception) - 발생하더라도 수습이 가능한 비교적 덜 심각한 오류(NullPointerException 등등)","text":"프로그램 오류 컴파일 에러 - 컴파일 시에 발생하는 에러(오타, 타입 불일치 등등) 런타임 에러 - 실행 시에 발생되는 에러(파일을 열어야하는데 없는 파일을 인자로 넘겼을 때 등등) 논리적 에러 - 의도와 다르게 동작하는 것(돈이 음수가 된다거나 적에게 부딪혀도 죽지않는 것 등등) 오류의 두 가지 종류 에러(Error) - 발생하면 복구할 수 없는 심각한 오류(StackOverflowError, OutOfMemoryError 등등) 예외(Exception) - 발생하더라도 수습이 가능한 비교적 덜 심각한 오류(NullPointerException 등등) 오류를 처리하는 클래스Error와 Exception 모두 클래스로 만들어져있고, 그 둘의 부모 클래스는 Throwable 클래스이다. (물론 최상위에는 Object 클래스가 자리잡고 있다.) 예외 클래스Exception 클래스는 다음 두 카테고리로 나눌 수 있다. Exception의 자식 클래스주로 외부의 영향(프로그램의 사용자)으로 발생한다. 존재하지 않는 파일의 이름을 입력(FileNotFoundException) 실수로 클래스 이름을 잘못 적은 경우(ClassNotFoundException) 입력한 데이터 형식이 잘못된 경우(DataFormatException) 기타 등등… RuntimeException의 자식 클래스(물론 RuntimeException 클래스도 Exception 클래스의 자식 클래스이다.)RuntimeException 클래스는 주로 개발자의 실수에 의해 발생한다. 배열의 범위를 벗어난 경우(IndexOutOfBoundException) 값이 null인 참조변수의 멤버를 호출한 경우(NullPointerException) 정수를 0으로 나눈 경우(ArithmeticException) 기타 등등… 예외 처리하기프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것이 그 목표이다.이러한 예외 처리를 제대로 해놓지 않으면 프로그램이 뻗고, JVM의 예외처리기(UncaughtExceptionHandler)가 받아서 원인을 로그에 출력해준다. 이러한 예외를 처리하기 위해서는 try-catch 문을 사용해야한다.try-catch 문은 문이 하나 뿐이어도 {} 블록의 생략이 불가능하다. 1234567try &#123; // 예외가 발생할 수 있는 구문&#125; catch(IndexOutOfBoundException e) &#123; System.out.println(&quot;배열의 길이를 벗어났습니다!&quot;);&#125; catch(ArithmeticException e) &#123; System.out.println(&quot;연산이 제대로 이루어지지 않았습니다!&quot;);&#125; 만약 저기서 NullPointerException이 발생했으면 예외 처리를 제대로 하지 않았으므로 프로그램이 뻗는다.매개변수의 다형성을 이용하면 아래와 같이 처리할 수 있다. 12345try &#123; // 예외가 발생할 수 있는 구문&#125; catch(Exception e) &#123; System.out.println(&quot;어디선가 예외가 발생했습니다!&quot;);&#125; 또한 예외가 발생하지 않았으면 try-catch 문 전체를 빠져나간다. 또한 try나 catch문 안에 try-catch문이 또 들어갈 수 있다.이렇게 중첩해서 try-catch문을 사용할 때는 중복된 변수(IndexOutOfBoundException와 ArithmeticException를 모두 e로 선언하는 경우 등등)를 사용하면 에러가 난다.지역 변수는 상위 스코프의 변수를 덮어씌우는데 try-catch문은 안되나 보다. 멀티 catchJava7부터 추가되었다.여기서 쓰이는 | 는 논리 연산자가 아니라 그냥 기호이고, 갯수에는 제한이 없다. 1234catch(IndexOutOfBoundException | ArithmeticException e) &#123;&#125;// catch(ParentException | ChildException e) &#123;&#125;// 부모 자식 관계인 경우에는 위 코드는 오류를 유발하므로 아래와 같이 써주자.catch(ParentException e) &#123;&#125; 예외 처리 정보 얻기 printStackTrace(): 예외 발생 당시 콜스택에 있던 메서드의 정보와 예외 메시지를 화면에 출력한다. getMessage(): 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻는다.12345678910111213141516public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; System.out.println(1); System.out.println(2/0); System.out.println(3); // 위에서 에러나서 출력 안 됨. &#125; catch (ArithmeticException e) &#123; // java.lang.ArithmeticException: / by zero // at ch08.Exception.main(Exception.java:7) e.printStackTrace(); System.out.println(&quot;예외 메시지:&quot; + e.getMessage()); // 예외 메시지:/ by zero &#125; catch (Exception e) &#123; System.out.println(&quot;asdf&quot;); &#125; &#125;&#125; switch-case 문처럼 instanceof가 true에 걸리는 녀석을 순서적으로 찾아가고 마지막에 default 마냥 Exception에 걸리게 된다.하지만 아래와 같이 하면 에러가 난다. 123456789101112131415161718public class ExceptionTest &#123; public static void main(String[] args) &#123; try &#123; System.out.println(1); System.out.println(2/0); System.out.println(3); &#125; catch (Exception e) &#123; System.out.println(&quot;asdf&quot;); &#125; // java: exception java.lang.ArithmeticException has already been caught catch (ArithmeticException e) &#123; // java.lang.ArithmeticException: / by zero // at ch08.Exception.main(Exception.java:7) e.printStackTrace(); System.out.println(&quot;예외 메시지:&quot; + e.getMessage()); // 예외 메시지:/ by zero &#125; &#125;&#125; 이미 먼저 예외 처리를 하고 있다고 아래서는 할 필요가 없다고 에러를 내고 있다. 예외 발생시키기정확하게 왜 일부로 예외를 발생시켜야하는지는 모르겠지만, 그런 경우가 있는 것 같다. 123456789101112131415public class ThrowTest &#123; public static void main(String[] args) &#123; try &#123; ArithmeticException e = new ArithmeticException(&quot;이거시 예외 메시지!&quot;); throw e; // throw new ArithmeticException(&quot;이거시 예외 메시지!&quot;); &#125; // java.lang.ArithmeticException: 이거시 예외 메시지! // at ch08.ThrowTest.main(ThrowTest.java:6) catch (ArithmeticException e) &#123; e.printStackTrace(); System.out.println(e.getMessage()); // 이거시 예외 메시지! &#125; &#125;&#125; 1234567891011import java.io.IOException;public class ThrowTest &#123; public static void main(String[] args) &#123; // RuntimeException의 자식 클래스가 아니면 컴파일 에러가 난다. // throw new IOException(); // RuntimeException의 자식 클래스면 런타임 에러가 난다. throw new ArithmeticException(); &#125;&#125; 메소드에 예외 선언하기다른 프로그래밍 언어에서는 메소드에 예외를 선언할 수 없었다.따라서 해당 메소드가 어떤 예외를 발생할지 모르므로 노련한 프로그래머야 해당 메소드를 쓸 때 예외처리를 잘 하겠지만,경험이 적은 개발자 입장에서는 다양한 테스트를 통해 어떤 상황에서 어떤 Exception이 발생하는지 순전히 노가다(?)로 알아볼 수 밖에 없었다.하지만 자바에서는 메소드에서 발생할 수 있는 예외를 명시해서 사용하는 측에서 어떻게 대비해야하는지를 알려줄 수 있다. 주의해야할 것은 메소드에 예외를 선언한다고 해서 예외 처리까지 떠맡게 되는 것은 아니다. 12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; throw new NullPointerException(); &#125; public static void main(String[] args) &#123; // Exception in thread &quot;main&quot; java.lang.NullPointerException // at ch08.MethodException.method2(MethodException.java:8) // at ch08.MethodException.method(MethodException.java:5) //at ch08.MethodException.main(MethodException.java:12) method(); &#125;&#125; main이 method를 호출했고, method가 method2를 호출했고 method2에서 NullPointerException 예외가 발생했다고 알려주고 있다.물론 다음과 같이 메소드 내에서도 예외를 처리할 수 있다. 12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; try &#123; throw new NullPointerException(); &#125; catch (NullPointerException e) &#123; System.out.println(e.getMessage() + &quot; 예외 처리&quot;); // null 예외 처리 &#125; &#125; public static void main(String[] args) &#123; method(); &#125;&#125; 이 예제는 main 메소드는 예외가 발생했다는 사실도 모른다는 것이다.내 생각에는 메소드에서 처리할 바에는 저렇게 throws로 명시해줄 필요가 없을 것 같다.throws 키워드로 던져주는 예외는 메소드 사용자가 처리해야할 예외인데,미리 발생할 예외를 메소드 개발자가 미리 처리하는데 굳이 throws로 어떤 예외가 발생했는지 알려줄 필요가 있나 싶다.따라서 메소드 사용자에게 예외 처리를 미뤄버리면 다음과 같이 구현하면 될 것이다. 12345678910111213141516public class MethodException &#123; static void method() throws NullPointerException &#123; method2(); &#125; static void method2() throws NullPointerException &#123; throw new NullPointerException(); &#125; public static void main(String[] args) &#123; try &#123; method(); &#125; catch (NullPointerException e) &#123; System.out.println(e.getMessage() + &quot; 예외 처리&quot;); // null 예외 처리 &#125; &#125;&#125; 이 예제는 main 메소드도 예외가 발생했다는 것을 알게 된다. finally1234567891011121314151617public class FinallyTest &#123; static void method() &#123; try &#123; System.out.println(&quot;try&quot;); return; &#125; catch (Exception e) &#123; System.out.println(&quot;catch&quot;); &#125; finally &#123; System.out.println(&quot;finally&quot;); &#125; &#125; public static void main(String[] args) &#123; // try // finally method(); &#125;&#125; 타짜를 보면 손은 눈보다 빠르듯, finally는 함수를 종료시키는 return 보다 빠르다. 자동 자원 반환주로 I&#x2F;O와 관련된 클래스를 처리할 때 유용하다. 12345678910111213try &#123; FileInputStream fis = new FileInputStream(&quot;score.dat&quot;); DataInputStream dis = new DataInputStream(fis); // 코드..&#125; catch(IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if(dis != null) dis.close(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125;&#125; 예외가 나던 안 나던 자원은 close(), 반환해줘야한다.하지만 이 close에서도 예외가 일어날 수도 있어서 또 예외 처리를 해줘야한다.가독성은 물론이고 문제가 있는 코드란다. (자세히는 모르겠다.) 그래서 JDK7에서는 try-with-resources 문이 생겼다. 123456try(FileInputStream fis = new FileInputStream(&quot;score.dat&quot;); DataInputStream dis = new DataInputStream(fis)) &#123; // 코드..&#125; catch(IOException e) &#123; e.printStackTrace();&#125; 문장이 두 개인 경우 ;를 구분자로 사용하며 finally 없이도 자원이 자동으로 반환된다.이렇게 자동으로 반환되는 자원이라면 클래스(DataInputStream 등등)가 AutoCloseable 인터페이스를 구현한 것이어야만 한다.자세히 모르니 나중에 다시 보자. java.lang 패키지Object 클래스equals 메소드최상위 클래스 Object에는 equals 메소드가 있고 다음과 같이 구현돼있다. 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 둘이 같은 객체를 참조하고 있는지 비교하고 있는 것이다.그렇다면 String 클래스에서 어떻게 문자열을 가지고 비교하는 것일까?String도 클래스이고, 인스턴스 생성시 항상 메모리에 비어있는 공간에 할당될텐데 어떻게 equals 메소드로 두 문자열의 값을 비교하는 것일까?바로 equals 메소드를 오버라이딩하는 것이다. String 클래스는 다음과 같이 구현돼있다. 1234567891011121314151617181920212223242526272829public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; // 결국에 다뤄지는 것은 C언어와 마찬가지로 문자 배열로 다루게 된다. private final char value[]; public boolean equals(Object anObject) &#123; if (this == anObject) &#123; // 같은 객체를 참조 하고 있으면 return true; &#125; if (anObject instanceof String) &#123; // 인자가 String 클래스의 인스턴스인 경우 // 기존에 넘어온 것은 Object 참조 타입이므로 Object 멤버 밖에 사용이 불가능하다. // 따라서 String 클래스의 멤버들을 사용하려면 String 클래스로 형변환(다운 캐스팅) 해줘야 한다. String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; // 둘의 길이가 같다면 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; // 둘의 문자 하나 하나를 각각 비교 if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125;&#125; hashCode 메소드해싱은 데이터 관리 기법 중의 하나인데, 다량의 데이터를 저장하고 검색하는 데 유용하다.해시 함수는 찾고자하는 값을 입력하면 그 값이저장된 위치를 알려주는 해시 코드를 반환한다. 일반적으로 해시코드가 같은 두 객체가 같은 것지 존재하는 것이 가능하지만(String 클래스),hashCode 메소드를 오버라이딩 하지 않는 한 Object 클래스의 hashCode 메소드를 사용할 것이고이 메소드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 절대 같은 해시코드를 가질 수 없다. 해싱기법을 사용하는 HashMap이나 HashSet 같은 클래스에 저장할 객체라면 반드시 이 메소드를 오버라이딩 해주자! toString 메소드기본적으로 println이나 print 메소드에서 인스턴스를 넣으면 자동적으로 toString 메소드가 호출된다.그리고 toString 메소드를 오버라이딩 하다보면 항상 public 접근 지정자를 왜 써야하는지 의문이었다.그에 대한 해답은 Object 클래스가 어떻게 toString 메소드를 구현했는지 보면 된다. 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 바로 public 접근 지정자를 쓰고 있다.메소드 오버라이딩을 하기 위해선 부모 클래스의 메소드보다 더 좁은 접근 지정자를 지정할 수 없는데,public 보다 넓은 접근 지정자는 없으니 무조건 public으로 접근 지정자를 지정하고 오버라이딩을 해줘야하는 거였다. clone 메소드Object 클래스의 clone 메소드를 보면 다음과 같다. 1protected native Object clone() throws CloneNotSupportedException; 무조건 CloneNotSupportedException 예외를 던진다.따라서 클래스에서 따로 이 예외를 처리해줘야한다. 1234567891011121314151617181920public class TV implements Cloneable &#123; public Object clone() &#123; Object obj = null; try &#123; // TV 클래스의 부모 클래스는 Object, // Object 클래스의 clone 메소드는 아래와 같은 예외를 유발하므로 예외 처리를 이렇게 해줘야함. obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123;&#125; return obj; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; TV t = new TV(); // 반환된 타입은 Object 객체니 TV 객체로 형변환 해줘야한다. TV t2 = (TV)t.clone(); &#125;&#125; 또한 clone을 하기 위해서는 클래스를 Cloneable 인터페이스를 구현해야한다.왜냐하면 코드의 안전성을 보장하기 위한 것인데 클래스 개발자가 명시적으로 클래스 복제를 허락했다고 알리는 것과 같다. 공변 반환 타입위 예제에서 clone을 하고 나서 Object로 반환했으니 TV 객체로 형변환해야하는 과정이 필요했다.하지만 JDK5부터는 공변 반환 타입이란 게 나왔다.뭔소린지 나도 모르겠으니까 코드로 보자. 1234567891011121314151617181920212223242526272829303132public class TV implements Cloneable &#123; public TV clone() &#123; Object obj = null; try &#123; obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123;&#125; return (TV)obj; &#125; // 아래 코드는 에러를 유발한다. // public TV2 toString() &#123; // return new TV2(); // &#125;&#125;class CaptionTV extends TV implements Cloneable &#123; &#125;class TVCR extends CaptionTV implements Cloneable &#123; public CaptionTV clone() &#123; // 부모 클래스의 메소드에서 이미 예외 처리를 하고 있기 때문에 얘는 예외 처리를 안 해줘도 된다. Object obj = super.clone(); return (CaptionTV)obj; &#125; &#125;class Test &#123; public static void main(String[] args) &#123; TV t = new TV(); TV t2 = t.clone(); &#125;&#125; 원래대로 라면 메소드 오버라이딩 조건에 의해 선언부는 완전히 일치해야하기 때문에 return 타입도 일치해야하기 때문에public Object clone()이 돼야하는데 TV instanceof Object가 true이기 때문에 public TV clone()도 가능해진 것이다.TVCR의 clone 메소드도 마찬가지다. 이런 clone 메소드는 배열, Vector, ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap, Calendar, Date와 같은 클래스에서도 사용이 가능하다. 얕은 복사와 깊은 복사clone 메소드는 객체의 값만 복사하므로 그 값이 참조하고 있는 객체를 또 복사하거나 하지 않는 Shallow Copy(얕은 복사)를 수행한다.멤버 변수가 기본값이 아닌 참조타입(클래스)인 경우가 이에 해당한다.기본적으로 deep copy는 해당 클래스의 인스턴스를 새로 반환하게 끔 해야하는 것 같다.JS처럼 hierarchical(계층적) 구조여서 재귀함수로 얕은 복사를 계속해서 수행하는 방식과는 다르다. Class 객체이름이 Class인 객체 1public final class Class implements ... &#123;&#125; 클래스마다 getClass라는 메소드를 가지고 있고, 이 메소드는 자신의 Class 객체를 반환한다.따라서 클래스마다 Class 객체는 단 하나만 가지고 있다.이 Class 객체는 클래스 파일이 클래스 로더(ClassLoader)에 의해 메모리에 올라갈 때 자동으로 생성된다.클래스 로더는 실행 시에 필요한 클래스를 동적으로 메모리에 로드하는 역할을 한다.클래스 파일을 찾지 못하면 ClassNotFoundException을 발생시키고, 찾으면 클래스 파일을 읽어서 Class 객체로 변환한다. 클래스 객체를 얻기 위해서는 세 가지 방법이 있다. Class c = new Card().getClass();, 생성된 객체(인스턴스)로부터 얻는 방법 Class c = Card.class;, 클래스 리터럴(*.class)로부터 얻는 방법 Class c = Class.forName(&quot;Card&quot;);, 클래스 이름으로부터 얻는 방법 또한 인스턴스를 만드는 방법도 두 가지 방법이 있다. Card card = new Card();, new 연산자를 이용해서 인스턴스 생성 Card card = c.newInstance();, 위에서 구한 Class 객체를 이용해서 인스턴스 생성 String 클래스immutable(변경 불가능한) 클래스이다.String 클래스에는 문자열을 저장하기 위해 문자형 배열 변수인 char[] value를 인스턴스 변수로 정의해놓고 있다.인스턴스 생성 시 매개변수로 입력하는 문자열은 이 인스턴스 변수(문자형 배열 변수 value)로 저장된다.따라서 + 연산자를 이용하여 문자열을 결합한다면 새로운 인스턴스를 생성한다고 보면 된다.따라서 + 연산자를 이용하여 계속해서 새로운 인스턴스를 생성하면 아무리 GC(Garbage Collector)가 회수해간다 해도 메모리 공간 측면에서 좋지 않을 것이다. “abc” vs new String(“abc”)문자열을 생성하는데도 위의 두 가지 방법이 있다.나는 편의를 위해서 그냥 new String()의 생략이 가능한 줄 알았는데 그게 아니었다. &quot;abc&quot;, 이미 인스턴스가 존재하면 해당 인스턴스를 반환 new String(&quot;abc&quot;), 매번 새로운 인스턴스를 반환 그러한 까닭에 &quot;abc&quot; == &quot;abc&quot;는 true이지만, &quot;abc&quot; == new String(&quot;abc&quot;)는 false인 것이다.그래서 어떤 방식으로 문자열을 생성했을지 모르니 문자열의 비교는 무조건 equals() 메소드를 사용하자. Constant Pool123456String a = &quot;aa&quot;;String a2 = &quot;aa&quot;;String a3 = &quot;aa&quot;;String b = new String(&quot;bb&quot;);String b2 = new String(&quot;bb&quot;);String b3 = new String(&quot;bb&quot;); 이 *.java 파일을 컴파일하고, 컴파일된 *.class 파일을 헥스 에디터로 열어보면aa는 단 한 번만 저장되고, bb는 세 번 저장돼있는 걸 볼 수 있다.Constant Pool이라는 상수 저장소에 바로 저 aa가 저장되게 되는 것이다. 문자형 배열에서 null의 부재?기존에 C를 배웠을 때 문자 배열에서 맨 끝에 null 문자(\\0)을 삽입해줬었다.이 null 문자를 만나는 순간이 배열의 끝이라는 걸 알려주기 위함이었다.하지만 Java에서는 따로 길이정보를 저장한다고 한다. 기본값String도 클래스이다 보니 참조변수의 기본값인 null이 들어가는 줄 알았는데 빈 문자열인 “”으로 초기화 된다고 한다. 123public String() &#123; this.value = &quot;&quot;.value;&#125; char는 빈 문자열이 들어갈 수 없으므로 공백(‘ ‘)이 들어간다고 한다. join vs split둘이 반대되는 개념이라고 보면 된다. join배열의 요소들 사이에 구분자를 넣어서 문자열로 반환한다. split문자열을 구분자로 나누어서 배열로 반환한다. int vs char메소드의 매개변수를 보면 int인 것이 있고 ch인 것이 있는데 차이는 다음과 같다. intUTF-16(2Byte, 65536개의 문자)로도 감당이 안 되다보니 int(4Byte, 4294967296개의 문자)를 매개변수로 받는 것이다.뭐 이런 문자는 거의 안 쓴다고 보면 된다. charUTF-16 내에 존재하는 문자로 커버가 된다고 생각하는 매개변수이다. “” vs valueOf자스에도 문자열로 변환하는 다양한 방법들이 있고, 자바에서도 마찬가지이다.“” 이 더 간결한데, 성능이 중요시 된다면 valueOf를 쓰라고 한다. parseInt vs valueOf둘 다 동일한 메소드이다.valueOf 내부를 보면 아래와 같이 parseInt를 호출하고 있다.아마 다른 클래스에서도 valueOf를 쓰기 때문에 통일성 때문에 추가된 게 아닐가 싶다. 123public static Integer valueOf(String s) Throws NumberFormatException&#123; return Integer.valueOf(parseInt(s, 10));&#125; 기본형 &lt;-&gt; 문자열 기본형 -&gt; 문자열 문자열 -&gt; 기본형 String.valueOf(boolean b) Boolean.parseBoolean(String s) String.valueOf(char c) 문자를 문자로 바꿀 필요 없음. btye b도 int i와 동일 Byte.parseByte(String s) short s도 int i와 동일 Short.parseShort(String s) String.valueOf(int i) Integer.parseInt(String s) String.valueOf(long l) Long.parseLong(String s) String.valueOf(float f) Float.parseFloat(String s) String.valueOf(double d) Double.parseDouble(String s) 문자열에 숫자로 인식 가능한 + - . f d L과 같은 접두어, 접미어를 붙일 수 있다. 12345678class Test &#123; public static void main(String args[]) &#123; int a = Integer.parseInt(&quot;+100&quot;); float b = Float.parseFloat(&quot;+100d&quot;); System.out.println(a); System.out.println(b); &#125;&#125; StringBuffer 클래스StringBuffer 클래스도 기본적으로 char[]로 문자열을 처리한다. 123456789public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, CharSequence &#123; /** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache;&#125; 또한 기본적으로 16자리 공간을 차지하며 문자열보다 + 16자리 큰 버퍼를 가진다. 12345678 public StringBuffer() &#123; super(16);&#125;public StringBuffer(String str) &#123; super(str.length() + 16); append(str);&#125; 또한 기존 char[] 보다 더 긴 문자열을 추가하려면 기존의 문자열을 복사하고 더 긴 char[]을 만들고 기존의 것을 복사한 후 새로운 걸 붙여넣는 형태로 만들 것이다.append 메소드가 있는데 요놈은 문자열을 뒤에 추가하고 + 자기 자신의 주소를 반환해서 메소드 체이닝이 가능하다. String 클래스는 equals() 메소드를 오버라이딩하여 비교가 가능하지만, StringBuffer 클래스는 오버라이딩하지 않아 문자열로 비교할 방법이 없다. 12345678class Test &#123; public static void main(String args[]) &#123; StringBuffer s = new StringBuffer(&quot;asd&quot;); StringBuffer d = new StringBuffer(&quot;asd&quot;); // StringBuffer를 String으로 변환 후 비교를 진행해야한다. System.out.println(s.toString().equals(d.toString())); // true &#125;&#125; StringBuffer vs StringStringBuffer는 데이터의 변경이 가능한데 String은 데이터를 변경하는 게 아니라 새로운 인스턴스를 생성하는 것이다. StringBuffer vs StringBuilder동기화는 StringBuffer의 성능을 떨어뜨린단다.또한 멀티 쓰레드로 작성된 프로그램이 아닌 경우에는 StringBuffer의 동기화는 불필요하게 성능만 떨어뜨린다.반면 StringBuilder는 멀티쓰레드에 안전(Thread Safe)하도록 동기화가 되어있단다.StringBuffer에서 쓰레드의 동기화만 뺀 게 StringBuilder란다.뭔 소린지 모르겠다.싱글 스레드면 StringBuilder가 더 좋다는 말같다.멀티 스레드면 StringBuffer를 쓰라는 건가…?근데 뭐 StringBuffer도 충분히 성능이 좋아서 크게 StringBuilder를 쓸 일은 없는 것 같다. Math 클래스Math 클래스는 PI, E 두개의 상수 외에는 전부 static 메소드이다.자동으로 메모리에 로딩되는 애들이기 때문에 굳이 생성자로 인스턴스를 만들어도 메모리 차지만 할 뿐, 추가적으로 이용 가능한 인스턴스 멤버가 없다.따라서 인스턴스를 생성할 필요가 없어서 클래스의 접근 지정자가 private이고 만들고 싶어도 만들 수 없다. 소수점 n째 자리까지 반올림하기 Math.round()를 쓰면 **정수(Long)**로 반올림 한다.소수점 n째 자리까지 반올림해서 구하고 싶다면 10n를 곱하고 Math.round로 정수로 반올림 후에 10n로 다시 나누면 된다.이때 나눌 때는 정수로 곱하면 안되고 뒤에 .0이나 실수형의 접두어인 f나 d를 붙여주자. 12345678class Test &#123; public static void main(String[] args) &#123; double d = 90.12345; Long i = Math.round(d * 100); d = i / 100.0; System.out.println(d); // 90.12 &#125;&#125; 올림, 내림, 반올림 Math.ceil(): 올림 Math.floor(): 내림 Math.round(): 반올림 Math.rint(): 반올림 Math.round vs Math.rint를 비교해보자. 1234567891011121314class Test &#123; public static void main(String[] args) &#123; System.out.println(Math.round(1.1)); // 1 System.out.println(Math.round(1.5)); // 2 System.out.println(Math.round(-1.1)); // -1 System.out.println(Math.round(-1.5)); // -1 System.out.println(Math.round(-1.6)); // -2 System.out.println(Math.rint(1.1)); // 1.0 System.out.println(Math.rint(1.5)); // 2.0 System.out.println(Math.rint(-1.1)); // -1.0 System.out.println(Math.rint(-1.5)); // -2.0 System.out.println(Math.rint(-1.6)); // -2.0 &#125;&#125; 예외를 발생시키는 메소드Java8에서 추가됐다.add 메소드는 결과만 반환하고 오버플로우(범위를 초과)가 발생했는지 얘기해주지 않는다.addExact 메소드는 오버플로우가 발생하면 ArithmeticException을 발생시킨다.여기서 negateExact라는 메소드도 있는데 단순히 부호를 바꿔주는 연산자인데 부호를 바꾸는 과정에서 어떻게 오버플로우가 발생하는지 알아보니 참 재밌는 것 같다.우선 a의 부호를 바꾸는 연산자는 -a이지만 내부적으로는 ~a+1로 돌아간다.내 말을 못 믿겠다면 아래 코드를 보고 원리를 이해해보자. 1234567class Test &#123; public static void main(String[] args) &#123; int i = -2147483648; System.out.println(i); // -2147483648 System.out.println(-i); // -2147483648 &#125;&#125; ~a는 십진수를 이진수로 바꾸고 비트를 전부 역전시키므로 a의 2의 보수를 구하게 된다.2의 보수 + 1은 음수이므로 ~a+1은 음수이다.그래서 그게 어쨌다는 건가… 싶으면 다음 내용을 보자. int는 4byte로 범위는 -232-1 ~ 232-1-1, 즉 -2147483648 ~ 2147483647이다.-2147483648를 negate, 부호를 바꾼다고 생각해보자.(-2147483648)+1을 구하면 되는 간단한 문제이다.-2147483648을 2진수로 표현하자면 다음과 같다.1000_0000_0000_0000_0000_0000_0000_000(2)이걸 2의 보수((-2147483648))를 구하면 다음과 같다.0111_1111_1111_1111_1111_1111_1111_1111(2)이 수는 int의 최대값인 2147483647이다.여기서 1을 더하면 다음과 같다.1000_0000_0000_0000_0000_0000_0000_000(2)다시 자기 자신으로 돌아왔다.최대값 + 1 &#x3D;&#x3D; 최소값, 즉 오버플로우가 발생했다.따라서 아래와 같이 처리해줘야한다. 1234567891011class Test &#123; public static void main(String[] args) &#123; int i = -2147483648; try &#123; System.out.println(Math.negateExact(i)); &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;범위 초과!&quot;); System.out.println(Math.negateExact((long)i)); // 2147483648 &#125; &#125;&#125; 단순히 부호를 바꾸는 연산자인데도 오버플로우가 발생할 수 있다는 사실이 참 신기하고 재미있다.따라서 negateExact라는 메소드가 필요한 것이다. Math vs StrictMathMath 클래스는 최대한의 성능을 얻기 위해 OS의 메서드를 호출해서 사용한다.즉 OS에 의존적이라 결과가 달라질 수도 있다.StrictMath는 성능을 좀 포기하더라도 어디서나 동일한 결과를 보장받기 위한 클래스이다. 기타 메소드 Math.random(): 0.0 &lt;&#x3D; x &lt; 1.0 Math.max(), Math.min(): 두 가지 인자를 받아서 둘 중에 누가 크고 작은지 알려줌. Math.abs(): 절대값 알려줌. 래퍼 클래스(Wrapper Class)기본타입을 객체로 다루기 위한 클래스Object 아래 Boolean, Character, Number 클래스가 있다.Number 클래스의 자식으로 Byte, Short, Integer, Long, Float, Double이 있고,추가적으로 BigInteger(Long 보다 큼), BigDecimal(Double보다 큼)도 존재한다. 오토 박싱 &amp; 언박싱(autoboxing &amp; unboxing)JDK5 이후에 등장했다.오토박싱은 기본값을 래퍼 객체의 인스턴스로 바꿔주는 걸 말한다. 1234567class Test &#123; public static void main(String[] args) &#123; // 제네릭에는 기본값이 못 들어간다. Vector&lt;Integer&gt; v = new Vector&lt;Integer&gt;(); v.add(10); // v.add(new Integer(10)) 이라고 컴파일러가 오토박싱 해줌. &#125;&#125; 언박싱은 반대로 래퍼 객체의 인스턴스를 기본값으로 바꿔주는 걸 말한다. 1234567class Test &#123; public static void main(String[] args) &#123; int i = 1; int i2 = new Integer(&quot;1&quot;); // new Integer(1); 과 동일 System.out.println(i + i2); // i + i2.intValue()로 컴파일러가 자동 언박싱 해준다. &#125;&#125; java.util.Objects 클래스Object 클래스의 보조 클래스이다.Math처럼 모든 메소드가 static이다. isNull(Object obj), nonNull(Object obj): 딱 보면 뭐하는 놈인지 알 것이다. 둘은 정반대 requireNonNull(T obj)기존에는 아래와 같이 했어야 했다. 12345678910void setName(String name) &#123; if(name == null) &#123; try &#123; throw new NullPointerException(&quot;name must not be null&quot;); &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name;&#125; 하지만 위 메소드를 쓰면 좀 더 줄일 수가 있다. 1234567void setName(String name) &#123; try &#123; this.name = Objects.requireNonNull(name, &quot;name must note be null&quot;); &#125; catch (NullPointerException e) &#123; e.printStackTrace(); &#125;&#125; compare(Object a, Object b, Comparator c)Object 클래스에는 equals만 있고 비교를 할 수 있는 메소드가 없는데 Objects 클래스에서 추가되었다.Comparator는 두 객체를 비교할 기준인 거 같다.크면 양수, 작으면 음수, 같으면 0을 반환한다. (아마 a가 기준일라나..??)String 클래스에서는 그냥 compareTo를 이용하거나 숫자는 부등호를 이용하면 될 것 같다.여튼 나중에 다시 알아보자. equals기존 Object 클래스에서 equals를 비교하기 전에 null인지 아닌지도 비교를 해줬어야 했다. 1if(a != null &amp;&amp; a.equals(b)) &#123;&#125; 하지만 Objects 클래스의 equals를 쓰면 한결 편해진다. 1if(Objects.equals(a, b)) &#123;&#125; deeqEquals(Object a, Object b)위 equals는 shallow equals라고 보면 된다.내부에 참조변수가 있으면 그녀석들은 비교하지 못한다.다차원 배열인 경우가 아마 그럴 것이다. 그럴 때 이 deepEquals를 쓰면 된다. toString(Object o)equals와 마찬가지로 내부적으로 null을 검사해주는 것 이외에는 큰 차이가 없다. toString(Object o, String nullDefault)null이면 기본으로 넣을 값을 지정해줄 수 있다. hashCode(Object o)이것도 내부적으로 null을 검사해주는 것 외에는 큰 차이가 없다.null이면 0을 반환한다. import static java.util.Objects.*을 한다면…?Objects 클래스까지 생략 가능하고 바로 메소드의 사용이 가능해진다.하지만 컴파일러는 자동적으로 java.lang.* 패키지도 넣어버리므로 Object 클래스까지 같이 import 된다.Objects 클래스와 Object 클래스는 메소드명이 겹치는 경우가 많아서 어떤 걸 써야할지 구분을 못 하는 경우가 있어서 이럴 때는 클래스명을 다 붙여줘야한다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"오류","slug":"오류","permalink":"https://perfectacle.github.io/tags/%EC%98%A4%EB%A5%98/"},{"name":"에러","slug":"에러","permalink":"https://perfectacle.github.io/tags/%EC%97%90%EB%9F%AC/"},{"name":"예외","slug":"예외","permalink":"https://perfectacle.github.io/tags/%EC%98%88%EC%99%B8/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"https://perfectacle.github.io/tags/%EB%82%B4%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4/"}]},{"title":"(Java) 자바의 정석 3판 015일차 - 유용한 클래스, 날짜와 시간 & 형식화, 컬렉션","slug":"Java-study-016day","date":"2017-08-04T15:17:49.000Z","updated":"2022-10-30T08:42:16.099Z","comments":true,"path":"2017/08/04/Java-study-016day/","link":"","permalink":"https://perfectacle.github.io/2017/08/04/Java-study-016day/","excerpt":"흠… 한 3일을 탱자탱자 논 거 같다…어찌보면 아까운 시간이지만 쉼이 있어야 또 달릴 수 있는 거 같다.고고씽! 스택과 큐의 사용 사례 스택 - 수식 계산, 수식 괄호 검사, undo&#x2F;redo, 뒤로&#x2F;앞으로 큐 - history, 인쇄작업 대기 목록, 버퍼 pop(poll) vs peek","text":"흠… 한 3일을 탱자탱자 논 거 같다…어찌보면 아까운 시간이지만 쉼이 있어야 또 달릴 수 있는 거 같다.고고씽! 스택과 큐의 사용 사례 스택 - 수식 계산, 수식 괄호 검사, undo&#x2F;redo, 뒤로&#x2F;앞으로 큐 - history, 인쇄작업 대기 목록, 버퍼 pop(poll) vs peek전자는 마지막(처음) 녀석을 삭제하면서 반환후자는 삭제는 하지 않고 반환만 Deque(데크, 덱, 디큐, Double Ended Queue)Queue의 변형으로 Deque는 양쪽 끝에 추가&#x2F;삭제가 가능하다.스택으로 사용할 수도 있고 큐로도 사용이 가능하다. Deque Queue Stack offerFirst() - - offerLast() offer() push() pollFirst() poll() - pollLast() - pop() peekFirst() peek() - peekLast() - peek() Iterator, ListIterator, Enumeration컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스Enumeration은 Iterator의 구버전이며, ListIterator는 Iterator의 기능을 향상시킨 것이다.Enumeration은 컬렉션 프레임워크가 나오기 전에 나온 애라서 레거시 코드를 위한 것이고, 웬만하면 쓰지 말자. Iterator 인터페이스컬렉션 프레임워크에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 아래와 같이 표준화하였다.1234567891011121314151617181920212223public interface Iterator &#123; boolean hasNext(); Object next(); // 아래 두 메소드는 default 메소드이므로 구현하지 않아도 됨. // next 해온 요소를 컬렉션에서 삭제할지를 뜻하는 것 같다. // next 이후에 호출해야함. default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125; // Java8에 추가됨. // 남은 요소들에게 추가적으로 수행할 작업 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125;public interface Collection &#123; public Iterator iterator();&#125; iterator() 메소드는 Collection 인터페이스 내에 정의된 메소드로, Collection 인터페이스의 자식인 List와 Set에도 포함되어 있다.ArrayList에 저장된 요소를 읽어오는 방법은 다음과 같다. 12345List list = new ArrayList();Iteraotr it = list.iterator();while(it.hasNext()) &#123; System.out.println(it.next());&#125; 위 예제는 왜 참조타입을 ArrayList 대신에 List를 썼을까?ArrayList에만 존재하는 메소드를 쓸 게 아니고 List에만 존재하는 메소드를 쓸 때는 List로 참조 타입을 잡아두는 게 좋다고 한다.아래와 같은 상황을 가정해보자.만약에 자료구조를 ArrayList에서 LinkedList로 바꿀 일이 생겼다. 참조타입을 List로 선언한 경우LinkedList는 List의 구현체이므로 선언문 부분만 바꿔주면 되고, 나머지 사용 부분에 있어서는 List의 메소드만 사용했을 것이므로 테스트 할 필요가 없다. 참조타입을 ArrayList로 선언한 경우ArrayList의 자식이 LinkedList가 아니므로 참조 타입을 List, 혹은 LinkedList로 바꿔줘야한다.그리고 나머지 사용 부분에 있어서도 ArrayList의 메소드를 사용했을지 모르므로 그런 부분을 다 바꿔줘야 할지도 모른다.따라서 List에만 존재하는 메소드를 쓴다면 다른 사람들에게 코드 변경에 대한 안정성도 심어줄 수 있고 굳이 ArrayList로 참조타입을 잡을 일이 없다. Map 인터페이스에서는 iterator를 어떻게 쓰나?ES6에서도 다음의 경우에는 오류를 내뱉는다. 12345const obj = &#123; name: &#x27;간장냥&#x27;, age: 25&#125;for(const key of obj) console.log(obj[key]); Object는 Iterable한 객체가 아니라서 for of Syntax를 쓸 수 없고 아래와 같이 해주거나proposal-object-rest-spread을 지원하는 바벨 플러그인을 깔거나 해야했다. 12345const obj = &#123; name: &#x27;간장냥&#x27;, age: 25&#125;for(const key of Object.keys(obj)) console.log(obj[key]); 아래와 같이 한 것이 지금 설명할 방법이다. 123456// ES6와 달리 Java의 Map은 Iterable 하지 않다.Map map = new HashMap();Iterator it = map.keySet().iterator();Set set = map.entrySet();Iterator it2 = set.iterator(); java의 경우에는 Map은 Key와 Value의 쌍(pair)라서 iterator를 호출할 수 없다는데ES6의 Map도 비슷한 맥락일텐데 왜 Iterable 한 걸까… 1234const myMap = new Map();myMap.set(0, &#x27;zero&#x27;);myMap.set(1, &#x27;one&#x27;);for(const [key, value] of myMap) console.log(key + &#x27; = &#x27; + value); ListIteratorListIterator는 Iterator를 상속받아서 기능을 추가한 것으로 컬렉션의 요소에 접근할 때Iterator는 단방향으로만 접근이 가능했지만 ListIterator는 양방향으로 접근이 가능하다.Iterator는 Set이나 Map에도 사용이 가능한 것에 비해 ListIterator는 List에만 사용이 가능하다. 1234567891011121314151617import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class ListIt &#123; public static void main(String[] args) &#123; List l = new ArrayList(); l.add(1); l.add(2); l.add(3); l.add(4); l.add(5); ListIterator it = l.listIterator(); while(it.hasNext()) System.out.println(it.next()); while(it.hasPrevious()) System.out.println(it.previous()); &#125;&#125; Iterator는 한 번 돌면 사용이 불가능해서 다시 얻어와야하지만, ListIterator는 역방향 순회가 가능해서 사용성이 더 높다. default methodInterface에 있는 default 메소드는 구현하는 구현체에서 굳이 구현해도 되지 않는 메소드이다.구현자의 부담을 약간 덜어줬다고 보면 된다.하지만 추상메소드라서 아래와 같이 몸통(body)는 반드시 명시해줘야한다. 12345678910interface Test &#123; // 몸통 반드시 존재 default void t()&#123;&#125; // 저렇게 그냥 빈 몸통을 넣어줘도 오류는 안 나지만... // 이 메소드를 지원하지 않는 구현체의 경우에는 해당 메소드를 사용하면 오류가 난다는 예외를 던져줘야 좀 더 안전하다. default void t1() &#123; throw new UnsupportedOperationException(); &#125;&#125; Iterator의 remove데이터를 가져만 온다면 next,가져온 데이터를 삭제까지 한다면 remove!즉 remove 하기 위해선 next를 해야함! Arrays 클래스이 클래스에는 배열을 다루는데 유용한 메소드가 정의돼있다. copyOf(), copyOfRange() 123456int[] arr = &#123;0, 1, 2, 3, 4&#125;;int[] arr2 = Arrays.copyOf(arr, arr.length); // 0, 1, 2, 3, 4int[] arr3 = Arrays.copyOf(arr, 3); // 0, 1, 2int[] arr4 = Arrays.copyOf(arr, 7); // 0, 1, 2, 3, 4, 0, 0int[] arr5 = Arrays.copyOfRange(arr, 2, 4); // 2, 3int[] arr6 = Arrays.copyOfRange(arr, 0, 7); // 0, 1, 2, 3, 4, 0, 0 fill(), setAll() 123int[] arr = new int[5];Arrays.fill(arr, 9); // 9, 9, 9, 9, 9Arrays.setAll(arr, () -&gt; (int)(Math.random()*5)+1); // 1, 5, 2, 1, 1 람다식을 보니 반갑다, 그냥 ES6의 Arrow Function을 보는 기분이고 익명 함수도 보니 더욱 JS를 보는 거 같아 반갑다. sort(), binarySearch()binarySearch는 요소를 검색할 때 사용하며 항상 정렬이 돼있어야한다. 1234567int[] arr = &#123;77, 105, 2, 33&#125;;int idx = Arrays.binarySearch(arr, 105); // 1, 잘못된 결과System.out.println(idx);Arrays.sort(arr);idx = Arrays.binarySearch(arr, 105); // 3System.out.println(idx); Linear Search(순차 검색)은 배열이 정렬돼있을 필요가 없으나 요소 하나하나 비교하기 때문에 느리고,Binary Search(이진 검색)은 배열의 검색 범위를 반복적으로 절반씩 줄여나가기 때문에 빠르나 배열이 정렬돼있어야한다. toString(), toDeepString(), equals(), deepEquals()전자는 얕은 문자열화, 후자는 깊은 문자열화?라고 보면 될 거 같다.즉 전자는 1차원 배열, 후자는 다차원 배열에 사용하면 된다.equals의 경우에도 마찬가지… asList(Object… a)배열을 List에 담아서 반환한다.매개변수가 가변인자라서 배열 생성 없이 그냥 요소만 넣어줘도 된다.일반 List와 달리 추가&#x2F;삭제는 안 되고 변경만 된다. 123456789101112List list = Arrays.asList(new int[]&#123;1, 2, 3, 4, 5&#125;);List list2 = Arrays.asList(new Integer[]&#123;1, 2, 3, 4, 5&#125;);List list3 = Arrays.asList(1, 2, 3, 4, 5);List list4 = new ArrayList(Arrays.asList(1, 2, 3, 4, 5));// UnsupportedOperationException 발생// list2.add(2);list4.add(2);System.out.println(list.get(0)); // int를 넣으면 안된다.System.out.println(list2.get(0));System.out.println(list3.get(0));System.out.println(list4.get(5)); // 2 parallelXXX(), spliterator(), stream()parallel로 시작하는 메소드는 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다.spliterator는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환한다.stream은 컬렉션을 스트림으로 반환한다. Comparator와 ComparableComparator는 sort하는 기준, 메소드이고 Comparable한 녀석들끼리만 비교해서 sort 할 수 있다.둘 다 인터페이스이다. 123456789101112131415161718192021222324import java.util.Arrays;import java.util.Comparator;public class ComparatorTest &#123; public static void main(String[] args) &#123; String[] str = &#123;&quot;마나&quot;, &quot;하마&quot;, &quot;가나&quot;&#125;; Arrays.sort(str); System.out.println(Arrays.toString(str)); // 가나, 마나, 하마 Arrays.sort(str, new Desc()); System.out.println(Arrays.toString(str)); // 하마, 마나, 가나 &#125;&#125;class Desc implements Comparator &#123; public int compare(Object o1, Object o2) &#123; if(o1 instanceof Comparable &amp;&amp; o2 instanceof Comparable) &#123; Comparable c1 = (Comparable)o1; Comparable c2 = (Comparable)o2; return c1.compareTo(c2) * -1; // return c2.compareTo(c1); &#125; return -1; &#125;&#125; Set순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.저장 순서를 유지하는 녀석으로 LinkedHashSet이 있다. HashSetSet 인터페이스의 구현체내부적으로는 HashMap을 이용해서 만들어졌다. load factor컬렉션 클래스에 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것.이 값을 0.8로 지정하면 80%가 찼을 때 용량이 두 배로 늘어남. 기본값은 0.75(75%)HashSet(int capacity, float loadFactor)과 같은 곳에서 사용한다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"https://perfectacle.github.io/tags/%EB%82%B4%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"날짜와 시간","slug":"날짜와-시간","permalink":"https://perfectacle.github.io/tags/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84/"},{"name":"형식화","slug":"형식화","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EC%8B%9D%ED%99%94/"}]},{"title":"(Spring) 스타트 스프링 부트 003일차 - Spring Data JPA","slug":"Spring-boot-study-003day","date":"2017-08-04T13:11:13.000Z","updated":"2022-10-30T08:42:16.119Z","comments":true,"path":"2017/08/04/Spring-boot-study-003day/","link":"","permalink":"https://perfectacle.github.io/2017/08/04/Spring-boot-study-003day/","excerpt":"드디어 유닛 테스트? 단위 테스트? JUnit을 써봤다~그럼 시작! RepositoryxBatis(MyBatis, iBatis) 같은 경우에는 DAO(Data Access Object)라는 개념이 있었다는데 나중에 공부해봐야겠다.여튼 JPA에서는 Repository가 비슷한 거라고 DAO와 비슷하다고 보면 될 거 같다.JPA에서는 EntityManager를 구성하고, 트랜잭션을 시작하고 종료하는 코드를 만들 수도 있지만…(트랜잭션은 나중에 또 공부하자 ㅠㅠ)JPA를 쓰기 좋게 구성한 Spring Data JPA 라이브러리를 쓰면 복잡하지 않은 Repository는 간단하게 구성이 가능하다. Repository&lt;T,ID&gt; &lt;- CrudRepository&lt;T,ID&gt; &lt;- PagingAndSortingRepository&lt;T,ID&gt;위는 Repository 인터페이스들의 상속 구조를 나타낸 것이다.&lt;&gt;는 제네릭이고(공부하자 ㅠㅠ), T는 타입(엔티티 타입), ID는 PK를 의미한다.CRUD(Create(insert), Read(Select), Update, Delete)는 CrudRepository로,Paiging과 Sorting은 PagingAndSortingRepository로 해주면 된다.페이징 로직(현재 몇 페이지인지, 데이터 몇 개씩 보여줄 건지, 페이지를 보여주는 블록에 관한 것 등등)을 안 짜도 된다니 혁명 같다 ㅠㅠ","text":"드디어 유닛 테스트? 단위 테스트? JUnit을 써봤다~그럼 시작! RepositoryxBatis(MyBatis, iBatis) 같은 경우에는 DAO(Data Access Object)라는 개념이 있었다는데 나중에 공부해봐야겠다.여튼 JPA에서는 Repository가 비슷한 거라고 DAO와 비슷하다고 보면 될 거 같다.JPA에서는 EntityManager를 구성하고, 트랜잭션을 시작하고 종료하는 코드를 만들 수도 있지만…(트랜잭션은 나중에 또 공부하자 ㅠㅠ)JPA를 쓰기 좋게 구성한 Spring Data JPA 라이브러리를 쓰면 복잡하지 않은 Repository는 간단하게 구성이 가능하다. Repository&lt;T,ID&gt; &lt;- CrudRepository&lt;T,ID&gt; &lt;- PagingAndSortingRepository&lt;T,ID&gt;위는 Repository 인터페이스들의 상속 구조를 나타낸 것이다.&lt;&gt;는 제네릭이고(공부하자 ㅠㅠ), T는 타입(엔티티 타입), ID는 PK를 의미한다.CRUD(Create(insert), Read(Select), Update, Delete)는 CrudRepository로,Paiging과 Sorting은 PagingAndSortingRepository로 해주면 된다.페이징 로직(현재 몇 페이지인지, 데이터 몇 개씩 보여줄 건지, 페이지를 보여주는 블록에 관한 것 등등)을 안 짜도 된다니 혁명 같다 ㅠㅠ 나머지는 다 코드 중심이고, CRUD 및 페이징, 정렬 코드 작성하고 테스트 하는 건데…넘나 덥고 자바의 정석 공부를 해야해서 나중에 정리해야겠다 ~~","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"https://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://perfectacle.github.io/tags/Spring-Data-JPA/"}]},{"title":"(자알쓰) 디버깅","slug":"js-012-debug","date":"2017-08-04T09:44:39.000Z","updated":"2022-10-30T08:42:16.683Z","comments":true,"path":"2017/08/04/js-012-debug/","link":"","permalink":"https://perfectacle.github.io/2017/08/04/js-012-debug/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 두 번째 시리즈는 번외편 격으로 디버깅 하는 방법을 주제로 진행하겠다. 디버깅이란…?우선 디버그란 De Bug, Bug를 제거하는 것이다.그렇다면 버그란…? 우리가 생각하는 오류를 뜻한다.그럼 왜 버그가 오류인가…?과거에 벌레(버그)가 기계 속에 들어가서 프로그램이 오류가 난 적이 있다.그래서 해당 벌레를 제거(디버그)했더니 프로그램이 정상적으로 실행됐다는 사례 때문에 붙여진 이름이라고 한다.디버깅은 디버그 하는 것, 즉 버그를 제거하는 것, 오류를 고치는 행위를 말한다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 두 번째 시리즈는 번외편 격으로 디버깅 하는 방법을 주제로 진행하겠다. 디버깅이란…?우선 디버그란 De Bug, Bug를 제거하는 것이다.그렇다면 버그란…? 우리가 생각하는 오류를 뜻한다.그럼 왜 버그가 오류인가…?과거에 벌레(버그)가 기계 속에 들어가서 프로그램이 오류가 난 적이 있다.그래서 해당 벌레를 제거(디버그)했더니 프로그램이 정상적으로 실행됐다는 사례 때문에 붙여진 이름이라고 한다.디버깅은 디버그 하는 것, 즉 버그를 제거하는 것, 오류를 고치는 행위를 말한다. 디버깅을 해보자아래와 같은 코드가 있다고 해보자. 123456var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 위 코드를 실행하면 Uncaught TypeError: str.charAt is not a function이라는 오류가 나게 된다.매개변수 str에 도대체 어떤 값이 들어왔길래 charAt가 함수가 아니라는 건지 도저히 모르겠을 때 다음과 같은 방법으로 str의 값을 얻어낼 수 있다. 로그 찍어보기.가장 간단하면서 빠른 방법이다.코드를 아래와 같이 고쳐보자. 1234567var getMidChar = function(str) &#123; console.log(str); // 1234 var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 코드가 간단해서 굳이 로그를 안 찍어봐도 되지만 로직이 복잡한 경우에 이렇게 로그를 찍어보면 어떤 값이 넘어와서 에러를 유발하는지 쉽게 찾아낼 수 있다. 브레이크 포인트 지정하기(묵시적)BP(Break Point), 말 그대로 코드를 끝까지 실행하는 게 아니라 어느 시점(Point)에서 멈추게(Break) 하는 것이다.위 코드를 로그 찍어보는 대신에 브레이크 포인트를 지정해 str에 넘어온 값을 얻어보고자 한다.로그를 찍어보는 것은 궁금한 내용을 찍어보기 위해서는 계속 소스를 수정해야하지만,브레이크 포인트를 걸어두면 브레이크 걸린 시점에서 소스 수정 없이 이것 저것 테스트 해볼 수 있다는 장점이 존재한다.이 포스트에서는 디버거의 사용 방법(다음 BP로 이동 등등)에 대해서는 설명하지 않으니 그건 알아서 공부하자. 브라우저설명은 크롬 기준으로 하지만 다른 브라우저에서도 모두 지원할 것이다. 우선 아래와 같은 html 파일을 만들자. 1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 브라우저에서 해당 html 파일을 열고 개발자 도구를 열어서 콘솔 탭을 보자. 11번 줄에서 에러가 난 상황이고, 11번을 call? 호출? 한 건 14번 라인에 의한 것이란다.일단 11번 라인으로 가기 위해 파란 박스를 클릭해주자. 해당 라인에서 오류가 나고 있다.정확히 어떤 값이 넘어오는지 봐야하기 때문에 브레이크 포인트를 지정해주자.파란 박스 친 11번 라인을 클릭해주자. 이제 새로고침을 해주자. 11번 라인이 실행되기 직전에 딱 브레이크가 걸린다.스코프들의 관계(누가 누구를 호출했는지) 콜스택을 통해 볼 수 있고, 어떤 브레이크 포인트에 의해 브레이크 된 건지 등등의 유용한 정보를 볼 수 있다. 또한 원래 콘솔에서는 전역 스코프만 접근이 가능했는데 브레이크 걸린 스코프는 로컬 스코프인데 마치 전역 스코프인 것 마냥 그 안으로 파고 들어와서 테스트를 할 수 있다. Node.js설명은 IntelliJ로 하지만 VSCode나 Atom에서도 Node.js를 디버깅 할 수 있는 것으로 알고 있다.요즘에는 Javascript가 브라우저를 탈출해 Node.js 런타임 환경까지 생기다보니 IDE에서 Node 인터프리터를 제공해주기도 한다.Node를 이용하면 브라우저에서 제공하는 DOM이나 BOM 객체의 사용은 불가능하지만, ES+Node API를 통해 데이터에 집중해서 테스트 할 수 있다는 장점이 존재한다. 아래와 같은 js 파일을 만들자. 123456var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 우클릭 후 **Run ‘test.js’**를 클릭해주자. 동일한 코드이므로 동일한 부분에서 에러가 난다.3번 라인 14번째 칸에서 오류가 났다고 하고, (3: 14)6번 라인 14번째 칸에 의해 호출이 일어났다고 한다. (6: 14) 3번 라인을 클릭해 BP를 걸어주자. 그리고 이번엔 **Debug ‘test.js’**를 클릭해주자. 그럼 3번 라인에서 BP가 걸리고 소스코드 창에는 해당 스코프에 어떤 인자가 넘어왔는지 등등을 보여주고 있다. 인터프리터 창의 Debugger 탭의 좌측에는 콜스택, 우측에는 스코프를 보여주고 있다. 인터프리터 창의 Console 탭으로 와서 str을 찍어보려고 하면마치 로컬 스코프(getMidChar())가 전역 스코프(Global)인 것마냥 자동완성을 해서 보여주고 있다. 별도의 소스코드 수정 없이 해당 스코프에서 하고싶은 테스트를 콘솔창에서 마음껏 해볼 수 있다. 브레이크 포인트 지정하기(명시적)명시적으로 소스코드 상에 브레이크 포인트를 지정해주는 걸 말한다. 다음과 같은 js 파일을 만들어주자. 1234567var getMidChar = function(str) &#123; var idxMid = ~~(str.length / 2); debugger; return str.charAt(idxMid);&#125;;var num = 1234;var midStr = getMidChar(num); 4번 라인이 실행되기 전에 BP를 명시적으로 걸어준 것이다.브라우저에서는 기본적으로 BP가 걸리고 IntelliJ에서는 Debug ‘test.js’ 해줘야지만 BP가 걸리는 모습을 볼 수 있다. 소스코드 주석 처리하기(+로그 출력하기)메소드의 어느 부분까지 제대로 실행되는지 확인하기 위해서는 확인하려는 부분 아래로 쭉 주석을 달고 오류가 나지 않는지 확인하면 된다.(혹은 그냥 제거해도 된다.)혹은 확인하려는 부분에 로그(의미없는 로그보다는 눈으로 확인하기 쉬운 임의의 로그)를 출력해보면 메소드가 어디까지 제대로 실행됐는지 확인할 수 있다. BP 걸고 로그 찍어서 어떻게 디버깅을 하는데?어떤 값이 들어왔는지 모르는 상황에서 머릿 속으로 상상의 나래를 펼치는 것보다그냥 로그 찍어보고 BP 걸어서 어떤 값들이 들어왔는지 확인하는 게 훨씬 빠를 경우가 많다.그래서 어떤 값들이 들어왔는지 확인하고 인자를 수정하던, 메소드 등등을 수정하던지 하면 훨씬 디버깅 하는데 용이할 것이다.따라서 로그 찍어보고 BP 거는 습관을 들이보다보면 훨씬 디버깅하는 데 용이할 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"디버깅","slug":"디버깅","permalink":"https://perfectacle.github.io/tags/%EB%94%94%EB%B2%84%EA%B9%85/"}]},{"title":"(ES6) Number.EPSILON은 왜 2.220446049250313e-16인가?","slug":"ES6-EPSILON","date":"2017-08-04T09:25:57.000Z","updated":"2022-10-30T08:42:16.075Z","comments":true,"path":"2017/08/04/ES6-EPSILON/","link":"","permalink":"https://perfectacle.github.io/2017/08/04/ES6-EPSILON/","excerpt":"들어가기에 앞서 Number.EPSILON이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 부동소수점이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 자바스크립트에서 숫자의 자료형은?C나 Java를 접해본 사람이라면 숫자의 자료형은 크게 두 가지로 나눌 수 있을 것이다.","text":"들어가기에 앞서 Number.EPSILON이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 부동소수점이 뭔지 모르는 사람은 해당 링크를 참조하고 오자. 자바스크립트에서 숫자의 자료형은?C나 Java를 접해본 사람이라면 숫자의 자료형은 크게 두 가지로 나눌 수 있을 것이다. 정수 실수 하지만 자바스크립트에서는 실수 하나 밖에 존재하지 않는다. 123console.log(0 === 0.0); // trueconsole.log(0 === .0); // trueconsole.log(.0 === 0.0); // true 또 이 실수는 크게 두 가지로 나눌 수 있을 것이다. float double 하지만 자바스크립트에서는 이 실수형 중에서도 double 형 하나 밖에 존재하지 않는다. 실수를 나타내는 데도 고정 소수점과 부동 소수점이 존재하는데 고정소수점은 직관적인데 반해 표현할 수 있는 범위가 좁아서거의 부동 소수점이 실수를 표현하는데 표준으로 자리잡고 있다.물론 이 부동 소수점도 오차가 존재한다는 단점을 떠안고 있지만… 이 부동 소수점을 표현하는데도 여러가지 방법이 있는데(아마도…?) 현재 거의 표준으로 자리잡은 것은전기 전자 기술자 협회(IEEE)에서 제정한 IEEE754라는 것이다. double 형이란…?자바스크립트도 이 IEE754를 따라서 숫자(실수, 부동소수점)을 표현하고 있고,Double-precision floating-point format을 따르고 있다. 해당 부동소수점 표현 방식은 아래와 같이 세 가지 부분으로 나뉘어진다. 부호 비트(sign, 1bit)MSB(most significant bit): 최상위 비트, 즉 제일 왼 쪽에 있는 비트를 뜻하며 0이면 양수, 1이면 음수를 나타낸다. 지수부(exponent, 11bit)이진 소수를 정규화 했을 때 나타낼 지수부.지수부는 정수형과 달리 바이어스 표기법을 사용한다.범위는 -211-1-1 ~ 211-1, 즉 -21024-1 ~ 21024이다.해당 범위를 넘어가는 지수부에 한해서는 아마도 오버플로우가 발생해서 예기치 않은 결과를 뿜어내지 않을까 싶다.(NaN, ±Infinity)또한 지수 표기법과 같이 1e1 같은 숫자를 봤을 때 나오는 저 e가 지수부의 exponent를 줄인 것이다. 가수부(fraction, 52bit)이진 소수를 정규화 했을 때 나타낼 가수부.부호 없는 정수를 나타내는 방식과 동일하며 0252-1 &#x3D; 0 ~ 4503599627370495이다.4503599627370495는 십진수 16자리인데 015자리 수를 모두 커버하고 있으므로 double의 정밀도는 소수점 15자리가 되는 것이다. 부동 소수점은 먼저 아래와 같은 절차를 거친다. 십진 소수를 이진 소수로 바꾼다. (십진 소수 8.25를 이진 소수로 바꾸면 1000.01(2)) 이진 소수를 정규화한다. (이진 소수를 지수부와 가수부로 나누어서 표현한 방식을 뜻한다.)예를 들어 이진 소수 1000.01(2)을 정규화를 거치면 1.000101(2) X 103(2)와 같이 나타나며 1.101e3(2)로도 표현이 가능하다. 물론 지수부의 범위를 넘어서는 숫자라면 오버플로우가 발생할 것이고 가수부의 범위를 넘어서는 경우에는 오차가 발생한다.이 오차는 왜 발생할까? 가수부의 범위를 넘어서는(정규화 이후에 소수점 이하가 15자리를 넘어서는 경우) 경우 십진수로는 유한 소수인데 이진수로는 무한 소수인 경우0.1만 해도 이진수로는 표현이 불가능하다. (구해보면 이진수로는 무한 소수)따라서 끝자리가 5로 끝나는 소수가 아니면 유한소수라고 단정지을 수가 없고, 오차가 없다고 말할 수가 없다. 왜 Number.EPSILON은 2.220446049250313e-16일까?double 형 부동 소수점 가수부에서 0을 제외하고 가장 작은 숫자는 무엇일까?바로 2-52, 0.0000000000000002220446049250313(2.220446049250313e-16)이다.(가수부는 소수점 이하를 표현하는 것이기 때문에 252가 아니다.)그 말은 0 &lt; x &lt; 0.0000000000000002220446049250313, 즉 x는 표현하지 못하는 숫자가 된다.그래서 Number.EPSILON이 2-52, 즉 2.220446049250313e-16가 된 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"EPSILON","slug":"EPSILON","permalink":"https://perfectacle.github.io/tags/EPSILON/"}]},{"title":"(Java) 자바의 정석 3판 013일차 - Constant Pool","slug":"Java-study-013day","date":"2017-08-03T15:05:34.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/08/03/Java-study-013day/","link":"","permalink":"https://perfectacle.github.io/2017/08/03/Java-study-013day/","excerpt":"어제 잠이 안 와서 늦잠을 잤더니 오늘은 어제꺼 복습이랑 연습문제 밖에 못 풀었다…내일부터 또 다시 진짜 빡세게 이빠이 달려야겠다 ㅠㅠ 연습문제 오답노트1~10 반복하기1234567class Test &#123; public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++) &#123; System.out.println(i % 10 + 1); &#125; &#125;&#125;","text":"어제 잠이 안 와서 늦잠을 잤더니 오늘은 어제꺼 복습이랑 연습문제 밖에 못 풀었다…내일부터 또 다시 진짜 빡세게 이빠이 달려야겠다 ㅠㅠ 연습문제 오답노트1~10 반복하기1234567class Test &#123; public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++) &#123; System.out.println(i % 10 + 1); &#125; &#125;&#125; 내가 생각한 것 12345678class Test &#123; public static void main(String[] args)&#123; for(int i = 0; i &lt; 20; i++) &#123; int lastNum = (i+1) % 10; System.out.println(num == 0 ? 10 : num); &#125; &#125;&#125; 이렇게 10인 경우에 대해서 먼저 덧셈을 진행하고 나머지 연산자를 쓰다보니 그런 문제가 발생한 것 같다.역시 나는 아직 멀었다, 알고리즘 ㅠㅠ 매개변수의 유효성 검사매일 까먹는데 매개변수가 들어오면 항상 유효성 검사를 하자!!특히 setter 부분… 내가 생각한 것 12345678SutdaCard pick(int idx) &#123; if(idx &lt; 0 &amp;&amp; idx &gt;= CARD_NUM) return null; return cards[idx];&#125;SutdaCard pick() &#123; return cards[(int)(Math.random() * CARD_NUM)];&#125; 위 코드보다 혹시 몰라서 유효성 검사까지 돌려주게 끔 하려고 기존에 작성된 메소드를 이용하는 것 같다.pick() 안에서 유효성 검사를 또 돌리면 중복이기에… 답안 12345678SutdaCard pick(int idx) &#123; if(idx &lt; 0 &amp;&amp; idx &gt;= CARD_NUM) return null; return cards[idx];&#125;SutdaCard pick() &#123; return pick([(int)(Math.random() * CARD_NUM)]);&#125; 자식 클래스에서 부모 메소드 호출1234567891011121314151617class Parent &#123; int y = 20; void method() &#123; System.out.println(y, + &quot;,&quot; + this.y); &#125;&#125;class Child extends Parent &#123; int y = 30;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); // 20,20 &#125;&#125; 메소드를 오버라이딩 하지 않아 부모 클래스의 메소드를 호출할 때가 있다.이때 메소드 내에 멤버들은 부모의 멤버를 가리킨다.ES2015와는 약간 다르다. 123456789101112131415161718class Parent &#123; constructor() &#123; this.x = 20; &#125; method() &#123; console.log(this.x); &#125;&#125;class Child extends Parent &#123; constructor() &#123; super(); this.x = 30; &#125;&#125;const c = new Child();c.method(); // 30 ES2015+에서는 메소드 오버라이딩을 하지 않았어도 자식 클래스에서 호출한 거면 자식 클래스의 멤버를 따른다. 이전 값 기억하기setter로 값을 계속 지정하고, 그 이전값으로 돌아가는 메소드까지 구현해보는 거였다.예제로 TV 클래스의 채널을 가지고 구현했는데 나는 아래와 같이 반복된 로직을 사용하였다. 1234567891011121314151617181920public class TV &#123; private int channel; private int prev; public int getChannel() &#123; return channel; &#125; public void setChannel(int channel) &#123; prev = this.channel; this.channel = channel; &#125; void gotoPrevChannel() &#123; int tmp = prev; prev = channel; channel = tmp; &#125;&#125; gotoPrevChannel 쪽에 저렇게 스와핑하는 로직을 쓸 필요가 없이 아래와 같이 하면 끝나는 거였다.나는 바보같다 흑흑… 123456789101112131415161718public class TV3 &#123; private int channel; private int prev; public int getChannel() &#123; return channel; &#125; public void setChannel(int channel) &#123; prev = this.channel; this.channel = channel; &#125; void gotoPrevChannel() &#123; setChannel(prev); &#125;&#125; Math 클래스의가 private 접근 지정자가 붙어있는 이유?Math 클래스는 인스턴스 멤버는 하나도 없고 죄다 static 멤버이다.따라서 클래스가 자동으로 로딩되니(컴파일러가 import.lang.*을 자동으로 삽입해주니) 메모리에 static 멤버는 바로 적재되니 인스턴스 생성없이 사용이 가능하며인스턴스를 생성할 필요가 없어서 private 접근 지정자로 호출이 불가능하게끔 하고 있다. 참조타입 간의 형변환12345678910111213141516171819202122232425262728293031class Unit &#123; int x = 1;&#125;class AirUnit extends Unit &#123;&#125;class GroundUnit extends Unit &#123; int y = 2;&#125;class Tank extends GroundUnit &#123;&#125;class AirCraft extends AirUnit &#123;&#125;class UnitTest &#123; public static void main(String[] args)&#123; Unit u = new GroundUnit(); Unit u2 = new Unit(); Tank t = new Tank(); AirCraft ac = new AirCraft(); // 가능하다. 나는 참조타입이 Unit이라 더 넓은 타입인 GroundUnit으로 변환이 불가능한 줄 알았다. // 근데 인스턴스 타입이 GroundUnit이어서 가능한 것이다. // u2처럼 만드는 것과 차이점이 무엇이 있냐면 // 이렇게 형변환을 자유로이(멤버의 범위를 여의봉 마냥 자유자재로 늘렸다 줄였다) 할 수 있는 장점이 있다. GroundUnit gu = (GroundUnit)u; // 컴파일 에러는 안 나는데 런타임 에러, // u2는 Unit 인스턴스 타입이라 참조 가능한 한계가 Unit 뿐임. // 하지만 위는 GroundUnit의 인스턴스라 참조타입에 따라서 여의봉 마냥 참조 가능한 멤버의 한계가 달라짐. // GroundUnit gu2 = (GroundUnit)u2; // System.out.println(u.y); 참조타입이 Unit이라 Unit꺼가 아니라 컴파일 에러 System.out.println(gu.y); // GroundUnit의 멤버까지 접근이 가능하다. &#125;&#125; 확실히 구현해야하는 메소드들은 오버라이딩 보다는 추상메소드를 쓰자추상 메소드로 쓰면 구현을 하지 않으면 컴파일 에러가 나서 무조건 구현해야하는구나 라고 개발자가 더 확실히 인식할 수 있다.또한 오버라이딩은 해도 그만 안 해도 그만이라 잘못된 메소드를 만들어서 메소드 오버로딩이 될 수도 있는데 추상 메소드는 그럴 가능성이 없다. 123456789101112131415161718192021class Unit &#123; int x, y; abstract move(int x, int y)&#123;&#125; // 메소드 오버라이딩 대신에 추상 메소드를 써서 무조건 구현하게끔 했다. void stop()&#123;&#125;&#125;class Marine extends Unit &#123; void move(int x, int y)&#123;&#125; void stimPack()&#123;&#125;&#125;class Tank extends Unit &#123; void move(int x, int y)&#123;&#125; void changeMode()&#123;&#125;&#125;class Dropship extends Unit &#123; void move(int x, int y)&#123;&#125; void load()&#123;&#125; void unload()&#123;&#125;&#125; 고객이 물건 사는 거 구현하기생각할 게 많은 예제인 것 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Product &#123; int price = 100; Product(int price) &#123; this.price = price; &#125;&#125;class TV extends Product &#123; TV() &#123; super(100); &#125; public String toString() &#123; return &quot;TV&quot;; &#125;&#125;class Computer extends Product &#123; Computer() &#123; super(200); &#125; public String toString() &#123; return &quot;Computer&quot;; &#125;&#125;class Audio extends Product &#123; Audio() &#123; super(50); &#125; public String toString() &#123; return &quot;Audio&quot;; &#125;&#125;class Buyer &#123; int money = 1000; Product[] cart = new Product[3]; int i = 0; void buy(Product p) &#123; if(p.price &lt;= money) &#123; money -= p.price; add(p); &#125; else &#123; System.out.println(&quot;잔액이 부족하여 &quot; + p + &quot;을/를 살 수 없습니다.&quot;); &#125; &#125; void add(Product p) &#123; int len = cart.length; // len - 1까지는 정상적으로 넣어도 되는 값이고 넣은 이후에 ++이 되기 때문에 len으로 조건을 걸어주면 된다. if(i &gt;= len) &#123; Product[] tmp = new Product[len*2]; System.arraycopy(cart, 0, tmp, 0, len); cart = tmp; &#125; cart[i++] = p; &#125; void summary() &#123; int spend = 0; System.out.print(&quot;구입한 물건: &quot;); // cart.length로 하면 null인 경우에 break를 걸어줘야하는데(아직 카트를 덜 채운 경우) // i를 맥스로 하면 i는 이제 넣어야할 차례의 인덱스이므로 끝까지 넣은 구간까지만 출력하니 null을 처리해주지 않아도 된다. for (int j = 0; j &lt; i; j++) &#123; System.out.print(cart[j] + &quot;, &quot;); // spend를 구할 때 1000 - money로 구해도 되지만 1000원이라는 확신이 없기에 이렇게 해줘야함. spend += cart[j].price; &#125; System.out.println(); System.out.println(&quot;사용한 금액: &quot; + spend); System.out.println(&quot;남은 금액: &quot; + money); &#125;&#125;class Test5 &#123; public static void main(String[] args) &#123; Buyer b = new Buyer(); b.buy(new TV()); b.buy(new Computer()); b.buy(new TV()); b.buy(new Audio()); b.buy(new Computer()); b.buy(new Computer()); b.buy(new Computer()); b.summary(); &#125;&#125; 매개변수가 인터페이스일 때매개변수의 다형성에 대해 묻는 얘기인 것 같다.이렇게 다형성을 이용하면 메소드 오버로딩 해야할 경우의 수를 많이 줄일 수 있다.하지만 특정 인스턴스에 특화된 게 아니라 공통된 멤버들만 사용이 가능하다는 제약이 있다.진짜 클래스의 다형성, 매개변수의 다형성, 메소드의 다형성, 인터페이스의 다형성 등등 그지같이 많다. null Interface Interface를 구현한 클래스(인스턴스) Interface를 구현한 클래스의 자식 클래스(인스턴스) 내부 클래스의 변수 사용하기사용할 일이 있을라나… 인스턴스 변수 123456789101112class Outer &#123; // 외부 클래스 class Inner &#123; // 내부 클래스(인스턴스 클래스) int iv=100; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Outer o = new Outer(); Outer.Inner ii = o.new Inner(); System.out.println(ii.iv); &#125; &#125; 클래스 변수 1234567891011class Outer &#123; // 외부 클래스 class Inner &#123; // 내부 클래스(인스턴스 클래스) static int iv=100; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Outer.Inner ii = new Outer.Inner(); System.out.println(ii.iv); &#125; &#125; 익명 클래스얘는 어딘가 써먹을 법하다. 1회성 클래스에… 캡슐화 시키고자 12345678910111213class Test &#123; public static void main(String[] args) &#123; Frame f = new Frame(); f.addWindowListener(new EventHandler()); &#125;&#125;class EventHandler extends WindowAdapter &#123; public void windowClosing(WindowEvent e) &#123; e.getWindow().setVisible(false); e.getWindow().dispose(); System.exit(0); &#125; &#125; EventHandler를 익명클래스로 작성하면 123456789101112class Test &#123; public static void main(String[] args) &#123; Frame f = new Frame(); f.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; e.getWindow().setVisible(false); e.getWindow().dispose(); System.exit(0); &#125; &#125;); &#125;&#125; 상속받은 클래스의 인스턴스를 호출하고 {} 블록을 열어서 내용을 채워주면 된다.Swing에서 1회성(하나의 버튼에서만 쓰인다거나) 이벤트 핸들러를 쓸 때 이걸 많이 썼던 것 같다. Constant PoolDB의 Connection Pool 마냥 상수를 모아놓은 곳인 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"}]},{"title":"(Spring) 스타트 스프링 부트 002일차 - Hibernate와 MySQL 연결하기","slug":"Spring-boot-study-002day","date":"2017-08-03T09:17:54.000Z","updated":"2022-10-30T08:42:16.119Z","comments":true,"path":"2017/08/03/Spring-boot-study-002day/","link":"","permalink":"https://perfectacle.github.io/2017/08/03/Spring-boot-study-002day/","excerpt":"Hibernate를 써보자! (feat. MySQL) 의존성 추가(build.gradle)12345dependencies &#123; compile(&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;) compile(&#x27;org.springframework.boot:spring-boot-starter-jdbc&#x27;) testCompile(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125; DB 정보 입력(및 하이버네이트 설정)","text":"Hibernate를 써보자! (feat. MySQL) 의존성 추가(build.gradle)12345dependencies &#123; compile(&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;) compile(&#x27;org.springframework.boot:spring-boot-starter-jdbc&#x27;) testCompile(&#x27;org.springframework.boot:spring-boot-starter-test&#x27;)&#125; DB 정보 입력(및 하이버네이트 설정)&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties에 정보를 입력해주자.이 DB 정보 입력을 datasource 지정이라고 하는 것 같다. 1234567891011121314151617spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/db?useSSL=falsespring.datasource.username=idspring.datasource.password=pw# 스키마 생성(create)spring.jpa.hibernate.ddl-auto=create# DDL 생성 시 데이터베이스 고유의 기능을 사용하는가?spring.jpa.generate-ddl=false# 실행되는 SQL문을 보여줄 것인가?spring.jpa.show-sql=true# 데이터베이스는 무엇을 사용하는가?spring.jpa.database=mysql# 로그 레벨logging.level.org.hibernate=info# MySQL 상세 지정spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect 필요한 정보들은 알아서 수정하자. JPA로 엔티티 만들기 SQL로 테이블 만들고 엔티티 클래스 만들기 JPA를 통해 클래스만 설계하고 자동으로 테이블 생성하기 이 중에 후자를 택했다. (책에서) 엔티티 클래스 설계(VO 만들기, model) 12345678910111213141516import lombok.Getter;import lombok.Setter;import lombok.ToString;import java.sql.Timestamp;@Getter@Setter@ToStringpublic class Board &#123; private Long bno; private String title; private String Writer; private String content; private Timestamp regdate; private Timestamp updatedate;&#125; JPA를 위한 어노테이션 추가 123456789101112131415161718192021222324252627import lombok.Getter;import lombok.Setter;import lombok.ToString;import org.hibernate.annotations.CreationTimestamp;import org.hibernate.annotations.UpdateTimestamp;import javax.persistence.*;import java.sql.Timestamp;@Getter@Setter@ToString@Entity@Table(name=&quot;tbl_boards&quot;)public class Board &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long bno; private String title; private String Writer; private String content; @CreationTimestamp private Timestamp regdate; @UpdateTimestamp private Timestamp updatedate;&#125; @Table vs @Entity나는 엔티티 &#x3D;&#x3D; 테이블이라고 알고 있어서 두 어노테이션의 차이점이 뭐가 있나 싶었는데@Table은 테이블에 관한 정보를 기술한 어노테이션이고,@Entity는 이 클래스의 인스턴스가 엔티티임을 명시해주는 거란다. @EntityScan나는 다른 패키지에 엔티티 클래스를 만들고 ComponentScan을 했는데 안 되서 구글링 해보니 @EntityScan 어노테이션을 써야하는 거였다.Controller와 Model을 import하는 어노테이션이 따로 있는 줄은 몰랐다.사실 스프링이며 JPA며 다 어제 처음 접한 거니 모르는 거 투성이다.근본 없이, 이해 없이 본다 하더라도 나중엔 피와 살이 되겠지 ㅠㅠ… Failed to start connector [Connector[HTTP&#x2F;1.1-8080]]해당 포트를 이미 사용 중이라는데 IDE 다 껐는데도 종종 살아있는 서버가 있는갑다 ㅠㅠ아래 명령어로 pid를 확인하고 kill해주자. 12lsof -i :8080kill -9 pid 테이블의 수동 생성 VS 자동 생성일단은 JPA에 익숙하지 않으니 자동으로 생성해보면서 익숙해지자!큰 규모의 프로젝트라면 테이블을 별도로 생성하고 코드를 작성하는 것이 일반적이란다! 엔티티와 엔티티 매니저 엔티티: DB 상에서 데이터로 관리하는 대상‘상품’, ‘회사’, ‘직원’ 등과 같이 명사인 것들(아마 테이블로 뽑아낼 수 있는 걸 얘기하는 듯…?)DB에서는 엔티티를 위해 테이블을 설계하고 데이터를 추가하는데 이렇게 추가된 데이터를 인스턴스 혹은 레코드라고 부란다.상품, 회사 이것들 하나 하나가 엔티티 타입이 되며 이 엔티티 타입을 생성한다는 의미는 하나의 클래스를 작성한다는 의미가 된다.또한 JPA에서의 엔티티는 하나의 **클래스(엔티티 타입, 테이블)**이 될 때도 있고 하나의 **인스턴스(레코드)**를 뜻할 때도 있다. 엔티티 매니저: 여러 엔티티 객체(아마 인스턴스이지 않을까…)들을 관리하는 역할을 한다.여기서 말하는 관리는 라이프 사이클이라고 할 수 있다.(고 한다.)엔티티 매니저는 자기가 관리해야하는 엔티티 객체를 **Persistence Context(영속 컨텍스트)**라는 곳에 넣고 객체들의 생사(라이프 사이클)을 관리한다. 엔티티 객체 생명주기 New(비영속): Java 영역에 객체만 존재하고, DB와 연동된 적이 없는 상태.엔티티 매니저의 관리 하에 있는 게 아니기 때문에 순수한 Java 객체 Managed(영속): DB에 저장되고 메모리 상에서도 같은 상태로 존재하는 상태.객체는 영속 컨텍스트 내에 들어가게 되고 PK를 통해 엔티티 객체를 꺼내 사용할 수 있다. Removed(삭제): DB에서 삭제된 상태, 객체는 더 이상 영속 컨텍스트에 존재하지 않는다. Detached(준영속): 영속 컨텍스트에서 엔티티 객체를 꺼내서 사용하는 상태.고유한 PK는 있지만, 아직 DB와 동기화가 이루어지지 않은 상태.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"https://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"MySQL","slug":"MySQL","permalink":"https://perfectacle.github.io/tags/MySQL/"},{"name":"Entity Lifecycle","slug":"Entity-Lifecycle","permalink":"https://perfectacle.github.io/tags/Entity-Lifecycle/"}]},{"title":"(자료구조) Vector vs ArrayList vs LinkedList","slug":"vector-array-list-linked-list","date":"2017-08-02T14:58:36.000Z","updated":"2022-10-30T08:42:16.999Z","comments":true,"path":"2017/08/02/vector-array-list-linked-list/","link":"","permalink":"https://perfectacle.github.io/2017/08/02/vector-array-list-linked-list/","excerpt":"위 개념들은 일단 자바에 존재한다. (다른 거에도 다 존재하려나…?)비슷비슷해서 각각의 차이점이 궁금해서 정리해보았다. 일단 이 포스트에서 소개하는 자료구조들은 Array의 다음과 같은 단점들을 극복하고자 나왔다. 길이가 한정적이라 길이를 넘어서게 되면 새로 배열을 만들고 복사를 한 후에 새로운 값을 넣어야한다는 굉장히 큰 비용을 지불해야한다. 똑같은 타입의 요소들만 들어간다. 차이점","text":"위 개념들은 일단 자바에 존재한다. (다른 거에도 다 존재하려나…?)비슷비슷해서 각각의 차이점이 궁금해서 정리해보았다. 일단 이 포스트에서 소개하는 자료구조들은 Array의 다음과 같은 단점들을 극복하고자 나왔다. 길이가 한정적이라 길이를 넘어서게 되면 새로 배열을 만들고 복사를 한 후에 새로운 값을 넣어야한다는 굉장히 큰 비용을 지불해야한다. 똑같은 타입의 요소들만 들어간다. 차이점 VectorJava1 버전 대에서 제일 먼저 등장해서 아무도 없을 때는 요놈만 썼다.또한 동기화를 보장해주어 공유 자원이나 복수의 사용자가 존재할 때 좀 더 안전하게 프로그램을 작성할 수 있다.하지만 하나의 스레드가 하나의 자원을 이용하는 경우에는 오히려 성능의 저하가 발생한다.또한 공간이 모자를 때 모자른 공간x2 만큼의 공간을 확보하기 때문에 메모리를 많이 잡아먹는다는 단점도 존재한다. ArrayListArray 라는 이름이 들어갔다싶이 인덱스를 가지고 있어서 검색에 용이하다.하지만 삽입&#x2F;삭제를 하려면 중간에 이빨 나간 곳을 전부 한칸씩 땡기거나 뒤로 밀어야하기 때문에삽입과 삭제가 빈번한 데이터인 경우에는 부적합하다.Vector와 달리 동기화를 보장해주지 못하고, 공간이 모자를 때는 모자른 만큼만 공간을 확보한다. LinkedList노드(데이터와 다음 노드로 연결시킬 주소지)들이 줄줄이 연결된 녀석이다.맨 마지막에 있는 녀석을 검색해야한다면 처음부터 끝까지 노드를 타고 줄줄이 이동해야해서 검색에는 적합하지 않다.하지만 삭제&#x2F;삽입을 할 때는 중간에 해당 노드의 주소지만 바꿔주면 되므로 삽입&#x2F;삭제가 빈번한 데이터에 적합하다. ArrayList vs LinkdedList12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ArrayLinked &#123; static long add(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) list.add(i + &quot;&quot;); long end = System.currentTimeMillis(); return end - start; &#125; static long add2(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.add(500, &quot;X&quot;); long end = System.currentTimeMillis(); return end - start; &#125; static long remove(List list) &#123; long start = System.currentTimeMillis(); for (int i = list.size()-1; i &gt;= 0; i--) list.remove(i); long end = System.currentTimeMillis(); return end - start; &#125; static long remove2(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.remove(i); long end = System.currentTimeMillis(); return end - start; &#125; static long access(List list) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) list.get(i); long end = System.currentTimeMillis(); return end - start; &#125; public static void main(String[] args) &#123; ArrayList a = new ArrayList(200000); LinkedList b = new LinkedList(); System.out.println(&quot;순차적으로 추가하기&quot;); System.out.println(&quot;ArrayList: &quot; + add(a) + &quot;ms 소요&quot;); // 44ms System.out.println(&quot;LinkedList: &quot; + add(b) + &quot;ms 소요&quot;); // 21ms System.out.println(); System.out.println(&quot;중간에 추가하기&quot;); System.out.println(&quot;ArrayList: &quot; + add2(a) + &quot;ms 소요&quot;); // 272ms System.out.println(&quot;LinkedList: &quot; + add2(b) + &quot;ms 소요&quot;); // 18ms System.out.println(); System.out.println(&quot;중간에 제거하기&quot;); System.out.println(&quot;ArrayList: &quot; + remove2(a) + &quot;ms 소요&quot;); // 259ms System.out.println(&quot;LinkedList: &quot; + remove2(b) + &quot;ms 소요&quot;); // 458ms System.out.println(); System.out.println(&quot;순차적으로 삭제하기&quot;); System.out.println(&quot;ArrayList: &quot; + remove(a) + &quot;ms 소요&quot;); // 5ms System.out.println(&quot;LinkedList: &quot; + remove(b) + &quot;ms 소요&quot;); // 15ms System.out.println(); add(a); add(b); System.out.println(&quot;접근 속도 테스트&quot;); System.out.println(&quot;ArrayList: &quot; + access(a) + &quot;ms 소요&quot;); // 1ms System.out.println(&quot;LinkedList: &quot; + access(b) + &quot;ms 소요&quot;); // 283ms &#125;&#125; 참고자료 Java 의 Vector 와 ArrayList , Linked List 의 차이점 What are the differences between ArrayList and Vector?","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"https://perfectacle.github.io/categories/Middle-end/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://perfectacle.github.io/tags/LinkedList/"},{"name":"Vector","slug":"Vector","permalink":"https://perfectacle.github.io/tags/Vector/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://perfectacle.github.io/tags/ArrayList/"}]},{"title":"(Java) 자바의 정석 3판 012일차 - 다형성(클래스, 매개변수, 인터페이스), 참조타입의 형변환, 추상 클래스, 인터페이스, 단일 상속과 다중 상속","slug":"Java-study-012day","date":"2017-08-02T11:35:34.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/08/02/Java-study-012day/","link":"","permalink":"https://perfectacle.github.io/2017/08/02/Java-study-012day/","excerpt":"다형성(Polymorphism)객체지향 개념에서 다형성이란 여러 가지 형태를 가질수 있는 능력을 의미함.자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현함. 12345678910111213141516171819202122232425public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); CaptionTV c = new CaptionTV(); TV2 t2 = new CaptionTV(); System.out.println(c.text); // System.out.println(t2.text); TV2에 생성된 것만 참조 가능. // CaptionTV c2 = new TV2(); CaptionTV보다 TV2가 가진 멤버가 더 적어서 생성 불가능. &#125;&#125; 다음과 같은 특성을 지닌다.참조변수 a = new 인스턴스타입() 을 기준으로 설명한다.","text":"다형성(Polymorphism)객체지향 개념에서 다형성이란 여러 가지 형태를 가질수 있는 능력을 의미함.자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현함. 12345678910111213141516171819202122232425public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); CaptionTV c = new CaptionTV(); TV2 t2 = new CaptionTV(); System.out.println(c.text); // System.out.println(t2.text); TV2에 생성된 것만 참조 가능. // CaptionTV c2 = new TV2(); CaptionTV보다 TV2가 가진 멤버가 더 적어서 생성 불가능. &#125;&#125; 다음과 같은 특성을 지닌다.참조변수 a = new 인스턴스타입() 을 기준으로 설명한다. 기본적으로는 참조변수와 인스턴스의 타입이 일치하는 걸 많이 쓴다. 참조 변수 보다 인스턴스 타입의 멤버가 더 범위가 넓어야한다.TV2 t2 = new CaptionTV();참조변수: 부모, 인스턴스 타입: 자식 -&gt; 가능, 부모의 멤버만 참조가 가능하다.CaptionTV c2 = new TV2();참조변수: 자식, 인스턴스 타입: 부모 -&gt; 불가능, 참조변수의 멤버를 모두 충족하지 못한다. 그럼 TV2 t = new TV2();와 TV2 t = new CaptionTV(); 차이점이 궁금할텐데 차차 보도록 하자. 참조 변수의 형변환(Casting)기본값과 마찬가지로 참조타입도 형변환이 가능하다.하지만 제약이 있는데 상속 관계에 있는 녀석들끼리만 가능하다.또한 부모의 부모로 형변환도 가능하므로 모든 클래스는 Object 클래스를 상속 받고 있으므로 Object 클래스로 형변환이 가능하다.참조 변수의 캐스팅의 특징은 다음과 같다. 자식 -&gt; 부모(Up-casting): 형변환 생략 가능자식이 부모의 모든 걸 상속 받았으므로 자식이 더 범위가 넓다고 판단하여 손실이 없다고 판단하는지 형변환의 생략이 가능하다. 부모 -&gt; 자식(Down-casting): 형변환 생략 불가능 우리 눈으로 보기에는 형제 관계도 있을 것 같은데 자바에서는 형제 관계가 존재하지 않아 형제 사이에 형변환은 불가능하다.그럼 TV2 t = new TV2();와 TV2 t = new CaptionTV(); 차이점을 알아보자.사실 TV2 t = new CaptionTV();는 다음을 줄인 것이다.TV2 t = (TV2)new CaptionTV(); 업 캐스팅이므로 형변환이 생략돼있던 것이다.이걸 또 풀어쓰면 다음과 같다. CaptionTV c = new CaptionTV(); TV2 t = (TV2)c역시 업캐스팅이므로 TV2는 생략이 가능하다. 그럼 위와 같은 차이점으로 인해 무엇이 달라진단 말인가?아래의 예제를 살펴보자. 12345678910111213141516171819202122232425262728public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); TV2 t2 = new CaptionTV(); // t는 TV2 인스턴스여서 TV2의 멤버만 가지고 있으므로 CaptionTV 타입을 커버할 수가 없다. // 컴파일 시에는 올바른 형변환으로 보지만 런타임에서 체크 해보면 부모가 자식을 커버할 수 없는 원리와 같다. // CaptionTV c = (CaptionTV)t; // System.out.println(c.text); // t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅 해서 일단 CaptionTV 멤버를 들고는 있는데 // 접근만 못할 뿐이라 CaptionTV 타입을 커버할 수 있다. CaptionTV c2 = (CaptionTV)t2; System.out.println(c2.text); // null &#125;&#125; 이렇듯 부모 클래스에서 자식 클래스로 형변환이 가능하지만부모 인스턴스 타입에서 자식 참조 타입으로 변환하지는 못한다.이 말을 풀어 쓰면 TV2 t = new TV2();부모 참조 타입에 부모 인스턴스면CaptionTV c = (CaptionTV)t;자식의 참조 타입으로 변환하지 못한다. TV2 t = new CaptionTV();부모 참조 타입에 자식 인스턴스면CaptionTV c = (CaptionTV)t;자식의 참조 타입으로 변환 가능하단 소리다. instanceof 연산자자스와 비슷하다고 보면 되고, null인 참조 변수는 항상 false를 반환한다.음… 말로 설명하기 까다로우니 다음 예제를 보자. 12345678910111213141516171819202122public class TV2 &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown()&#123;&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; CaptionTV c2 = new CaptionTV(); System.out.println(c2 instanceof CaptionTV); // true System.out.println(c2 instanceof TV2); // true System.out.println(c2 instanceof Object); // true &#125;&#125; 참조변수와 인스턴스의 연결1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Parent &#123; int x = 10; static int y = 20; void method() &#123; System.out.println(&quot;asdf&quot;); &#125; static void method2() &#123; System.out.println(&quot;qwer&quot;); &#125;&#125;class Child extends Parent &#123; int x = 20; static int y = 30; void method() &#123; System.out.println(&quot;x=&quot;+x); // 20 System.out.println(&quot;this.x=&quot;+this.x); // 20 System.out.println(&quot;super.x=&quot;+super.x); // 10 &#125; static void method2() &#123; System.out.println(&quot;zxcv&quot;); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Parent p = new Child(); // (Parent)new Child(); // 인스턴스 변수인 x는 참조타입인 Parent를 따른다. System.out.println(p.x); // 10 // static 변수인 y는 참조타입인 Parent를 따른다. System.out.println(p.y); // 10 // static 메소드인 method2는 참조타입인 Parent를 따른다. p.method2(); // 인스턴스 메소드인 method는 인스턴스 타입인 Child를 따른다. p.method(); Child c = new Child(); // 인스턴스 변수인 x는 참조타입인 Child를 따른다. System.out.println(c.x); // 20 // static 변수인 y는 참조타입인 Child를 따른다. System.out.println(c.y); // 30 // static 메소드인 method2는 참조타입인 Child를 따른다. c.method2(); // zxcv // 인스턴스 메소드인 method는 인스턴스 타입인 Child를 따른다. c.method(); &#125;&#125; 참조타입에 좌지우지 되지 않고 뚝심있게 인스턴스 타입으로 밀고나가는 것은 인스턴스 메소드 밖에 없다.static 타입도 참조타입에 좌지우지 되므로 인스턴스.멤버 말고 클래스.멤버로 적어주는 것이 좋다. 매개변수의 다형성1234567891011121314151617181920public class Product &#123; int price; int bonusPoint;&#125;class Computer extends Product &#123;&#125;class Radio extends Product &#123;&#125;class Buyer &#123; int money = 1000; int bonusPoint = 0; void buy(Computer c) &#123; money -= c.price; bonusPoint += c.bonusPoint; &#125; void buy(Radio r) &#123; money -= r.price; bonusPoint += r.bonusPoint; &#125;&#125; 제품이 추가될 때 마다 계속해서 메소드를 오버로딩할 것인가…?아래와 같이 다형성을 이용하면 된다. 1234567891011121314151617181920212223class Buyer &#123; int money = 1000; int bonusPoint = 0; void buy(Product p) &#123; money -= p.price; bonusPoint += p.bonusPoint; &#125; void buy(Radio r) &#123; // 따로 처리하고 싶은 녀석만 따로 빼면 된다. money -= r.price; bonusPoint += r.bonusPoint; System.out.println(&quot;asdf&quot;); &#125;&#125;class Test5 &#123; public static void main(String[] args) &#123; Buyer b = new Buyer(); b.buy(new Radio()); // &quot;asdf&quot;까지 무사 출력된다. System.out.println(b.money); // 900으로 까였다. b.buy(new Computer()); System.out.println(b.money); // 800으로 까였다. &#125;&#125; Product의 instanceof로 자식 클래스들이 전부 걸리므로 저기서도 전부 매칭이 된다.매개변수의 다형성이 저렇게 부모 클래스로 추상화시키는 것이라면 메소드의 다형성은 오버로딩이려나…?? 여러 종류의 객체를 배열로 다루기1234567891011121314class Test5 &#123; public static void main(String[] args) &#123; // Product의 instanceof에 걸리므로 이렇게도 할 수 있다. // 물론 배열 내부에 있는 애들은 부모 타입으로 업캐스팅 된다. (형변환 연산자는 생략된 것임) Product[] p = &#123;new Computer(), new Radio(), new Radio()&#125;; // 배열은 길이가 고정적인데 반해 벡터는 10개는 기본이고, 그 이후에는 계속해서 추가된다. // 이러한 단점을 극복한 게 Vector이다. Vector는 객체 배열이다. // 따라서 클래스의 인스턴스 멤버들을 사용하려면 다운캐스팅 해줘야한다. // System.out.println(((Audio)p[3]).volume); Vector&lt;Product&gt; v = new Vector&lt;&gt;(); v.add(new Computer()); v.add(new Radio()); &#125;&#125; 추상 클래스(abstract class)미완성 클래스(설계도)이다.틀만 그려놓고 자식이 상속받아서 구현하라는 뜻이다.이 클래스를 가지고는 인스턴스를 생성하지 못한다.백지에서 클래스를 설계하기 보다는 공통된 요소를 모아논 추상 클래스를 만들고 여기 저기서 상속 받아서 클래스를 작성하면 훨씬 수월할 것이다.추상 메소드가 있으면 abstract 키워드를 붙여 상속 받아서 완성시켜야할 놈이 있다고 명시적으로 알려주는 게 좋다.abstract에는 미완성인 녀석만 있는 게 아니라 생성자나 메소드 등등 다 가지고 있을 수 있다.심지어 일반 클래스도 그냥 abstract 키워드를 붙여 추상 클래스로 만들 수 있는데 이렇게되면 직접 인스턴스 생성을 하지 못한다.상속이 자식 클래스를 만드는데 부모 클래스(공통 부분)를 이용하는 것이라면,추상화는 부모 클래스(공통 부분)을 만드는데 자식 클래스(여러 자식에서 공통되는 부분들을 추출)를 이용한다.추상화는 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업이라고 할 수 있고,구체화는 상속을 통해 클래스를 구현, 확장하는 작업이라고 할 수 있다. 추상 메소드(abstract method)일반적인 클래스에는 존재할 수 없다.몸통이 없으므로 abstract void a();와 같이 세미콜론을 찍어주고 {} 블록이 없다.일반 메소드와 달리 추상 메소드는 무조건 오버라이딩 해줘야 오류가 발생하지 않는다. 인터페이스(Interface)추상 클래스보다 추상화 정도가 훨씬 높다.인터페이스는 추상 메소드와 상수만 존재할 수 있다. 그리고 인터페이스 멤버의 제약 사항은 다음과 같다. 모든 멤버변수는 public static final이어야 하면 생략 가능하다. 모든 메소드는 public abstract이어야 하며 생략 가능하다 Java8부터 static 메소드와 default 메소드도 가능해졌다. 인터페이스의 상속은 다른 인터페이스로부터만 가능하며 다중 상속이 가능하다.인터페이스는 클래스의 Object와 같은 최고 조상이 없다.인터페이스의 모든 메소드들을 구현해야하는데 일부만 구현하는 클래스는 abstract 키워드를 붙여 추상 클래스로 만들어주면된다.인터페이스는 주로 ~able로 끝나는 것들이 많다.그 이유는 어떤 기능 또는 행위를 하는데 필요한 메소드를 제공한다는 의미를 지니기 때문이다. 123456789interface TT &#123; // public abstract void a(); void a();&#125;class T implements TT &#123; // 구현부는 원본보다 접근 지정자가 넓어야한다. public void a() &#123;&#125;&#125; 다중 상속?다중 상속을 하면 멤버(변수, 메소드) 명의 충돌 위험이 존재한다는 단점이 존재해서 Java에서는 지원하지 않는다.하지만 다른 객체 지향 언어인 C++에서는 지원하는데 반해 Java에서는 지원하지 않자 이게 단점처럼 지적을 받았다.그러다보니 마케팅(?)을 위해서인지 Java에서도 인터페이스를 통해 다중 상속(구현)을 지원하기 시작했는데 실제로 인터페이스를 다중 상속하는 경우는 드물단다. 인터페이스의 다형성클래스에서 부모 타입으로 자식 인스턴스를 생성하듯,인터페이스에서도 인터페이스 타입으로 인터페이스를 구현한 클래스의 인스턴스를 생성할 수 있다. 12// Fightable 인터페이스에 존재하는 멤버들만 사용이 가능한다.Fightable f = new Fighter(); // (Fightable)new Fighter();와 동일. 그 진가는 아래 예제를 통해 발동한다.instanceof 연산자는 자기 자신, 부모, 조상, 추상 클래스, 인터페이스에 모두 걸리는 모양이다. 12345678910111213141516171819202122232425262728293031public interface Parseable &#123; void parse(String fileName);&#125;class XMLParser implements Parseable &#123; public void parse(String fileName) &#123; System.out.println(fileName + &quot; - XML parsing completed.&quot;); &#125;&#125;class HTMLParser implements Parseable &#123; public void parse(String fileName) &#123; System.out.println(fileName + &quot; - HTML parsing completed.&quot;); &#125;&#125;class ParserManager &#123; public static Parseable getParser(String type) &#123; if(type.equals(&quot;XML&quot;)) return new XMLParser(); return new HTMLParser(); &#125;&#125;class ParserTest &#123; public static void main(String[] args) &#123; Parseable parser = ParserManager.getParser(&quot;XML&quot;); parser.parse(&quot;document.xml&quot;); // document.xml - XML parsing completed. parser = ParserManager.getParser(&quot;HTML&quot;); parser.parse(&quot;document.html&quot;); // document.html - HTML parsing completed. &#125;&#125; 매개변수와 리턴타입으로 인터페이스가 올 수 있는데 이는 해당 인터페이스를 구현한 클래스의 인스턴스를 의미한다.그래서 Parseable라는 인터페이스 타입에 XMLParser나 HTMLParser 인스턴스를 모두 저장할 수 있는 것이다.이러한 장점은 분산환경 프로그래밍에서 그 위력을 발휘한다.사용자가 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자는 변경된 프로그램을 사용할 수 있게 된다라고 하는데 뭔 소린지 모르겠다. 기본 메소드와 static 메소드Java8에 들어와서 기본 메소드가 등장했다.인터페이스에 메소드가 하나 추가되면 모든 구현체 클래스에 해당 메소드를 구현해야한다는 부담이 생긴다.따라서 아래와 같이 하면 기본적인 메소드가 생겨서 굳이 구현을 하지 않아도 오류가 생기지 않는다. 1default void newMethod()&#123;&#125; // public default void newMethod()&#123;&#125; static 메소드는 인스턴스와 관계가 없는 독립적인 메소드이기 때문에 인터페이스에 넣지 않을 이유가 없다는데 그게 무슨 상관인지 모르겠다. 만약 여러 인터페이스에서 default 메소드가 중복된다면 구현하는 클래스에서 오버라이딩해야하고,부모 클래스와 default 메소드 간에 충돌이 일어나면 디폴트 메소드는 무시되고 부모 클래스의 메소드를 상속받는다. 내부 클래스클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계가 있기 때문이다.내부 클래스를 선언하면 두 클래스 멤버 사이에 서로 쉽게 접근할 수 있고, 외부에 불필요한 데이터를 감춤으로써코드의 복잡성을 줄일 수 있다. (캡슐화)","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"}]},{"title":"(Spring Boot) 스타트 스프링 부트 001일차 - 스프링(부트), 빌드툴, VO, Lombok, 어노테이션, Jackson, ORM, JPA, Hibernate","slug":"Spring-boot-study-001day","date":"2017-08-02T10:02:06.000Z","updated":"2022-10-30T08:42:16.119Z","comments":true,"path":"2017/08/02/Spring-boot-study-001day/","link":"","permalink":"https://perfectacle.github.io/2017/08/02/Spring-boot-study-001day/","excerpt":"자바에 대한 근본도 없고, MVC, Servelet&#x2F;JSP에 대한 이해도 제대로 없는데 이런 걸 해도 될런지 모르겠지만… 일단은 시작!나머지는 병행해가면서 해보자… 스프링 vs 스프링 부트 스프링: 프론트로 치면 웹팩, 바벨, 걸프 설정 등등을 처음부터 내가 다 짜줘야함. 스프링 부트: CRA(Create React App) or Vue-CLI와 같이 알아서 설정을 도와줌.IntelliJ에서 프로젝트를 만들 때 Sprign Initializer를 선택하면 된다.보이지 않는다면 최신버전으로 업뎃하고 플러그인에서 Spring Boot가 제대로 설치&#x2F;활성화 됐는지 확인하자. 스프링이란?","text":"자바에 대한 근본도 없고, MVC, Servelet&#x2F;JSP에 대한 이해도 제대로 없는데 이런 걸 해도 될런지 모르겠지만… 일단은 시작!나머지는 병행해가면서 해보자… 스프링 vs 스프링 부트 스프링: 프론트로 치면 웹팩, 바벨, 걸프 설정 등등을 처음부터 내가 다 짜줘야함. 스프링 부트: CRA(Create React App) or Vue-CLI와 같이 알아서 설정을 도와줌.IntelliJ에서 프로젝트를 만들 때 Sprign Initializer를 선택하면 된다.보이지 않는다면 최신버전으로 업뎃하고 플러그인에서 Spring Boot가 제대로 설치&#x2F;활성화 됐는지 확인하자. 스프링이란?1.0이 2004년에 나왔고 2011년에는 3.x가 나왔다.처음에는 light-weight(경량)화됐으나 지금은 매우 무겁다…Servlet&#x2F;JSP에서 진보된 웹 개발 방식?이라고 해야하려나…여튼 스프링은 프레임워크이다.스프링 부트는 루비의 RoR(Ruby on Rails), 파이썬의 Flask, Django 등의 마이크로 프레임워크를 보고 영감을 얻은 것 같다.이런 마이크로 프레임워크들은 프로젝트 생성과 동시에 필요한 라이브러리를 초기화 해주며, 템플릿 등을 제공해줘 개발의 생산성을 높였다.스프링 부트는 기존 스프링의 복잡한 설정 과정이나 버전 충돌 등의 불편한 점을 제거하고 빠르고 쉬언 서버&#x2F;테스트 환경을 제공해준다.또한 내부에 WAS(Web Application Server)인 Tomcat을 내장하고 있어서 따로 Tomcat을 설치할 필요가 없는 것 같다. Ant, Maven, Gradle나중에 더 자세히 조사해봐야겠지만 일단은 정리.빌드 툴이란다.빌드는 컴파일 내에 속하는 것(?) 같은데 그 중간에 해줘야하는 복잡한 과정들을 기술한 것 같다.프론트로 치면 Task Runner인 Gulp와 Grunt, 그리고 npm scripts 정도…??또한 이 안에는 의존성이 주입(?)된 라이브러리도 기술돼있으므로 npm도 포함하는 개념인 것 같다.프론트도 d3 홈페이지가서 js 파일 받고, jQuery 홈페이지가서 js 파일 받고 수동으로 해서 이걸 편하게 하기 위해(?) npm이 나왔 듯백엔드도 라이브러리 홈피가서 zip 파일 받아서 zip 파일 풀고 jar 파일 import 하는 게 귀찮아서인지 이런 툴들이 나온 것 같다. Java Bean VS VO(Variable Object)Java Bean은 일종의 스펙이고 VO는 특정한 의도를 달성하기 위해 Java Bean을 준수한 것 같다. Java Bean은 다음과 같은 스펙을 준수한 클래스를 칭하는 것 같다.(내가 아는 수준만 적어보았다.) 모든 변수는 private 접근 지정자를 지정해줘야한다. 해당 변수에 접근하기 위한 getter와 setter가 있어야한다. 이외에도 더 많은 것 같은데 나중에 다시 한 번 공부를 해보고 지금 내가 당장 이해한 수준은 위와 같다. VO는 Java Bean 스펙을 준수했는데 값 자체를 나타내며 불변(immutable)이란다.또 아래 내용을 인용했는데 이쪽이 더 이해하기 쉬운 것 같다.출처: vo하고 bean의 차이가 무엇인가요? 자바 빈은 특정 형태의 클래스를 가르키는 말이고 VO는 주로 계층형 구조에서 계층간 값을 전달하기 위해 자바 빈의 형태로 구현한 클래스입니다.그래서 지금 시점에서는 그냥 퍼블릭 생성자와 속성(컨벤션에 맞는 getter&#x2F;setter 조합)을 갖는 클래스를 가르키는 뜻으로 쓰이는 만큼, POJO(Plain Old Java Object)와도 거의 동일한 개념으로 이해해도 무방합니다. Lombok이것도 라이브러리? 플러그인? 같은데 Sass가 CSS 전처리기라면 Lombok은 어노테이션 전처리기란다.프로젝트를 만들 때 Core에서 Lombok을 설정해줘야한다.IntelliJ에서 플러그인에서 설치를 해줘야하고(그래야 IDE에서 오류로 처리하지 않는다. 아마…??),또 실제로 작동하게 하려면 Setting으로 가서 … &gt; Compiler &gt; Annotation Processors로 가서 Enable 시켜주기. 일반 IDE에서는 아래와 같이 getter와 setter를 자동으로 만들어주기도 해서 굳이 Lombok을 쓸 필요가 있냐고 주장하는 사람도 있다. 1234567891011121314151617181920212223242526272829public class SampleVO &#123; private String val1; private String val2; private String val3; public void setVal1(String val1) &#123; this.val1 = val1; &#125; public void setVal2(String val2) &#123; this.val2 = val2; &#125; public void setVal3(String val3) &#123; this.val3 = val3; &#125; public String getVal1() &#123; return val1; &#125; public String getVal2() &#123; return val2; &#125; public String getVal3() &#123; return val3; &#125;&#125; Lombok을 쓰면 아래와 같이 간단해진다. 12345678910import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class SampleVO &#123; private String val1; private String val2; private String val3;&#125; 하지만 Lombok을 쓰면 Setter에 로직을 심을 수 없다는 단점이 존재해서 간단한 getter&#x2F;setter나 기타 어노테이션 정도만 써야겠다.기타 어노테이션은 (Lombok)사용 설명을 참고하자. 스프링의 어노테이션ES.Next에도 어노테이션과 비슷한 데코레이터라는 게 있는데 아직도 어떻게 동작하는지 제대로 이해하지 못했다.자바의 정석을 차근차근 진도 빼면서 익혀봐야겠다.아 그리고 클래스나 메소드를 감싸(?)는 게 어노테이션이므로 클래스와 메소드를 먼저 작성하고 추후에 어노테이션을 뭘 쓸지 고민하고 사용하자.여튼 스프링에서 REST API를 구현하기 위해 사용한 어노테이션을 조금 익혀보자. @RestController컨트롤러 클래스에 붙이는 어노테이션, REST API를 담당하는 Controller라는 뜻인 것 같다.또한 이렇게 하면 스프링의 빈(Bean)으로 등록된단다.기존 스프링에서는 어노테이션을 사용해도 &lt;component-scan&gt; 등과 같은 별도의 설정이 필요했지만 스프링 부트에서는 그런 귀찮은 작업이 필요없다. 12345678package com.example.exo.controller;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorld &#123; &#125; @ComponentScan만약 스프링 앱(main 메소드가 있고 run 하는 *.java 파일)과 같은 패키지, 혹은 자식패키지에 존재하지 않고 다른 패키지에 존재한다면해당 어노테이션을 사용해서 클래스들을 스프링에 인식시켜야한다. 12345678910111213package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@SpringBootApplication@ComponentScan(basePackages = &#123;&quot;com.example.demo&quot;, &quot;com.example.exo&quot;,&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 주의 사항으로 @ComponentScan 어노테이션을 쓰지 않으면 현재 패키지 내에 있는 모든 클래스를 스프링에 등록하지만@ComponentScan을 사용해서 다른 패키지를 등록하는 순간 현재 패키지는 제외된다.따라서 @ComponentScan 어노테이션을 사용한다고 하면 현재 패키지까지 추가를 무조건 해줘야한다. @GetMappingREST API 중 http method인 get에 매핑되는 녀석에 해당하는 어노테이션이다.@PostMapping, @PutMapping, @DeleteMapping도 물론 존재한다. 12345678910111213package com.example.exo.controller;import com.example.exo.vo.SampleVO;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.GetMapping;@RestControllerpublic class HelloWorld &#123; @GetMapping(&quot;/hello&quot;) public String sayHello() &#123; return &quot;Hello World&quot;; &#125;&#125; JacksonVO의 toString()한 일반 문자열을 JSON 형태로 뿌려주는 라이브러리인 것 같다.Spring Boot에서 기본적으로 깔린다. JPA와 HibernateJPA는 Java Persistence API의 줄임말이고, 이 JPA를 스프링에서 쓰기 편하게 한 라이브러리가 Spring Data JPA이다. 그럼 Hibernate는 무엇일까?이 관계를 ECMAScript와 Javascript로 풀어보았다.ECMAScript는 스펙이고 Javascript는 그 스펙을 준수해서 구현한 구현체(?)이다.JPA는 스펙이고 Hibernate는 그 스펙을 준수해서 구현한 구현체(?)이다.맞을라나 모르겠다.Hibernate 말고 JPA의 구현체는 EclipseLink, DataNucleus 등등이 있다. 그럼 이 JPA는 뭘까? ORM을 자바라는 언어로 구현(?)한 것이라고 나는 본다.ORM(Object Relational Mapping)은 객체지향에서 말하는 객체와 DB에서 말하는 개체가 상당히 유사하다는 입장에서 시작했다.회원정보를 객체(클래스)로 표현한 것과 개체(Entity, DB의 Table이라고 보면 될 것 같다)로 표현한 것이 매우 유사하다는 점이다.이러한 ORM은 언어에 종속적인 게 아니라서 Java에서는 JPA가 있 듯이, Javascript 진영에는 Sequelize라는 녀석이 존재한다. 마지막으로 ORM의 장단점을 정리해보자. 장점 DB 관련 코드에 대해 유연함을 얻을 수 있다. DB가 변경되면 우리가 사용하는 Java 코드도 다 고쳐야하는데 ORM을 이용하면 모델 부분?만 고쳐주면 된단다. DB와 독립적 관계이다. RDB, NoSQL을 가리치 않는다는 소리 같다. Join 관계가 매우 복잡해지면 쌩 SQL보다 가독성이 좋다고 한다. 단점 학습 곡선(Learning curve)가 크다. 객체 지향에 대한 이해가 제대로 돼야 제대로 된 설계가 가능하다. 특정 DB의 특성을 이용할 수 없다. 장점의 2를 보면 특정 DB에 의존적이지 않다는 것은 특정 DB의 특성을 이용하지 않고 범용적인 부분만 사용한다는 것이다. 이러한 특성을 못 살리다 보니 튜닝이라던지 퍼포먼스 측면에서 Natvie SQL보다는 구리다는 단점이 존재한다. 따라서 ORM과 Native SQL을 케바케로 잘 섞어 써야하는 것 같다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"https://perfectacle.github.io/categories/Note/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Gradle","slug":"Gradle","permalink":"https://perfectacle.github.io/tags/Gradle/"},{"name":"VO","slug":"VO","permalink":"https://perfectacle.github.io/tags/VO/"},{"name":"Bean","slug":"Bean","permalink":"https://perfectacle.github.io/tags/Bean/"},{"name":"Lombok","slug":"Lombok","permalink":"https://perfectacle.github.io/tags/Lombok/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"Ant","slug":"Ant","permalink":"https://perfectacle.github.io/tags/Ant/"},{"name":"Maven","slug":"Maven","permalink":"https://perfectacle.github.io/tags/Maven/"}]},{"title":"(Java) 자바의 정석 3판 011일차 - 상속과 포함, 오버라이딩, super, 패키지와 클래스, 접근 지정자","slug":"Java-study-011day","date":"2017-08-01T18:30:01.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/08/01/Java-study-011day/","link":"","permalink":"https://perfectacle.github.io/2017/08/01/Java-study-011day/","excerpt":"연습문제 실수 기존의 코드를 재사용할 수 있으면 하자. 123456789101112131415public class SutdaCard &#123; int num = 0; boolean isKwang = false; SutdaCard() &#123; // 이 한줄로 커버 되고 이래야 유지보수 측면에서도 용이하다. this(1, true); // num = 1; // isKwang = true; &#125; SutdaCard(int num, boolean isKwang) &#123; this.num = num; this.isKwang = isKwang; &#125;&#125; 형변환10f와 10.0f는 동일하니 쓸 데 없는 .0을 안 찍도록 하자. 지역변수 123public static void main(String[] args)&#123; &#125; args도 지역변수다.또한 main은 변수가 아니라 (클래스) 메소드이다.자바스크립트에서는 함수를 변수에 담을 수 있어서 함수도 변수의 범주 안에 속하고,함수와 메소드가 유사한 측면을 갖고 있다보니 main 메소드도 static 키워드를 썼으므로 클래스 변수인 줄 알았는데 아니었다. String vs StringBuffer 1234567891011121314151617181920public class Test &#123; static void change(String str) &#123; str += &quot;456&quot;; &#125; static void change(StringBuffer str) &#123; str.append(&quot;456&quot;); &#125; public static void main(String[] args) &#123; String str = &quot;ABC123&quot;; System.out.println(str); // ABC123 change(str); System.out.println(&quot;After change:&quot;+str); // ABC123 StringBuffer str2 = new StringBuffer(&quot;ABC123&quot;); System.out.println(str2); // ABC123 change(str2); System.out.println(&quot;After change:&quot;+str2); // ABC123 &#125;&#125; String 클래스는 참조타입임에도 불구하고 내용을 변경할 수 없기 때문에 ABC123456이라는 새로운 변수를 지역변수 str에 만들고메소드 종료와 더불어 해당 지역변수도 날아가서 원하는 결과가 나오지 않는다.따라서 원하는 결과를 얻어내려면 return으로 반환 값을 받아오거나 StringBuffer 클래스를 이용해야한다. 상속생성자와 초기화 블럭은 상속되지 않고, 멤버(변수, 메소드)만 상속된다.접근 지정자가 private 또는 default는 상속은 받되, 자식 클래스에서 직접적인 접근이 불가능하다.","text":"연습문제 실수 기존의 코드를 재사용할 수 있으면 하자. 123456789101112131415public class SutdaCard &#123; int num = 0; boolean isKwang = false; SutdaCard() &#123; // 이 한줄로 커버 되고 이래야 유지보수 측면에서도 용이하다. this(1, true); // num = 1; // isKwang = true; &#125; SutdaCard(int num, boolean isKwang) &#123; this.num = num; this.isKwang = isKwang; &#125;&#125; 형변환10f와 10.0f는 동일하니 쓸 데 없는 .0을 안 찍도록 하자. 지역변수 123public static void main(String[] args)&#123; &#125; args도 지역변수다.또한 main은 변수가 아니라 (클래스) 메소드이다.자바스크립트에서는 함수를 변수에 담을 수 있어서 함수도 변수의 범주 안에 속하고,함수와 메소드가 유사한 측면을 갖고 있다보니 main 메소드도 static 키워드를 썼으므로 클래스 변수인 줄 알았는데 아니었다. String vs StringBuffer 1234567891011121314151617181920public class Test &#123; static void change(String str) &#123; str += &quot;456&quot;; &#125; static void change(StringBuffer str) &#123; str.append(&quot;456&quot;); &#125; public static void main(String[] args) &#123; String str = &quot;ABC123&quot;; System.out.println(str); // ABC123 change(str); System.out.println(&quot;After change:&quot;+str); // ABC123 StringBuffer str2 = new StringBuffer(&quot;ABC123&quot;); System.out.println(str2); // ABC123 change(str2); System.out.println(&quot;After change:&quot;+str2); // ABC123 &#125;&#125; String 클래스는 참조타입임에도 불구하고 내용을 변경할 수 없기 때문에 ABC123456이라는 새로운 변수를 지역변수 str에 만들고메소드 종료와 더불어 해당 지역변수도 날아가서 원하는 결과가 나오지 않는다.따라서 원하는 결과를 얻어내려면 return으로 반환 값을 받아오거나 StringBuffer 클래스를 이용해야한다. 상속생성자와 초기화 블럭은 상속되지 않고, 멤버(변수, 메소드)만 상속된다.접근 지정자가 private 또는 default는 상속은 받되, 자식 클래스에서 직접적인 접근이 불가능하다. 포함(Composite)12345678class Point &#123; int x, y;&#125;class Circle &#123; //int x, y, r; Point p = new Point(); int r;&#125; 이렇게 단위별로 클래스를 여러 개로 쪼개면 조합해서 사용할 수도 있어서 유지보수(재사용성, 적은 변경사항) 측면에서 뛰어나다. extends vs composite 원은 점이다. - Circle is a Point, 상속(extends) 원은 점을 가지고 있다. - Circle has a Point, 포함(composite) toString() 메소드1234567891011class Card &#123; public String toString() &#123; return &quot;asdf&quot;; &#125; public static void main(String[] args)&#123; Card c = new Card(); System.out.println(c.toString()); // &quot;asdf&quot; System.out.println(c); // &quot;asdf&quot; System.out.println(&quot;qwer&quot; + c); // &quot;qwerasdf&quot; &#125;&#125; java.lang.Object 클래스에 있는 메소드를 오버라이딩한 것이다.모든 객체(클래스, 인스턴스)는 Object 클래스를 상속 받는다. 단일 상속(single inheritance)또 다른 객체지향 언어인 C++에서는 다중 상속을 허용하지만, 자바는 그렇지 않다.다중 상속을 하면 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 존재하지만,클래스 간의 관계가 복잡해질 수 있고, 다른 클래스로부터 상속받은 멤버간의 이름이 같으면 구별할 수 있는 방법이 없다.static 멤버야 클래스 이름을 붙여서 구분이 가능하지만 인스턴스 멤버는 그렇지 않다.다중 상속의 장점을 포기했지만, 그럼으로 인해서 클래스 간의 관계가 명확해지고 코드의 신뢰도가 올라간다는 장점이 존재한다. 물론 아래와 같이 다중 상속을 흉내낼 수 있다. 12345678910111213141516171819202122232425262728293031323334353637class TV &#123; boolean power; int channel; void power()&#123;&#125; void channelUp()&#123;&#125; void channelDown90()&#123;&#125;&#125;class VCR &#123; boolean power; int counter; void power()&#123;&#125; void play()&#123;&#125; void stop()&#123;&#125; void rew()&#123;&#125; void ff()&#123;&#125;&#125;class TVCR extends TV &#123; VCR vcr = new VCR(); int counter = vcr.counter; void play() &#123; vcr.play(); &#125; void stop() &#123; vcr.stop(); &#125; void rew() &#123; vcr.rew(); &#125; void ff() &#123; vcr.ff(); &#125;&#125; TVCR은 TV이다. (상속) TVCR은 VCR을 가지고 있다. (포함) 위 관계를 잘 활용하면 다중 상속과 같은 효과를 낼 수 있다.TVCR.play는 사실 VCR 클래스의 play 메소드를 실행하고 있다. 오버라이딩(overriding)발음상 overwrite(오버라이트)와 override(오버라이드)가 비슷하다.따라서 override는 덮어쓴다고 생각하면 될 것 같다.부모 클래스의 메소드를 재정의하는 것이다. 조건은 아래와 같다. 이름이 같아야한다. 매개변수가 같아야한다. 반환타입이 같아야한다.Java5부터는 자손 클래스의 타입으로 변경하는 것이 가능하게 되었다.covariant return type이라고도 부른다.(공변, 함께 변하는 이라는 뜻) 즉 선언부는 아예 일치해야한다는 뜻이다.하지만 접근 지정자와 예외 처리는 예외이다. 부모 클래스 보다 접근 지정자가 넓어야한다. 보통은 같은 걸 쓴다. 123456789public class Parent &#123; protected void a()&#123;&#125;&#125;class Child extends Parent &#123; protected void a()&#123;&#125; // private가 protected 보다 범위가 좁아서 오류가 난다. // private void a()&#123;&#125; &#125; 부모 클래스보다 예외 처리할 수 있는 경우가 적어야한다. 12345678910public class Parent &#123; protected void a() throws IOException, SQLException &#123;&#125;&#125;class Child extends Parent &#123; protected void a() throws IOException &#123;&#125; // 단순 갯수의 문제가 적어야하는 게 아니라 경우의 수의 문제이다. // Exception은 모든 예외의 경우를 커버하므로 경우의 수가 부모보다 훨씬 많다. // protected void a() throws Exception &#123;&#125;&#125; 인스턴스 메소드 &lt;-&gt; static 메소드가 불가능하다.또한 부모 클래스의 static 메소드를 자식 클래스에서 static 메소드로 선언하는 것은 각 클래스에 별개의 static 메소드를 선언하는 것이므로 오버라이딩은 아니다. 오버로딩 vs 오버라이딩 오버로딩(new): 기존에 없던 새로운 메소드(이름만 같은)를 선언하는 것 오버라이딩(modify): 상속받은 메소드를 수정하는 것 super vs thisthis가 인스턴스 자기 자신을 가리키는 참조 변수이듯, super는 상속받은 부모 인스턴스를 가리키는 참조 변수이다. 123456789101112131415161718class Parent &#123; int x = 10;&#125;class Child extends Parent &#123; void method() &#123; System.out.println(&quot;x=&quot;+x); // 10 System.out.println(&quot;this.x=&quot;+this.x); // 10 System.out.println(&quot;super.x=&quot;+super.x); // 10 &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); &#125;&#125; 읭? 뭐지? 싶으면 아래를 보자. 12345678910111213141516171819class Parent &#123; int x = 10;&#125;class Child extends Parent &#123; int x = 20; void method() &#123; System.out.println(&quot;x=&quot;+x); // 20 System.out.println(&quot;this.x=&quot;+this.x); // 20 System.out.println(&quot;super.x=&quot;+super.x); // 10 &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Child c = new Child(); c.method(); &#125;&#125; 매개변수와 인스턴스 변수를 구분할 때 this를 썼 듯이,부모 인스턴스 변수와 자식 인스턴스 변수를 구분할 때 super를 사용하면 유용하다.물론 변수 뿐만 아니라 메소드도 가능하다. 1234567891011121314public class Point &#123; int x, y; String getLocation() &#123; return &quot;x: &quot; + x + &quot;, y: &quot; + y; &#125;&#125;class Point3D extends Point &#123; int z; String getLocation() &#123; // return &quot;x: &quot; + x + &quot;, y: &quot; + y + &quot;, z: &quot; + z; return super.getLocation() + &quot;, z: &quot; + z; &#125;&#125; this() vs super()this()는 같은 클래스 내의 생성자를 호출하기 위해 사용하는 데 비해,super()는 부모 클래스의 생성자를 호출하기 위해 사용된다.this와 마찬가지로 super도 제일 첫 줄에 호출해야하는데자식 클래스가 부모 클래스의 멤버를 사용했을 수도 있으므로먼저 부모 클래스의 생성자를 호출해서 멤버들을 초기화시켜야한다.자식 생성자에서 다른 생성자(super()나 this())가 없는 경우에는 컴파일러가 자동으로 super()를 삽입한다. 123456789101112131415161718192021222324252627282930class Test &#123; public static void main(String[] args) &#123; Point3D p = new Point3D(1, 2, 3); System.out.println(p.x + &quot;, &quot; + p.y + &quot;, &quot; + p.z); // 1, 2, 3 &#125;&#125;// 아무것도 상속받지 않으면 컴파일러가 자동적으로 extends Object를 붙여준다.// 그래서 equals()나 toString() 같은 메소드는 모든 클래스에서 사용이 가능한 것이다.public class Point &#123; int x, y; Point(int x, int y) &#123; // super(); // 여기에도 마찬가지로 다른 생성자(this()나 super())가 없으므로 자동으로 super()가 삽입된다. // 아마 최상위 부모인 Object까지 타고 가지 않을까 싶다. this.x = x; this.y = y; &#125;&#125;class Point3D extends Point &#123; int z; Point3D(int x, int y, int z) &#123; // super()가 자동으로 삽입되지만 부모 클래스에는 Point() 생성자는 없고 Point(int x, int y) 생성자만 존재한다. // this.x = x; // this.y = y; super(x, y); this.z = z; &#125;&#125; 따라서 Point3D 클래스의 인스턴스의 생성 순서는 다음과 같다. Point3D(int x, int y, int z) Point(int x, int y) Object() 패키지와 클래스클래스: 물리적으로 하나의 파일(*.class)패키지: 물리적으로 하나의 디렉토리java.lang.String -&gt; java 패키지(디렉토리) 안에 lang 패키지(디렉토리) 안에 String 클래스(파일)패키지(디렉토리)가 다르면 클래스(파일)명은 같아도 된다. 모든 클래스는 반드시 패키지 안에 속해야하며 패키지를 명시하지 않으면 default package로 같은 패키지 안에 속하게 된다. importimport 문은 다른 패키지에 있는 클래스를 사용할 때 패키지 명을 붙이지 않고 사용할 수 있게 해준다. 123456789import java.util.Scanner;public class Test2 &#123; java.util.Scanner sc = new java.util.Scanner(System.in); &#125;class Test4 &#123; Scanner sc = new Scanner(System.in);&#125; import 문을 많이 쓰거나 import java.util.* 처럼 *을 썼다고 해서 실행할 때 퍼포먼스 상 차이는 없다.단지 컴파일 시간이 조금 더 오래 걸릴 뿐이다.하지만 *을 쓰면 어떤 패키지의 클래스인지 구분하기 어려울 때가 있다.또한 *은 클래스에만 매칭되지 하위 패키지까지 매칭되는 것은 아니다. 123// 이렇게 하면 java 패키지의 클래스만 매칭되지 // java 패키지 내부에 있는 util 패키지까지 import 되는 것은 아니다. import java.*; 같은 패키지 내의 클래스들은 import 없이도 사용이 가능하다! 또한 System이나 String 클래스는 어떻게 패키지를 import하지 않고도 사용이 가능했던 걸까?같은 패키지 내의 클래스는 import 없이 사용 가능하다는데 그럼 모든 패키지에는 System이나 String 과 관련된 패키지가 삽입된 걸까? 123// 컴파일러가 자동적으로 아래와 같은 import 문을 삽입해주기 때문이다.// 해당 패키지의 클래스들은 매우 빈번하게 사용하기 때문이다.import java.lang.*; static import 문import를 하면 패키지명을 생략할 수 있듯이static 키워드를 사용하면 클래스명을 생략할 수 있다.단 export 한 녀석은 public static이어야한다. 1234567891011import static java.lang.System.out;import static java.lang.Math.random;// 아래와 같이 하면 Math 클래스의 모든 public static 메소드(random, ceil, abs 등등)에서 Math 클래스를 생략 가능하다. // import static java.lang.Math.*;class Test2 &#123; public static void main(String[] args) &#123; // System과 Math가 생략이 가능해졌다. out.println(random()); &#125;&#125; 그냥 import는 package.*로 해서 모든 클래스들을 불러와서 패키지 명을 생략가능하게 했다면static import는 package.class.*로 해서 클래스 내의 모든 멤버를 불러와서 클래스 명을 생략 가능하게 했다고 알아두면 될 것 같다. 클래스 멤버 vs 인스턴스 멤버멤버: 변수, 메소드클래스 멤버는 static 멤버라고도 부른다.인스턴스 멤버를 사용하지 않는 인스턴스 메서드는 static 메서드로 바꾸는 걸 고려해보자. 다음과 같은 장점이 있다. 클래스가 메모리에 로드될 때 단 한번만 수행된다. 인스턴스를 생성하지 않고 호출이 가능하다. 더 편리하고 속도도 더 빠르다. final 변수 -&gt; 상수로 만들어버림. 메소드 -&gt; 오버라이딩이 불가능해짐. 클래스 -&gt; 상속받지 못하는 클래스가 됨. 예외로 인스턴스 변수는 상수로 선언만 했을 때는 생성자 함수에서 초기화가 가능하다.그 이유는 생성자 함수에서 초기화가 불가능하다면 모든 인스턴스마다 같은 인스턴스 상수를 갖게 될 것이기 때문이다.인스턴스 상수도 일단은 인스턴스 변수이니 인스턴스마다 다른 값을 가져야 의미가 있는 것이지 다 같은 값을 가지면 static 변수와 큰 차이점이 없게 된다. 1234567891011class Test2 &#123; final int x; final int y = 10; Test2() &#123; x = 10; // 초기화 되지 않은 상수를 초기화 시켜주지 않고 방치하면 오류가 발생한다. // y = 20; 초기화만 가능하지 재할당은 불가능하다. &#125; void a() &#123; // x = 22; 생성자 함수 이외에는 불가능하다. &#125;&#125; 접근 지정자 제어자 같은 클래스 같은 패키지 자식 클래스 전체 public O O O O protected O O O X (default) O O X X private O X X X 대상 사용 가능한 접근 지정자 클래스 public, (default) 멤버 public, protected, (default), private 지역변수 없음 접근 지정자를 사용하는 이유는 다음과 같다. 외부로부터 데이터를 보호하기 위해서 외부에는 불필요하고 내부적으로만 사용하는 부분들을 감추기 위해서이러한 것들을 캡슐화(encapsulation)이라고 부른다.데이터가 유효한 값을 유지하고, 비밀번호 같은 데이터를 외부에서 함부로 변경하지 못하게 하기 위함.이렇게 접근 범위를 축소해나가다 보면 테스트를 할 때도 다른 패키지들을 다 커버할 필요없이 해당 코드가 접근 가능한 부분들만 테스트하면 되니 유지보수 측면에서도 용이하다.또한 getter와 setter를 써서 변수의 유효성 검사도 할 수 있다. 12345678910111213141516171819202122public class Time &#123; private int hour; public int getHour() &#123; return hour; &#125; public void setHour(int hour) &#123; if(hour &gt; 0 &amp;&amp; hour &lt; 24) this.hour = hour; &#125;&#125;class TimeTest &#123; public static void main(String[] args) &#123; Time t = new Time(); // t.hour = 25; 접근지정자가 없으면 유효한 시간 값인지 검사할 방법이 없다. t.setHour(25); System.out.println(t.getHour()); // 0 t.setHour(11); System.out.println(t.getHour()); // 11 &#125;&#125; 또한 생성자에 접근 제어자를 사용하면 싱글톤 패턴을 구현할 수 있다.싱글톤: 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴. 123456789101112131415161718192021// 싱글톤 객체는 상속이 불가능하다.// 왜냐하면 자식 클래스에서 부모 클래스의 생성자 호출이 불가능하기 때문이다.// 따라서 명시적으로 final 키워드를 붙여서 상속이 불가능한 클래스라는 것을 표기해주는 게 좋다.public final class Singleton &#123; private static Singleton s = new Singleton(); private Singleton() &#123; System.out.println(11); &#125; public static Singleton getInstance() &#123; return s; &#125;&#125;class SingletonTest &#123; public static void main(String[] args) &#123; // Singleton s = new Singleton(); private이므로 다른 클래스에서 생성자에 접근 불가 // 클래스의 인스턴스를 얻으려면 이미 static 변수에 저장된 동일한 인스턴스만 불러오면 된다. Singleton s = Singleton.getInstance(); System.out.println(s); &#125;&#125; 또한 다음과 같은 주의사항이 있다. 메소드에 static과 abstract를 함께 사용할 수 없다.abstract는 몸통이 없는 불완전한 애이고, static은 클래스가 로딩되자마자 메모리에 적재되므로구현이 안 된 애를 메모리에 적재할 수는 없다. 클래스에도 abstract와 final을 함께 사용할 수 없다.abstract는 선언부만 던져주고 상속받아서 알아서 구현하라는 키워드인데final 키워드를 붙여 상속이 불가능하게 만들면 모순되는 말이다. 메소드에 abstract와 private를 함께 사용할 수 없다abstract는 선언부만 던져주고 상속받아서 알아서 구현하라는 키워드인데private 키워드는 그 상속받은 자식 클래스에서 조차 접근이 불가능하므로 모순되는 말이다. 메소드에 private과 final을 같이 사용할 필요는 없다.private인 메소드는 자식에서도 접근이 불가능하기 때문에 오버라이딩 될 수 없다. 이미 둘 다 같은 역할을 하기 때문에 하나만 사용하면 된다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"}]},{"title":"(자작) Hexo theme overdose starter","slug":"hexo-theme-overdose-starter","date":"2017-07-22T09:58:01.000Z","updated":"2022-10-30T08:42:16.647Z","comments":true,"path":"2017/07/22/hexo-theme-overdose-starter/","link":"","permalink":"https://perfectacle.github.io/2017/07/22/hexo-theme-overdose-starter/","excerpt":"깃헙 저장소로 바로가기 만든 계기기본적으로 헥소로 블로그 테마를 얹히는 것은 크게 어렵지 않다.하지만 적용한 테마를 깃헙에 올리고 다른 컴퓨터에서 다운받으려고 하면 참담한 결과를 맞이하게 된다.","text":"깃헙 저장소로 바로가기 만든 계기기본적으로 헥소로 블로그 테마를 얹히는 것은 크게 어렵지 않다.하지만 적용한 테마를 깃헙에 올리고 다른 컴퓨터에서 다운받으려고 하면 참담한 결과를 맞이하게 된다. 이유는 다음 스크린샷을 보면 알게 된다. 이러한 문제점은 모든 테마에서 발생하고 있으며 .git 폴더를 삭제하면 해결되는 문제이다.하지만 이미 컴퓨터를 포맷한 이후라면 여태까지 커스터마이징한 내역을 복구가 불가능할 것이다. (지못미 ㅠㅠ)물론 .gitignore도 삭제해야 우리가 여태까지 테마를 커스터마이징한 설정 파일인 _config.yml까지 형상관리가 가능하게 된다. overdose 테마의 문제점일단 한국인이 만들었고, 테마도 깔끔하다는 점은 굉장히 높게 평가할만 하다.하지만 다음과 같은 문제점이 존재한다. overdose에서 사용하는 패키지 중에 Node 8을 지원하지 않는 패키지가 있는데 명시돼있지 않다! (Node 7 버전 이하만 사용 가능한 테마이다.) 또한 테마를 설치하고 테마의 디렉토리로 이동해서 항상 아래 명령어를 입력해주어야한다.(packge.json 참조) 1npm run clone 해당 명령어는 다음과 같은 역할을 한다. https://github.com/spoqa/spoqa-han-sans 저장소를 source&#x2F;libs&#x2F;spoqa-han-sans 폴더로 클론한다.이 과정이 제일 문제가 많다. 해당 저장소를 가보면 Original과 VFB_FILES 디렉토리를 보면 폰트 개발자나 관심있을 법한 폰트 관련한 파일들이 존재한다.우리에게 필요한 것은 웹폰트와 css 파일이 전부인데 쓸 데 없는 파일까지 클론을 받게 되는 것이다.뭐 이게 무슨 대수냐고 볼 수도 있는데 두 디렉토리의 용량이 각각 238MiB와 195MiB에 달한다.테마의 국제화를 겨냥한 것인지 일본어 폰트까지 제공해주는 테마에서 이렇게 큰 용량은 인터넷 속도가 빠른 한국에서도 부담이 될 수 밖에 없는 용량이다. https://github.com/hyunseob/noto-sans-kr 저장소를 source&#x2F;libs&#x2F;noto-sans-kr 폴더로 클론한다.이 과정에서는 2MiB 정도의 데이터만 다운받기 때문에 큰 시간은 소요되지 않는다. 하지만 위 과정에도 역시나 문제는 존재한다. 이유는 바로 클론을 받았기 때문에 해당 디렉토리 내에도 .git 디렉토리가 존재한다.따라서 .git 디렉토리를 지워주고 다시 올려야 나중에 클론할 때도 폰트 파일까지 정상적으로 받아오게 된다.물론 폰트파일만 400MiB가 넘을테지만… 아마 최신의 폰트를 제공하고자 해당 저장소의 내용을 내포하고 있는 게 아니라 클론시키게 하다보니 이런 문제점이 발생하는 것 같다.하지만 해당 폰트는 CJK(중국, 일본, 한국) 계열에서나 쓸 법한 폰트지 그 이외의 국가에서는 사용하지 않을 법 하므로 필수적으로 설치하지 않게 한 것은 높은 점수를 줄만하다. 그래서 어떻게 해결했나? overdose 테마가 저장소에 올라가지 않던 문제테마를 커스터마이징한 내역을 내포하게 끔 하다보니 내가 작업한 현 시점의 overdose 최신 테마를 stater 저장소에 추가하였다.v0.2.8이 최신이지만, 내가 업데이트하지 않는 한 해당 테마의 최신버전을 따라서 업데이트가 되긴 힘들 것이다. spoqa-han-sans 폰트의 용량이 400MiB가 넘어가던 문제이건 최소한으로 용량을 줄이고자 웹폰트(*.ttf 제외, 용량이 커서…)와 css 파일만 따로 뺀 저장소를 한국어, 일본어 버전으로 만들었다.이것도 내가 spoqa-han-sans의 업데이트에 발맞춰 갱신하지 않는 이상은 해당 버전과 발맞춰 따라가기가 힘들 것이다. 설치한 폰트가 저장소에 올라가지 않던 문제이 문제는 클론 받는 대신에 그냥 저장소 자체에 폰트 파일을 내장하면 되지만 그렇게 되면 두 가지 문제점이 존재한다. 폰트를 최신 버전이 아닌 내가 저장소에 추가한 시점의 폰트만 사용이 가능하다. (그렇다고 해서 내가 폰트 파일을 계속 업데이트 할 지는 모르겠지만…) CJK 계열이 아닌 다른 국가에서도 해당 폰트를 필수로 설치해야한다. (용량이 20MiB에 달한다. 일어만 16MiB…) 따라서 해당 문제는 클론을 받되 해당 디렉토리의 .git을 삭제하는 단계를 거치도록 하였다.물론 명령어로 해결하면 되지만, 윈도우 유저와 Mac 폴더 삭제부터 명령어 차이가 나기 때문에(npm scripts에서 구분은 불가능한 걸로 알고 있다.)node에서 지우도록 rm-git.js라는 파일을 만들었다. 클론이 끝난 이 후에 이 파일을 실행하게 된다. 또한 폰트 설치 옵션을 다음과 같이 세분화하였다.왜냐하면 noto-sans-kr이나 spoqa-han-sans-kr은 각각 2MiB 남짓이라 크게 부담되지 않을 수 있는데,spoqa-han-sans-jp는 한자 때문인지 16MiB에 달해 부담이 될만한 용량이라 각각 나눠놨다. noto-sans-kr spoqa-han-sans-kr spoqa-han-sans-jp 한국어 폰트(noto-sans-kr, spoqa-han-sans-kr), Spoqa 폰트(spoqa-han-sans-kr, spoqa-han-sans-jp), 모든 폰트(noto-sans-kr, spoqa-han-sans-kr, spoqa-han-sans-jp) 추가된 사항 정적인 html 파일들만 버전관리가 되는 문제 기존 헥소 블로그에는 위와 같은 고질적인 문제가 존재한다.따라서 나는 이러한 문제를 해결하고자 과거에는 md나 기타 파일들을 관리하는 저장소를 따로 팠었는데 그냥 브랜치를 하나 파서 하나의 저장소에서 관리하게끔 하였다.그리고 새로 만든 브랜치를 default 브랜치로 정해놓으면 더 편하다. 포트폴리오를 블로그 위에 얹기원래 깃헙 페이지는 블로그가 메인이 아니라 정적 페이지를 서비스하는 게 메인인 것으로 알고 있다. (아닌가…?)그럼 블로그 위에 포트폴리오도 얹을 수 있다는 발상이 떠오르게 된다. 물론 포트폴리오는 웹서버나 DB를 사용하지 않는 동적인 페이지만 가능하다. (예를 들면 홈페이지나 웹 어플리케이션)이 디렉토리에 있는 파일들은 아래와 같이 접근이 가능하다. SEO 친화적으로 만들기(검색 엔진에 노출 잘 되게 만들기) hexo-generator-seo-friendly-sitemap을 이용하여 사이트맵 만들기. hexo-generator-feed을 이용하여 RSS Feed를 만들기. hexo-autonofollow를 이용하여 크롤러를 위해 외부 링크에는 nofollow 속성이 달리게 끔 하기. 대표 URL(선호 URL)을 지정해주는 canonical 속성 추가하기. 남은 과제overdose 테마의 컨트리뷰터가 되어 이렇게 스타터 저장소를 만들 게 아니라근본적인 문제를 해결하고자 해당 저장소에 pull request를 몇 개 날려봐야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://perfectacle.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://perfectacle.github.io/tags/hexo/"},{"name":"starter","slug":"starter","permalink":"https://perfectacle.github.io/tags/starter/"}]},{"title":"(JS) 문자, 단어, 동음이의어 갯수 세기","slug":"js-count-char-word","date":"2017-07-18T23:14:51.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/07/18/js-count-char-word/","link":"","permalink":"https://perfectacle.github.io/2017/07/18/js-count-char-word/","excerpt":"웰 컴 투 정규표현식 문자 &amp; 단어 세기 1234567891011const str =`반응형웹, 반응형 웹, Responsive, responsive web 웹표준웹표준, 웹 표준, Web Standard, web Standard`;const countChar = (char, str) =&gt; &#123; const matchedChars = str.match(new RegExp(char, &#x27;gmi&#x27;)); return matchedChars ? matchedChars.length : 0;&#125;;console.log(countChar(&#x27;웹&#x27;, str)); // 5console.log(countChar(&#x27;웹표준&#x27;, str)); // 2 동음이의어 세기","text":"웰 컴 투 정규표현식 문자 &amp; 단어 세기 1234567891011const str =`반응형웹, 반응형 웹, Responsive, responsive web 웹표준웹표준, 웹 표준, Web Standard, web Standard`;const countChar = (char, str) =&gt; &#123; const matchedChars = str.match(new RegExp(char, &#x27;gmi&#x27;)); return matchedChars ? matchedChars.length : 0;&#125;;console.log(countChar(&#x27;웹&#x27;, str)); // 5console.log(countChar(&#x27;웹표준&#x27;, str)); // 2 동음이의어 세기 123456789101112131415161718let str =`반응형웹, 반응형 웹, Responsive, responsive web 웹표준웹표준, 웹 표준, Web Standard, web Standard`;const homonym = [&#x27;웹 표준&#x27;, &#x27;웹표준&#x27;, &#x27;Web Standard&#x27;];const countHomonym = (homonym, str) =&gt; &#123; let cnt = 0; for(const word of homonym) &#123; const regExp = new RegExp(word, &#x27;gmi&#x27;); const matchedWords = str.match(regExp); if(matchedWords) cnt += matchedWords.length; &#125; return cnt;&#125;;console.log(countHomonym(homonym, str));","categories":[],"tags":[]},{"title":"(후기) 키워드 크롤러를 만들고 나서...","slug":"keyword-crawler-review","date":"2017-07-18T15:34:38.000Z","updated":"2022-10-30T08:42:16.735Z","comments":true,"path":"2017/07/18/keyword-crawler-review/","link":"","permalink":"https://perfectacle.github.io/2017/07/18/keyword-crawler-review/","excerpt":"프로젝트로 바로가기 왜 만들었나?수작업을 줄여보자.과거 어떤 사람이 프론트 엔드 개발자 채용 공고에서 직접 수집한 키워드를 빈도수 별로 모은 자료를 보여준 적이 있다.이후에 크롤러의 존재에 대해 알고 나서 물어보니 수작업으로 했다고 한다. (그렇기 때문에 신뢰도가 좀 더 높은 것 같다.)이런 수작업(노가다성)을 어떻게 하면 줄일 수 있을까 고민을 하면서 만들어보고 싶다는 막연한 생각만 가지고 있었다.","text":"프로젝트로 바로가기 왜 만들었나?수작업을 줄여보자.과거 어떤 사람이 프론트 엔드 개발자 채용 공고에서 직접 수집한 키워드를 빈도수 별로 모은 자료를 보여준 적이 있다.이후에 크롤러의 존재에 대해 알고 나서 물어보니 수작업으로 했다고 한다. (그렇기 때문에 신뢰도가 좀 더 높은 것 같다.)이런 수작업(노가다성)을 어떻게 하면 줄일 수 있을까 고민을 하면서 만들어보고 싶다는 막연한 생각만 가지고 있었다. 백엔드 개발자가 되려면 뭘 공부해야하는지 알고 싶었다.작년부터 같은 고민을 했지만 백엔드 개발자가 되고 싶었다. HTML&#x2F;CSS를 만지는 시간은 행복하지 않았고,오로지 자바스크립트 하나 때문에 프론트 엔드 개발 공부를 계속 했고, 쉽게 쉽게 취업하자는 생각에 프론트 엔드 개발자로 취업을 하였다.(프론트 엔드 개발자로 취직하는 게 쉽다는 게 아니라 내 기준에서 프론트 엔드 개발 공부만 1년 가까이 했기 때문에 백엔드보다 더 쉽다는 뜻이다.)하지만 작업하면서 역시나 행복하지 않았다. 그래서 그런지 작업 속도도 느리고, 내 코드 자체에 만족하지 못했다.백엔드도 직접 경험해본 건 아니어서 재미없다고 생각할지 모르겠지만 후회하더라도 직접 경험 해보고 후회하고 싶었다.다른 사람들은 목표로 정한 회사가 있느냐고 물었지만, 나는 그냥 개발이 중심이고, 대우받는 그러한 환경에서 작업을 한다면 다른 건 크게 신경쓰지 않는 타입이다.어찌보면 어리석고 철이 덜 들은 건지 모르겠지만 개발 이외에는 하기가 싫다는 생각이 들었다. (물론 고쳐야할 생각이다.)따라서 일단은 회사를 목표로 하기 보다는 여러 기업에서 백엔드 개발자라면 어떤 걸 알고 있어야하는지 알아내는 게 중요했다.최대한 많은 회사에서 요구하는 것들부터 집중적으로 배워나가면 된다고 생각했기 때문이다. 좋았던 점배웠던 걸 써먹을 수 있었다.자바스크립트와 Node.js를 이용한 웹 크롤링 테크닉란 책으로 스터디를 한 적이 있었다.책의 구성은 큰 덩어리 덩어리로 나눠져 있지만, 그 내부의 작은 덩어리로 봤을 때는 되게 비슷한 내용들끼리 묶여져있어서스터디를 할 때도 계속 비슷한 예제 타이핑하고 실행해보고 하느라 다소 지루한 감이 없지 않았고, 후딱 끝내버리자는 의견도 나왔었다.책 안의 내용 자체는 좋았지만 ‘이걸 일일이 타이핑하고 실행해봐야하나’라는 의문이 들 정도였다.그래도 해당 주제로 스터디를 한 바람에 크롤러, 헤드리스 브라우저, 형태소 분석기 등등 어떤 키워드로 검색해야할지,샘플 코드는 뭘 참조해야할지에 대해 힌트를 많이 알고 있었기 때문에 크롤러를 만들어보는데 훨씬 수월하였다. 비동기 작업을 동기식으로 작성해 볼 기회가 많았다. 무한 스크롤을 하기 위해서는 순차적으로 스크롤을 아래로 계속 내려야하는 점. 채용 공고 하나 들어가서 수집하고 다시 다른 공고 들어가서 수집하고 순차적으로 이뤄져야한다는 점. 위 코드들을 작성하면서 async&#x2F;await를 제대로 써본 것 같다.그러면서 Async&#x2F;Await는 배열 표준 메소드에서 작동하지 않는다.라는 점도 알게 되었다. 아쉬웠던 점타입스크립트 넘나 어려운 것맨 처음에는 타입스크립트를 도입하려고 했다.하지만 팬텀 자체도 phantomjs에서 phantomjs-prebuilt라고 이름을 바꿀 만큼 변화가 많았는데phantomjs에 대한 d.ts는 있었는데 phantomjs-prebuilt에 대한 d.ts는 없었다.새로 만들자니 시간도 오래 걸릴 것 같고… 이거 때문에 너무 시간을 지체하는 느낌이 많이 들었다.약 만 하루동안 타입스크립트를 가지고 뻘짓을 해보다 과감히 포기하였다.나중에… 나중에는 기필코 타입스크립트를 다른 라이브러리들과 함께 써봐야겠다. 테스트 코드의 부재역시나 테스트 코드를 작성하는 건 감을 잡기 어렵다.테스트 코드를 작성하는 것보다 무엇을 테스트 해야할지를 감을 못 잡겠다.그러다보니 그냥 코드만 계속 작성하고 결국 테스트 코드는 작성하질 못했다…하… 나 혼자 스스로 능동적인 공부를 해 본 경험이 적다보니 역시 이런 쪽은 쥐약이다 ㅠㅠ… 외국어 형태소 분석의 부재mecab-ko-dic에는 한국어 단어만 들어가있어서 외국어의 형태소 분석이 되질 않는다.따라서 이 예제는 외국어로 작성된 채용 공고에는 부적합하다.형태소 분석을 두 번 돌려야하는 것 같은데… 넘나 어려워보여서 시도도 하지 않았다 ㅜㅜ하지만 역으로 국내 쪽 채용 공고는 기술 스택들만 영어로 기재하는 경우가 있어서 오히려 신뢰도가 높다는 장점도 존재한다. 이상한 키워드까지 분류된다형태소 별로 분석하다보니 구두점이나 쓸 데 없는 기호들, 을&#x2F;를과 같은 조사 등등은 빠져서 참 좋다.명사만 필터링해서 좋긴 좋은데… 아래와 같은 단점이 존재한다. 웹 표준 이라는 키워드가 있으면 웹 따로 표준 따로 분류해버린다. 프론트 엔드 개발 같은 경우에도 세 가지를 따로 따로 분류해버린다. 기업이 채용 공고에 기술 스택만 올리는 게 아니다보니 관련 없는 단어들까지 분류돼서 나온다. 아직 실력이 많이 모자라서 일일이 수작업으로 해야하는데 손이 너무 많이 가는 작업이라 엄두도 못 내고 있다. 차트나 그래프로 표시하기에 부적합하다.이상한 키워드들이 너무 많이 뽑혀져 나오다보니… 차트나 그래프로 표시하면 알아보기 힘든 경우가 굉장히 많다.화면은 한정적인데 키워드들이 너무 많아서 렉이 걸리거나 마우스를 올려도 원하는 곳으로 올리기 힘든 경우도 있고…그렇다고 표로 표시하기에는 너무 길어지고 이쁘지도 않아서… 이 문제점은 확실히 이상한 키워드들을 전부 필터링해야 어느정도 해결이 될 것 같다. 특정 사이트에 한정적이다.이 예제만 하더라도 페이지네이션 페이지에는 부적합하고 무한 스크론 페이지에만 적합하다.또 내가 만든 원티드 크롤러만 하더라도 원티드의 마크업 구조가 달라지면 해당 내용을 제대로 크롤링하지 못할 수도 있다.원래 크롤러가 그런 건지 모르겠지만… 이거는 도저히 내 머릿 속에서는 해결이 불가능한 난제로 남을 것 같다. 남은 숙제들서버 구현하기매일 매일 정보를 크롤링해서 업데이트 하려면 24시간 켜져있는 서버 혹은 수동으로 매일 매일 해줘야한다.하지만 수동으로 하는 것은 비효율적이고 서버를 한 대 구동해야하는데 집에 남아있는 컴퓨터가 없다.이를 위해서 한 번 라즈베리 파이를 사서 리눅스도 올려보고, 웹 서버도 올려보고 이것저것 해보고 싶다.좀 더 검토해보고 라즈베리 파이를 사서 직접 서버를 구현해보면서 백엔드의 이것 저것을 공부해봐야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"review","slug":"review","permalink":"https://perfectacle.github.io/tags/review/"}]},{"title":"(자작) 키워드 크롤러","slug":"keyword-crawler","date":"2017-07-18T13:59:43.000Z","updated":"2022-10-30T08:42:16.735Z","comments":true,"path":"2017/07/18/keyword-crawler/","link":"","permalink":"https://perfectacle.github.io/2017/07/18/keyword-crawler/","excerpt":"소스 코드 보러가기사이트에서 원하는 내용만 수집해오는 크롤러.더 나아가 mecab-ko와 같은 형태소 분석기를 사용하면 키워드 별로 분류하고 빈도수도 알아낼 수 있다.무한 스크롤 페이지에 적합하게 만들었고, 페이지네이션 사이트를 크롤링 하려면 직접 구현해야한다.원티드의 프론트 개발 지원 자격을 크롤링 하여 키워드 별로 분류 후 나타낸 그래프 설치1npm i 형태소 분석기(한국어 버전)","text":"소스 코드 보러가기사이트에서 원하는 내용만 수집해오는 크롤러.더 나아가 mecab-ko와 같은 형태소 분석기를 사용하면 키워드 별로 분류하고 빈도수도 알아낼 수 있다.무한 스크롤 페이지에 적합하게 만들었고, 페이지네이션 사이트를 크롤링 하려면 직접 구현해야한다.원티드의 프론트 개발 지원 자격을 크롤링 하여 키워드 별로 분류 후 나타낸 그래프 설치1npm i 형태소 분석기(한국어 버전) mecab-ko mecab-ko-dic 개발하기첫 번째로 태스크 러너를 실행해야한다. (gulp) eslint babel 1npm run dev 두 가지 태스크를 먼저 수행한 후에 ES5로 트랜스파일 된 파일을 실행하면 된다.혹시 다른 태스크를 실행하고 싶다면 gulpfile.js 를 수정한 후 package.json의 npm script를 수정하거나npm v5.2.0 이상이라면 npx를 사용하자. 1npx gulp TASK_NAME 두 번째로 크롤러 코드를 작성해야한다. 크롤러 코드 (&#x2F;src&#x2F;crawlContents.js) 크롤링한 내용을 형태소로 분석하기 위한 코드(&#x2F;src&#x2F;morphemeParser.js) 형태소로 분류한 단어들의 빈도수를 구하기 위한 코드(&#x2F;src&#x2F;countKeyword.js) 이 프로젝트는 완성본이 아니기 때문에 위 코드들을 구현해줘야한다.실제로 구현된 내용은 페이지의 무한 스크롤 컨텐츠를 모두 로딩하는 것 밖에 없다.위 코드들을 어떻게 작성해야할지 감이 잡히지 않는 사람들은 demo 디렉토리에 있는 예제를 보자.해당 예제는 구인구직 사이트인 원티드에서 프론트 엔드 개발자의 지원 자격을 키워드 별로 뽑아내는 예제이다. 세 번째로 크롤러를 구동하자.1npm start 만약 다른 크롤러를 구동하고 싶다면 package.json의 npm script를 수정하거나npm v5.2.0 이상이라면 npx를 사용하자. 1npx phantomjs ANOTHER_CRAWLER.js 데모 크롤러 구동해보기1npm test 무한 스크롤 콘텐츠를 모두 로딩하고 100 여 개가 넘는 채용 공고를 크롤링 하기 때문에 시간이 다소 걸린다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://perfectacle.github.io/tags/node-js/"},{"name":"crawler","slug":"crawler","permalink":"https://perfectacle.github.io/tags/crawler/"},{"name":"phantomjs","slug":"phantomjs","permalink":"https://perfectacle.github.io/tags/phantomjs/"},{"name":"mecab","slug":"mecab","permalink":"https://perfectacle.github.io/tags/mecab/"}]},{"title":"(ES2015+) Async/Await는 배열 표준 메소드에서 작동하지 않는다.","slug":"es8-async-fact","date":"2017-07-17T20:00:04.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2017/07/17/es8-async-fact/","link":"","permalink":"https://perfectacle.github.io/2017/07/17/es8-async-fact/","excerpt":"1234567891011const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 제대로 작동하질 않는다.nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;);&#125;); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 역시 마찬가지로 제대로 작동하지 않는다.(async() =&gt; &#123; nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;);&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 이터레이터에서는 잘 작동한다.(async() =&gt; &#123; for(const num of nums) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 물론 일반 반복문에서도 잘 작동한다.(async() =&gt; &#123; for(let i=0, len=nums.length; i&lt;len; i++) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(nums[i]); res(); &#125;, 1000); &#125;); &#125;&#125;)();","text":"1234567891011const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 제대로 작동하질 않는다.nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;);&#125;); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 역시 마찬가지로 제대로 작동하지 않는다.(async() =&gt; &#123; nums.forEach(async (num) =&gt; &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;);&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 이터레이터에서는 잘 작동한다.(async() =&gt; &#123; for(const num of nums) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(num); res(); &#125;, 1000); &#125;); &#125;&#125;)(); 12345678910111213const nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];// 물론 일반 반복문에서도 잘 작동한다.(async() =&gt; &#123; for(let i=0, len=nums.length; i&lt;len; i++) &#123; await new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(nums[i]); res(); &#125;, 1000); &#125;); &#125;&#125;)(); 아마 실행 주도권이 배열 표준 메소드 내부의 콜백 함수가 가지게 되어서 그런 게 아닐까?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"},{"name":"ES2015+","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"async","slug":"async","permalink":"https://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://perfectacle.github.io/tags/await/"}]},{"title":"(자알쓰) 변수","slug":"js-011-variable","date":"2017-07-01T14:39:27.000Z","updated":"2022-10-30T08:42:16.683Z","comments":true,"path":"2017/07/01/js-011-variable/","link":"","permalink":"https://perfectacle.github.io/2017/07/01/js-011-variable/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 한 번째 시리즈는 변수를 주제로 진행하겠다. 변수란?이번 주제는 정재남 님의 자바스크립트 세미나를 듣고 해당 자료를 토대로 내 맘대로 해석한 포스트이다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 한 번째 시리즈는 변수를 주제로 진행하겠다. 변수란?이번 주제는 정재남 님의 자바스크립트 세미나를 듣고 해당 자료를 토대로 내 맘대로 해석한 포스트이다. 책을 보다보면 변수는 그냥 값들을 담아놓는 상자 정도로 설명해놓는다.과연 이게 변수의 끝일까? 정말 변수는 이렇게 작동할까? 뜬금없이 RAM이 왜 등장했냐 하면…컴퓨터의 프로그램이 실행되려면 모두 RAM에 해당 소스가 존재해야한다.그 말은 RAM에 우리가 짠 자바스크립트 소스, 변수가 어딘가에 존재한다는 것이다.하지만 RAM은 Random Access Memory, 즉 랜덤하게 데이터가 들어가게 된다.var a &#x3D; 2; 라고 해서 어디에 우리의 데이터가 들어가있는지 알지 못한다.var a &#x3D; 2; 라고 하면 2라는 값이 저장된 메모리 주소가 어딘가 있을 거다.그 때 그 주소가 0x1234라고 가정했을 때 변수가 많다보니 모든 변수의 메모리 주소를 외우는 것은 불가능하다.따라서 해당 메모리 주소에 이름을 붙인 것이 바로 변수이다.마치 네이버의 ip 주소(125.209.222.141)를 다 외우지 못해 www.naver.com으로 치는 격이다.ip 주소가 메모리 주소고, 도메인 네임이 바로 변수라고 보면 될 것 같다. 변수의 초기화 과정이는 호이스팅과 묶어서 보면 좋을 것 같다.아래와 같은 코드가 있다고 치자. 123456var a = 2;console.log(a); // 2console.log(b); // undefinedvar b = a;console.log(b); // 2console.log(c); // ReferenceError: c is not defined 호이스팅 때문에 위 코드는 아래와 같이 바뀌게 될 것이다. 12var a;var b; 그럼 위 과정과 메모리를 엮어서 한 번 봐보자.a와 b는 메모리 주소에 이름을 붙인 것이고, 실제 데이터는 해당 메모리 주소에 저장이 된다. a b 0x1234 0x1235 0x1234 0x1235 123var a;var b;a = 2; 그리고 3번 라인에 의해 아래와 같이 바뀐다. a b 0x1234 0x1235 0x1234 0x1235 2 12345678var a;var b;a = 2;console.log(a); // 2console.log(b); // undefinedb = a;console.log(b); // 2console.log(c); // ReferenceError: c is not defined 그리고 6번 라인에 의해 아래와 같이 바뀐다. a b 0x1234 0x1235 0x1234 0x1235 2 2 원시값은 위와 같이 메모리의 새로운 영역에 값을 ‘복사’하는 형태로 가고 있다.그럼 참조 타입인 객체들을 어떻게 만들어지는지 한번 살펴보자. 123456var a = &#123; name: &#x27;양권성&#x27;, friends: [&#x27;양간장&#x27;, &#x27;간장냥&#x27;], age: 25&#125;;var b = a; 그럼 이제 위 데이터들을 하나씩 까보자. 12var a;var b; 먼저 호이스팅에 의해 아래와 같이 메모리를 잡을 것이다. a b 0x1234 0x1235 0x1234 0x1235 1234567var a;var b;a = &#123; name: &#x27;양권성&#x27;, friends: [&#x27;양간장&#x27;, &#x27;간장냥&#x27;], age: 25&#125;; 그리고 3번에 의해 아래와 같이 바뀔 것이다. a b 0x1234 0x1235 0x1236 0x1237 0x1238 0x1239 0x1240 0x1234 0x1235 0x1236 { name: 0x1237, friends: 0x1238, age: 0x1239 } 양권성 0x1240 25 [‘양간장’, ‘간장냥’] 0x1236의 객체를 보면 name, friends, age라는 키에 해당하는 값들도 어딘가 메모리에 적재가 돼있을 것이다. 그 메모리 주소에 대한 이름을 키라고 보면 될 것 같다. 그리고 friends는 원시값이 아니고 참조값이기 때문에 해당 메모리 주소로 이동하면 또 메모리 주소가 있고, 그 메모리 주소를 타고 가야 비로소 우리가 원하는 값이 있다. 12345678var a;var b;a = &#123; name: &#x27;양권성&#x27;, friends: [&#x27;양간장&#x27;, &#x27;간장냥&#x27;], age: 25&#125;;b = a; 마지막 라인에 의해 아래와 같은 결과가 나오게 된다. a b 0x1234 0x1235 0x1236 0x1237 0x1238 0x1239 0x1240 0x1234 0x1235 0x1236 0x1236 { name: 0x1237, friends: 0x1238, age: 0x1239 } 양권성 0x1240 25 [‘양간장’, ‘간장냥’] 객체는 거의 무한한 데이터를 담을 수 있으므로 복사보다는 참조하는 것이 메모리를 더 절약하기 때문인지 객체를 참조 타입으로 지정한 것 같다.역시 이런 기초 기반 지식들이 상당히 중요한 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"변수","slug":"변수","permalink":"https://perfectacle.github.io/tags/%EB%B3%80%EC%88%98/"}]},{"title":"(자알쓰) 자료형(객체)","slug":"js-010-data-type-object","date":"2017-07-01T13:14:58.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/07/01/js-010-data-type-object/","link":"","permalink":"https://perfectacle.github.io/2017/07/01/js-010-data-type-object/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 번째 시리즈는 자료형 중에 객체를 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 열 번째 시리즈는 자료형 중에 객체를 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자. 자바스크립트에서 자료형은 크게 두 가지로 나뉜다. 원시값 객체 하나 하나 파헤쳐보자. 객체(Object)객체는 다음과 같은 유형이 있다.이번 글에서는 해당 내용들은 다루지 않고, 객체의 특성에 대해서만 다루도록 하겠다. 객체 배열 함수 정규 표현식 날짜 컬렉션(ES6에서 생김) 기타 등등 그리고 이 객체에는 다음과 같은 특징이 있다. 변하는(Mutable) 값이다. 값으로써 비교하는 게 아니라 참조하는 주소로써 비교한다. typeof 연산자로 구분하기 어려운 경우가 많다. 프로퍼티의 추가가 가능하다. 12345678910111213141516171819var a = [1];var b = a;b.push(2);console.log(a); // [1, 2], 건드리지도 않은 a가 왜...?var c = &#123;&#125;;var d = &#123;&#125;;console.log(c === d); // false, 둘은 똑같은 값이 아닌가...?? console.log(typeof function()&#123;&#125;); // &#x27;function&#x27;console.log(typeof &#123;&#125;); // &#x27;object&#x27;console.log(typeof []); // &#x27;object&#x27;, 배열의 타입도 objectconsole.log(typeof /a/); // &#x27;object&#x27;, 정규 표현식의 타입도 objectconsole.log(typeof new Date()); // &#x27;object&#x27;, 날짜의 타입도 objectconsole.log(typeof new WeakSet()); // &#x27;object&#x27;, 컬렉션의 타입도 objectvar e = function()&#123;&#125;;e.asdf = &#x27;qwer&#x27;;console.log(e.asdf); // &#x27;qwer&#x27;, 함수도 객체이므로 프로퍼티의 추가가 가능하다. 참조 타입(Reference Type)1번과 2번의 특징과 같이 작동하는 이유는 객체는 참조 타입이기 때문이다.그럼 뭘 참조하느냐? 바로 메모리 주소를 말한다. 기본적으로 우리가 작성한 프로그램(그 안에 존재하는 모든 소스 코드 및 변수 등등)은 메모리에 있어야한다.메모리는 8GB 등등 다양한 용량을 가지고 있고 그 안에 우리의 변수가 여기 저기 산재돼있는 구조이다. 1234var a = 2;var b = a;var c = [1];var d = c; 이렇게 코드를 짰다고 하면 사실은 아래와 같다고 보면 된다.0x1234 와 같은 메모리 주소는 내가 임의로 지정한 것이다.절대로 저런 식으로 메모리가 생기지 않았고, 이해를 돕기 위해 쉽게 설명하고자 적은 거다. a b c d 0x1234 2 2 0x1234 0x1234 [1] 즉 변수 c와 d에 [1]이 직접 저장되는 게 아니라 배열은 객체이고, 객체는 참조 타입이므로 메모리의 주소가 각각 저장되는 것이다.메모리의 주소를 참조하는 형태가 바로 참조 타입니다. 그럼 아래와 같은 경우에 한 번 어떻게 값이 변하는지 보자. 123var a = [1];var b = a;b.push(2); 2번 라인까지 하면 아래와 같을 것이다. a b 0x1234 0x1234 0x1234 [1] 3번 라인에 의해서 다음과 같이 바뀌게 되는 것이다. a b 0x1234 0x1234 0x1234 [1, 2] 즉 b가 참조하고 있는 녀석과 a가 참조하고 있는 녀석이 같으니 b를 통해 바꿔도 a가 참조하는 녀석이 바뀌게 되는 격이다.하지만 아래와 같이 재할당을 하면 얘기는 달라진다. 123var a = [1];var b = a;b = [1, 2]; 2번 라인까지 하면 아래와 같을 것이다. a b 0x1234 0x1234 0x1234 [1] 3번 라인에 의해서 다음과 같이 바뀌게 되는 것이다. a b 0x1234 0x1235 0x1234 0x1235 [1] [1, 2] 새로 할당을 하게 되면 새로운 메모리 공간에 해당 값을 만들고, 해당 메모리 주소를 바라보게 만든다. 자료형 검출하기위 코드를 봤을 때 function을 제외하고 모든 객체가 object라는 문자열이 나왔다.그럼 각기 다른 데이터 타입들을 어떻게 구분할까?아래와 같이 하면 된다. 123456console.log(&#123;&#125;.toString() === &#x27;[object Object]&#x27;); // true, 객체 검출 성공console.log(Array.isArray([])); // true, 배열 검출 성공console.log(Object.prototype.toString.call(/a/) === &#x27;[object RegExp]&#x27;); // true, 정규표현식 검출 성공console.log(Object.prototype.toString.call(new Date()) === &#x27;[object Date]&#x27;); // true, 날짜 검출 성공console.log(new Map().toString() === &#x27;[object Map]&#x27;); // true, 컬렉션 검출 성공console.log(Math.toString() === &#x27;[object Math]&#x27;); // true, 컬렉션 검출 성공 얕은 복사? 깊은 복사?그렇담 참조 타입의 데이터를 동일한 메모리 주소를 참조하는 게 아니라 복사해서 새로운 메모리 공간에 할당하고 지지고 볶고 싶다면…?이런 걸 위해 자바스크립트에서는 참조 데이터의 복사가 가능하다.ES5는 아래 링크를 참조하자.직접 구현해본 JS 객체, 배열의 깊은 복사하는 방법 얕은 복사(Shallow Copy)배열의 복사를 진행해보자. 12345const a = [1, 2];const b = [...a];b.push(3);console.log(a); // [1, 2]console.log(b); // [1, 2, 3] 결과는 아래와 같다. a b 0x1234 0x1235 0x1234 0x1235 [1, 2] [1, 2, 3] 그럼 이번에는 객체를 복사해보자. 12345678const a = &#123;name: &#x27;양권성&#x27;&#125;;// 객체에 spread 연산자를 쓸 수 있게 해주는 것은 Stage-3 단계이다. // https://github.com/tc39/proposal-object-rest-spread// 따라서 바벨의 stage-3 preset이나 transform-object-rest-spread 플러그인을 사용하면 된다.const b = &#123;...a&#125;;b.age = 25;console.log(a); // &#123;name: &#x27;양권성&#x27;&#125;console.log(b); // &#123;name: &#x27;양권성&#x27;, age: 25&#125; 결과는 아래와 같다. a b 0x1234 0x1235 0x1234 0x1235 {name: ‘양권성’} {name: ‘양권성’, age: 25} 위의 데이터들을 참조 단계가 1단계 밖에 없었다.뎁스가 깊어진다면 어떻게 될까…? 123456const a = [1, [2]];const b = [...a];b.push(4);b[1].push(3);console.log(a); // [1, [2, 3]]console.log(b); // [1, [2, 3], 4] 참조 데이터 안에 참조 데이터가 있는 격이다.메모리를 까보면 아래와 같을 것이다. a b 0x1234 0x1235 0x1236 0x1234 0x1236 [1, 0x1235] [2, 3] [1, 0x1235, 4] 즉 뎁스가 한 단계만 깊어져도 수박 겉핥기 식으로 껍데기만 복사가 되는 것이다.그 속 알맹이는 재귀적으로 계속 타고 타고 들어가서 복사를 해줘야한다.이는 객체도 마찬가지다. 깊은 복사(Deep Copy)위 방식대로 얕은 복사를 진행하면 참조 단계가 한 뎁스만 깊어져도 제대로 된 복사가 이루어지지 않는 것을 알았다.그렇다면 그 안에 참조 데이터가 있는지 없는지 계속해서 얕은 복사를 재귀적으로 진행해나가는 걸 깊은 복사라고 한다.그럼 직접 깊은 복사를 구현해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 혹시 추후에 Array나 Object의 표준 메소드로 clone이 생길지 모르니 심볼을 통해 유니크한 값을 만들어서 쓰자.const symClone = Symbol(&#x27;clone&#x27;);Array.prototype[symClone] = function() &#123; // 배열의 얕은 복사(Shallow Copy)를 한 번 함. let copy = [...this]; // map 메소드는 원본 배열을 훼손시키지 않으므로 반환된 값을 원본 배열에 할당. copy = copy.map(v =&gt; &#123; // 현재 배열의 요소가 배열 또는 객체라면 // 그것들을 다시 얕은 복사하는 재귀함수를 호출. if(Array.isArray(v) || v.toString() === &#x27;[object Object]&#x27;) v = v[symClone](); // 리턴 값이 없다면 배열에 undefined가 들어가게 됨. return v; &#125;); return copy;&#125;;Object.prototype[symClone] = function() &#123; // 객체의 얕은 복사(Shallow Copy)를 한 번 함. let copy = &#123;...this&#125;; // 객체의 키 값들을 순회 for(const key of Object.keys(copy)) &#123; // 현재 배열의 요소가 배열 또는 객체라면 // 그것들을 다시 얕은 복사하는 재귀함수를 호출. if(Array.isArray(copy[key]) || copy[key].toString() === &#x27;[object Object]&#x27;) copy[key] = copy[key][symClone](); &#125; return copy;&#125;;// 무지하게 참조 뎁스가 복잡한 객체.const obj = &#123; name: &#x27;asdf&#x27;, arr: [ // 객체 안에 배열 1, 2, 3, [ // 객체 안에 배열 안에 배열 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체 age: 999 &#125; ] ]&#125;;const objClone = obj[symClone]();objClone.arr[2] = 4;objClone.arr[3].unshift(2);objClone.arr[3][4].qwer = &#x27;qwer&#x27;;// &#123;// name: &#x27;asdf&#x27;,// arr: [ // 객체 안에 배열// 1, 2, 4, [ // 객체 안에 배열 안에 배열// 2, 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체// age: 999,// qwer: &#x27;qwer&#x27;// &#125;// ]// ]// &#125;;console.log(objClone);// &#123; 원본 값은 전혀 바뀌지 않았다.// name: &#x27;asdf&#x27;,// arr: [ // 객체 안에 배열// 1, 2, 3, [ // 객체 안에 배열 안에 배열// 4, 5, 6, &#123; // 객체 안에 배열 안에 배열 안에 객체// age: 999// &#125;// ]// ]// &#125;;console.log(obj); symClone은 모든 참조 데이터를 순회하면서 재귀적으로 얕은 복사를 수행하는 함수이다.결국엔 모든 참조 데이터를 얕은 복사하면서 그 깊숙한 곳까지 타고 들어가기 때문에 깊은 복사라고 부르는 것이다.이것이야말로 진또배기 복사라고 할 수 있다.하지만 이런 깊은 복사는 계속해서 함수를 호출하는 재귀함수이므로 콜스택을 많이 만들어내는 등등의 문제로 인해 값비싼 비용을 치르게 된다.즉 느리다는 뜻이다. (체감 못하는 경우가 많을테지만)이를 위해 Immutable.js가 나오고 여기서는 Immutable 자료형인 List와 Map을 권장하는 바이다.좀 더 궁금한 사람은 Immutable.js 공식 사이트를 참고하도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"자료형","slug":"자료형","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"객체","slug":"객체","permalink":"https://perfectacle.github.io/tags/%EA%B0%9D%EC%B2%B4/"}]},{"title":"(자알쓰) 자료형(원시값)","slug":"js-009-data-type-primitive-value","date":"2017-07-01T09:53:29.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/07/01/js-009-data-type-primitive-value/","link":"","permalink":"https://perfectacle.github.io/2017/07/01/js-009-data-type-primitive-value/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 아홉 번째 시리즈는 자료형 중에 원시값을 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 아홉 번째 시리즈는 자료형 중에 원시값을 주제로 진행하겠다. 자료형0과 1로 이루어진 데이터를 메모리에서 꺼내서 써야하는데 어떻게 해석할지를 결정하는 유형.나는 위와 같이 이해하고 있는데 잘 이해가 가지 않는다면 그냥 넘어가도 무방하다.더 딥하게 알고 싶은 사람은 정적 타입의 언어(C, Java 등등)을 공부해보자. 자바스크립트에서 자료형은 크게 두 가지로 나뉜다. 원시값 객체 하나 하나 파헤쳐보자. 원시값(Primitive Value)원시값에는 6가지 유형이 있다. boolean number string null undefined Symbol(ES2015에서 새로 생김) 그리고 이 원시값에는 다음과 같은 특징이 있다. 불변(Immutable)하는 값이다. 값으로써 비교가 가능하다. (심볼을 제외하고) typeof 연산자를 쓰면 각자 고유한 타입을 내뱉는다. (typeof null을 제외하고) 너무나 당연한 소리를 하고 있어서 이게 무슨 특징인가 싶을 수 있다.하지만 다음 파트인 객체를 보고 나면 생각이 달라질 것이다. 1234567891011121314151617181920212223242526// 불변하는 값이다.var a = &#x27;a&#x27;;var b = a;b = &#x27;b&#x27;;console.log(a, b); // &#x27;a&#x27;, &#x27;b&#x27;// 값으로써 비교가 가능하다.console.log(false === !!0); // true// 하지만 항상 유니크한 값을 가지는 심볼은 값으로써 비교가 불가능하다.var c = Symbol(&#x27;c&#x27;);var d = Symbol(&#x27;c&#x27;);console.log(c === d); // false// Symbol.for는 심볼 레지스트리에 해당 키값의 심볼이 있다면 새로 만들지 않고 해당 값을 반환한다.var e = Symbol.for(&#x27;c&#x27;);var f = Symbol.for(&#x27;c&#x27;);console.log(e === f); // true// 모두 고유한 타입을 내뱉어서 타입을 구분짓기가 쉽다. console.log(typeof false); // &#x27;boolean&#x27;console.log(typeof 123); // &#x27;number&#x27;console.log(typeof &#x27;123&#x27;); // &#x27;string&#x27;console.log(typeof null); // &#x27;object&#x27;, 버그이다. 상단의 링크를 참조하자.console.log(typeof undefined); // &#x27;undefined&#x27;console.log(typeof Symbol()); // &#x27;symbol&#x27; 부울(Boolean)참&#x2F;거짓을 나타내는 자료형이다.주로 조건을 명시해야하는 경우에 많이 쓴다. 123456789var a = 1;var b = 2;if(a &gt; b) &#123; // 1. 조건문 console.log(123);&#125;for(var i=0; i&lt;10; i++) &#123; // 2. 반복문의 조건부 부분 console.log(i); // 0~9까지 출력하게 된다.&#125;var c = (a%2 === 1) ? 1 : 2; // 2. 삼항 연산자 형변환을 위해서는 다음과 같은 방법이 존재한다. 12345console.log(new Boolean(&#x27;&#x27;).valueOf()); // falseconsole.log(Boolean(&#x27;&#x27;)); // false// ! 연산자는 참을 거짓으로, 거짓을 참으로 바꿔주는 Not 연산자이다. // !으로 한 번 뒤집고 !으로 한번 더 뒤집어주면 원래의 참/거짓 값이 나오게 되는 원리다.console.log(!!&#x27;&#x27;); // false, 가장 짧아서 쓰기 간편해서 자주 쓴다. Falsy&#x2F;Truthy Valueboolean으로 형변환 했을 때 거짓으로 판명되는 값이 Falsy Value, 참으로 판명되는 값이 Truthy Value이다.아래의 경우를 제외하고 모두 Truthy Value이다.자바스크립트의 유연한 동적 타입의 특성이 여기서 드러나는 것 같다. 123456789101112console.log(!!0); // false, 숫자 0console.log(!!undefined); // false, undefinedconsole.log(!!null); // false, nullconsole.log(!!false); // false, boolean의 falseconsole.log(!!&#x27;&#x27;); // false, 빈 문자열(공백 아님, 쌍따옴표 아님)console.log(!!NaN); // false, 숫자 NaN(Not a Number)// 위 경우를 제외하고 모두 Truthy Valueconsole.log(!!12341234); // true, 0을 제외한 숫자console.log(!!&#x27; &#x27;); // true, 공백이라도 true로 인식console.log(!!&#123;&#125;); // true, 빈 개체라도 true로 인식console.log(!![]); // true 빈 배열이라도 true로 인식 문자열(String)다른 프로그래밍 언어에서 문자열은 기본 자료형에 속하지 않는다.C에서는 문자의 배열로 문자열을 다루며, 자바에서는 클래스로 다루고 있는데 자바스크립트에서는 기본 자료형에 속해있다.C에서 문자의 배열이라고 말하듯이 자바스크립트에서도 배열과 같이 사용이 가능하다. 12345678910111213141516171819// 쌍따옴표, 홑따옴표 개인의 기호에 맞게, 혹은 코딩 컨벤션에 맞게 사용하면 된다.var url = &#x27;https://perfectacle.github.io/&#x27;;// HTML 템플릿을 바인딩 할 때 HTML 템플릿은 쌍따옴표를 사용하므로 홑따옴표 사용을 주장하는 입장도 있다.var a = &#x27;&lt;a href=&quot;&#x27; + url + &#x27;&quot; target=&quot;_blank&quot;&gt;짱짱맨의 블로그&lt;/a&gt;&#x27;;var b = &quot;&lt;a href=\\&quot;&quot; + url + &quot;\\&quot; target=\\&quot;_blank\\&quot;&gt;짱짱맨의 블로그&lt;/a&gt;&quot;;// 또한 ES6 들어선 템플릿 리터럴 ``이 등장했기 때문에 이와 구별을 위해 쌍따옴표 사용을 주장하는 입장도 있다.var c = `&lt;a href=&quot;$&#123;url&#125;&quot; target=&quot;_blank&quot;&gt;짱짱맨의 블로그&lt;/a&gt;`;// 배열과 같이 인덱스로 접근이 가능하다.console.log(url[11], url[0], url[20]); // f h g// 덧셈 연산자를 쓰면 문자열이 아닌 것을 문자열로 바꾼 후 문자열끼리 합쳐준다. // 연산 순서가 매우 중요하므로 먼저 계산해주고 싶은 내용을 앞에 배치하던가 괄호로 묶어 우선순위를 높여줘야한다.var e = &#x27;10&#x27;;console.log(e + 2 + 1); // &#x27;1021&#x27;, &#x27;10&#x27; + &#x27;2&#x27; + 1 = &#x27;102&#x27; + &#x27;1&#x27;console.log(2 + e + 1); // &#x27;2101&#x27;, &#x27;2&#x27; + &#x27;10&#x27; + 1 = &#x27;210&#x27; + &#x27;1&#x27;console.log(2 + 1 + e); // &#x27;310&#x27;, 2 + 1 + &#x27;10&#x27; = &#x27;3&#x27; + &#x27;10&#x27; 형변환은 다음과 같이 할 수 있다. 123console.log(new String(123).valueOf()); // &#x27;123&#x27;console.log(String(false)); // &#x27;false&#x27;console.log(&#x27;&#x27;+false); // &#x27;false&#x27;, 가장 간결해서 자주 쓰는 방법이다. Null값이 없음을 나타내기 위한 자료형이다.어떤 사람은 이 null을 할당해주는 작업이 해당 변수를 쓸 준비가 되었다는 것과 같다고 한다.또한 null은 어떠한 프로퍼티나 메소드의 사용도 불가능하다. 123var a = null;a += &#x27;&#x27;; // &#x27;null&#x27;console.log(null.valueOf()); // Cannot read property &#x27;valueOf&#x27; of null Undefined값이 정의되지 않음을 나타내기 위한 자료형이다.null은 값이 정의 됐다, 변수에 할당된 상태이나 undefined는 값이 할당되지 않은 상태이다.undefined도 null과 마찬가지로 어떠한 프로퍼티나 메소드의 사용도 불가능하다. 12345678var a;console.log(a); // undefinedvar b = &#x27;asd&#x27;;console.log(b[3]); // undefined// 자바스크립트는 요상하게도 초기화되지 않은 변수에 연산자를 써도 오류가 나질 않는다.// 최대한 프로그램이 죽지 않도록 설계한 것 같다.a += &#x27;&#x27;; // &#x27;undefined&#x27;console.log(b[4].valueOf()); // Cannot read property &#x27;valueOf&#x27; of undefined 분량이 길어졌으니 한 번 끊고 그 다음 자료형인 객체에 대해서 공부해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"자료형","slug":"자료형","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"원시값","slug":"원시값","permalink":"https://perfectacle.github.io/tags/%EC%9B%90%EC%8B%9C%EA%B0%92/"}]},{"title":"(함수형 JS) 함수형 프로그래밍(JS)이란...?","slug":"js-func-00-what","date":"2017-06-30T21:33:47.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/30/js-func-00-what/","link":"","permalink":"https://perfectacle.github.io/2017/06/30/js-func-00-what/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 목차포스트와는 무관하며 내가 정리한 함수형 JS의 포스트 목록이다. 왜 쓸까? filter map each reduce find curry pipe","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 목차포스트와는 무관하며 내가 정리한 함수형 JS의 포스트 목록이다. 왜 쓸까? filter map each reduce find curry pipe 함수형 JS?간단하게 생긴 모습을 보면 다음과 같다. 123456// 객체 지향형[1, 2, 3].filter(v =&gt; v%2);// 함수형const filter = () =&gt; &#123;&#125;; // 구현했다고 가정.filter([1, 2, 3], v =&gt; v%2); 모두 다 그런 건 아니지만 대체적으로뭔가 .을 찍고 찍고 들어간다고 하면 그건 객체 지향형(객체에 존재하는 메소드나 프로퍼티 등등을 사용)그냥 함수로 시작해서 그 안에서 함수 쓰고 쓰고 뭐시기 지지고 볶고 하다가 함수로 끝나면 함수형이라고 보면 될 것 같다. 순수 함수?함수형 프로그래밍을 접하다 보면 순수 함수란 것을 많이 보게 된다.이는 객체 지향형에서 쓰이던 메소드와는 매우 다르다. 1234567891011// 객체 지향형const arr = [1, 2, 3];arr.push(4);console.log(arr); // [1, 2, 3, 4]// 함수형const arr2 = [1, 2, 3];const push = () =&gt; &#123;&#125;; // 구현했다고 가정.const newArr = push(arr2, 4);console.log(arr); // [1, 2, 3];console.log(newArr); // [1, 2, 3, 4]; 객체 지향형(arr.push(4))이 어떻게 동작을 했는지 보면 다음과 같다. arr에 4라는 데이터를 제일 끝에 넣었다. arr은 push 메소드의 입력값이 아닌데 메소드 내부에서 사용을 하였다. push 메소드가 메소드 외부의 데이터를 손 댄 것이다. 사이드 이펙트(부수 효과)를 발생 시켰다. 물론 위와 같은 코드는 너무 간단해서 개발자가 당연히 사이드 이펙트를 기대하고 짠 코드이다.객체 지향형은 기본적으로 사이드 이펙트를 기대하고 개발하게 된다.따라서 실행 시점에 따라 출력값이 다르다.즉 평가 시점을 어느 한 시점으로 한정 지을 수 밖에 없다. 그럼 함수형 코드(push(arr2, 4))를 한 번 보자. arr2를 복사하여 그 뒤에 4를 넣었다. push 함수의 입력값에 arr2가 있고, 그 입력값을 가지고만 함수가 실행되었다. push 메소드가 메소드 외부의 데이터에 손을 대지 않았다. 사이드 이펙트가 발생하지 않았다. 타입스크립트에서 any가 적폐 세력이라면, 함수형 프로그래밍에서는 사이드 이펙트가 적폐 세력인 것 같다.사이드 이펙트가 없기 때문에 동일한 입력값을 넣으면 언제나 동일한 출력값이 나온다.따라서 언제 실행하던 동일한 출력값이 나오기 때문에 평가 시점으로부터 자유롭다.바로 이런 게 순수 함수다. (사이드 이펙트가 없다는 게 핵심)그렇다고 사이드 이펙트가 있는 함수를 불순 함수라고는 부르지 않는다. 수학 시간에 배웠던 바로 그 함수다.f(x)는 언제나 y이다.10년 후에 실행하던 100년 후에 실행하던 f(x)는 언제나 y이다.하지만 객체 지향 개념의 함수(메소드)는 너무나 많은 사이드 이펙트로 둘러쌓여 있어서 실행할 때 마다 동일한 결과를 보장할 수 없다. 일급 함수? 일급 객체? 일급 시민?아래 링크를 베꼈다.참고하였다.JavaScript의 함수는 1급 객체(first class object)이다 일급 시민(first class citizen) 변수(variable)에 담을 수 있다. 매개변수(parameter)로 전달할 수 있다. 반환값(return value)으로 전달할 수 있다. 즉, 우리가 생각하는 값으로써 역할을 하는 것을 일급 시민이라고 말하는 것 같다. 일급 객체(first class object)특정 언어에서 객체를 일급 시민으로써 다룰 수 있느냐를 뜻한다.자바스크립트에서 객체는 위 조건을 만족하는 일급 시민이므로 일급 객체이다. 1234const obj = &#123;name: &#x27;양권성&#x27;, age: 25&#125;; // 1. 변수(variable)에 담을 수 있다.const fn = obj =&gt; &#123; // 2. 매개변수(parameter)로 전달할 수 있다. return obj; // 3. 반환값(return value)으로 전달할 수 있다.&#125; 일급 함수(first class function)특정 언어에서 함수를 일급 시민으로써 다룰 수 있느냐를 뜻한다.자바스크립트에서 함수는 위 조건을 만족하는 일급 시민이므로 일급 함수이다.또 일급 시민에 더해서 일급 함수는 다음과 같은 조건까지 있어야한다고 주장하기도 한다. 런타임(runtime) 생성이 가능하다. 익명(anonymous)으로 생성이 가능하다. 1234567const fn = () =&gt; &#123;&#125;; // 1. 변수(variable)에 담을 수 있다.const _fn = fn =&gt; &#123; // 2. 매개변수(parameter)로 전달할 수 있다. return fn; // 3. 반환값(return value)으로 전달할 수 있다.&#125;;function a() &#123;&#125; // 함수 선언식은 스크립트 로딩 시점에 VO(Variable Object)에 저장됨.const b = () =&gt; &#123;&#125;; // 4. 함수 표현식은 런타임 시에 해석 및 실행이 된다. const c = () =&gt; () =&gt; &#123;&#125;; // 5. 익명으로 생성이 가능하다. VO와 함수 표현식 및 선언식에 대한 내용은 아래 사이트를 참고하자. Variable Object in JS Javascript : 함수(function) 다시 보기 하지만 자바스크립트에서 함수는 객체이다. 123const a = () =&gt; &#123;&#125;;a.b = 123; // 객체와 같이 프로퍼티 추가가 가능하다.console.log(a.b); // 123 따라서 자바스크립트에서 함수는 일급 객체라고 주장도 하지만 나는 일급 함수가 좀 더 정확한 것 같다. (더 많은 조건을 충족하므로)뭐 자바스크립트에서 함수가 일급 시민이건 객체건 함수건 뭐가 중요한 지는 다음 고차 함수를 통해 알 수 있다. 고차 함수?함수형 프로그래밍을 접하다 보면 고차 함수란 것을 많이 보게 된다.뭔가 고차원적인 함수일 것 같은데 전혀 아니다.바로 다음과 같은 걸 고차 함수라고 말한다. 함수의 인자로 함수를 받는 경우 함수의 출력값이 함수인 경우 함수의 인자로 함수를 받으면서 출력값이 함수인 경우 (1+2번의 경우) 123const fn = fn =&gt; fn(); // 1. 함수의 인자로 함수를 받는 경우const fn2 = a =&gt; b =&gt; b; // 2. 함수의 출력값이 함수인 경우const fn3 = fn =&gt; fn; // 함수의 인자로 함수를 받으면서 출력값이 함수인 경우 함수형 프로그래밍의 장점은 여러가지 로직들을 추상화할 수 있는데,매개변수로 함수를 넘기기 때문이다.또 그 출력값으로 얻어낸 함수를 실행해서 여러 코드와 조합을 할 수 있다. 내가 아는 한도 내에서 틀렸을지 모르겠지만 함수형 자바스크립트에 대한 것은 다 적은 것 같으니 이제 목차를 보고 하나씩 터득해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) pipe","slug":"js-func-08-pipe","date":"2017-06-30T21:30:56.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/30/js-func-08-pipe/","link":"","permalink":"https://perfectacle.github.io/2017/06/30/js-func-08-pipe/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? pipe다음과 같은 함수를 작성해보자. [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]이란 배열을 만든다. 이 배열의 각 요소들을 x3한 배열을 구한다. x3한 배열에서 2의 배수만 추려내서 새로 배열을 구한다. 2의 배수들만 모아놓은 각 요소들을 합한 결과를 구하자.","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? pipe다음과 같은 함수를 작성해보자. [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]이란 배열을 만든다. 이 배열의 각 요소들을 x3한 배열을 구한다. x3한 배열에서 2의 배수만 추려내서 새로 배열을 구한다. 2의 배수들만 모아놓은 각 요소들을 합한 결과를 구하자. 함수형에 충실한 우리는 아래와 같이 짜게될 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const _each = (list, iteratee) =&gt; &#123; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; _each(list, item =&gt; newList.push(iteratee(item))); return newList;&#125;;const _head = list =&gt; list.toString() === &#x27;[object Object]&#x27; ? Object.keys(list)[0] : list[0];const _tail = list =&gt; ( list.toString() === &#x27;[object Object]&#x27; ? Object.keys(list).slice(1) : list.slice ? list.slice(1) : Array.from(list).slice(1));const _reduce = (list, iteratee, memo) =&gt; &#123; if(memo === undefined) &#123; memo = _head(list); list = _tail(list); &#125; _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;// 1번, 배열 만들기const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);console.log(nums); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]// 2번, x3한 배열 구하기.const mul3Nums = _map(nums, num =&gt; num*3);console.log(mul3Nums); // [ 3, 6, 9, 12, 15, 18, 21, 24, 27, 30 ]// 3번, 2의 배수 구하기.const getEven = _filter(mul3Nums, num =&gt; !(num%2));console.log(getEven); // [ 6, 12, 18, 24, 30 ]// 4번, 2의 배수들만 구한 배열의 합을 구하기.const sumEven = _reduce(getEven, (num, memo) =&gt; memo+num);console.log(sumEven); // 90 함수형에 더 충실한 사람은 아래와 같이 시도를 해봤을 것이다. 123456789101112// 1번, 배열 만들기const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);console.log(nums); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]console.log( _reduce( // 4번, 2의 배수들만 구한 배열의 합을 구하기. _filter( // 3번, 2의 배수 구하기. _map(nums, num =&gt; num*3), num =&gt; !(num%2) // 2번, x3한 배열 구하기. ) , (num, memo) =&gt; memo+num)); // 90 소스를 거꾸로 읽어나가야하고, 마치 콜백 함수 지옥에 빠진 듯한 기분이 든다.이러한 콜백 함수 지옥을 헤쳐나가기 위해 나온 것이 pipe이다.마치 비동기 함수에서 콜백 함수 지옥을 탈출하기 위해 프로미스가 나온 것과 비슷해보인다.역시 콜백 함수가 문제다. 우리가 인자로 넘긴 함수를 하나 하나 순차적으로 실행할 수 있게 해주는 pipe 함수를 만들어보자.머리를 굴려도 생각이 나지 않아 아래 링크를 베껴참조 하였다.(함수형JS) 흐름 기반 프로그래밍최종 결과는 아래와 같을 것이다. 1234567891011const nums = [];for(let i=1; i&lt;=10; i++) nums.push(i);// 함수 목록들을 리듀스 돌려버린다.const _pipe = (...fn) =&gt; _reduce(fn, (fn, memo) =&gt; fn(memo));console.log(_pipe( _map(nums, num =&gt; num*3), // 첫 번째 memo에 결과값이 담겨서 mul3Nums로 다음 함수에게 넘겨지고 있다. mul3Nums =&gt; _filter(mul3Nums, num =&gt; !(num%2)), // 두 번째 memo에 결과값이 담겨서 getEven으로 다음 함수에게 넘겨지고 있다. getEven =&gt; _reduce(getEven, (num, memo) =&gt; memo+num))); // 세 번째 memo에 결과값이 담겨서 로그 창에 찍힌다. // 이렇게 괄호를 쫙쫙쫙 닫아주는 게 함수형 프로그래밍 언어의 컨벤션이며 간지다. 역시 얕게 공부하다보니 간단하게 함수 만들고 예제 만들고 끝나는 것 같다.이제는 세미나 때 들었던 기억이 고갈되는 기분이라 좀 더 공부를 해야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) curry","slug":"js-func-07-curry","date":"2017-06-30T20:37:22.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/30/js-func-07-curry/","link":"","permalink":"https://perfectacle.github.io/2017/06/30/js-func-07-curry/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? curry카레와 컬링과는 아무런 관련이 없다.백문이 불여일견, 간단한 예제를 하나 보자. 123456789101112131415161718192021222324252627282930// 기존 방식const add = (a,b) =&gt; a+b;const sub = (a,b) =&gt; a-b;console.log(add(10, 10)); // 20console.log(add(10, 20)); // 30console.log(add(10, 30)); // 40console.log(add(10, 40)); // 50console.log(sub(10, 1)); // 9console.log(sub(10, 2)); // 8console.log(sub(10, 3)); // 7console.log(sub(10, 4)); // 6// 기존 방식의 함수를 커링을 이용하여 구성.const _add = a =&gt; b =&gt; a+b;const _sub = a =&gt; b =&gt; a-b;const add10 = _add(10);const sub10 = _sub(10);console.log(add10(10)); // 20console.log(add10(20)); // 30console.log(add10(30)); // 40console.log(add10(40)); // 50console.log(sub10(1)); // 9console.log(sub10(2)); // 8console.log(sub10(3)); // 7console.log(sub10(4)); // 6","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? curry카레와 컬링과는 아무런 관련이 없다.백문이 불여일견, 간단한 예제를 하나 보자. 123456789101112131415161718192021222324252627282930// 기존 방식const add = (a,b) =&gt; a+b;const sub = (a,b) =&gt; a-b;console.log(add(10, 10)); // 20console.log(add(10, 20)); // 30console.log(add(10, 30)); // 40console.log(add(10, 40)); // 50console.log(sub(10, 1)); // 9console.log(sub(10, 2)); // 8console.log(sub(10, 3)); // 7console.log(sub(10, 4)); // 6// 기존 방식의 함수를 커링을 이용하여 구성.const _add = a =&gt; b =&gt; a+b;const _sub = a =&gt; b =&gt; a-b;const add10 = _add(10);const sub10 = _sub(10);console.log(add10(10)); // 20console.log(add10(20)); // 30console.log(add10(30)); // 40console.log(add10(40)); // 50console.log(sub10(1)); // 9console.log(sub10(2)); // 8console.log(sub10(3)); // 7console.log(sub10(4)); // 6 기존에 n개의 인자를 받던 방식 대신 함수를 n번 호출하는 함수가 curry 함수, 그러한 기법을 currying이라 부른다.b =&gt; a+b 이 부분은 클로저이다.클로저는 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수, 생성 당시의 스코프에 대한 연결을 갖는 블록이라고 정리하고 있다.ES6는 블록 단위의 스코프라 b =&gt; a+b 에서 a는 모르지만 생명 주기가 끝난 외부 함수 a =&gt; b =&gt; a+b에서 a를 참조하고 있으므로 클로저이다.이런 걸 어디다 써먹느냐고 생각할 수 있는데 나중에 go나 pipe, 또한 우리가 작성했던 함수와도 엮어서 사용이 가능하다.위 _add와 _sub는 로직이 비슷해서 추상화가 가능하다. 12345678910111213const _curry = (a, fn) =&gt; b =&gt; fn(a, b);const add10 = _curry(10, (a, b) =&gt; a+b);const sub10 = _curry(10, (a, b) =&gt; a-b);console.log(add10(10)); // 20console.log(add10(20)); // 30console.log(add10(30)); // 40console.log(add10(40)); // 50console.log(sub10(1)); // 9console.log(sub10(2)); // 8console.log(sub10(3)); // 7console.log(sub10(4)); // 6 뭔가 추상화가 잘 된 것 같다, 인자가 두 개인 경우만…그럼 인자가 세 개인 경우에는 인자가 세 개인 커리 함수를 만들 것인가…?n개의 인자에 대해 대비할 수 있는 커리 함수를 다시 만들어보자.아래 링크를 보고 완전히 베낀 수준이며 ES6로 작성했을 뿐이다.아래 링크를 참고하면 좀 더 자세하고 ES5로 작성된 예제를 볼 수 있다.JavaScript에서 커링 currying 함수 작성하기 클로저는 함수가 아무리 호출되어도 다시 초기화 하지 않고, 유지되어야하는 값을 위해 쓴다고 나는 알고 있다.(혹시 틀렸다면 태클을…)기존 함수를 커리 함수로 호출할 때 유지해야할 값이 두 가지가 있다. 내가 호출하려는 원래 함수가 몇 개의 인자를 요구하는가 내가 지금까지 몇 개의 인자를 넘겼는가 이 두 가지 값은 함수를 아무리 호출해도 유지를 하고 있어야한다.그럼 커리 함수를 본격적으로 작성해보자. 내가 호출하려는 원래 함수가 몇 개의 인자를 요구하는가 12345const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. return () =&gt; console.log(fnArgLen); // 외부 스코프의 변수인 fnArgLen을 사용하고 있다.&#125;; 간단하게 테스트를 위해 함수의 인자를 유지하고 있는지 테스트하기 위한 함수를 만들어보았다.아래와 같이 테스트 해보자. 12_curry((a, b, c) =&gt; &#123;&#125;)(); // 3_curry((a, b, c, d, e) =&gt; &#123;&#125;)(); // 5 _curry 함수는 함수를 반환하는 고차함수다.따라서 ()()와 같이 함수를 호출해서 반환한 값을 또 호출할 수 있는 것이다.그 결과 우리가 두 번째 함수에는 딱히 인자를 넘기지 않았음에도 불구하고 그 값을 기억하고 있는클로저를 만들어냈다. (클로저가 뭐 그렇게 별 게 아니다.) 내가 지금까지 몇 개의 인자를 넘겼는가이 값은 함수를 호출할 때마다 값이 변해야한다.그렇다고 해서 처음부터 초기화를 하는 게 아니라 기존의 값을 기억하고 그 뒤에 현재 넘긴 인자를 추가하면 된다.값이 계속해서 동일하지 않더라도 값을 기억하고 있어야하기 때문에 클로저를 써야한다.위 함수에서 좀 더 작성해보자. 1234567891011121314151617181920212223242526const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. console.log(fnArgLen); return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. console.log(fnArgLen, memo); return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; console.log(fnArgLen, memo); return res; &#125; &#125;&#125;;const abcdef = (a, b, c, d, e, f) =&gt; &#123;&#125;;let a = _curry(abcdef); // 6let b = a(1); // 6, [1]let c = b(2); // 6, [1, 2]let d = c(3); // 6, [1, 2, 3]let e = d(4); // 6, [1, 2, 3, 4]let f = e(5); // 6, [1, 2, 3, 4, 5]let g = f(6); // 6, [1, 2, 3, 4, 5, 6]let h = g(7); // 6, [1, 2, 3, 4, 5, 6, 7]h(8); // 6, [1, 2, 3, 4, 5, 6, 7, 8] 함수를 계속 호출해도 원래 함수 인자의 갯수와 내가 여태까지 넘겼던 인자를 계속해서 들고있다.여기서 한가지 문제점이 존재한다.내가 원래 넘기려는 인자와 갯수가 일치하면 해당 함수를 실행해야하는데 여전히 계속해서 res 함수를 반환한다는 단점이 존재한다.적절히 조건문을 섞어주면 될 것 같다. 1234567891011121314151617181920212223242526272829const _curry = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. console.log(fnArgLen); return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. console.log(fnArgLen, memo); return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; console.log(fnArgLen, memo); // 인자의 갯수를 충분히 받았다면 원래 실행하려고 했던 함수를 실행한 결과를 반환, 그게 아니면 계속해서 인자를 누적시키는 res 함수를 반환. // fnArgLen과 같은 스코프에 공존하는 fn이라는 매개변수도 클로저 때문에 살아있기 때문에 사용이 가능하다. return memo.length &gt;= fnArgLen ? fn.apply(null, memo) : res; &#125; &#125;&#125;;const add = (a, b, c, d, e, f) =&gt; a + b + c + d + e + f;let a = _curry(add); // 6let b = a(1); // 6, [1]let c = b(2); // 6, [1, 2]let d = c(3); // 6, [1, 2, 3]let e = d(4); // 6, [1, 2, 3, 4]let f = e(5); // 6, [1, 2, 3, 4, 5]let g = f(6); // 6, [1, 2, 3, 4, 5, 6]console.log(g); // 21console.log(add(1, 2, 3, 4, 5, 6)); // 21let h = g(7); // TypeError: g is not a function Function.prototype.apply은 첫 번째 인자로 this로 바인딩할 값, 두 번째 인자로 매개변수들을 배열로 받는다.여태까지 입력받은 인자를 (1, 2, 3, 4)의 형태로 넘기는 게 가능한지는 모르겠으나(Function.prototype.call이 이런 식으로 동작)그것보다 매개변수를 배열로 ([1, 2, 3, 4])와 같이 넘기는 게 훨씬 편하다.우리가 원하는 형태로 n개의 매개변수를 넘기면 n번 호출해야 함수가 비로소 실행(지연해서 실행이라고 해야하려나)되는 커리 함수를 만들었다. curryr하지만 이것도 쓰다보면 어딘가 모르게 어색한 부분이 존재한다. 12345678const add = (a, b) =&gt; a + b;const sub = (a, b) =&gt; a - b;const _add = _curry(add);const _sub = _curry(sub);const add10 = _add(10)const sub10 = _sub(10);console.log(add10(3)); // 13console.log(sub10(3)); // 7 add를 할 때는 3에 10을 더해서 13이 나오는 듯한 느낌인데sub를 할 때는 3에 10을 빼서 -7이 나와야할 것 같은데 반대로 10에 3을 빼서 7이 나왔다.덧셈이야 순서가 상관이 없다지만 뺄셈의 경우에는 이야기가 달라진다.따라서 아래와 같이 하면 문제가 해결된다. 1234const sub = (a, b) =&gt; b - a;const _sub = _curry(sub);const sub10 = _sub(10);console.log(sub10(3)); // -7 음… 함수를 커리에게 넘겨줄 때 반대로 쓰면 되는 문제인데…어쨌든 curryr(curry reverse)이라는 녀석이 존재한다.어떤 이유에서 생기긴 했을 거다. 그냥 보자. 123456789101112131415161718const _curryr = fn =&gt; &#123; // fnArgLen은 함수를 호출할 때 마다 유지돼야하고, 값이 변하지 않는다. const fnArgLen = fn.length; // 인자로 받은 함수(fn)에서 요구하는 인자의 갯수. return (...args) =&gt; &#123; // 함수의 인자의 갯수를 기억하는 클로저 // 인자를 넘겼을 때 그 인자들의 목록은 매번 함수를 호출할 때마다 기억해야함. let memo = [...args]; // 처음 인자를 넘기고 호출했을 때 그 인자를 담을 배열. return function res(...args) &#123; // 여태까지 넘긴 인자들을 기억하는 클로저, 재호출을 위해 이름을 붙여줌. memo = [...memo, ...args]; // curry reverse이기 때문에 매개변수도 뒤집어서 실행해주면 된다. return memo.length &gt;= fnArgLen ? fn.apply(null, memo.reverse()) : res; &#125; &#125;&#125;;const sub = (a, b) =&gt; a - b;const _sub = _curryr(sub);const sub10 = _sub(10);console.log(sub10(3)); // -7 짱구를 굴려봤지만 _curry를 이용해서 추상화 할 수가 없었다 ㅠㅠ…아마 이 curryr의 진가는 pipe와 go를 익히면 알게 될 것이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) find","slug":"js-func-06-find","date":"2017-06-28T09:54:16.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/28/js-func-06-find/","link":"","permalink":"https://perfectacle.github.io/2017/06/28/js-func-06-find/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? findfind는 두 말 하면 입 아프겠지만, 기존 데이터 사이에서 원하는 것을 찾을 때 사용한다.아래 예제를 보자. 1234567891011121314151617const nums = [1, 3, 5, 7, 100];let no = 0;for(const num of nums) &#123; if(!(num % 2)) &#123; // 짝수인지 no = num; break; &#125;&#125;const users = [ &#123;name: &#x27;asdf&#x27;, age: 12&#125;, &#123;name: &#x27;qwer&#x27;, age: 33&#125;];let name = &#x27;&#x27;; let over30 = null;for(const user of users) if(user.age &gt; 30) return over30 = user;console.log(no); // 100console.log(over30.age ); // 33","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? findfind는 두 말 하면 입 아프겠지만, 기존 데이터 사이에서 원하는 것을 찾을 때 사용한다.아래 예제를 보자. 1234567891011121314151617const nums = [1, 3, 5, 7, 100];let no = 0;for(const num of nums) &#123; if(!(num % 2)) &#123; // 짝수인지 no = num; break; &#125;&#125;const users = [ &#123;name: &#x27;asdf&#x27;, age: 12&#125;, &#123;name: &#x27;qwer&#x27;, age: 33&#125;];let name = &#x27;&#x27;; let over30 = null;for(const user of users) if(user.age &gt; 30) return over30 = user;console.log(no); // 100console.log(over30.age ); // 33 위 코드를 보면 일단 반복문이 반복해서 쓰이고 있고, 뭘 구할지도 반복되고 있다.이 부분들을 추상화해보자. 12345678910111213141516const _find = (list, predicate) =&gt; &#123; for(const item of list) if(predicate(item)) return item; // 새로운 변수를 만들어서 거기다 값을 담고 리턴하려니 추상화를 해도 오히려 코드가 길어져서 복잡해보인다. //let match; //_each(list, item =&gt; &#123; // if(predicate(item)) match = item; //&#125;); //return match&#125;;const nums = [1, 3, 5, 7, 100];const users = [ &#123;name: &#x27;asdf&#x27;, age: 12&#125;, &#123;name: &#x27;qwer&#x27;, age: 33&#125;];console.log(_find(nums, num =&gt; !(num % 2))); // 100console.log(_find(users, user =&gt; user.age &gt;= 30).age); // 33 findIndex이렇게 배열(과 ArrayLike)을 넘겨서 그 요소 중에서 내가 원하는 조건을 추상화시킨 _find를 써서 원하는 값을 얻어낼 수 있다.그럼 이 요소들이 몇 번째에 있는지 구하는 _findIndex도 만들어보자.기본적으로 순서가 없는, 인덱스로 접근이 불가능한 객체는 무시하고 만들도록 하겠다. 123456789const nums = [1, 3, 100, 2, 7];let idx = -1; for(let i=0, len=nums.length; i&lt;len; i++) &#123; if(nums[i] &gt;= 100) &#123; idx = i; break; &#125;&#125;console.log(idx); // 2 새 리스트를 만들어서 그 리스트에 할당하는 부분은 없으니 반복문은 추상화시키지 못할 것 같다.또한 인덱스를 반환해야하니 for of 구문은 쓰지 못할 것 같다.추상화시킬 건덕지는 조건문 밖에 없어보인다. 12345678910111213const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1; // 새로운 변수를 만들어서 거기다 값을 담고 리턴하려니 추상화를 해도 오히려 코드가 길어져서 복잡해보인다. //let idx = -1; //_each(list, item =&gt; &#123; // _each는 인덱스를 리턴하는 게 아니라 매칭된 값을 리턴하기 때문에 추상화 불가. // if(predicate(item)) idx = item; //&#125;); //return idx;&#125;;const nums = [1, 3, 100, 2, 7];console.log(_findIndex(nums, num =&gt; num &gt;= 100)); // 2 왜 -1을 리턴하는지 모르겠는 사람은 ~(Tilde) 연산자를 참고하자. somesome은 하나라도 조건을 만족하면 true를 반환하는 함수다.||(or)의 특성을 지닌다고 보면 될 것 같다.바로 어떤 녀석이 some인지 보자. 1234567891011121314let nums = [1, 3, 100, 2, 7];let no3 = false;for(const num of nums) if(!(num % 3)) &#123; // 3의 배수라면 no3 = true; break;&#125;console.log(no3); // truenums = [3, 6, 20, 9];no3 = false;for(const num of nums) if(!(num % 3)) &#123; // 3의 배수라면 no3 = true; break;&#125;console.log(no3); // false 조건문 부분만 추상화가 가능해보인다.바로 구현해보자. 12345678const _some = (list, predicate) =&gt; &#123; for(const item of list) if(predicate(item)) return true; return false;&#125;;let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [4, 8, 16, 20];console.log(_some(nums, num =&gt; !(num % 3))); // false 위 함수를 보면 find에서 return 구문만 바뀐 걸 볼 수 있다.find 함수와 조합을 해보면 더 추상화 할 수 있을 것 같다. 1234567const _some = (list, predicate) =&gt; ( !!_find(list, item =&gt; predicate(item)));let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [0, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // flase 0은 3으로 나눴을 때 0이므로 조건식을 만족해서 find 함수로 0을 땡겨온다.하지만 0은 falsy value이므로 거짓이 나온다.따라서 find의 반환값으로 falsy value를 의도적으로 검출해낼 수도 있으므로 위와 같이 _find로는 추상화하지 못한다. 123456789101112const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1;&#125;;const _some = (list, predicate) =&gt; _findIndex(list, item =&gt; predicate(item)) !== -1;// 비트단위의 논리 연산자(Not)인 ~(Tilde)를 쓰면 다음과 같이 할 수 있다.// const _some = (list, predicate) =&gt; !!~_findIndex(list, item =&gt; predicate(item));let nums = [1, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // truenums = [0, 3, 100, 2, 7];console.log(_some(nums, num =&gt; !(num % 3))); // true _find는 조건을 만족하는 값이면 어떤 값이든 땡겨올 수 있고 falsy value는 물론,심지어 undefined도 땡겨올 수 있으므로 boolean으로 캐스팅해도 올바른 결과를 얻어낼 수 없다._findIndex는 -1만 아니면 참인 것이기 때문에 -1에 대해서만 대비하면 되므로 추상화하기에 적당하다. everyevery는 하나라도 조건을 만족하지 않으면 false를 반환하는 함수다.&amp;&amp;(and)의 특성을 지닌다고 보면 될 것 같다.바로 어떤 녀석이 every인지 보자. 1234567891011121314let nums = [1, 3, 100, 2, 7];let no3 = true;for(const num of nums) if(!(num % 3 === 0)) &#123; // 3의 배수가 아니라면 no3 = false; break;&#125;console.log(no3); // falsenums = [4, 8, 16, 20];no3 = true;for(const num of nums) if(!(num % 2 === 0)) &#123; // 2의 배수가 아니라면 no3 = false; break;&#125;console.log(no3); // true 위 코드는 모두 3의 배수인지, 모두 2의 배수인지를 구한 반복문이다.그럼 한 번 추상화해보자. 12345678const _every = (list, predicate) =&gt; &#123; for(const item of list) if(!(predicate(item))) return false; return true;&#125;;let nums = [1, 3, 100, 2, 7];console.log(_every(nums, num =&gt; num % 3 === 0)); // falsenums = [4, 8, 16, 20];console.log(_every(nums, num =&gt; num % 2 === 0)); // true 위에 반복문 부분도 _find로 추상화해보고 싶지만 위의 _some과 같이 falsy value 이슈가 있을 것 같다.그럼 falsy value로 부터 자유로운 _findIndex를 가지고 추상화해보자. 123456789101112const _findIndex = (list, predicate) =&gt; &#123; for(let i=0, len=list.length; i&lt;len; i++) if(predicate(list[i])) return i; return -1;&#125;;const _every = (list, predicate) =&gt; _findIndex(list, item =&gt; !predicate(item)) === -1;// 비트단위의 논리 연산자(Not)인 ~(Tilde)를 쓰면 다음과 같이 할 수 있다.//const _every = (list, predicate) =&gt; !~_findIndex(list, item =&gt; !predicate(item));let nums = [1, 3, 100, 2, 7];console.log(_every(nums, num =&gt; num % 3 === 0)); // falsenums = [4, 8, 16, 20];console.log(_every(nums, num =&gt; num % 2 === 0)); // true 오늘은 여기까지만 알아보도록 하자.다음 시간에는 함수형의 꽃이라 할 수 있는 curry에 대해 알아보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) reduce","slug":"js-func-05-reduce","date":"2017-06-26T09:26:21.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/26/js-func-05-reduce/","link":"","permalink":"https://perfectacle.github.io/2017/06/26/js-func-05-reduce/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? reduce기본적으로 reduce는 기존 데이터들을 가공해 아예 새로운 데이터를 얻고자 할 때 쓰인다.1~6까지의 배열이 존재할 때 해당 수들을 가지고 새로운 수를 얻고자 할 때 쓰인다. 1234567const nums = [1, 2, 3, 4, 5, 6];let sum = 0;for(const num of nums) sum += num*2;console.log(sum); // 42sum = 0;for(const num of nums) if(num%2) sum+= num;console.log(sum); // 1 + 3 + 5 = 9","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? reduce기본적으로 reduce는 기존 데이터들을 가공해 아예 새로운 데이터를 얻고자 할 때 쓰인다.1~6까지의 배열이 존재할 때 해당 수들을 가지고 새로운 수를 얻고자 할 때 쓰인다. 1234567const nums = [1, 2, 3, 4, 5, 6];let sum = 0;for(const num of nums) sum += num*2;console.log(sum); // 42sum = 0;for(const num of nums) if(num%2) sum+= num;console.log(sum); // 1 + 3 + 5 = 9 뭐 딱히 추상화할 건 별로 없어보이지만 이런 반복스런 냄새들을 잘 맡고 캐치하는 것이 중요하다.반복문 부분, 그리고 arrayLike와 객체를 위해 일단 추상화를 진행해보자. 123456789101112131415161718const _each = (list, iteratee) =&gt; &#123; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;// memo는 디자인 패턴 중 하나인 메모제이션 패턴을 이용한다는 것을 뜻하는 것 같다.// 또한 데이터들을 어떻게 가공할지는 반복된 함수(iteratee)에게 위임, 추상화 하였다.const _reduce = (list, iteratee, memo) =&gt; &#123; // for(const item of list) memo = iteratee(item, memo); // 위 코드는 리스트의 반복문을 돌기 때문에 아래와 같이 추상화가 가능하다. _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;const nums = [1, 2, 3, 4, 5, 6];console.log(_reduce(nums, (num, memo) =&gt; memo + num*2, 0)); // 42 head, tail하지만 초기값인 메모제이션 인자가 제공되지 않으면 위 함수는 죽고 만다.좀 더 사용하기 쉽게 함수를 만드려면 초기값은 생략이 가능해야한다. 12345678910111213141516171819202122232425262728293031323334const _each = (list, iteratee) =&gt; &#123; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;// 리듀스에 초기값이 제공되지 않는 경우 그 초기 값을 얻어내기 위한 함수// 인덱스로 접근할 수 없는 객체에 대해서 처리를 해줘야 함.const _head = list =&gt; list.toString() === &#x27;[object Object]&#x27; ? Object.keys(list)[0] : list[0];// 초기값을 제외한 값들const _tail = list =&gt; ( // slice 메소드가 없는 객체의 경우에는 키값들을 퉁친 배열로 반환 list.toString() === &#x27;[object Object]&#x27; ? Object.keys(list).slice(1) : // slice 메소드(프로토타입 등등)가 있으면 고대로 쓰면 되고 ArrayLike 같은 경우에는 Array로 바꿔준 후에 호출하면 됨. list.slice ? list.slice(1) : Array.from(list).slice(1));const _reduce = (list, iteratee, memo) =&gt; &#123; if(memo === undefined) &#123; // 초기 값이 없다면 // 해당 리스트의 첫 번째 값을 초기값으로 삼으면 된다. memo = _head(list); // 해당 리스트의 첫 번째 값을 제외한 녀석을 리스트로 삼으면 된다. list = _tail(list); &#125; _each(list, item =&gt; memo = iteratee(item, memo)); return memo;&#125;;const nums = [1, 2, 3, 4, 5, 6];const doms = document.querySelectorAll(&#x27;*&#x27;);const obj = &#123;name: &#x27;ㅁㄴㅇㄹ&#x27;, age: 9999&#125;;console.log(_reduce(nums, (item, memo) =&gt; memo + item*2)); // 41console.log(_reduce(doms, (node, memo) =&gt; `$&#123;memo&#125;노드 이름은 $&#123;node.nodeName&#125;\\n`, &#x27;&#x27;));console.log(_reduce(obj, (key, memo) =&gt; `$&#123;memo&#125;$&#123;key&#125;: $&#123;obj[key]&#125;\\n`, &#x27;&#x27;)); 세미나 들은 걸 토대로 머리를 굴려봐서 짜봤는데 틀린 부분은 없는지 확신은 못 하겠다.여튼 뭐 돌아는 가니… curry와 curryr, 그리고 pipe와 go가 정말 함수형의 꽃인 것 같은데…일단 다음 포스트인 find를 보도록 하자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) each","slug":"js-func-04-each","date":"2017-06-26T09:26:15.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/26/js-func-04-each/","link":"","permalink":"https://perfectacle.github.io/2017/06/26/js-func-04-each/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? each기본적으로 each는 반복문을 추상화 할 때 쓰인다.완벽할 것 같은 이 _filter와 _map도 다시 보면 중복이 존재한다.이런 중복을 제거하고 추상화 하는 것들이 함수형의 묘미가 아닐까 싶다. 123456789101112131415161718192021const _filter = (list, predicate) =&gt; &#123; const newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) newList.push(iteratee(item)) return newList;&#125;;","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? each기본적으로 each는 반복문을 추상화 할 때 쓰인다.완벽할 것 같은 이 _filter와 _map도 다시 보면 중복이 존재한다.이런 중복을 제거하고 추상화 하는 것들이 함수형의 묘미가 아닐까 싶다. 123456789101112131415161718192021const _filter = (list, predicate) =&gt; &#123; const newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) newList.push(iteratee(item)) return newList;&#125;; 바로 for 반복문 부분과 객체를 배열화 시키는 부분이 굉장히 반복스런(?) 냄새를 풍긴다.저 부분까지 추상화 해낼 수 있다. 12345678910111213141516171819202122232425262728const _each = (list, iteratee) =&gt; &#123; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;;const _map = (list, iteratee) =&gt; &#123; const newList = []; _each(list, item =&gt; newList.push(iteratee(item))); return newList;&#125;;const users = [ &#123;id: 0, name: &#x27;양간장&#x27;, age: 55&#125;, &#123;id: 1, name: &#x27;간장냥&#x27;, age: 45&#125;, &#123;id: 2, name: &#x27;장냥이&#x27;, age: 35&#125;, &#123;id: 3, name: &#x27;양권성&#x27;, age: 25&#125;];const over40 = _filter(users, user =&gt; user.age &gt;= 40);const over40Name = _map(over40, person =&gt; person.name);console.log(over40);console.log(over40Name); 사실 추상화 해놓고 보면 약간 함수 외부에 있는 리스트에 요소를 넣는다거나 사이트 이펙트를 발생시키긴 하지만…최소한의 사이드 이펙트 정도는 눈감아줘도 되지 않을까… 싶다.음… 그리고 코드가 크게 줄어들지 않아서 와닿지 않을 수도 있는데…ES5 식 코드로 보면 정말 크게 와닿는다. 1234567891011121314151617181920212223242526// ES5var __filter = function(list, predicate) &#123; var newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(var i=0, len=Object.keys(list).length; i&lt;len; i++) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(i=0, len=list.length; i&lt;len; i++) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;// ES6const _each = (list, iteratee) =&gt; &#123; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) iteratee(item)&#125;;const _filter = (list, predicate) =&gt; &#123; const newList = []; _each(list, item =&gt; predicate(item) &amp;&amp; newList.push(item)); return newList;&#125;; ES5 식으로 작성한 반복문은 굉장히 실수를 하기 좋다.(물론 ES6도 아주 가끔…)조건문을 잘못 쓴다거나 등등…하지만 잘 작성해 놓은 반복문 하나(each)를 추상화해서 배열의 갯수만큼 순서대로 반복문을 돌릴 때반복문 로직을 직접 짜지 않고, 저 추상화한 each 메소드를 쓰면 실수를 할 여지가 많이 줄어드는 것 같다. 그럼 이제 바로 다음 포스트인 reduce를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) map","slug":"js-func-03-map","date":"2017-06-26T09:26:10.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/26/js-func-03-map/","link":"","permalink":"https://perfectacle.github.io/2017/06/26/js-func-03-map/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? map기본적으로 map은 수집, 원본 데이터들을 어떠한 형태로 가공해서 수집할까의 기능을 한다. 기존 프로그래밍","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? map기본적으로 map은 수집, 원본 데이터들을 어떠한 형태로 가공해서 수집할까의 기능을 한다. 기존 프로그래밍우선 얻어온 데이터들을 우리가 만든 _filter 함수를 써서 필터링된 결과를 얻은 이후부터 생각해보자.이제 그 데이터(객체)에서 우리가 원하는 나이나 이름(가공)만 뽑아내보자. 1234567891011121314151617181920const _filter = (list, predicate) =&gt; &#123; const newList = []; for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;const users = [ &#123;id: 0, name: &#x27;양간장&#x27;, age: 55&#125;, &#123;id: 1, name: &#x27;간장냥&#x27;, age: 45&#125;, &#123;id: 2, name: &#x27;장냥이&#x27;, age: 35&#125;, &#123;id: 3, name: &#x27;양권성&#x27;, age: 25&#125; ];const over40 = _filter(users, user =&gt; user.age &gt;= 40);const over40Age = [];for(const person of over40) &#123; over40Age.push(person.age);&#125;const over40Name = [];for(const person of over40) &#123; over40Name.push(person.name);&#125; 위 로직을 보니 역시 반복문 부분과 배열에 넣는 부분, 그리고 객체에서 어떤 걸 뽑아서 넣을지요 부분들이 추상화가 가능할 것 같다.그래서 아래와 같이 함수로 추상화가 가능할 것 같다. 1234567891011const __map = (list, key) =&gt; &#123; const newList = []; for(const item of list) &#123; newList.push(item[key]); &#125; return newList;&#125;;const over40Age = __map(over40, &#x27;age&#x27;);const over40Name = __map(over40, &#x27;name&#x27;);console.log(over40Age); // [ 55, 45 ]console.log(over40Name); // [ &#x27;양간장&#x27;, &#x27;간장냥&#x27; ] 잘 추상화 한 것 같다.객체의 다른 프로퍼티를 구한다고 할 때도 두 번째 키 인자만 바꿔주면 된다.읭? 객체 말고 다른 녀석인 경우에는? 배열의 요소에다가 모두 1을 더한 배열을 얻고 싶을 때는?이런… 추상화의 포커스가 객체의 키 값들을 얻어내는 데만 맞춰져있었다.다시 함수형 본연의 모습을 되찾을 때가 됐다. 함수형12345678910111213// 리스트의 아이템을 어떠한 형태로 수집할지를 iteratee 함수로 추상화하였다.// 이제 _map 함수는 데이터를 어떻게 수집할지에 대한 책임을 iteratee에게 위임하였다. // iteratee는 반복하는 행위를 하는 함수를 뜻하는 것 같다.// 그 함수는 요소를 인자로 받아서 그 요소를 가지고 지지고 볶고 하는 건 사용할 때 결정하면 될 일이다. // 위처럼 &#x27;어떻게 지지고 볶을지&#x27;를 추상화 해놓지 않고 직접 정의해놓으면 다르게 지지고 볶을 때마다 함수를 계속 만들어줘야한다.const _map = (list, iteratee) =&gt; &#123; const newList = []; for(const item of list) newList.push(iteratee(item)) return newList;&#125;;// 두 번째 함수에서는 데이터들을 어떻게 지지고 볶아서 가져올지에 대해 정의를 해주면 된다.console.log(_map(over40, person =&gt; person.age+1));console.log(_map(over40, person =&gt; person.name)); 하지만 아직 우리에게는 숙제가 하나 남아있다.filter에서는 딱히 필요성을 느끼지 못해 돌림직한 객체를 건너뛰었지만 이번 map 예제는 객체에서도 나름 쓸모가 있어 보인다.아래와 같이 객체의 값들을 얻어오고 싶다고 가정을 해보자.조금 복잡하게 설명했지만 객체는 배열과 같이 for of 구문으로 반복문을 돌릴 수 있는 녀석이 아니다.왜냐하면 객체는 순서가 없기 때문이다. (사실은 Symbol.Symbol(iterator) 프로퍼티가 없기 때문)원리가 궁금한 사람은 아래 포스트들을 참고하자.간단하게 Iterator 포스트 정도만 참고해도 될 것 같다. Interface Symbol Iterator123456const obj = &#123;name: &#x27;간장이&#x27;, age: 255&#125;;// Object는 이터러블(반복을 돌릴 수 있는 애)이 아니기 때문에 이터레이터(반복해서 돌릴 수 있는 녀석)가 아니다. // 따라서 for of와 같은 구문을 만나면 오류가 나게 되는 것이다.console.log(_map(obj, v =&gt; v));// 물론 아래와 같이 에러를 회피할 수 있지만 위와 같이 쓰는 게 더 간결하지 않은가?console.log(_map(Object.keys(obj), key =&gt; obj[key])); // [&#x27;간장이&#x27;, 255] key와 value의 쌍으로 이루어져있는 돌림직한 객체도 map으로 돌려버릴 수 있게 코드를 좀 손보자.간단하게 한 줄만 추가해주면 된다. 1234567891011const _map = (list, iteratee) =&gt; &#123; const newList = []; if(list.toString() === &#x27;[object Object]&#x27;) &#123; const objValList = []; for(const key of Object.keys(list)) key !== &#x27;length&#x27; &amp;&amp; objValList.push(list[key]); list = objValList; &#125; for(const item of list) newList.push(iteratee(item)) return newList;&#125;;console.log(_map(obj, v =&gt; v)); // [&#x27;간장이&#x27;, 255] 그럼 이제 바로 다음 포스트인 each를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) filter","slug":"js-func-02-filter","date":"2017-06-26T09:26:04.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/26/js-func-02-filter/","link":"","permalink":"https://perfectacle.github.io/2017/06/26/js-func-02-filter/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? filter기본적으로 filter는 필터링, 조건에 맞는 녀석들만 걸러내서 새로운 데이터를 얻는 역할을 한다. 기존 프로그래밍","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? filter기본적으로 filter는 필터링, 조건에 맞는 녀석들만 걸러내서 새로운 데이터를 얻는 역할을 한다. 기존 프로그래밍우선 서버와 ajax로 통신해서 db에서 다음과 같은 json 데이터를 얻어왔다고 가정해보자. 123456const users = [ &#123;id: 0, name: &#x27;양간장&#x27;, age: 55&#125;, &#123;id: 1, name: &#x27;간장냥&#x27;, age: 45&#125;, &#123;id: 2, name: &#x27;장냥이&#x27;, age: 35&#125;, &#123;id: 3, name: &#x27;양권성&#x27;, age: 25&#125; ]; 이 유저들 중에 40대 이상인 사람과 40대 미만인 사람을 구분하는 필터링을 구현해보자. 1234567891011121314const over40 = [];for(const user of users) &#123; if(user.age &gt;=40) &#123; over40.push(user); &#125;&#125;const under40 = [];for(const user of users) &#123; if(user.age &lt; 40) &#123; under40.push(user); &#125;&#125;console.log(over40);console.log(under40); 위 코드를 보니 반복문 구문과 새로운 배열에 만족하는 녀석들을 삽입하는 부분이 반복된다.요것들을 어떻게 추상화 시켜서 재사용이 가능하게 끔 한번 해보고 싶어졌다. 123456789const __filter = users =&gt; &#123; const tmp = []; for(const user of users) &#123; if(?????) &#123; tmp.push(user); &#125; &#125; return tmp;&#125; 우리가 기존에 객체 지향으로 프로그래밍을 했을 때는 조건문 부분은 추상화하기가 힘들다.이런 간지러운 부분을 함수형으로 바꾸면 바로 해결이 가능하다. 함수형 프로그래밍123456789101112131415161718// predicate는 참인지 거짓인지를 판별하는 함수?를 뜻하는 것 같다.// 또한 사용자만 받는 users라는 인자 보다는 좀 더 범용적인 이름인 list를 쓰는 게 좋다.const _filter = (list, predicate) =&gt; &#123; // 나는 그냥 임시로 쓰고 말 녀석이기 때문에 별 생각 없이 tmp 등등으로 쉽게 네이밍을 했다. // 하지만 순수 함수는 사이드 이펙트를 발생시키지 않고, // 입력값을 토대로 새로운 값을 출력하는 불변성을 가지니 new라는 키워드를 붙여주는 게 좋다. const newList = []; // 필터링의 조건을 predicate 함수로 추상화시켰다. // 구현부에서는 조건문을 신경쓰지 않고 해당 함수에게 위임하면 된다. // 또한 함수형 프로그래밍에서는 뭔가 한 줄로 적는 게 간지 같아서 조건문을 논리 연산자로 함축시키고, 중괄호도 다 생략했다. for(const item of list) predicate(item) &amp;&amp; newList.push(item); return newList;&#125;;// 이 유저들 중에 40대 이상인 사람과 40대 미만인 사람을 구분하는 필터링을 구현해보자. const over40 = _filter(users, user =&gt; user.age &gt;= 40);const under40 = _filter(users, user =&gt; user.age &lt; 40);console.log(over40);console.log(under40); 위에 _filter 함수를 보면 조건(predicate)를 함수의 인자로 받아서그 내부가 어떻게 구현됐건 신경쓰지 않고 predicate 함수에게 배열의 요소만 넘겨서 조건이 참이면 새 배열에 넣게 끔 구현했다.이렇게 _filter는 조건을 추상화, predicate 함수에게 위임했기 때문에 좀 더 사용성이 높아졌다.위와 같이 짜게 되면 ArrayLike의 대표적인 케이스인 NodeList도 필터링이 가능하다. 그리고predicate(item) &amp;&amp; newList.push(item);위 구문이 이해 안 가는 사람은 똑똑한 논리 연산자와 값 vs 식 vs 문을 참고해보자. 1234const nodeList = document.querySelectorAll(&#x27;*&#x27;);console.log(_filter(nodeList, node =&gt; node.nodeName === &#x27;HTML&#x27;));// Uncaught TypeError: nodeList.filter is not a functionconsole.log(nodeList.filter(node =&gt; node.nodeName === &#x27;HTML&#x27;)); key와 value의 쌍으로 이루어져있는 돌림직한 객체를 필터링하는 것은 세미나에서 다루지 않았기 때문에 정리하지 않겠다.key와 value의 쌍으로 이루어져있는 돌림직한 객체를 필터링하는 것은 예제가 잘 떠오르지 않고,필요성을 잘 느끼지 못했기 때문에 정리하지 않도록 하겠다.혹시 관련된 예제나 필요성 등등을 아신다면 댓글을… ^^ 그럼 이제 바로 다음 포스트인 map을 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"(함수형 JS) 왜 쓸까?","slug":"js-func-01-why-make","date":"2017-06-26T09:25:57.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/06/26/js-func-01-why-make/","link":"","permalink":"https://perfectacle.github.io/2017/06/26/js-func-01-why-make/","excerpt":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 왜 쓸까?우선 함수형 프로그래밍의 핵심을 꼽아보라고 하면 Filter Map Reduce Find","text":"이 포스트는 인프런에서 진행한 유인동 님의 함수형 자바스크립트를 듣고 감명 받아서 쓴 글이다.사실 underscore, lodash 등 함수형 패러타임으로 코드를 짤 수 있게 끔미리 이런 함수들을 제공하는 라이브러리들을 쓰고, 이 포스트는 그닥 볼 필요가 없다.하지만 이런 원리를 알고 접근을 하다보면 위 라이브러리를 쓴다고 하더라도 추가로 필요한 나의 코드를 함수형으로 더 짜기 유용하지 않을까? 왜 쓸까?우선 함수형 프로그래밍의 핵심을 꼽아보라고 하면 Filter Map Reduce Find 등등을 꼽아볼 수가 있다. 기본적으로 ES5부터는 Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.find 등등의 메소드가 이미 존재한다.단순히 메소드이기 때문에 함수로 만들고자 이 행위를 하는 것일까?아니다.이 메소드들은 ArrayLike나 돌림직한(?), 돌릴 수 있는 데이터(key와 value의 쌍으로 이루어져있는 object 등등)들에게는 적용되지 못한다. ArrayLike…? ArrayLike는 배열 같지만 배열이 아니다.다음과 같은 특징을 갖는다. length 프로퍼티가 존재한다. index로 접근이 가능하다. Symbol(Symbol.iterator) 프로퍼티가 있기 때문에 이터러블하다. 하지만 Array의 프로토타입을 상속받지 않는다. 1~3번 때문에 배열 같지만, 정작 4번 때문에 배열의 메소드들은 사용하지 못한다는 점이 특징이다.여하튼, 위 메소드들은 순수 배열만 사용 가능하지만 이제부터 우리가 만들어 볼 애들은 돌림직한 녀석들이면 모두 가능하다!즉 언어가 특정 기능을 추가해줄 때까지 기다릴 필요 없이 내 입맛대로 원하는 녀석들을 구현할 수가 있다.이게 바로 함수형이 가지는 장점이다! 또한 함수형으로 프로그래밍을 하다보면 기존에 객체 지향 프로그래밍을 할 때보다 더 추상화할 수 있는 요소가 많아진다.기존에 코딩을 하다보면 분명 반복된 것 같은데… 라는 생각은 들지만 마땅히 어떻게 추상화를 해야할지 찾아내기가 힘들었던 경험이 많다.하지만 함수형에서는 단순 변수에 값을 변화시키는 것을 뛰어넘어서 조건문, 반복문 등등 다양한 것들이 추상화가 가능하다.그래서 비슷한 일을 하는 녀석을 하나로 퉁쳐서 사용하기 때문에 비슷한 코드를 짤 필요가 없어진다. 그리고 함수형 프로그래밍을 할 때 장점이 이것 저것 조합해서 만들 수 있는 일이 많아진다.따라서 추상화 할 수 없을 것 같았던 부분도 여러 함수들로 조합을 하다보면 전부 추상화가 가능해 생산성이 올라간다.추상화가 가능하다는 것은 이 코드를 여기 저기서 쓸 수 있다는 것이고, 그렇게 된다면 당연히 코드를 짜는 시간이 줄어들기 때문이다.따라서 정말 보다보면 아무런 의미 없는 undefined를 리턴하는 함수, 값을 입력받아서 그대로 리턴하는 함수 등등뭐 이런 거까지 함수로 뽑아내나? 싶은 녀석들까지 있다고 한다. (아직 그런 걸 배워본 경지는 아니라서…) 이렇게 작은 단위로 쪼개서 함수를 만들다보면 테스트하기도 쉬워지고 오류가 날 가능성도 적어진다.또한 기존 객체 지향 프로그래밍에서는 사이드 이펙트 때문에 함수의 평가 시점에 따라서 결과가 다르게 나왔다.하지만 함수형 프로그래밍에서는 기본적으로 사이드 이펙트가 없는 순수 함수를 지향하기 때문에 어느 시점에 평가가 이루어져도 된다.따라서 기존 객체 지향 프로그래밍에서는 싱크를 맞추거나 락을 걸어놓거나 쓰레드 풀을 만들어 놓고기타 뻘짓을 했어야 했다는데(자바를 잘 몰라서 죄송합니다 ㅠㅠ) 함수형 프로그래밍으로 작성을 하면 언제 실행되던 간에 상관이 없는 것이다. 따라서 이러한 진가를 발휘하는 게 또 Node.js이다.기본적으로 자바와 같은 프로그램에서는 하나의 요청이 들어오면 하나의 쓰레드를 만들고,그 쓰레드는 그 유저의 요청이 끝날 때까지 해당 유저만 점령할 수 있는 것으로 알고 있다.하지만 Node는 하나의 요청이 들어오면 요청에 대한 처리를 돌리고, 그 처리가 끝나는 동안 다른 유저의 요청들을 받는다.그 이후에 기존 유저의 처리가 끝나면 콜백함수가 실행되는 싱글 스레드 형태이다.이렇게 비동기 I&#x2F;O로 서버를 구성하다보니 동접에 있어서 훨씬 적은 자원으로 효율성이 올라간다고 한다.이 비동기에서 중요한 것은 언제 실행하던 동일한 결과를 보장받아야 한다는 것이다.유저의 요청이 언제 끝나는지에 따라 실행 결과가 달라진다면 기존 자바와 같이 락을 걸어놓아야 할 것이다.하지만 순수 함수로 하다보면 이런 요청에 대한 평가가 언제 이루어지던 동일한 결과를 보장받으므로비동기 I&#x2F;O의 동시성, 병렬성 뭐시기 이런 것들을 더욱 쓸 수 있다는데… 요런 놈도 더 공부를 해야겠다. 이런 것들을 알고 보니 lodash나 underscore는 단순히 유틸성 라이브러리가 아니라함수형 프로그램 패러다임을 준수하여 코딩하는 걸 도와주는 차원의 라이브러리였다는 걸 깨닫게 되었다. 그럼 이제 바로 다음 포스트인 filter를 공부해보자!","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"}]},{"title":"Node.js란...?","slug":"what-is-node-js","date":"2017-06-18T21:12:33.000Z","updated":"2022-10-30T08:42:17.015Z","comments":true,"path":"2017/06/18/what-is-node-js/","link":"","permalink":"https://perfectacle.github.io/2017/06/18/what-is-node-js/","excerpt":"이 글을 쓰게 된 계기는 다음과 같다. Q: Node.js는 서버인가요?A: 네, 백엔드 개발자들이 Node.js를 씁니다. ‘백엔드 개발자도 쓸 뿐, 프론트 엔드 개발자도 쓸 수 있다’가 내가 내린 결론이고,오늘은 그에 대해 하나 하나 검증해보는 시간을 가져보고, 다른 사람들에게 잘못된 지식이 전파되는 걸 막고자 한다.혹시 내가 내린 결론이 잘못된 부분은 무한 태클을 환영한다. Node.js란…?","text":"이 글을 쓰게 된 계기는 다음과 같다. Q: Node.js는 서버인가요?A: 네, 백엔드 개발자들이 Node.js를 씁니다. ‘백엔드 개발자도 쓸 뿐, 프론트 엔드 개발자도 쓸 수 있다’가 내가 내린 결론이고,오늘은 그에 대해 하나 하나 검증해보는 시간을 가져보고, 다른 사람들에게 잘못된 지식이 전파되는 걸 막고자 한다.혹시 내가 내린 결론이 잘못된 부분은 무한 태클을 환영한다. Node.js란…? Node.js는 Chrome V8 Javascript 엔진으로 빌드된 Javascript 런타임이다.V8 자바스크립트 엔진은 여기서 중요한 포인트가 아니므로 직접 찾아보길 바란다. 런타임에 대해 정리한 다른 블로그의 포스트를 빌려보자면 다음과 같다. 런타임이란 프로그래밍 언어가 구동되는 환경 예전에는 자바스크립트 런타임이 브라우저 밖에 존재하질 않았다.하지만 그러한 한계를 극복하고 Node.js가 나왔다. Javascript 실행 환경?첫 번째로 Node.js는 REPL(Read, Eval, Print, Loop)을 통해서 런타임을 제공한다. Read: 유저의 입력 값을 받아서 메모리에 저장 Eval: 입력 값의 평가, 실행 Print: Eval로 인해 반환된 값을 출력 Loop: 1~3을 반복. 이러한 REPL은 Babel REPL과 같이 웹에서 제공해주기도 하고,Node.js에서 제공하는 REPL은 윈도우의 CMD, 맥의 터미널 등등에서 제공을 해준다. 두 번째로 따로 자바스크립트 파일을 Node.js에서 제공하는 자바스크립트 런타임을 통해 실행이 가능하다.위와 같이 REPL에서 개발을 하면 간단한 테스트 정도면 몰라도 어플리케이션을 개발하는 데 적합하지 않다.따라서 repl 보다는 따로 스크립트 파일을 만들어서 그 스크립트 파일을 node.js, V8이 해석 후 실행하는 형태로 작업을 많이 하게 된다.아래 소스 코드를 node.js에서 돌리는 것은 위의 REPL에서 실행한 것과 동일하다. 12345// a.jsconst a = 2;a;a + 4;console.log(a); 그럼 왜 Node.js는 백엔드 영역이라는 오해가 생겼을까?Node.js를 통해서 서버도 만들 수 있기 때문이다. 123456// server.jsconst http = require(&#x27;http&#x27;);http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); res.end(&quot;Hello World\\n&quot;);&#125;).listen(8080); 그럼 프론트 엔드 개발자는 언제 Node.js를 쓰는가?매우 빈번하게 쓰이는데 그 중에서 대표적으로 ES2015+ 문법을 ES5 문법으로 트랜스파일 해주는 Babel을 예로 들어보겠다.먼저 babel의 기본적인 요소들을 설치하겠다. 1npm i -S babel-cli babel-preset-env babel-cli, CLI이기 때문에 터미널 위에서 돌아간다는 점을 염두해두자. 그리고 간단한 바벨 설정 파일(.babelrc)을 만들어주자. 123&#123; &quot;presets&quot;: [&quot;env&quot;]&#125; 그 다음에 package.json의 npm script 부분을 다음과 같이 추가해주면 된다. 12345&#123; &quot;scripts&quot;: &#123; &quot;babel&quot;: &quot;babel&quot; &#125;&#125; 그리고 ES2015+의 간단한 파일을 하나 만들어보겠다. 12// a.jsconst a = 1; 터미널에서 babel-cli를 통해 해당 파일을 ES5로 트랜스파일 된 결과를 보자. 이게 뭐가 Node.js를 통해 실행한 내용인지 확인해보자.기본적으로 npm script는 node_modules 디렉토리 안의 .bin 디렉토리에 있는 디렉토리를 인식한다. 그리고 그 내용은 다음과 같다. 123#!/usr/bin/env noderequire(&quot;../lib/babel&quot;); #!/usr/bin/env node 요 구문으로 인해 node.js에서 cli를 만들 수 있게 해주는 것이라고 생각하면 된다.그럼 직접 ../lib/babel을 찾아가보자. Node.js에서 기본적으로 디렉토리 뒤에 따로 파일이 명시되지 않으면 index.js 파일을 찾아가는 규칙이 있다.index.js 파일의 상단 부분을 보면 다음과 같다. 123456789101112131415161718#!/usr/bin/env node&quot;use strict&quot;;var _keys = require(&quot;babel-runtime/core-js/object/keys&quot;);var _keys2 = _interopRequireDefault(_keys);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var fs = require(&quot;fs&quot;);var commander = require(&quot;commander&quot;);var kebabCase = require(&quot;lodash/kebabCase&quot;);var options = require(&quot;babel-core&quot;).options;var util = require(&quot;babel-core&quot;).util;var uniq = require(&quot;lodash/uniq&quot;);var glob = require(&quot;glob&quot;);// 이하 생략 소스 코드 첫 라인에 #!/usr/bin/env node을 보면 CLI임을 짐작할 수 있다.그럼 다음과 같이도 실행을 해볼 수도 있다는 말이 된다. 하지만 우리가 접근한 파일은 우리가 흔히 보고 있는 js 파일이다.Node.js는 자바스크립트를 실행해줄 수 있는 환경인 런타임을 제공해주기 때문에 다음과 같이도 할 수 있다. 즉, 바벨을 쓴다면, 프론트 엔드 개발자도 Node.js를 쓴다는 결론을 내릴 수가 있다.바벨 뿐만 아니라 웹팩, 걸프, CRA, Vue-CLI 등등 npm으로 설치하는 모든 CLI는 Node.js를 이용한다고 보면 된다.그리고 npm(Node Package Manger)을 쓴다는 것 자체가 Node.js를 이용한다고 보면 된다. 웹을 벗어난 Node.js Node.js는 확장성 있는 네트워크 애플리케이션을 위해 설계했다고 나온다.네트워크 어플리케이션, 즉 서버, 서버를 위해서 설계된 플랫폼이다.따라서 Node.js로 실제 구현하는 내용도 서버가 많다는 것에는 동의한다.또한 많은 프론트 엔드 개발자들이 주로 노드를 이용하는 사례인npm으로 의존성 모듈 관리, 바벨, 웹팩과 같은 CLI를 Node.js 위에서 구동하는 경우이 경우에 나 노드 할 줄 안다 라고 누군가에게 어필하기에는 다소 무리가 있을 수가 있다.왜냐면 노드로 서버를 구축하는 사례가 너무 많고, 이미 그런 오해가 정석처럼 받아들여지는 상황이라필드에 나가서 노드 할 줄 안다고 했을 때 나 노드로 서버 만들 줄 안다. 나 노드로 의존성 모듈 관리하고 CLI를 Node.js 위에서 돌릴 줄 알아.둘 중에 누구의 말로 받아들이는 경우가 더 많을까…이런 고민을 하다보니 그럼 웹이 아닌 경우에는 무엇이 있을까 고민하게 됐다. 데스크탑 어플리케이션을 제작해주는 일렉트론(Electron) 맥, 윈도우 등등의 크로스 플랫폼 데스크탑 어플리케이션을 HTML, CSS, JS를 통해 만들 수 있다.자세히 몰라서 아래의 사진으로 대체하겠다. 슬랙과 atom, vs code가 일렉트론으로 만들어졌다 하니 믿을만 하다고 할 수 있을 것 같다. 결론Node.js를 할 줄 안다고 하면 Node.js로 서버를 구성할 줄 안다라고 인식되는 것은 어느 정도 이해할 수 있다.하지만 Node.js 그 자체를 백엔드 자체만의 기술, 웹 서버 자체만으로 받아들이고프론트 엔드 개발자들은 Node.js를 쓸 줄 모른다는 그런 잘못된 지식으로 남들에게 더 이상 인식되지 않는 환경이 조성되길 바란다.명심하자.Node.js는 백엔드, 웹 서버가 아니라 자바스크립트 실행 환경에 불과하다 참조 링크 런타임이란? REPL 터미널 Electron으로 웹 앱 만들듯 데스크톱 앱 만들기","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Node.js","slug":"Programming/Node-js","permalink":"https://perfectacle.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"}]},{"title":"(자알쓰) 연산자","slug":"js-008-operator","date":"2017-06-02T09:35:42.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/06/02/js-008-operator/","link":"","permalink":"https://perfectacle.github.io/2017/06/02/js-008-operator/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여덟 번째 시리즈는 연산자를 주제로 진행하겠다. 캐스팅(Casting) 연산자캐스팅이라 하면 형변환이랑 동일하다고 보면 된다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여덟 번째 시리즈는 연산자를 주제로 진행하겠다. 캐스팅(Casting) 연산자캐스팅이라 하면 형변환이랑 동일하다고 보면 된다. Any -&gt; String123456console.log(false.toString()); // &#x27;false&#x27;console.log(new String(true).toString()); // &#x27;true&#x27;console.log(String(null)); // &#x27;null&#x27;// 제일 간결해서 추천한다.console.log(&#x27;&#x27; + undefined); // &#x27;undefined&#x27; Any -&gt; Number123456789101112console.log(parseInt(true)); // NaNconsole.log(parseFloat(null)); // NaNconsole.log(new Number(&#x27;11a&#x27;).valueOf()); // NaNconsole.log(Number(&#x27;123&#x27;)); // 123console.log(1 * &#x27;334&#x27;); // 334console.log(&#x27;123.4&#x27; / 1); // 123.4console.log(-(-&#x27;445.2&#x27;)); // 445.2console.log(~~&#x27;112.2&#x27;); // 112// + 연산자가 제일 간결하고, 소수점 이하 보존도 되고, ES6+에서 생긴 이진수, 십진수 리터럴도 지원한다. console.log(+&#x27;0b1111&#x27;); // 15console.log(+&#x27;1233.3&#x27;); // 1233.3 Any -&gt; Boolean12345console.log(Boolean(null)); // falseconsole.log(new Boolean(undefined).valueOf()); // false// 아래가 제일 간결해서 아래를 추천한다.console.log(!!2); // true &#x3D; 연산자의 비밀&#x3D; 은 우항의 값을 좌항의 변수에 할당할 때 쓰는 할당 연산자이다.하지만 모든 연산자에는 반환 값이 존재한다. 반환값 없는 연산자는 존재하지 않는다. 1234567var a = 2;var b;var c;console.log(c = b = a = 3); // 3console.log(a); // 3console.log(b); // 3console.log(c); // 3 a &#x3D; 3에 의해 3이 a에 할당된다. b &#x3D; a에 의해 a의 값인 3이 b에 할당된다. c &#x3D; b에 의해 b의 값인 3이 c에 할당된다. &#x3D; 연산자는 우항의 값을 반환하는 연산자이므로 3이 반환된다. 이렇게 &#x3D; 연산자는 변수 할당문으로 쓸 수 있지만 그 자체가 연산자이기 때문에 표현식으로써의 기능도 충실히 수행할 수 있다.표현식이기 때문에 변수에 할당할 수 있다는 것은 당연한 소리다.위를 보고 변수 할당 체이닝이라 부르려나.. 쉼표(,) 연산자의 비밀, 또한 연산자이다. 그 말은 반환값이 있다는 것이다.우선 ,의 사용 사례를 보도록 하자. 1234567891011121314151617181920// 1. 변수 선언문var i = 2;var j = 3;var k;// 아래와 같이 할 수도 있다.// var i = 2, j = 3, k;// 2. 함수 선언문(표현식)function a(b, c) &#123; return b*c; &#125;// 3. 함수 호출문a(2, 3); // 6// 그렇다면 , 연산자의 반환 결과는 무엇일까?console.log((1, 2, 3)); // 3var a = 2, b = 2;console.log((a += 2, b += 3, a*b)); // 20console.log(a); // 4console.log(b); // 5 쉼표 또한 연산자이고 가장 우측에 있는 녀석의 값을 반환한다는 사실을 알았다.신기하다. n제곱 연산자(ES2016+)ES2016+이기 때문에 웬만해서는 바벨을 돌려야할 것이다. 1console.log(2 ** 3); // 8 기타 유용한 연산자&amp;&amp;, ||와 같은 똑똑한 논리 연산자, ~(Tilde) 연산자도 참고해보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Value","slug":"Value","permalink":"https://perfectacle.github.io/tags/Value/"},{"name":"Expression","slug":"Expression","permalink":"https://perfectacle.github.io/tags/Expression/"},{"name":"Statement","slug":"Statement","permalink":"https://perfectacle.github.io/tags/Statement/"}]},{"title":"(자알쓰) 값 vs 식 vs 문","slug":"js-007-value-expression-statement","date":"2017-06-02T09:35:27.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/06/02/js-007-value-expression-statement/","link":"","permalink":"https://perfectacle.github.io/2017/06/02/js-007-value-expression-statement/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 일곱 번째 시리즈는 값 vs 식 vs 문을 주제로 진행하겠다. 값(Value)값은 고정적이다. 변하지 않는다. 너무 쉬워서 뭐라 달리 설명할 게 없다.아래와 같은 것을 값이라고 부른다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 일곱 번째 시리즈는 값 vs 식 vs 문을 주제로 진행하겠다. 값(Value)값은 고정적이다. 변하지 않는다. 너무 쉬워서 뭐라 달리 설명할 게 없다.아래와 같은 것을 값이라고 부른다. 123456789101112131415161718192021222324252627282930313233// 1. Undefinedconsole.log(undefined);// 2. Nullconsole.log(null);// 3. Booleanconsole.log(true);console.log(false);// 4. Numberconsole.log(1);console.log(0);console.log(-2.1);console.log(NaN);console.log(-0);console.log(Infinity);console.log(-Infinity);// 5. Stringconsole.log(&#x27;&#x27;);console.log(&#x27;\\n&#x27;);console.log(&#x27;aa qq&#x27;);// 6. Symbol (ES2015+)console.log(Symbol(&#x27;aa&#x27;));console.log(Symbol.for(&#x27;qqq&#x27;));// 7. Objectconsole.log(function()&#123;&#125;);console.log([]);console.log(&#123;&#125;);console.log(/a/); Falsy Value &amp;&amp; Truthy valueFalsy Value는 조건식에서 false로 취급되는 모든 경우를 뜻한다.다음과 같다. 123456console.log(!!0);console.log(!!NaN);console.log(!!&#x27;&#x27;);console.log(!!undefined);console.log(!!null);console.log(false); Truthy Value는 조건식에서 true로 취급되는 값이고 위의 경우를 제외하고 전부이다. 식(Expression)표현식이라고도 부른다.평가(실행)했을 때 값을 반환하는 녀석은 전부 식이라고 한다.다음과 같이 말도 안 되는 것 같이 보이는 것들도 식이라고 할 수 있다. 123456789101112var a = 2;function b(c) &#123; return c*c; &#125;// 대부분은 아래와 같이 변수 할당&#x27;문&#x27;(?)의 형태로만 써봤을 것이다.// a = 3;console.log(a = 3); // 3console.log(b(2)); // 8console.log((a=3, false, 3+7)) // 10// 아래 코드를 다음과 같이 쓸 수 있다. 물론 권장하지 않는다.// a = 1 &gt; a ? 3 : 2;1 &gt; a ? a = 3 : a = 2; 제일 기괴한 것은 a = 3을 문이 아닌 식으로써 쓸 수 있다는 것이다.대부분 a &#x3D; 3; 과 같이 문으로써는 써봤어도 식으로써는 써본 적이 적거나 없을 것이다.여기서는 일단 위 구문을 식으로써 써서 값을 반환한다는 정도만 알아두자.다음에 연재할 연산자 파트에서 자세히 알아보도록 하자.여기서 알아둘 점은 식은 값을 반환하고 그 값을 변수에 할당이 가능, 즉 변수 할당문 우변에 사용이 가능하다는 뜻이다.혹은 반복문이나 조건문의 조건식, 반복문의 증감식 등등에도 쓰일 수 있고 삼항 연산자,함수의 반환값 등등에서도 충분히 사용이 가능하니 꼭 알아둬야할 부분이다. 문(Statement)세미콜론을 만나면 문이라고 생각하면 된다.단 조건문, 반복문, 함수 선언문, 예외 처리 구문 등등과 같이 블록(&#123;&#125;)이 들어간 구문은문 끝에 세미콜론이 포함되면 문법 상 옳지 않다. 123456789101112if(1 &gt; 10) &#123; alert(1); &#125; // 조건문while(false) &#123; alert(2); &#125; // 반복문function x()&#123;&#125; // 함수 선언문// 예외 처리 구문try &#123;&#125;catch(e) &#123;&#125;var z; // 변수 선언문z = 2; // 변수 할당문x(); // 함수 호출문var y = function(a)&#123; // 변수 초기화 구문 return a; // 값 반환 구문&#125;; 문 중에는 변수 할당문과 함수 호출문 같이 식으로써 쓰일 수 있는 것도 있다.하지만 다른 문들은 값, 식과는 달리 할 수 없는 게 있다.바로 문은 변수에 할당이 불가능하다.상식적으로 if 문을 변수에 할당한다고 생각하면 말이 안 된다고 볼 수 있다.예외로 함수 선언문은 함수 표현식으로 변환이 되어 변수에 할당이 가능하다. 막상 적고 보니 별로 생각나는 게 없으니 이만 마무리하고 연산자 파트까지 보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Value","slug":"Value","permalink":"https://perfectacle.github.io/tags/Value/"},{"name":"Expression","slug":"Expression","permalink":"https://perfectacle.github.io/tags/Expression/"},{"name":"Statement","slug":"Statement","permalink":"https://perfectacle.github.io/tags/Statement/"}]},{"title":"(자알쓰) 반복문의 진실 (번외편)","slug":"js-loop-truth","date":"2017-06-02T09:35:00.000Z","updated":"2022-10-30T08:42:16.699Z","comments":true,"path":"2017/06/02/js-loop-truth/","link":"","permalink":"https://perfectacle.github.io/2017/06/02/js-loop-truth/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에도 번외편 격으로 반복문의 진실에 대해 알아보도록 하자. 반복문의 진실?사실 리덕스의 하나의 진실의 근원(Single Source of Truth)에서 영향을 받았다.우선 가장 간단한 1~10까지 더해서 출력하는 for 문을 살펴보도록 하자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에도 번외편 격으로 반복문의 진실에 대해 알아보도록 하자. 반복문의 진실?사실 리덕스의 하나의 진실의 근원(Single Source of Truth)에서 영향을 받았다.우선 가장 간단한 1~10까지 더해서 출력하는 for 문을 살펴보도록 하자. 12345var sum = 0;for(var i=1; i&lt;11; i++) &#123; sum += i;&#125;console.log(i); // 55 for 문은 아래와 같이 나눌 수 있다. 다른 곳에서는 선언 및 초기화, 조건식, 증감식으로 했는데나는 거기다 표현식까지 붙였다. 위 구문은 아래와 같이 줄일 수 있다.for, while, if 문 등등은 실행 구문이 한 줄이면 대괄호가 생략 가능하다. 12var sum = 0;for(var i=1; i&lt;11;) sum += i++; 증감 표현식은 필수가 아니다.또한 초기화 및 선언 구문도 필수가 아니기 때문에아래와 같이 줄일 수 있지만 전역 스코프를 더럽힐 가능성이 있기 때문에해당 변수를 스코프 외부에서도 쓰려는 특수한 경우가 아닌 이상은 권장하지 않는다. 1234var sum = 0;var i = 1;for(; i&lt;11;) sum += i++;console.log(sum); // 55 이제부터 나오는 걸 실무에서 사용했다간 협업자나 사수에게 등짝 스매싱을 당할 수도 있다.하지만 증감 표현식을 달리 생각해보면 그냥 표현식으로 볼 수도 있다.반복문의 실행 구문, {} 안의 내용(여기선 생략했지만),이 끝난 이후에 한 번 실행되는 표현식에 불과하다고 볼 수 있다.아래와 같이 말이다. 1234var sum = 0;var i = 1;for(; i&lt;11; sum += i++);console.log(sum); // 55 sum += i++ 이게 문이 아니라 표현식으로써 쓰일 수가 있다.표현식이라 하면 평가(실행)를 하여 값을 반환할 수 있으면 표현식이라 부를 수 있다.sum +&#x3D; i++에 의해 우선 sum에 sum + i++의 값이 할당되게 된다.그리고 그 반환값은 sum + i++이 된다.하지만 우리에게 중요한 것은 sum에 sum + i++의 값이 담겼다는 게 중요하지 그것의 반환값은 중요하지 않다.또한 그 자체만으로 표현식이기 때문에 조건과 관련이 있는 i에 i++과 같은 증감의 내용을 담고 있다면증감 표현식 자리에 반복문의 실행 구문이 들어갈 수 있게 되는 것이다. 하지만 여기서 멈춘다면 진실의 근원으로부터 멀어질 수가 있다.이 증감 표현식 부분 마저도 줄여버릴 수가 있다.아래와 같이 말이다. 1234var sum = 0;var i = 1;for(; i&lt;11 &amp;&amp; (sum += i++););console.log(sum); // 55 &amp;&amp; 뒷부분을 괄호로 묶어주지 않으면 &amp;&amp; 연산자가 우선순위가 더 높아11 &amp;&amp; sum을 먼저 평가하고 거기다가 +&#x3D; 연산을 수행하므로 괄호로 묶어줘야한다.&amp;&amp; 연산자의 동작 원리가 궁금한 사람은 을 참고하자. 물론 해당 내용은 while에게도 적용이 된다. 12345678910111213var sum = 0;var i = 1;while(i&lt;11) &#123; sum += i; i++;&#125;console.log(sum); // 55sum = 0;i= 1;// 위 while문을 줄이고 줄여보자.while(i&lt;11 &amp;&amp; (sum += i++));console.log(sum); // 55 do-while은 귀찮으니 그만 알아보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Loop","slug":"Loop","permalink":"https://perfectacle.github.io/tags/Loop/"}]},{"title":"(자알쓰) 훼이크 연산자 (번외편)","slug":"js-fake-operator","date":"2017-05-30T09:39:29.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/05/30/js-fake-operator/","link":"","permalink":"https://perfectacle.github.io/2017/05/30/js-fake-operator/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 번외편 격으로 훼이크 연산자를 배워보도록 하자.아이디어를 제공해주신 백성훈 님께 감사를 전한다. 훼이크 연산자?말 그대로 훼이크 연산자이다. 공식 명칭은 아니다.의도한 대로 동작하지 않는 연산자를 뜻한다.어찌보면 왜 이렇게 스펙에 구현됐는지 이해하기 힘든 내용이라서 굳이 몰라도 될 것 같기도 하다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.이번에는 번외편 격으로 훼이크 연산자를 배워보도록 하자.아이디어를 제공해주신 백성훈 님께 감사를 전한다. 훼이크 연산자?말 그대로 훼이크 연산자이다. 공식 명칭은 아니다.의도한 대로 동작하지 않는 연산자를 뜻한다.어찌보면 왜 이렇게 스펙에 구현됐는지 이해하기 힘든 내용이라서 굳이 몰라도 될 것 같기도 하다. 기본적으로 함수 선언문은 함수의 이름이 필수적이다. 12function a() &#123;&#125;function() &#123;&#125; // Uncaught SyntaxError: Unexpected token ( 그에 반해 함수 표현식은 함수의 이름이 옵션이다.디버깅을 위해서 권장을 한다지만 크롬에서는 이마저도 기본으로 제공해주는 것 같다. 12const a = function a() &#123;&#125;;const b = function() &#123;&#125;; 에러가 전혀 나질 않는다.하지만 여기서 공통된 부분이 보인다. 12345// 함수 선언문에서 이름을 뺀 부분, 비록 에러가 나지만...function() &#123;&#125;// 함수 표현식에서 이름을 뺀 부분const b = function() &#123;&#125;; 위 두 구문에서 변수 선언을 제외하고는 완전히 일치한다.이 내용들이 아래 (훼이크)연산자들을 만나면 시너지(?)를 발휘한다.모두 단항(Unary) 연산자들이다. 1+ - ! ~ 단항 연산자가 뭐라고 훼이크 연산자라고 말하는지 모르겠다면최신 스펙 문서인 ES2017 스펙의 Unary Operator 부분에서 대표적으로 Unary + Operator만 살펴보자. 맨 위에 보이듯이 우선 우리가 예측하는, + 연산자의 기능은 뒤에 있는 표현식의 평가 결과로써 얻어지는 값을 숫자형으로 변환해주는 기능을 한다.그렇다. + 뒤에있는 녀석은 무조건 표현식으로 취급한다.그 뒤에 있는 녀석이 표현식으로서의 문법만 지켰다면 선언문이어도 표현식인 것처럼 강제로 문변환? 식변환?이 일어나게 되는 것이다.그렇다면 우리가 살펴볼 훼이크 오퍼레이터 부분은 아래 부분에 나온다.evaluating UnaryExpression. + 뒤에 나오는 단항 표현식을 평가한다고 하는 것 같다.그렇다면 여기서 한 번 짱구를 굴려봐서 선언문을 표현식으로서 강제시켜서 써먹을 수 있는 방법이 있을까? 라는 생각까지 미치게 된다. (사실 나도 다른 글을 보고 유추한 거지만…)그렇다면 선언문과 표현식이 같은 문법으로 쓰이는 경우를 찾아보니 위에 적어논 익명(?) 함수 선언문과 익명 함수 표현식이었다.익명 함수 선언문은 오류를 뿜지만 이를 표현식으로써 사용한다면 문법상 오류를 뿜어내질 않는다.확인해보자. 12345678// 함수 표현식을 평가해서 나오는 것은 함수 그 자체이다.// 왜냐하면 함수를 호출해서 true를 반환한 게 아니기 때문이다.// 이 함수 그 자체를 숫자형으로 바꾸니 Not a Number(NaN)이 나오는 것이다.console.log(isNaN(+function() &#123;return true;&#125;)); // true// 내 말이 안 믿긴다면 아래의 결과로 확인해보자.const a = function() &#123;return true;&#125;;console.log(+a); // NaN 이렇게만 쓰면 의미가 없으니 대부분 IIFE(Immediately Invoked Function Expressions, 즉시 실행 함수)와 엮어서 많이 쓴다. 1234// 이렇게 쓰는 이유는 두 가지가 있는 것 같다.// 즉시 실행 함수의 가독성이 떨어지거나 보기 흉해서 보기 좋게 표현하려고,// 혹은 반환값을 가지고 다른 연산을 해야하는 경우인 것 같다.+function() &#123;return true;&#125;() === 1; 그런데 나는 딱히 즉시 실행 함수의 가독성이 나쁘다고 생각해본 적이 없고,즉시 실행 함수의 반환값을 가지고 뭘 해본 적이 없어서 딱히 필요성은 잘 모르겠다.다만 선언문 형태를 표현식으로서 취급한다는 게 신기했다. 참고 링크 JavaScript plus sign in front of function name Fake operator overloading in JavaScript","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Operator","slug":"Operator","permalink":"https://perfectacle.github.io/tags/Operator/"},{"name":"Unary","slug":"Unary","permalink":"https://perfectacle.github.io/tags/Unary/"}]},{"title":"성공(?)한 겜덕이 되다","slug":"become-successful-gamtaku","date":"2017-05-26T09:07:59.000Z","updated":"2022-10-30T08:42:16.143Z","comments":true,"path":"2017/05/26/become-successful-gamtaku/","link":"","permalink":"https://perfectacle.github.io/2017/05/26/become-successful-gamtaku/","excerpt":"나의 유년시절을 함께한 슈퍼 패미콤6세 경에 명절이 되면 할머니 집에 친척들이 다 같이 모여 슈퍼 패미콤으로 게임을 하였다.당시 미국에 살았던 친척 형네서 사온 것으로 알고 있는데, 그 형이 게임을 잘해서 덕분에 명절 때마다 항상 즐거웠다.슈퍼 스트리트 파이터 2, 슈퍼 동키콩 2, 슈퍼 마리오 월드, 요시 아일랜드 등등 정말 재미있게 했다.지금도 그 때 그 시절을 회상하면 참 그립다. 따라서 나는 아직도 슈퍼 패미콤이란 단어만 들어도 가슴이 뛰고 항상 그립다.초등학생 때 슈퍼 마리오 RPG의 한글패치를 접하면서 게임을 한글로 바꿀 수 있다는 사실을 알게 되었다.하지만 당시 나는 프로그래밍의 ‘프’자도 모르던 상황이라 미완성 패치를 즐기는 것으로 만족할 수 밖에 없었다.","text":"나의 유년시절을 함께한 슈퍼 패미콤6세 경에 명절이 되면 할머니 집에 친척들이 다 같이 모여 슈퍼 패미콤으로 게임을 하였다.당시 미국에 살았던 친척 형네서 사온 것으로 알고 있는데, 그 형이 게임을 잘해서 덕분에 명절 때마다 항상 즐거웠다.슈퍼 스트리트 파이터 2, 슈퍼 동키콩 2, 슈퍼 마리오 월드, 요시 아일랜드 등등 정말 재미있게 했다.지금도 그 때 그 시절을 회상하면 참 그립다. 따라서 나는 아직도 슈퍼 패미콤이란 단어만 들어도 가슴이 뛰고 항상 그립다.초등학생 때 슈퍼 마리오 RPG의 한글패치를 접하면서 게임을 한글로 바꿀 수 있다는 사실을 알게 되었다.하지만 당시 나는 프로그래밍의 ‘프’자도 모르던 상황이라 미완성 패치를 즐기는 것으로 만족할 수 밖에 없었다. 그렇게 기억 속에 묻어뒀던 한글패치였는데 대학을 컴공으로 진학하게 되고,강좌를 보고 롬파일들을 분석하면서 어느 정도 할 수 있게 되면서 여러 게임들을 한글로 패치하게 되었다. 분석부터 번역가를 구하고 최종 검수까지 험난한 여정이 진행되지만,내 대학 생활은 그런 취미 생활로 인해 활력이 부여된 것 같다.지금은 생업과 다른 취미가 생겨 한글화를 접었지만, 후일에 또 할지도 모르겠다.내가 한 한글화는 다음과 같다. 초오공전 돌격편 초오공전 각성편 슈퍼마리오 RPG 고스트 트릭 제절초 생전 처음으로 팬(?)이 생기다위에서 한 게임 중에 가장 네임드 있는 작품은 슈퍼마리오 RPG와 고스트 트릭이다.그 중에서도 슈퍼마리오 RPG는 발매된 지 20년이 넘은 작품이라 그런지요즘 콘솔 게임을 즐기는 사람들보다 더 추억에 젖어있고 연배가 있는 매니아 층이 형성된 것 같다.그래서인지 2월 경에 직접 팩에다가 납땜을 해서 한글패치 된 팩을 제작해서 보내주신 분도 계신다. 정말 정말 뿌듯했다.한글화 하면서 가장 뿌듯했던 적이 아닐까 싶다.나름 유명(?)해졌다는 착각에 빠지기도 하면서 마냥 기분이 좋았다 ㅎㅎ 실기로 한글 패치 구동하기슈퍼 패미콤을 약 9세 경에 친척에게 떠나보내고, 실물을 보지 못한 지 어언 16년이 되었다.아직도 슈패하면 가슴이 뛴다. 하지만 막상 사라고 하면 사고 싶진 않은 걸 왜일까…요 근래 생일을 맞아 고스트 트릭을 번역해줬던 지인이 슈퍼 패미콤을 선물해주었다.하지만 110v 전원이라 바로 구동하진 못하고 변압기를 다시 구매하고 오늘에서야 도착을 했다.부푼 마음으로 연결하고 구동을 해봤는데, 레트로 TV가 아니라 화면이 많이 뭉개지지만 너무 가슴이 벅차 올랐다. 정말 인복이 타고난 것 같다.내심 내가 한글 패치 제작했으니 누군가 나에게 선물해 줬으면… 하는 마음도 가졌지만정말 뜻 깊고 내 유년시절로 돌아간 것 같은 시간이었다.잠깐 추억팔이 하고 말 줄 알았는데 게임을 하다보니 한글에다가 옛 추억들이 새록새록 피어나서 은근히 재미있다.역시 게임은 실기로 해야 제맛인 것 같다.언젠가 다시 한글화를 재개할 지는 모르겠지만… 이 맛에 한글화 하는 게 아닌가 싶다 ㅎㅎ행복한 밤이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"https://perfectacle.github.io/tags/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}]},{"title":"(자알쓰) 모듈화 Part. 2","slug":"js-006-module","date":"2017-05-20T21:43:33.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/05/20/js-006-module/","link":"","permalink":"https://perfectacle.github.io/2017/05/20/js-006-module/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여섯 번째 시리즈는 ES2015+의 Module(모듈)을 주제로 진행하겠다.일단 ES5 이하에서 모듈화를 읽고 오길 바란다. import&#x2F;exportES5 이하에서는 네임스페이스 패턴을 이용해 모듈화를 진행했지만 전역 스코프를 더럽힌다는 단점,전역 스코프를 더럽히지 않으려면 즉시 실행함수 패턴을 이용해야하지만 외부에서 접근이 불가능하다는 단점이 존재했다.진정한 모듈이라고 하면 외부에서 참조가 가능하면서 전역 스코프를 더럽히면 안 된다.그를 해결한 게 ES2015의 import&#x2F;export 문법인데 지원 가능한 브라우저/노드가 없다.바벨이라는 트랜스파일러를 사용해서 ES5로 변환해도 Node.js에서 밖에 안 되고,브라우저에서는 모듈들을 하나로 합쳐주는 웹팩과 같은 모듈 번들러를 이용하는 수 밖에 없다.일단 스펙에는 표준으로 등록됐으니 한 번 알아보도록 하자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 여섯 번째 시리즈는 ES2015+의 Module(모듈)을 주제로 진행하겠다.일단 ES5 이하에서 모듈화를 읽고 오길 바란다. import&#x2F;exportES5 이하에서는 네임스페이스 패턴을 이용해 모듈화를 진행했지만 전역 스코프를 더럽힌다는 단점,전역 스코프를 더럽히지 않으려면 즉시 실행함수 패턴을 이용해야하지만 외부에서 접근이 불가능하다는 단점이 존재했다.진정한 모듈이라고 하면 외부에서 참조가 가능하면서 전역 스코프를 더럽히면 안 된다.그를 해결한 게 ES2015의 import&#x2F;export 문법인데 지원 가능한 브라우저/노드가 없다.바벨이라는 트랜스파일러를 사용해서 ES5로 변환해도 Node.js에서 밖에 안 되고,브라우저에서는 모듈들을 하나로 합쳐주는 웹팩과 같은 모듈 번들러를 이용하는 수 밖에 없다.일단 스펙에는 표준으로 등록됐으니 한 번 알아보도록 하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// export 키워드로 모듈(변수라고 보이지만 이 변수가 하나의 일을 수행하는 모듈이 될 수도 있다.)을 내보내고 있다.// a.jsexport const a = 11;export const b = 22;const ajax = function(url) &#123; // 비동기 통신을 하는 함수.&#125;;// 그걸 외부에서 사용할 수 있게 끔 모듈로 만듦.// default로 만들 수 있는 모듈은 파일 당 한 개 뿐이다. export default c;// b.jsexport const a = 33;export const b = 44;const getLastIndex = function(arr) &#123; // 배열의 마지막 인덱스를 구하는 함수.&#125;;// 그걸 외부에서 사용할 수 있게 끔 모듈로 만듦. export default c;// a파일에 존재하는 모듈과 b파일에 존재하는 모듈들을 써서 실제로 앱을 만들어보자 // app.js// default 키워드로 export 한 모듈은 &#123;&#125; 안에 안 써줘도 된다.// 그냥 export 한 모듈은 &#123;&#125; 요 안에 모듈 이름을 적어줘야한다.// export 한 모듈을 한 번에 다 import 하려면 * as A 하면 A 객체의 프로퍼티로 모듈이 전부 바인딩 된다.import ajax, * as A from &#x27;./a.js&#x27;;// default 키워드로 export 한 모듈은 이름을 어떻게 불러와도 사용이 가능하다.// b.js에 a란 모듈을 불러오려고 했는데 이미 a란 모듈이 불러와졌거나 a라는 이름이 마음에 안 들면// as 라는 별칭 키워드를 써서 _a로 이름을 바꿔서 불러오고 있다.// b는 export 했지만 안 쓴다면 export하지 않아도 된다.import getLastIdx, &#123;a as _a&#125; from &#x27;./b.js&#x27;console.log(A.a); // 11console.log(A.b); // 22console.log(_a); // 33// 모듈을 마음대로 불러다 쓸 수 있다.ajax(&#x27;http://www.naver.com&#x27;);getLastIdx([1, 2, 3, null, undefined, 7]); 전역 스코프를 더럽히지도 않으면서 네이밍도 자유로워지고 불러올 때도 입맛에 맞춰 불러올 수 있다.사실 여기서 설명한 모듈화는 빙산의 일각이고(내가 일각만 알고 있기도 하고…),import &#x2F; export에서 좀 더 자세한 설명을 참고하고,추가적으로 Node.js 진영에서 모듈화를 위해 사용하는 CommonJS 스펙과 브라우저 진영에서 사용했던 AMD 스펙을 비교&#x2F;정리 해주는JavaScript 표준을 위한 움직임: CommonJS와 AMD 포스팅을 참고하길 바란다.다음으로는 자료형과 변수에 대해서 정리를 해 볼 예정이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Module","slug":"Module","permalink":"https://perfectacle.github.io/tags/Module/"},{"name":"import","slug":"import","permalink":"https://perfectacle.github.io/tags/import/"},{"name":"export","slug":"export","permalink":"https://perfectacle.github.io/tags/export/"}]},{"title":"(자알쓰) 모듈화 Part. 1","slug":"js-005-module","date":"2017-05-20T09:14:47.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/05/20/js-005-module/","link":"","permalink":"https://perfectacle.github.io/2017/05/20/js-005-module/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 다섯 번째 시리즈는 모듈화를 주제로 진행하겠다. 모듈화란?저번 시간에 아래와 같은 문제점이 존재한다는 것을 발견했다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 다섯 번째 시리즈는 모듈화를 주제로 진행하겠다. 모듈화란?저번 시간에 아래와 같은 문제점이 존재한다는 것을 발견했다. 1234&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;!-- 요 사이에 내 부사수가 작성한 c.js를 로딩시켰다. --&gt;&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt; 123456789101112131415161718192021&#x27;use strict&#x27;;// 내가 작성한 a.jsvar num = 1;// 내 부사수가 작성한 c.js// 블라블라var num = 2;// 블라블라// 내가 작성한 b.jswindow.onload = function() &#123; &#x27;use strict&#x27;; var btnA = document.getElementById(&#x27;a&#x27;); var btnB = document.getElementById(&#x27;b&#x27;); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; a와 b 버튼을 누르면 내가 작성한 a.js의 num이 아닌 부사수가 작성한 c.js의 num값인 2가 출력된다.a보다 c.js를 더 늦게 불러왔고 js의 스코프는 모듈(이해하기 쉽게 설명하면 파일) 단위가 아니기 때문이다. 이런 문제점을 극복하고자 아래와 같은 패턴이 존재한다. 네임스페이스 패턴C++에서 처음 이 단어를 접했는데 일단 뭐 그 부분은 알아서들 찾아보고,그럼 어떻게 활용하는지 알아보자. 1234567891011121314151617181920// 내가 작성할 a.jsvar util = util || &#123;&#125;;util.num = util.num || 1;// 부사수가 작성할 c.jsvar util2 = util2 || &#123;&#125;;util2.num = util2.num || 2;// 내가 작성할 b.jswindow.onload = function() &#123; &#x27;use strict&#x27;; var btnA = document.getElementById(&#x27;a&#x27;); var btnB = document.getElementById(&#x27;b&#x27;); btnA.onclick = function() &#123; console.log(util.num); &#125;; btnB.onclick = function() &#123; console.log(util.num); &#125;&#125;; 이제 부사수가 지지고 볶고 자신의 스크립트를 어디서 불러오든간에부사수가 util 객체만 건드리지 않는다면 내 코드는 안전을 보장받는 것이다. 그럼 저 || or 연산자는 왜 썼는지 알아보자.||의 원리가 궁금한 사람은 (ES) 똑똑한 논리 연산자를 참고하자. 1234567891011121314151617181920212223242526// 내가 작성한 util 모듈// util 이라는 1차 네임 스페이스var util = util || &#123;&#125;;// array라는 2차 네임 스페이스util.array = util.array || &#123;&#125;;util.array.getIdx = util.array.getIdx || function(val, array) &#123; // 블라블라&#125;;// 자바스크립트 파일이 너무 많아서 util이란 모듈이 존재하는지 모르고// || 연산자(기본값 지정)을 사용하지 않고 util 모듈을 재정의할 경우var util = &#123; string: &#123; getLastChar: function(str) &#123; // 블라블라 &#125; &#125;&#125;// 내가 작성한 util 모듈을 쓴 다른 코드var arr = [1, 4, 7];// 부사수가 정의한 util 모듈에 의해 array 네임스페이스는 날아간 상태임.// 따라서 오류가 발생함.var midIdx = util.array.getIdx(7, arr); 위와 같은 상황이 발생할까봐 좀 귀찮더라도 || 연산자를 써서 모듈을 정의할 것을 추천한다.아래와 같이 작성해야한다. 12345678910111213141516171819202122232425262728293031323334// 내가 작성한 util 모듈// util 이라는 1차 네임 스페이스var util = util || &#123;&#125;;// array라는 2차 네임 스페이스util.array = util.array || &#123;&#125;;util.array.getIdx = util.array.getIdx || function(val, array) &#123; // 블라블라&#125;;// 자바스크립트 파일이 너무 많아서 util이란 모듈이 존재할까봐 기본값 패턴을 써서 util 모듈을 정의한 경우var util = util || &#123;&#125;;util.string = util.string || &#123;&#125;;util.string.getLastChar = function(str) &#123; // 블라블라&#125;;// 따라서 util 모듈은 아래와 같은 형태를 띈다.// 내가 작성한 util 모듈을 전혀 훼손시키지 않고 부사수의 모듈과 결합이 되었다.// 뭐 사실 모듈 간에 이름은 최대한 겹치지 않고 작하는 게 맞는 것 같다.util = &#123; array: &#123; getIdx: function(val, array) &#123;&#125; &#125;, string: &#123; getLastChar: function(str) &#123;&#125; &#125;&#125;;// 내가 작성한 util 모듈을 쓴 다른 코드var arr = [1, 4, 7];// 내가 작성한 util 모듈의 array 네임스페이스는 살아있음.var midIdx = util.array.getIdx(7, arr); 하지만 매번 있는지 없는지 기본 연산자로 체크하고 귀찮기도 하고,만약에 그 값이 존재한다면 내가 쓰려고 하는 값이 아닌 기존의 값으로 대체가 돼버리니재정의가 불가능해질 수도 있다.이를 위해서 ES2015에 대한 모듈화 포스팅을 참고하자. 스코프 강제 형성ES2015+는 블록 단위의 스코프라 {}만 써도 강제로 스코프가 형성이 됐었다.그럼 함수 단위의 스코프인 ES5에서는 어떻게 할 수 있을까? 123456789101112131415// 함수를 임의로 만들면 된다.// 근데 함수는 만든다고 실행하는 게 아니니 함수를 만들자마자 실행해야한다.(function() &#123; // 즉시 실행할 것이기 때문에 재호출할 일이 없으니 이름이 필요 없으니 익명함수로 작 var a = 11; console.log(a);&#125;)(); // 그 함수를 실행// 이를 즉시 실행함수(IIFE: Immediately Invoked Function Expressions)라고 부른다. // 대개 1회성 함수, 한번만 쓰는 코드, 클로저 등등에 쓰는데// 전역 스코프를 더럽히지 않는다는 장점 때문에 나는 무조건 쓴다. // 하지만 외부에서 참조해야하는 경우에는 네임스페이스 패턴을 이용해 모듈화를 진행해서 쓰는 편이다.// 사실 ES2015+ 들어가면 이렇게 절대 안 쓰니 딥하게 파고들 필요는 없는 것 같다.(function() &#123; console.log(a); // a is not defined&#125;()); 위와 같은 즉시 실행함수 패턴은 단순 1회성 코드, 즉 다시는 참조할 일이 없는 코드들만 넣을 때 썼다.전역의 스코프를 더럽히지 않아 변수 네이밍이 자유롭다는 장점이 있다.다음 포스트에서는 ES2015+에서 모듈화를 어떻게 진행하는지 알아보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Module","slug":"Module","permalink":"https://perfectacle.github.io/tags/Module/"},{"name":"Namespace","slug":"Namespace","permalink":"https://perfectacle.github.io/tags/Namespace/"}]},{"title":"(자알쓰) Scope Part. 2","slug":"js-004-scope","date":"2017-05-19T09:14:47.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/05/19/js-004-scope/","link":"","permalink":"https://perfectacle.github.io/2017/05/19/js-004-scope/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 네 번째 시리즈는 ES2015+의 Scope(스코프)를 주제로 진행하겠다.일단 ES5 이하에서 스코프를 읽고 오길 바란다. ES5와의 차이점ES2015+ 들어서 변수를 선언할 때 const와 let이 추가되었다.이에 대한 설명은 추후 포스트에서 정리할 예정이다.ES2015+를 쓴다 하더라도 var를 쓰면 큰 차이점이 없다.var와 const, let을 비교해보자.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 네 번째 시리즈는 ES2015+의 Scope(스코프)를 주제로 진행하겠다.일단 ES5 이하에서 스코프를 읽고 오길 바란다. ES5와의 차이점ES2015+ 들어서 변수를 선언할 때 const와 let이 추가되었다.이에 대한 설명은 추후 포스트에서 정리할 예정이다.ES2015+를 쓴다 하더라도 var를 쓰면 큰 차이점이 없다.var와 const, let을 비교해보자. 1234const a = 1;var b = 2;// const와 let은 window 객체의 프로퍼티에 할당되지 않는다.console.log(window.a, window.b); // undefined 2 블록 단위의 스코프ES5의 var는 함수 단위의 스코프라고 얘기했다.블록은 {} 요 구문을 뜻 하고 요 안에서만 변수가 살아 숨쉰다고 보면 된다. 123456789101112131415161718192021222324252627// for문 - ()와 &#123;&#125;을 포함 - 에서 선언한 변수 i가// for 문 밖에서도 살아 숨쉬고 있다.for(var i=0; i&lt;10; i++) &#123;&#125;console.log(i); // 11// var와는 달리 let은 for문 안에서 선언했으면// for 문 외부에서는 참조가 불가능하다.for(let j=0; j&lt;10; j++) &#123;&#125;console.log(j); // j is not defined// for 문 외부에서 선언해야 for 문 외부에서도 사용이 가능하다.let k = 0;while(k++ &lt; 10) &#123;&#125;console.log(k); // 11// &#123;&#125;으로 명시적으로 스코프를 만들 수도 있다.// 이 다음 모듈화 포스트에 얘기할 즉시 실행함수 패턴과 유사하다고 보면 된다.&#123; const a = 1; console.log(a); // 1&#125;&#123; const a = 2; console.log(a); // 2&#125; ES5와 공통점이 역시 파일 별로 스코프를 가지는 게 아니라 역시 전역 스코프를 더럽힌다는 단점이 있다. 12345// a.jsconst a = 2;// b.jsconst a = 3; // Identifier &#x27;a&#x27; has already been declared 이를 극복하기 위해 import&#x2F;export 문법이 있지만 다음 모듈화 포스트에서 다룰 예정이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Scope","slug":"Scope","permalink":"https://perfectacle.github.io/tags/Scope/"}]},{"title":"(JS) 숫자가 증가하는 애니메이션 구현하기","slug":"js-async-number-animation","date":"2017-05-03T09:39:29.000Z","updated":"2022-10-30T08:42:16.695Z","comments":true,"path":"2017/05/03/js-async-number-animation/","link":"","permalink":"https://perfectacle.github.io/2017/05/03/js-async-number-animation/","excerpt":"숫자가 0~100까지 순서대로 변하는 예제를 만들어볼 것이다.일단 예제 파일에 쓰일 index.html을 하나 만들어보자. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이제 index.js 파일을 만들자.110까지 출력이니 반복문을 쓰면 될 것 같다.아래와 같이 콘솔창에 찍어보면 110까지 아주 잘 나온다. 123for(var i=1; i&lt;11; i++) &#123; console.log(i);&#125;","text":"숫자가 0~100까지 순서대로 변하는 예제를 만들어볼 것이다.일단 예제 파일에 쓰일 index.html을 하나 만들어보자. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 이제 index.js 파일을 만들자.110까지 출력이니 반복문을 쓰면 될 것 같다.아래와 같이 콘솔창에 찍어보면 110까지 아주 잘 나온다. 123for(var i=1; i&lt;11; i++) &#123; console.log(i);&#125; 이제 실제 DOM에다 렌더링 시켜보자.예제 보기 숫자를 보여줄 때 그냥 보여주기만 하면 재미 없죠?한 번 쯤은 0~100까지 숫자가 순차적으로 올라가면서 보여주면더 역동적일 것 같다고 생각해보신 적들 있을 겁니다.저도 같은 생각을 해보며 글을 작성해보았습니다.콜백 함수, Promise, Async 123456var domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.for(var i=1; i&lt;11; i++) &#123; domRoot.innerText = i;&#125; 결과를 확인하면 너무 한 순간에 값이 바뀌어서 눈으로 확인이 불가능할 정도다.그렇다면 setTimeout으로 딜레이를 걸어보자!예제 보기 12345678910111213141516171819var domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.for(var i=1; i&lt;11; i++) &#123; // ES5까지는 함수 단위의 스코프여서 아래와 같이 하면 함수를 실행하는 시점은 // 반복문이 끝난 시점이라 i에는 10이 10번 들어가게 된다. //setTimeout(function() &#123; // domRoot.innerText = i; //&#125;); // ES5까지는 함수 단위의 스코프라 즉시 실행함수를 통해 변수의 스코프를 가두었다. // 즉시 실행 함수의 내부에 있는 함수를 실행하는 시점은 역시 반복문이 끝난 시점이다. // 하지만 즉시 실행 함수를 통해 변수를 가둬두었으므로 클로저를 통해 해당 변수에 들어간 값을 렌더링한다. (function(i) &#123; setTimeout(function() &#123; domRoot.innerText = i; &#125;, 100) &#125;(i));&#125; 하지만 위의 결과도 우리가 원하던 결과가 아니다.100ms 동안은 가만히 있지만 그 이후에 함수가 물밀듯 실행한다.setTimeout 함수는 동기식으로 동작하는 게 아니라 비동기 식으로 동작하기 때문이다.이를 위해서 우리에겐 콜백 함수란 게 존재한다!예제 보기 12345678910111213141516171819202122232425262728293031323334353637383940// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.var changeNum = function(dom, num) &#123; dom.innerText = num;&#125;;var MS = 100;var domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.setTimeout(function() &#123; changeNum(domRoot, 1); setTimeout(function() &#123; changeNum(domRoot, 2); setTimeout(function() &#123; changeNum(domRoot, 3); setTimeout(function() &#123; changeNum(domRoot, 4); setTimeout(function() &#123; changeNum(domRoot, 5); setTimeout(function() &#123; changeNum(domRoot, 6); setTimeout(function() &#123; changeNum(domRoot, 7); setTimeout(function() &#123; changeNum(domRoot, 8); setTimeout(function() &#123; changeNum(domRoot, 9); setTimeout(function() &#123; changeNum(domRoot, 10); &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS) &#125;, MS)&#125;, MS); 코드가 보기 좋은가?이를 위한 대안으로 ES2015에 나온 Promise를 써보자.예제 보기 12345678910111213141516171819202122232425262728293031323334353637383940// promise 함수는 콜백 함수를 매개변수로 받아서 Promise 객체를 반환한다. // 그 Promise 객체는 매개변수로 받은 콜백 함수를 실행한다.const promise = cb =&gt; new Promise(res =&gt; &#123; // 요 res 위치에 앞으로 실행할 콜백 함수가 들어온다고 생각하면 된다. cb(res);&#125;);// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const MS = 100;const domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.promise( // promise 함수의 콜백으로 (동기식으로 바꾼) 비동기 함수가 들어가게 된다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 changeNum.bind(null, domRoot, 1), MS))// 요 then을 타고 cb(res) 요 안으로 계속해서 함수를 침투시킨다고 생각하면 된다.// 그렇게 침투시켜서 콜백 함수 피라미드와 같은 효과를 내는 거다..then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 2), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 3), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 4), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 5), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 6), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 7), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 8), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 9), MS))).then(() =&gt; promise(syncSetTimeout.bind(null, changeNum.bind(null, domRoot, 10), MS))); 뭐 썩 보기 좋은 건 아니지만 콜백 함수 지옥에 비하면 훨씬 봐주기가 좋아졌다.하지만 숫자를 1~10이 아닌 100까지 표현해야한다면…?저걸 100줄을 쓰고 있어야한다.그럼 이제 남은 방안은 ES2017의 async&#x2F;await가 있다!예제 보기 12345678910111213141516171819202122232425262728293031323334353637// promise 함수는 콜백 함수를 매개변수로 받아서 Promise 객체를 반환한다. // 그 Promise 객체는 매개변수로 받은 콜백 함수를 실행한다.const promise = cb =&gt; new Promise(res =&gt; &#123; // 요 res 위치에 앞으로 실행할 콜백 함수가 들어온다고 생각하면 된다. cb(res);&#125;);// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.// promiseCb는 promise 함수로부터 전달받은 콜백함수이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const MS = 100;const domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.(async() =&gt; &#123; // async는 함수이기 때문에 실행하려면 즉시 실행 함수를 써야한다. for(let i=1; i&lt;101;) &#123; // 반복문을 통해 1~100까지 반복하고 있다. // await 함수는 비동기 함수를 동기식으로 실행시키는 데 쓰이는 함수이다. // 내가 알기로는 Promise 없이는 죽도 밥도 안되는 것으로 알고 있다. await( promise( // promise 함수의 콜백으로 (동기식으로 바꾼) 비동기 함수가 들어가게 된다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. changeNum.bind(null, domRoot, i++), // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 MS) ) ); &#125;&#125;)(); 하지만 async&#x2F;await와 Promise를 학습하는 것은 어느 정도 러닝 커브가 있다.한번 내가 만들어본 async-to-sync 라이브러리를 이용하여 바꿔보자.예제 보기 1234567891011121314151617181920212223242526272829303132// 비동기 함수를 동기식으로 실행해주는 async-to-sync 모듈을 로드하자.import ats from &#x27;async-to-sync&#x27;;// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.const changeNum = (dom, num) =&gt; dom.innerText = num;// 기본적으로 async-to-sync 모듈은 위 async/await + Promise를 짬뽕한 라이브러리다.// 비동기 함수를 동기 함수로 바꾸는 방법은 위의 예제와 같다.// 함수 매개변수에 promise 함수에서 전달받은 promiseCb를 추가하고, 함수 마지막 부분에 그 콜백 함수를 실행시키면 된다.// promise 함수에 전달할 콜백 함수.// 비동기 함수인 setTimeout을 동기식으로 실행시켜주게 바꾼 코드이다.const syncSetTimeout = (cb, ms, promiseCb) =&gt; setTimeout(() =&gt; &#123; cb(); // 함수 마지막에 이 콜백 함수는 위에 promise 함수의 cb(res) 요 부분이 실행되는 거라고 보면 된다. promiseCb();&#125;, ms);const arrAsync = []; // async-to-sync는 비동기 함수들이 담겨있는 배열을 매개변수로 받아서 실행시킨다.const MS = 100;const domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.for(let i=1; i&lt;101;) &#123; // 반복문을 통해 1~100까지 반복하고 있다. arrAsync.push( // 배열에 비동기 함수들을 하나씩 담고 있다. syncSetTimeout.bind(null, // 매개변수로 콜백 함수를 넘겨줘야하기에 bind 함수 사용. changeNum.bind(null, domRoot, i++), // 콜백함수로 dom에 숫자를 렌더링하는 changeNum 함수 실행 MS) );&#125;ats(arrAsync); // 배열에 담은 비동기 함수들을 한 번에 실행시키고 있다. 더 쉬운 방법역시 구글링을 해보니 더 쉬운 방법이 존재하였다.왜 이런 뻘짓을 했는지… 1234567891011121314151617181920let current = 0; // 현재 숫자// 콜백 함수를 익명 함수로 일일이 작성하기 귀찮으니 따로 빼주자.// 돔에 숫자를 렌더링하는 함수이다.// 외부에 있는 변수를 건드리므로 좋지는 않지만 어쩔 수 없다.const changeNum = (dom) =&gt; dom.innerText = ++current;// setTimeout 말고 setInterval이 더 간결하다.const SetInterval = (cb, ms) =&gt; setInterval(() =&gt; &#123; if(current &gt;= 100) return clearInterval(SetInterval); cb();&#125;, ms);const MS = 100;const domRoot = document.getElementById(&#x27;root&#x27;);domRoot.innerText = 0; // 0으로 초기값 설정.// 이 함수를 실행할 때는 current가 1이 되므로 계속해서 1로 고정하게 된다. // 그래서 부득이하게 콜백 함수 안에서 외부 변수를 불러오게 했다.SetInterval(changeNum.bind(null, domRoot), MS);","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"},{"name":"ES6+","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"async","slug":"async","permalink":"https://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://perfectacle.github.io/tags/await/"},{"name":"callback","slug":"callback","permalink":"https://perfectacle.github.io/tags/callback/"}]},{"title":"(자작) async-to-sync (자바스크립트 비동기 함수 헬퍼)","slug":"async-to-sync","date":"2017-05-01T12:47:00.000Z","updated":"2022-10-30T08:42:16.131Z","comments":true,"path":"2017/05/01/async-to-sync/","link":"","permalink":"https://perfectacle.github.io/2017/05/01/async-to-sync/","excerpt":"async-to-syncasync-to-sync는 자바스크립트 비동기 함수를 동기 함수로 바꿔주는 헬퍼 함수이다.async&#x2F;await는 물론 Promise를 몰라도 된다!! npm github 왜 async-to-sync를 만들었는가?","text":"async-to-syncasync-to-sync는 자바스크립트 비동기 함수를 동기 함수로 바꿔주는 헬퍼 함수이다.async&#x2F;await는 물론 Promise를 몰라도 된다!! npm github 왜 async-to-sync를 만들었는가?드디어 async&#x2F;await가 ES2017에 추가 되었다(아직 최종 스펙이 나온 건 아니지만).async&#x2F;await는 자바스크립트 비동기 함수를 동기 함수로 바꿔주는 기능을 한다.하지만 여전히 사용하기가 어렵고, 또한 ES2015의 Promise를 알고 있다는 전제 하에 사용이 가능하다.그래서 비동기 함수를 동기 함수로 만들 때 사용하기 편하려고 만들었다. 시작하기설치npm1npm i -S async-to-sync yarn1yarn add async-to-sync 사용법만약 타겟 브라우저&#x2F;노드의 async&#x2F;await 및 Promise 지원 여부를 모른다면 아래 링크를 확인하자.ECMAScript 6 compatibility table | PromiseNode.js ES2015&#x2F;ES6 | PromiseECMAScript 2016+ compatibility table | asyncNode.js ES2017 support | async주의!async-to-sync는 babel-polyfill을 포함하지 않았다.따라서 babel-polyfill을 사용해야한다면 설치를 하자.npm 1npm i -S babel-polyfill yarn 1yarn add babel-polyfill 혹은 CDN을 이용하면 된다.아래 구구절절한 사용 방법 대신 빠르게 사용 방법을 익히고 싶다면 examples를 참조하자. async-to-sync 모듈을 불러오는 방법웹팩async&#x2F;await &amp; Promise 지원 브라우저인 경우1import ats from &#x27;async-to-sync&#x27;; async&#x2F;await &amp; Promise or ES2015 미지원 브라우저인 경우babel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 바벨과 같은 트랜스파일러를 쓰지 않는다면, ES2015 문법 사용은 지양하자. (MS 진영은 암담하기에…) 12import &#x27;babel-polyfill&#x27;;import ats from &#x27;async-to-sync/module/no-es2017&#x27;; 브라우저 (CDN은 지원 예정이니 잠시만 기다리자!)async&#x2F;await &amp; Promise 지원 브라우저1&lt;script src=&quot;node_modules/async-to-sync/browser/es2017/index.min.js&quot;&gt;&lt;/script&gt; async&#x2F;await &amp; Promise or ES2015 미지원 브라우저babel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 바벨과 같은 트랜스파일러를 쓰지 않는다면, ES2015 문법 사용은 지양하자. (MS 진영은 암담하기에…) 12&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.23.0/polyfill.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/async-to-sync/browser/no-es2017/index.min.js&quot;&gt;&lt;/script&gt; Node.jsasync&#x2F;await &amp; Promise를 지원할 때만약 import 문법을 쓰고 싶다면 바벨과 같은 트랜스파일러를 이용하자. 1const ats = require(&#x27;async-to-sync&#x27;); In async&#x2F;await &amp; Promise or ES2015 not support Nodebabel-polyfill 사용이 필수이다.또한 async-to-sync 모듈을 불러오기 전에 babel-polyfill을 불러와야만 한다.만약 import 문법을 쓰고 싶다면 바벨과 같은 트랜스파일러를 이용하자. 12require(&#x27;babel-polyfill&#x27;);const ats = require(&#x27;async-to-sync/module/no-es2017&#x27;); 어떻게 쓰는가비동기 함수에는 몇 가지 종류가 있다. setTimeout(or setInterval) 1234567891011var a = function() &#123; setTimeout(function() &#123; console.log(123); &#125;, 2000);&#125;;var b = function(b) &#123; setTimeout(function() &#123; console.log(b); &#125;, 1000);&#125;; AJAX(Asynchronous Javascript And XML)bluebird, axios, jQuery slim과 같은 써드 파티들을 사용해도 된다.XHR(XMLHttpRequest)이나 fetch를 쓸 때는 Promise를 써야한다.then 메소드는 성공 콜백 함수와 같고, catch 메소드는 실패 콜백 함수와 같다.주의!몇몇 AJAX 요청은 IE9에서 문제가 되지만 이것은 async-to-sync의 문제가 아니다.아래 링크를 참조하자. Can I Use Cross-Origin Resource Sharing? IE9 jQuery AJAX with CORS returns “Access is denied” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var fallback = function(e) &#123; alert(&#x27;Error: &#x27; + e);&#125;;var xhr = function(url, method) &#123; method = method || &#x27;get&#x27;; return new Promise(function(res, rej) &#123; var xhr = new XMLHttpRequest(); xhr.open(method, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); &#125; else &#123; rej(xhr.status); &#125; &#125; &#125;; xhr.send(); &#125;);&#125;;var _fetch = function(url, method, headers, body) &#123; method = method || &#x27;get&#x27;; headers = headers || null; body = body || null; return fetch(url, &#123; method, headers, body &#125;).then(function(res) &#123; return res.json(&#123;&#125;); &#125;);&#125;;var c = function(url) &#123; xhr(url).then(function(data) &#123; console.log(data); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;;var d = function(url) &#123; _fetch(url).then(function(data) &#123; console.log(data); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;; 주의!다음의 규칙들을 따라서 함수를 재작성하자. 함수의 파라미터에 콜백 함수를 추가해주자. 비동기 함수 맨 마지막에 콜백 함수를 실행해주자. 12345678910111213141516171819202122232425262728293031323334// 모든 비동기 함수마다 콜백 함수를 파라미터로 추가해줘야한다.var a = function(cb) &#123; setTimeout(function() &#123; console.log(123); // 비동기 함수의 맨 마지막에는 콜백 함수를 반드시 실행해줘야한다. cb(); &#125;, 2000);&#125;;// 콜백 함수는 파라미터 제일 끝 부분에 추가해주자.var b = function(b, cb) &#123; setTimeout(function() &#123; console.log(b); cb(); &#125;, 1000);&#125;;var c = function(url, cb) &#123; xhr(url).then(function(data) &#123; console.log(data); cb(); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;;var d = function(url, cb) &#123; _fetch(url).then(function(data) &#123; console.log(data); cb(); &#125;).catch(function(e) &#123; fallback(e) &#125;);&#125;; 진짜 사용 방법ats(Array arrAsync[, Function fallback]) arrAsync의 타입은 배열이다.이 배열은 비동기 함수들을 포함하고 있다.이 함수들은 동기적으로 실행될 것이다. fallback의 타입은 함수이며, 필수 사항이 아니다.이 함수는 에러 발생시 실행되며, 그 이후에 실행될 함수들의 실행을 모두 멈춰버린다. 123456789101112131415161718var arrUrl = [ &#x27;https://perfectacle.github.io/mock/test.json&#x27;, &#x27;https://perfectacle.github.io/mock/test2.json&#x27;];var arrAsync = [ a, // 인자를 넘겨주거나 this 값을 바인딩해야할 경우 bind 메소드를 사용하면 된다. c.bind(null, arrUrl[0]), // 물론 인자를 넘길 때 ES2015의 arrow function을 사용해도 된다. // 하지만 이 때는 콜백 함수까지 같이 매개변수 및 인자로 넘겨줘야한다. cb =&gt; b(2, cb), a, cb =&gt; d(arrUrl[1], cb), b.bind(null, 33)];ats(arrAsync, fallback); 지원하는 플랫폼 | | | | — | — | — | — |Latest ✔ | Latest ✔ | 9+ ✔ | 6+ ✔ |","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Promise","slug":"Promise","permalink":"https://perfectacle.github.io/tags/Promise/"},{"name":"async","slug":"async","permalink":"https://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://perfectacle.github.io/tags/await/"}]},{"title":"(자알쓰) Scope Part. 1","slug":"js-003-scope","date":"2017-04-27T09:14:47.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/04/27/js-003-scope/","link":"","permalink":"https://perfectacle.github.io/2017/04/27/js-003-scope/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 세 번째 시리즈는 Scope(스코프)를 주제로 진행하겠다. Scope? 스코프?흔히 변수의 Scope라고 부른다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 세 번째 시리즈는 Scope(스코프)를 주제로 진행하겠다. Scope? 스코프?흔히 변수의 Scope라고 부른다. Scope(무엇을 하거나 이룰 수 있는) 기회; (주제・조직・활동 등이 다루는) 범위 후자의 범위라고 보면 될 것 같다.즉 변수의 Scope는 변수를 사용할 수 있는 범위가 된다.ES5까지는 함수 단위의 스코프를 가진다.백문이 불여일견, 일단 코드로 보고 이해하자. 1234567891011121314151617// 전역 공간은 스코프를 공유한다.var a = 1;var b = 2;if(a &lt; b) &#123; var i = 3;&#125; else &#123; // 사실 전역에 있는 변수는 공유되기 때문에 여기서는 var를 생략해도 된다. var i = 4;&#125;var c = function() &#123; // 함수 단위의 스코프가 시작됐다. var a = 5; var d = 6; console.log(a); // 5, 현재 스코프에 a가 있기 때문에 현재 스코프에 있는 a를 출력한다.&#125;console.log(i); // 3, 함수 단위의 스코프이기 때문에 같은 전역 공간에 있다고 간주해서 변수를 공유하기 때문에 사용 가능하다.c();console.log(d); // Uncaught ReferenceError: d is not defined, 함수 단위의 스코프이기 때문에 함수에서 쓰인 변수는 함수에서만 사용할 수 있다. 이것 또한 전통 방식의 자바, C와 큰 차이점 중 하나이다.기존 프로그래밍 언어들은 블록 단위의 스코프라고 해서 if 문도 별도의 스코프를 가졌는데자바스크립트에는 쌩뚱맞은 함수 단위의 스코프라는 게 존재한다.왜 이렇게 만들었는지 나도 모르겠다. Scope Chaining(스코프 체이닝) Chaining체이닝, 연쇄(적 처리) 뭔가를 연쇄적으로 처리하는 내용이다.이번에도 코드를 봄으로써 이해해보자. 12345678910111213141516171819var a = 1;var b = function() &#123; // 외부 함수 스코프(b)의 시작 var c = 2; var d = function() &#123; // 내부 함수 스코프(d)의 시작 // 1. 현재 스코프(d)에는 a란 변수가 없다. // 2. 스코프 체인을 타고 스코프 b로 올라간다. // 3. 스코프 b에도 a란 변수가 없다. // 4. 스코프 체인을 타고 전역 스코프로 올라간다. // 5. 전역 스코프에는 a란 변수가 있으므로 그 a를 출력한다. console.log(a); // 1 // 1. 현재 스코프(d)에는 c란 변수가 없다. // 2. 스코프 체인을 타고 스코프 b로 올라간다. // 3. 스코프 b에도 c란 변수가 있으므로 그 c를 출력한다. console.log(c); // 2 &#125; d(); // 내부 함수 d를 호출&#125;b(); // 함수 b를 호출 하지만 이 스코프 체이닝은 변수 사용에서만 존재하는 게 아니다.변수 선언에 있어서도 스코프 체이닝이 발생할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041var b = 1;var c = function() &#123; // 외부 함수 스코프(c)의 시작 var d = 2; var e = function() &#123; // 내부 함수 스코프(e)의 시작 // 변수의 선언을 var 없이 하면 스코프 체이닝이 발생한다. // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 d가 있으므로 그 변수에 3을 할당한다. d = 3; // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 b가 없다. // 4. 스코프 체인을 타고 상위 스코프인 전역 스코프로 이동한다. // 5. 전역 스코프에는 변수 b가 있으므로 그 변수에 4를 할당한다. b = 4; // 1. 현재 스코프(e)에는 d라는 변수가 없다. // 2. 스코프 체인을 타고 상위 스코프인 c로 이동한다. // 3. 스코프 c에는 변수 b가 없다. // 4. 스코프 체인을 타고 상위 스코프인 전역 스코프로 이동한다. // 5. 전역 스코프에는 변수 f가 없으니 새로 만들고 5를 할당한다. f = 5; &#125; // 똥 싸기 전에는 2를 가지고 있다가 console.log(d); // 2 e(); // 내부 함수 e를 호출 // 똥싸고 나니 3으로 변하였다. console.log(d); // 3&#125;// 똥 싸기 전에는 1을 가지고 있고 f는 벌써 호이스팅 처리가 전부 끝난 건지 5가 할당되어있다.console.log(b); // 1console.log(f); // 5c(); // 함수 c를 호출// 똥싸고 나니 3과 5라는 변수로 바뀌었다.console.log(b); // 4console.log(f); // 5 이렇게 var를 쓰지 않고 변수를 선언하면 상위 스코프로 체인을 타고 해당 변수를 찾아 여정을 떠난다.전역 스코프에도 해당 변수가 없다면 새로 만들게 된다.이렇게 var를 쓰지 않고 변수를 선언하다보면 변수의 스코프가 뒤죽박죽이 되어버린다.따라서 이렇게 코딩하는 걸 사전에 방지하고 오류를 뿜어주는 게 존재한다. strict modeES5에서 새로 생긴 모드다.이 포스트에서는 변수 선언에 대해서만 다룰테니 자세한 내용은 아래 링크를 확인하자.Strict mode - JavaScript | MDN코드의 문법을 좀 더 깐깐하게 검사해서 오류를 내뿜어 개발자로 하여금 의도한 바대로 실행 결과를 도출하게끔 하는 모드이다.나는 사용을 권장한다.혹시 IE8 같은 경우에는 지원하지 않아서 오류를 뿜지 않을까 걱정이라면 붙들어 메도 된다.일단 코드로 보자. 1234567891011121314&#x27;use strict&#x27;;// 이렇게 전역 스코프 상단에 저 구문을 넣어주거나 // 사용하려는 함수 바디 상단에만 넣어주면 된다. // 미지원 브라우저는 그냥 문자열로 인식하고 오류를 뿜지 않는다.var a = 1;var b = function() &#123; // 얘는 전역 스코프에 존재하는 녀석이어서 그 변수를 덮어씌우면 되니 오류를 뿜지 않는다. a = 1; // 스코프 체인 상에 존재하지 않는 변수를 var 없이 선언하면 오류를 뿜게 된다. d = 2; // Uncaught ReferenceError: d is not defined&#125;// 스코프 체인 상에 존재하지 않는 변수를 var 없이 선언하면 오류를 뿜게 된다. c = 3; // Uncaught ReferenceError: c is not definedb(); 아주그냥 난장판인 스코프하나의 html 파일에는 여러가지 자바스크립트 파일이 들어가게 된다.그럼 2개의 자바스크립트 파일을 썼다고 가정해보고 코드를 보자. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;a&quot;&gt;a&lt;/button&gt;&lt;button id=&quot;b&quot;&gt;b&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; a.js를 작성해보자. 12&#x27;use strict&#x27;;var num = 1; b.js를 작성해보자. 1234567891011window.onload = function() &#123; &#x27;use strict&#x27;; var btnA = document.getElementById(&#x27;a&#x27;); var btnB = document.getElementById(&#x27;b&#x27;); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; 버튼을 누르면 1이 출력된다.그러다가 내 부사수 마니똘이 추가 작업을 하다가 아래와 같이 c.js를 만들고 html에 추가하였다. 1234&#x27;use strict&#x27;;// 코드 블라블라var num = 2;// 코드 블라블라 그리고 b.js 보다 먼저 처리해야할 로직이 있어서 스크립트를 아래와 같은 순서로 로딩하게 하였다. 1234&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;!-- 요 사이에 내 부사수가 작성한 c.js를 로딩시켰다. --&gt;&lt;script src=&quot;c.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt; 그리고 나서 다시 버튼들을 클릭해보자.그럼 내가 기대했던 1이 아닌 부사수가 작성한 2가 찍히게 된다.사실 위 3가지 js 파일을 아래와 같이 바꿀 수도 있다. 123456789101112131415161718192021&#x27;use strict&#x27;;// 내가 작성한 a.jsvar num = 1;// 내 부사수가 작성한 c.js// 블라블라var num = 2;// 블라블라// 내가 작성한 b.jswindow.onload = function() &#123; &#x27;use strict&#x27;; var btnA = document.getElementById(&#x27;a&#x27;); var btnB = document.getElementById(&#x27;b&#x27;); btnA.onclick = function() &#123; console.log(num); &#125;; btnB.onclick = function() &#123; console.log(num); &#125;&#125;; num이 더 뒤에 할당된 2가 찍히게 되는 것이다.자바의 경우에는 파일(클래스) 별로 별도의 스코프가 존재했는데, js는 그렇지 못하다.이 또한 기존에 다른 언어 개발자들을 미치게 하는 요인 중에 하나다. 마치며…글이 길어져서 일단 한 템포 끊어서 가야할 것 같다.다음 포스트에서는 ES2015+의 스코프를 다루고,그 다음에는 스코프의 한계를 극복한 모듈화에 대해 다뤄야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Scope","slug":"Scope","permalink":"https://perfectacle.github.io/tags/Scope/"}]},{"title":"(자알쓰) Hoisting","slug":"js-002-hoisting","date":"2017-04-26T23:25:29.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/04/26/js-002-hoisting/","link":"","permalink":"https://perfectacle.github.io/2017/04/26/js-002-hoisting/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 두 번째 시리즈는 Hoisting(호이스팅)을 주제로 진행하겠다. Hoisting? 호이스팅?이 처음보는 단어는 뭐지 싶을 수도 있다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 두 번째 시리즈는 Hoisting(호이스팅)을 주제로 진행하겠다. Hoisting? 호이스팅?이 처음보는 단어는 뭐지 싶을 수도 있다. Hoisting끌어 올리기; 들어올려 나르기. 말 그대로 끌어올리는 것이다. 무엇을? 코드를! 1console.log(qwer); // Uncaught ReferenceError: qwer is not defined 누구나 예상한 결과일 것이다.qwer이란 녀석은 선언된 적이 없으니 사용도 불가능한 것이다.하지만 아래 예제를 보자. 12345678910console.log(asdf); // undefined, 오류가 나질 않는다. 즉 프로그램이 뻗질 않는다.console.log(qwer); // undefinedconsole.log(zxcv); // function zxcv() &#123; console.log(456); &#125;var asdf = &#x27;asdf&#x27;;var qwer = function() &#123; console.log(111);&#125;;function zxcv() &#123; console.log(456);&#125; 전통적인 C언어나 자바와 같은 프로그래밍 언어로 개발하던 사람들이 이해하지 못하는 부분 중 하나가 바로 이거다.내가 선언하기 전에 사용된 변수, 즉 없는 변수인데 왜 갑자기 툭 튀어나와서undefined를 내뱉고 프로그램이 죽지 않는 거지?바로 호이스팅이 일어났기 때문이다.위의 코드는 아래와 같이 변환된다고 보면 된다. 123456789101112var asdf;var qwer;function zxcv() &#123; console.log(456);&#125;console.log(asdf);console.log(qwer);console.log(zxcv);asdf = &#x27;asdf&#x27;;qwer = function() &#123; console.log(111);&#125;; 함수 선언문에서는 변수 없이 함수를 선언한 것이므로 전체 코드가 호이스팅 된다.하지만 함수 표현식은 변수 선언과 할당을 구분할 수 있으므로 선언 부분만 호이스팅이 일어났다.따라서 오류가 날 것으로 예상했던 코드가 예측한 대로 작동하질 않는다.오류를 최소화하려는 전략이었는지 모르겠지만 의도대로 코드가 작동하지 않는 것은 옳지 않다.소스 코드를 분석하다가도 본 적 없는 변수나 함수가 갑자기 튀어나오면 요 놈이 어디서 나온 녀석인지 혼란스럽게 하기 마련이다.그래서 나는 차라리 오류를 안 나게 호이스팅을 하는 것보다 오히려 오류를 내는 쪽이 더 안전하게 코드를 설계하는 건 아닐까 싶다.따라서 사용할 변수와 함수는 최소한 사용하기 전에 미리 선언해야 의도한대로 코드가 동작한다고 확신을 가질 수 있다. ES2015+에서는?이렇게 짧게 끝내기 아쉬우니 ES2015+에서는 호이스팅이 어떻게 처리되는지 알아보자.일단 ES2015+에서는 변수를 선언할 때 const와 let으로 대신해서 쓴다.이에 대해서는 다른 포스트에서 자세히 다룰테니 일단은 그런 놈들이 있다고만 알자.그럼 똑같은 코드를 ES2015+ 식으로 작성해보자. 1234console.log(asdf); // Uncaught ReferenceError: asdf is not definedconsole.log(qwer);const asdf = &#x27;asdf&#x27;;let qwer = &#x27;qwer&#x27;; 1번 라인에서 오류가 나서 2번 라인은 실행도 못하고 바로 뻗어버린다.우리의 바람대로 호이스팅이 사라진 것 같다.과연 정말일까…? TDZ(Temporal Dead Zone)임시적 사각 지대, 변수가 임시로 죽어있는 공간이라고 이해하면 될 것 같다.뭔소린지 글로만 봐서는 모르니 코드를 통해서 보자. 123456const asdf = &#x27;asdf&#x27;;const qwer = function() &#123; console.log(asdf); // Uncaught ReferenceError: asdf is not defined let asdf = &#x27;qwer&#x27;;&#125;qwer(); 호이스팅이 일어나지 않았다면 3번 라인에서는 ‘asdf’가 찍혀야 정상일 것이다.혹은 호이스팅이 일어났다면 undefined라도 찍혀야하는데 오히려 에러를 내뱉었다.이건 무슨 경우일까? 답은 바로 TDZ!위 코드를 다시 TDZ라는 것과 연관 지어서 풀어보겠다. 123456789const asdf = &#x27;asdf&#x27;;const qwer = function() &#123; let asdf; // 사실 이렇게 변수 선언부가 호이스팅에 의해 스코프 상단으로 끌어올려진다. // 변수의 초기화 구문을 만나기 전까지 TDZ가 형성됨. console.log(asdf); // TDZ에서 해당 변수가 쓰였다면 에러를 발생! // 여기까지 TDZ. asdf = &#x27;qwer&#x27;;&#125;qwer(); TDZ는 변수 선언(호이스팅에 의해 스코프 상단으로 끌어올려진 부분)부터 변수의 할당을 만나기 전 부분까지 형성이 되는 구간인데이 TDZ에서는 해당 변수가 임시적으로 죽어있는 구역인데 이 구역에 해당 변수가 끼어들면서 오류가 발생하게 되는 것이다. 마치며…오늘 올린 호이스팅은 사실 스코프와 연관지어 생각해봐야 이해하기가 쉬운 부분이다.따라서 다음에 포스팅 할 예정인 스코프 포스트까지 꼭 보길 바란다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Hoisting","slug":"Hoisting","permalink":"https://perfectacle.github.io/tags/Hoisting/"}]},{"title":"(자알쓰) ECMASCript? ES?","slug":"js-001-es","date":"2017-04-26T09:44:42.000Z","updated":"2022-10-30T08:42:16.679Z","comments":true,"path":"2017/04/26/js-001-es/","link":"","permalink":"https://perfectacle.github.io/2017/04/26/js-001-es/","excerpt":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 첫 번째 시리즈는 ECMAScript(이하 ES)를 주제로 진행하겠다. ES의 탄생 배경브라우저 전쟁 시절 개발자들은 몸살을 앓았다.넷 스케이프 사의 자바스크립트가 부러웠는지 사용자 층을 더 끌어내기 위해 MS의 IE 3에도 JScript라는 이름으로 자바스크립트를 탑재하였다.하지만 둘의 내용이 매우 달랐는지, 같은 기능을 구현하기 위해 개발자가 해야하는 일들이 더 많아졌다.날이 가면 갈 수록 사용자를 끌어내기 위해 서로 기능을 넣다보니 Javascript와 JScript는 날이 가면 갈 수록 달라지는 경향을 보였다.이에 대한 심각성을 파악하고, European Computer Manufacturers Association(ECMA, 현 ECMA International)에서는이러한 자바스크립트에 대한 표준을 내리게 된다.또한 ECMA에서는 자바스크립트의 표준만 내리는 게 아니라 다른 표준안도 정하기 때문에 그와 구분하기 위해 숫자를 붙였는데 262다.ECMA262라고 보인다면 아, 자바스크립트 표준 규격이구나라고 생각하면 될 것 같다.","text":"자알쓰란?자바스크립트 알고 쓰자. (잘 쓰자는 의미도 담겨있다.)자바스크립트라는 언어 자체는 내 기준에서는 설계 상 미스가 참 많다.함수 단위의 스코프, 호이스팅, 동적 타입 등등자바와 같은 깐깐(?)한 언어를 배우고 바라본 자스는 허점 투성이처럼 보였다.애초에 자바스크립트는 어떠한 프로그램을 만들기 위해서 탄생했다기 보다는웹 페이지에 입력값에 대한 유효성 검사(데이터가 공란인지 아닌지 등등)와 같은페이지의 동적 제어가 주된 목적 + 짧은 개발 기간(넷 스케이프 사의 새로운 브라우저에 탑재 예정) 때문에설계 상에 미스가 있을 수 밖에 없다고 나는 생각된다.일종의 안전 장치가 없어서 개발자가 일일이 구현해주고, 신경써야 하는 느낌이었다.그렇다고 해서 자바스크립트를 극혐하거나 그런 것은 아니고 매우 사랑한다.또한 그 허점을 아는 사람은 허점을 보완해서 요리조리 피해서 잘 쓰겠지만…잘 모르는 부분들은 잘못 써도 동작이 잘 되기 마련이다.이는 지금 당장에는 큰 문제가 안 될지 모르겠지만, 추후에 대규모 웹 어플리케이션을 만들거나직면할 문제로부터 미리 해방시키기 위해 처음부터 좋은 습관을 들여가는 것이 좋다고 생각한다.그 첫 번째 시리즈는 ECMAScript(이하 ES)를 주제로 진행하겠다. ES의 탄생 배경브라우저 전쟁 시절 개발자들은 몸살을 앓았다.넷 스케이프 사의 자바스크립트가 부러웠는지 사용자 층을 더 끌어내기 위해 MS의 IE 3에도 JScript라는 이름으로 자바스크립트를 탑재하였다.하지만 둘의 내용이 매우 달랐는지, 같은 기능을 구현하기 위해 개발자가 해야하는 일들이 더 많아졌다.날이 가면 갈 수록 사용자를 끌어내기 위해 서로 기능을 넣다보니 Javascript와 JScript는 날이 가면 갈 수록 달라지는 경향을 보였다.이에 대한 심각성을 파악하고, European Computer Manufacturers Association(ECMA, 현 ECMA International)에서는이러한 자바스크립트에 대한 표준을 내리게 된다.또한 ECMA에서는 자바스크립트의 표준만 내리는 게 아니라 다른 표준안도 정하기 때문에 그와 구분하기 위해 숫자를 붙였는데 262다.ECMA262라고 보인다면 아, 자바스크립트 표준 규격이구나라고 생각하면 될 것 같다. JS? ES?자바스크립트는 언어이고, ES는 스펙이다.IE8에서는 ES3 스펙을 준수한 거고, IE9에서는 ES5 스펙을 준수한 거다.그럼 우리가 여태까지 알고 있던 자바스크립트를 ES라고 불러야할까?나도 이 문제에 대해서는 아직도 잘 모르겠다.지금 내가 말할 뉘앙스대로라면 ES는 자바스크립트의 표준을 세운 언어라는 느낌이고,그냥 자바스크립트하면 비표준 언어라는 느낌이 많이 드는데 나는 아래와 같이 구분해서 부른다. 자바스크립트ES5까지의 내용을 나는 그냥 자바스크립트라고 부른다.ES3나 5의 특징을 설명해야할 때는 콕 찝어서 ES3다 뭐다 하고 부르지만,그렇지 않은 경우에는 그냥 자바스크립트라고 퉁쳐서 부른다.또한 많은 사람들이 생각하는 웹 브라우저에서 돌아가는 자바스크립트의 기준은 아래의 범주도 포함하는 것 같다.ES + DOM(Document Object Model) + BOM(Browser Object Model)DOM은 document.뭐시기~ 요런 애들이고 BOM은 window.머시기~(window를 생략하기도 한다.) 이런 애들이라고 알아두면 될 것 같다. ESES2015(a.k.a ES6)+나 ES3, 5의 특징과 같은 걸 콕 찝어 말할 때 ES라고 부른다.왜 ES2015 이상의 내용을 얘기할 때 ES를 쓰냐면 ES5와 ES2015 사이에 너무나 큰 변화가 있었기 때문이다.그래서 일반적으로 자바스크립트라고 알고 있는 ES5의 내용으로 사람들이 이해하지 않길 바라는 마음에 ES2015라고 구분해서 부르고 있다.또한 위에 자바스크립트에서도 언급 했 듯이 ES에는 DOM과 BOM을 포함하지 않는다는 점을 유념해둬야한다.즉 ES2015가 되건 2020이 되건 BOM과 DOM의 내용하고는 전혀 관련이 없다는 점을 알아둬야한다. ES3 (1999)대중적으로 많이 아는 그냥 자바스크립트라고 생각하면 될 것 같다.함수 단위의 스코프, 호이스팅, 모듈화 미지원, 프로토타입, 클로저 등등 자바스크립트의 기본적인 특징들이 들어있다.대부분의 브라우저에서 지원한다.IE8까지 크로스브라우징하는 환경이면 ES3를 쓰고 있다고 생각하면 된다. ES5 (2009)4는 너무 급변하는 내용이 있었던지 거절되고, 그 후에 점진적인 개선을 하고자 5가 나온 것으로 알고있다.기본적으로 IE9부터 본격적인 지원을 하지만 es5-shim을 사용하면 하위 버전에서도 특정 기능들을 지원해준다.5부터는 아래와 같은 내용들이 추가되었다. 배열배열과 관련해서 새로운 메소드들이 많이 생겼는데 대표적으로forEach, map, filter, reduce, some, every와 같은 순환 메소드들이 생겼다.이 메소드들은 개발자가 반복 횟수나 조건을 잘못 입력하는 등의 실수를 줄여주는 효과가 있다. 객체일단 눈에 띄는 점은 객체의 프로퍼티에 대한 설정을 할 수 있다는 것이다.객체를 생성&#x2F;수정&#x2F;복사하는 표준 메소드들(Object.create(), Object.defineProperty(), Object.freeze(), Object.assign() 등등)과 getter&#x2F;setter 등등또한 Object.keys 메소드를 쓰면 for in 메소드도 대체할 수 있게 된다. strict 모드문법을 좀 더 깐깐하게 체크하는 모드이다.물론 이유없이 그러는 게 아니라 좀 더 코드를 안전하게(에러가 안 나게, 미연에 방지하고자) 등장했다.특징은 아래 링크를 통해 확인해보자.Strict mode - JavaScript | MDN bind() 메소드this를 강제로 bind 시켜주는 메소드이다. 실행 컨텍스트 내에 존재하는 Lexical Environment JSON(JavaScript Object Notation)과거 통신을 할 때 데이터를 XML 형태로 많이 주고 받았다.하지만 JSON이 좀 더 경량화 돼있는지 요새는 JSON이 대세다.JSON은 자바스크립트의 객체 리터럴과 생긴 건 유사한데 다음과 같은 차이점이 존재한다. 키는 무조건 쌍따옴표(“”)로 감싼 문자열이어야한다. 주석은 사용할 수 없다. 프로퍼티로 메소드는 불가능하다. 프로퍼티에서도 메소드의 사용이 불가능하다.통신을 위해 Object를 JSON으로 바꾸는 방법은 JSON.stringify(obj)이고, 자바스크립트 코드에서 사용하기 위해 JSON은 Object로 바꾸는 방법은 JSON.parse(json)이다. ES2015(ES6)원래는 ES6였는데 사람들이 끝자리인 6과 2016년을 연관짓는 습성 때문에 2016년에 나온 걸로 착각을 해서인지 ES2015로 바꾼 것 같다.그냥 갤럭시 노트 6가 7으로 바로 건너뛴 것처럼 ES도 그냥 건너뛰면 어떨까… 싶은 생각이 든다. (개인적으로 연도 다 붙이기 너무 귀찮다.)ES6 Harmony라고도 불리우는 것 같다.ES2015 들어서면서 다음과 같은 문제점들이 해결되었다. 호이스팅이 사라진 것 같은 효과 함수 단위 스코프에서 블록 단위 스코프로 변경 this를 동적으로 바인딩하지 않는 애로우 펑션 모듈화 지원 콜백 지옥의 구원자, Promise (ES6) ajax 위주의 promise 실습 (ES6) Promise에 파라미터를 넘겨서 사용해보자 Default, Rest 파라미터 해체 할당, Spread 연산자 템플릿 리터럴 클래스이 외에도 특징은 엄청나게 많아서 사람들이 이 부분에서 많은 장벽을 느끼는 것 같다.일단 브라우저(특히 MS 계역)에서 지원해주지 않는 경우가 많아바벨이라는 트랜스파일러를 써야하는데 바벨 웹 사이트 REPL에서도 즉시 변환이 가능하다.하지만 매번 번거롭게 하기 귀찮으니 바벨을 설치해야하는데… 바벨은 웹 브라우저가 아닌 노드 JS 위에서 돌아가고… 노드 JS에서 바벨을 설치하려면 NPM을 알아야하고… 또 모듈화를 사용하려면 웹팩과 같은 모듈 번들러를 사용해야하고… 이런 다양한 장벽 때문에 사람들이 ES2015를 겁내고 쉽사리 접근하지 못하는 경향도 있는 것 같다.하지만 공부를 위해서라면 바벨 없이도 크롬에서 돌리면 원활한 공부가 가능하고,모듈화 부분은 지원하는 브라우저가 없기 때문에 건너 뛰고 공부해야할 것 같다. ES2015+현재 ES2016이 작년 6월 경에 발표됐다.ES2017은 조만간 발표될 예정이다.ES2015에서 너무 내용이 많이 바뀌어 겁을 먹었다면 여기서부터는 크게 겁 낼 필요 없는 게 그렇게 큰 내용이 변하지 않았다는 점이다.3에서 5까지 10년, 5에서 6까지 7년이라는 공백 때문에 엄청난 변화들이 있거나 했는데이제는 매년 표준을 제정하면서 그런 혼란을 줄일 예정인 것 같다.또한 이후에 나올 ES를 통칭해서 ES.Next라고도 부르는 것 같다. 마치며…ES3 ~ ES.Next까지 많은 내용을 다룬 것 같은데 너무 ES2015+를 어려워하지 않았으면 좋겠다.막상 공부해보면 새로운 특성도 있지만, 기존에 사용하던 패턴들을 조금씩 변경하는 내용들이 많고,오히려 복잡하게 구현하던 것을 간편하게 구현할 수 있게 만들어줘서 더 편한 것 같다.다음 시간에는 호이스팅(Hoisting)과 함수 단위의 스코프에 대해서 알아보도록 하자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"}]},{"title":"ES6 Generator","slug":"ES6-Generator","date":"2017-04-22T17:17:14.000Z","updated":"2022-10-30T08:42:16.075Z","comments":true,"path":"2017/04/22/ES6-Generator/","link":"","permalink":"https://perfectacle.github.io/2017/04/22/ES6-Generator/","excerpt":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol, (ES6) Iterator에 대한 내용은 링크를 참조하도록 하자. 사용 사례이 사용 사례가 전부는 아니겠지만, 제너레이터는 이터레이터를 구현할 때 좀 더 쉽게 만들어준다.우리는 지난 포스트에서 다음과 같이 배열의 요소를 거꾸로 사용하는 이터레이터를 구현해보았다.","text":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol, (ES6) Iterator에 대한 내용은 링크를 참조하도록 하자. 사용 사례이 사용 사례가 전부는 아니겠지만, 제너레이터는 이터레이터를 구현할 때 좀 더 쉽게 만들어준다.우리는 지난 포스트에서 다음과 같이 배열의 요소를 거꾸로 사용하는 이터레이터를 구현해보았다. 12345678910111213141516171819202122232425262728// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function(idx) &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.slice(-idx)[0], // value 값이 반환됨. done: --idx === this.length &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; let idx = 0; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // 이 next 함수 안에 있는 내용은 매번 실행됨. // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this, ++idx); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // 요 함수에 있는 내용은 한 번만 실행됨. // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this);&#125;;const arr2 = [...arr]; // [0, undefined, 3, 2, 1] IteratorResult 객체, Iterator 객체, Iterable 객체, 이 3개를 다 구현하기란 매우 귀찮고 어렵다.따라서 제너레이터를 사용하면 아래와 같이 바꿀 수 있게 된다. 1234567891011121314151617181920212223242526const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function*() &#123; // Iterator 인터페이스를 준수한 객체를 반환 for(let i=0, length=this.length; i&lt;length; i++) yield this.slice(-i)[0];&#125;;// 반복문의 횟수를 오타낼 염려가 있으니 아래와 같이도 할 수 있다.// arr[Symbol.iterator] = function*() &#123;// yield* this.map(function(v, idx)&#123;// return this.slice(-(++idx))[0];// &#125;, this);// &#125;; const gen = arr[Symbol.iterator]();console.dir(gen); // 제너레이터 함수의 실행 결과는 Iterator 객체를 반환한다.console.log(gen.next()); // &#123; value: 0, done: false &#125;console.log(gen.next()); // &#123; value: undefined, done: false &#125;console.log(gen.next()); // &#123; value: 3, done: false &#125;console.log(gen.next()); // &#123; value: 2, done: false &#125;console.log(gen.next()); // &#123; value: 1, done: false &#125;console.log(gen.next()); // &#123; value: undefined, done: true &#125;for(const a of arr) console.log(a); // 0 undefined 3 2 1 마법과도 같은 일이 일어났다.그럼 이 마법같은 일을 낱낱이 파헤쳐보자. Generator일단 두 가지 케이스가 눈에 띄었다.function 키워드 뒤의 *와 yield.funcion 키워드 뒤의 *는 이 함수가 제너레이터 함수라는 것을 명시해주는 기능을 한다.그리고 그 일반 함수가 아닌 제너레이터 함수에서는 yield 키워드를 쓸 수 있다.이 yield는 return과 마찬가지로 값을 반환하는 기능을 하는데, 함수는 종료시키지 않는다.next를 호출할 때마다 yield 구문까지의 코드를 실행하고 yield 값을 반환하게 되는 것이다.그리고 실행 컨텍스트를 어디선가 물고 있어서 코드의 흐름과 상관없이 next를 호출할 때마다 그 실행 결과를 보장받게 되는 것이다.몇 가지 예제들을 통해 그 특성들을 알아보자. 123456789101112131415161718192021222324252627282930313233343536const gen = function*() &#123; console.log(&#x27;내가 실행됐니?&#x27;); yield 1; const b = yield 3; console.log(b); const c = yield 4; console.log(c); return 4; yield 5;&#125;;let a = gen(); // 이터레이터 객체를 반환// 내가 실행됐니?가 출력되고, 1을 반환console.log(a.next());// b에 yield 3이 할당되고, 3이 반환됨.console.log(a.next());// 하지만 yield 3 자체는 undefined를 반환해서 b에는 undefined가 찍힘.// 그리고 c에 yield 4가 할당되고, 4가 반환됨.console.log(a.next());// 원래 c에는 yield 4가 할당돼 undefined가 찍혀야하지만, next에 매개변수를 주면 c에 새로운 값을 할당하게 됨.// 따라서 9를 출력.console.log(a.next(9));// return 이후로는 닿질 못한다.console.log(a.next()); // &#123; value: undefined, done: true &#125;console.log(&#x27;-----------------&#x27;);// 이터레이터 내부의 요소(yield)들을 모두 소모했으므로 재충전(?)a = gen();// 이터레이터이므로 for of 구문을 사용할 수 있다. // 반환 값으로는 yield에 지정한 값들이 반환된다.for(const v of a) console.log(v); yield는 모든 타입을 반환할 수 있다. 1234567891011121314151617181920212223242526272829303132333435const gen = function*() &#123; const a = &#123;obj: 2&#125;; yield a; yield () =&gt; console.log(7777777); yield* [1, 2, 3, 4]; yield* (function*() &#123;yield 5; yield 6;&#125;)(); yield function*() &#123;yield 7; yield 8;&#125;;&#125;;// 제너레이터 함수의 실행 결과로 이터레이터 객체가 a에 담기게 된다.const a = gen();// a.next()까지 하게 되면 IterableResult 객체인 &#123; value: &#123; obj: 2 &#125;, done: false &#125;가 반환된다.// 실제 for of와 같은 문법에서도 value 값을 반환하게 되는 것이다.console.log(a.next().value);// 반환값이 함수이니 반환된 함수를 실행하니 7777이 콘솔 로그에 찍힘.console.log(a.next().value());// yield에도 *(asterisk)를 찍어줄 수 있는데 yield를 쪼갠다고 보면 된다.console.log(a.next().value); // 1console.log(a.next().value); // 2console.log(a.next().value); // 3console.log(a.next().value); // 4// 그 다음엔 제너레이터 함수를 즉시 실행했으므로 이터레이터 객체가 반환된다.// 그 반환된 이터레이터 객체를 *을 써서 또 쪼갰다.console.log(a.next().value); // 5console.log(a.next().value); // 6// 이번엔 제너레이터 함수의 실행 결과가 아닌 함수 자체를 리턴했으므로 쪼갤 수가 없다.// 따라서 그 함수를 실행한 이터레이터 객체를 b에 따로 담아서 쪼개줘야한다.const b = a.next().value();console.log(b.next().value); // 7console.log(b.next().value); // 8 제너레이터 함수의 스코프를 벗어나는 공간에 yield를 쓸 수 없다. 12345const gen = function*() &#123; const arr = [1, 2, 3]; // 콜백 함수는 제너레이터 함수가 아니므로 yield를 쓸 수 없다. arr.forEach(v =&gt; yield v);&#125; 제너레이터를 통해 비동기 함수를 제어하는 방법이 있지만 ES2017의 async와 await를 적극 활용하기 바란다. (ES6+) ajax를 위한 fetch와 async&#x2F;await (ES6+) 비동기 함수를 깔끔하게 처리해보자. 참조 링크 [es6] GDG 2016 발표자료 function* - JavaScript | MDN ES6 In Depth: 제너레이터(Generator) ★ Mozilla 웹 기술 블로그 ES6 Generator with Aysnc | programmist","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"https://perfectacle.github.io/tags/Interface/"},{"name":"Symbol","slug":"Symbol","permalink":"https://perfectacle.github.io/tags/Symbol/"},{"name":"Iterator","slug":"Iterator","permalink":"https://perfectacle.github.io/tags/Iterator/"},{"name":"Generator","slug":"Generator","permalink":"https://perfectacle.github.io/tags/Generator/"}]},{"title":"(ES6) Iterator","slug":"ES6-Iterator","date":"2017-04-22T16:17:14.000Z","updated":"2022-10-30T08:42:16.079Z","comments":true,"path":"2017/04/22/ES6-Iterator/","link":"","permalink":"https://perfectacle.github.io/2017/04/22/ES6-Iterator/","excerpt":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol에 대한 내용은 링크를 참조하도록 하자.또한 이 글을 다 읽고 나서 ES6 Generator도 읽어보자.Iterator는 반복자란 뜻을 가지고 있으며, 대충 반복과 관련된 용어라는 것만 알고 글을 읽어보자. 다음에 나오는 예제는 이터레이터를 쓴다.ES6에서는 다음과 같은 문법에서 알게 모르게 이터레이터를 쓰고 있다.","text":"들어가기에 앞서이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.(ES6) Interface와 (ES6) Symbol에 대한 내용은 링크를 참조하도록 하자.또한 이 글을 다 읽고 나서 ES6 Generator도 읽어보자.Iterator는 반복자란 뜻을 가지고 있으며, 대충 반복과 관련된 용어라는 것만 알고 글을 읽어보자. 다음에 나오는 예제는 이터레이터를 쓴다.ES6에서는 다음과 같은 문법에서 알게 모르게 이터레이터를 쓰고 있다. 12345678910111213141516// 1. for offor(const num of [1, 2, 3, 4]) console.log(num); // 1 2 3 4// 2. spread operatorconst arr = [1, 2, 3];const arr2 = [...arr]; // shallow copy// 3. destructuring assignmentconst str = &#x27;asdf&#x27;;const [a, ...b] = str;console.log(a, b); // &#x27;a&#x27;, [&#x27;s&#x27;, &#x27;d&#x27;, &#x27;f&#x27;]// 4. rest parameterconst func = (a, ...args) =&gt; console.log(a, args);func(1, 2, 3, 4, 5); // 1, [2, 3, 4, 5] 위 문법은 이터러블한 객체(Iterable Interface를 준수한 객체, (Typed )Array, String, (Weak)Map&#x2F;Set)만 쓸 수 있는 문법이다. 1console.log(Array.prototype); 반면에 Object는 이터러블한 객체가 아니다. 1console.dir(Object.prototype); Symbol.iterator() 메소드를 눈 씻고 찾아볼 수가 없다.따라서 for of와 같은 문법을 쓸 수 없다.하지만 현재 object에도 spread operator와 destructuring assignment를 쓸 수 있게 한 제안이 Stage-3까지 올라가 있어서바벨의 transform-object-rest-spread나 Stage 3 preset을 쓰면 된다.그럼 이제 이터러블과 이터레이터가 뭔지 알아보자. Iterator 관련 Interface타입스크립트의 인터페이스 표기법을 사용하고 있으므로 타입스크립트에 익숙한 사람은이미지를 보자마자 무슨 의미인지 알 수 있을 것이다. Iterable Interface 인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: Symbol.iterator(well-known symbol 중 하나) 키(Symbol.iterator): 함수인데 반환 값은 Iterator 인터페이스를 준수한 객체가 오면 된다.123456// Iterable 인터페이스를 준수한 obj 객체const IterableObject = &#123; [Symbol.iterator]() &#123; return IteratorObject; &#125;&#125; Iterator Interface 인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: next라는 키를 가진다. 키(next)가 가져야할 값: 함수인데 반환 값은 IteratorResult 인터페이스를 준수한 객체이다. 123456// Iterator 인터페이스를 준수한 IteratorObject 객체.const IteratorObject = &#123; next() &#123; return IteratorResultObject; &#125;&#125; IteratorResult Interface인터페이스이기 때문에 객체가 가져야하는 키와 그 키가 가져야하는 값을 명시하고 있다. 가져야하는 키: value와 done이라는 키를 가진다. 키(value, done)가 가져야할 값: value에는 어떤 값이든 와도 상관 없고, done에는 boolean 값만 허용하고 있다. 12345// IteratorResult 인터페이스를 준수한 IteratorResultObject 객체const IteratorResultObject = &#123; value: console.log(&#x27;뭐든 들어와도 상관 없어!&#x27;), done: 1 &lt;= 0&#125; 커스텀 이터레이터를 만들어보자.위의 따분한 이론은 집어치우고 이제 배열의 요소를 거꾸로 반환하는 커스텀 이터레이터를 만들어보자.Array.prototype.reverse()가 없다고 생각해보자. 123456789101112131415161718192021222324252627// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function() &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.pop(), // value 값이 반환됨. done: this.length === 0 &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this)&#125;;for(const a of arr) console.log(a); // 0 undefined 3 2 까지만 찍히게 된다.for(const a of arr) console.log(a); // this.pop()으로 원본 배열을 손상시켜서 이터레이터가 1회성을 띈다. 그러면 이터레이터를 하나씩 분리해서 찍어보자.다시 말해 이터러블 객체는 반복 요소를 끊어서 실행할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function() &#123; console.log(this.length) return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.pop(), // value 값이 반환됨. done: this.length === 0 &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this)&#125;;const iter = arr[Symbol.iterator]();console.dir(iter); // Iterator 오브젝트를 반환함.// pop 하기 전 length: 5, pop 한 후 length 4console.log(iter.next()); // Object &#123;value: 0, done: false&#125;// pop 하기 전 length: 4, pop 한 후 length 3console.log(iter.next()); // Object &#123;value: undefined, done: false&#125;// pop 하기 전 length: 3, pop 한 후 length 2console.log(iter.next()); // Object &#123;value: 3, done: false&#125;// pop 하기 전 length: 2, pop 한 후 length 1console.log(iter.next()); // Object &#123;value: 2, done: false&#125;// pop 하기 전 length: 1, pop 한 후 length 0// 즉 value를 실행해서 pop을 먼저 실행하고 그 이후의 length인 0을 가지고 done이 평가되는 거임.// 그리고 그 done이 true이면 value를 반환하지 않게되니 1이 반환되지 않는 거였음.console.log(iter.next()); // Object &#123;value: 1, done: true&#125;console.log(iter.next()); // Object &#123;value: undefined, done: true&#125; 그럼 위에서 기술한 커스텀 이터레이터를 수정해보자. 123456789101112131415161718192021222324252627282930313233343536373839// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorResultObject = function(idx) &#123; return &#123; // IteratorResult 인터페이스를 준수한 객체를 반환 value: this.slice(-idx)[0], // value 값이 반환됨. done: --idx === this.length &#125;;&#125;;// this를 바인딩해야하므로 ES5식 함수 사용const makeIteratorObject = function() &#123; let idx = 0; return &#123; // Iterator 인터페이스를 준수한 객체를 반환 next: () =&gt; &#123; // 이 next 함수 안에 있는 내용은 매번 실행됨. // IteratorResult 인터페이스를 준수한 객체를 반환 return makeIteratorResultObject.call(this, ++idx); &#125; &#125;&#125;;const arr = [1, 2, 3, undefined, 0];// arr은 Iterable 인터페이스를 준수한 객체가 됨.arr[Symbol.iterator] = function() &#123; // 요 함수에 있는 내용은 한 번만 실행됨. // Iterator 인터페이스를 준수한 객체를 반환 return makeIteratorObject.call(this);&#125;;const iter = arr[Symbol.iterator]();console.log(iter.next()); // Object &#123;value: 0, done: false&#125;console.log(iter.next()); // Object &#123;value: undefined, done: false&#125;console.log(iter.next()); // Object &#123;value: 3, done: false&#125;console.log(iter.next()); // Object &#123;value: 2, done: false&#125;console.log(iter.next()); // Object &#123;value: 1, done: false&#125;console.log(iter.next()); // Object &#123;value: undefined, done: true&#125;// 원본 배열을 손상시키지 않으므로 이터레이터를 무한정 쓸 수 있다.for(const num of arr) console.log(num);for(const num of arr) console.log(num); 객체 관련 이터레이터객체 관련해서도 커스텀 이터레이터를 만들 수 있지만, 커스텀 이터레이터를 쓰지 않고도 이터레이터를 쓸만한 방법이 있다. 123456789101112131415161718192021222324const obj = &#123; name: &#x27;간장냥&#x27;, age: 25, [Symbol(&#x27;symbol&#x27;)]: &#x27;오 마이 심볼!&#x27;&#125;;obj.__proto__.asdf = &#x27;qwer&#x27;;// 객체의 키 뽑아내기(name과 age, [Symbol(&#x27;symbol&#x27;)])// ES5(Symbol로 지정한 키는 못 뽑아냄)for(const key in obj) &#123; if(obj.hasOwnProperty(key)) console.log(key);&#125;// ES6(Symbol로 지정한 키가 없으면 그냥 Object.keys를 쓰면 된다.)for(const key of Reflect.ownKeys(obj)) console.log(key);// 객체의 값 뽑아내기(간장냥과 25, &#x27;오 마이 심볼!&#x27;)// ES5(Symbol로 지정한 키는 못 뽑아냄)for(const key in obj) &#123; if(obj.hasOwnProperty(key)) console.log(obj[key]);&#125;// ES6(Symbol로 지정한 키가 없으면 그냥 Object.keys를 쓰면 된다.)for(const key of Reflect.ownKeys(obj)) console.log(obj[key]); 배열 순환 메소드를 개선시킨 break &amp; continue우리는 에서 (ES5) 배열의 순회 메소드에서 break 기능 구현하기배열에서 반복문에서 break, continue를 어떻게 구현할지 생각해보았다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수//ES3var isArrNum = function(arr) &#123; var isNum = false; // 프로그래머가 실수로 let i = 1;이라고 초기화한다면? // 실수로 i&lt;arr.length+1; 이라고 조건식을 잘못 입력한다면? // i+=2; 라고 증감식을 잘못 입력한다면? // arr[i+1]로 잘못 참조한다면? // 이렇게 일일이 초기화, 조건식 지정, 증감식 지정 등등을 일일이 해줘야하므로 귀찮다. for(var i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]); if(!isNaN(arr[i])) &#123; // 숫자라면 // 아래 있는 코드는 실행할 필요 없이 다음 요소를 검사해야함. // 즉 다음 반복문을 실행. continue; &#125; // 숫자가 아니라면 isNum = false; break; &#125; return isNum;&#125;;// ES5var isArrNum2 = function(arr) &#123; // 과연 직관적이라고 말할 수 있는가? return !arr.some(v =&gt; &#123; console.log(v); return isNaN(v); &#125;);&#125;;// ES6const isArrNum3 = arr =&gt; &#123; // 실수할 요소가 확연히 줄어들고 ES5보다 훨씬 직관적으로 변하였다. let isNum = true; for(const v of arr) &#123; console.log(v); if(!Number.isNaN(+v)) continue; isNum = false; break; &#125; return isNum;&#125;// 0// 1// 2// 3// q// falseconsole.log(isArrNum(arr));console.log(isArrNum2(arr));console.log(isArrNum3(arr)); 참조 링크 [es6] GDG 2016 발표자료 [MDN] Iteration protocols ES6 Iterable and Iterator | programmist 21. Iterables and iterators","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"https://perfectacle.github.io/tags/Interface/"},{"name":"Symbol","slug":"Symbol","permalink":"https://perfectacle.github.io/tags/Symbol/"},{"name":"Iterator","slug":"Iterator","permalink":"https://perfectacle.github.io/tags/Iterator/"}]},{"title":"(Webpack 2) 상대경로 헬파티에서 탈출하기","slug":"webpack2-escape-relative-path-hell","date":"2017-04-20T09:37:49.000Z","updated":"2022-10-30T08:42:17.007Z","comments":true,"path":"2017/04/20/webpack2-escape-relative-path-hell/","link":"","permalink":"https://perfectacle.github.io/2017/04/20/webpack2-escape-relative-path-hell/","excerpt":"상대경로 헬파티 &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.js에는 아래와 같은 변수가 들어가있다. 1export const num = 2; &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.scss에는 아래와 같은 변수가 들어가있다.","text":"상대경로 헬파티 &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.js에는 아래와 같은 변수가 들어가있다. 1export const num = 2; &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.scss에는 아래와 같은 변수가 들어가있다. 1$var: 100px; 이제 이 변수를 사용하는 모듈이 &#x2F;app&#x2F;src&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;f 폴더 안에 있는 녀석들이다.&#x2F;app&#x2F;src&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;f&#x2F;a.js 파일의 내용은 아래와 같다. 12import &#123;num&#125; from &#x27;../../../../../../lib/lib&#x27;;export const num2 = num*num; &#x2F;app&#x2F;src&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;f&#x2F;a.scss 파일의 내용은 아래와 같다. 123456@import &#x27;../../../../../../lib/lib&#x27;;div &#123; width: $var; height: $var; background-color: black;&#125; 자동 완성이 되는 IDE의 경우에는 다행이지만… 그렇지 않은 에디터를 사용하는 경우에는 헬파티가 열리게 된다.오늘은 이러한 문제점을 해결해보고자 한다! 프로젝트 세팅 일단 프로젝트로 쓸 디렉토리를 아무거나 만들고 터미널로 해당 디렉토리로 이동 후 다음 명령어를 쳐서 npm을 초기화 시키고 패키지들을 설치하자. 12npm init --ynpm i -S webpack html-webpack-plugin style-loader css-loader node-sass sass-loader 웹팩 2에서는 바벨 없이도 import&#x2F;export 문법을 쓸 수 있게 됐다! html-webpack-plugin빌드한 후에 소스 디렉토리에 있는 html 파일을 dist 디렉토리로 옮기기 위해 사용.script, css 파일 자동 삽입 및 템플릿 엔진 사용, html minify 등등 다양한 기능 제공. style-loader css-loadercss 파일을 모듈로써 사용하기 위해 사용. node-sass sass-loadersass, scss 파일을 모듈로써 사용하기 위해 사용. 프로젝트 디렉토리에 웹팩 설정 파일인 webpack.config.js 파일을 만들고 아래와 같이 적어주자.웹팩 1은 Configuration - Webpack 링크를 참조하자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const ROOT = &#x27;./app/src&#x27;;const DIST = &#x27;./app/dist&#x27;;module.exports = &#123; entry: &#123; app: `$&#123;ROOT&#125;/index`, &#125;, output: &#123; filename: &#x27;bundle.js&#x27;, path: `$&#123;__dirname&#125;/$&#123;DIST&#125;` &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: `$&#123;ROOT&#125;/index.html` &#125;), new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;) ], module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; test: /\\.scss$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#123; loader: &#x27;sass-loader&#x27;, // 사스에서 상대경로 헬파티를 구제해줄 속성 options: &#123; includePaths: [ROOT] &#125; &#125;] &#125;] &#125;, resolve: &#123; // es6 native module에서 상대경로 헬파티를 구제해줄 속성 modules: [ROOT, &#x27;./node_modules&#x27;] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는 게 보기 싫어서 추가.process.noDeprecation = true; &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.js은 아래와 같이 만들어주자. 1export const num = 2; &#x2F;app&#x2F;src&#x2F;lib&#x2F;lib.scss도 아래와 같이 만들어주자. 1$var: 100px; 이제 &#x2F;app&#x2F;src&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;f&#x2F;a.js를 아래와 같이 만들어주자.상대 경로의 헬파티로부터 벗어나게 된다. 12import &#123;num&#125; from &#x27;lib/lib&#x27;;export const num2 = num*num; &#x2F;app&#x2F;src&#x2F;a&#x2F;b&#x2F;c&#x2F;d&#x2F;e&#x2F;f&#x2F;a.scss도 아래와 같이 만들어주자.역시 상대 경로의 헬파티로부터 벗어나게 된다. 123456@import &#x27;lib/lib&#x27;;div &#123; width: $var; height: $var; background-color: black;&#125; &#x2F;app&#x2F;src&#x2F;index.js는 아래와 같이 만들어주자. 1234import &#123;num2&#125; from &#x27;./a/b/c/d/e/f/a&#x27;;import &#x27;./a/b/c/d/e/f/a.scss&#x27;;console.log(num2); &#x2F;app&#x2F;src&#x2F;index.html은 아래와 같이 만들어주자.번들 된 js 경로를 입력하지 않아도 html-webpack-plugin이 알아서 삽입해준다. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; package.json에 빌드 스크립트를 넣어주자.scripts 부분에 넣어주면 된다. 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;$(npm bin)/webpack&quot;&#125; 그리고 다음과 같이 빌드를 해보자. 1npm start 그리고 나서 &#x2F;app&#x2F;dist&#x2F;index.html을 열어보면 다음과 같이 원하는 결과를 얻을 수 있다. 100x100의 까만 div와 2*2&#x3D;4의 결과를 콘솔창에서 볼 수 있다. 갓텔리제이 짱짱맨 한 가지 아쉬운 점이라면 IDE는 웹팩에서 정해준 루트 경로를 이해하지 못한다.따라서 자동완성과 인덱싱(폴더가 존재하는 경로나 파일로 이동)을 지원하지 않는다. 아마 Jet Brains의 IDE(Webstorm, PHPStorm 등등)에서는 다 지원될 것이다.최신 버전으로 업데이트 한 후에 &#x2F;app&#x2F;src 경로를 Resource Root로 지정해주자.Source Root로 지정하면 sass에서 모듈을 인덱싱하지 못한다. 경로, 변수 자동 완성 및 인덱싱까지 너무 잘 돼서 개발자에게 뽀뽀 해주고 싶은 심정이다.다른 IDE는 어떤지 모르겠지만 역시 갓텔리제이라 할만하다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"}]},{"title":"(Webpack 2) 최적화하기","slug":"webpack2-optimize","date":"2017-04-18T09:56:26.000Z","updated":"2022-10-30T08:42:17.011Z","comments":true,"path":"2017/04/18/webpack2-optimize/","link":"","permalink":"https://perfectacle.github.io/2017/04/18/webpack2-optimize/","excerpt":"들어가기에 앞서이 포스트들에서 말하는 내용들은 전부 배포용 파일에 적합한 작업이다.이런 압축 작업을 개발용 버전에서 매번 빌드할 때마다 실행하면 빌드 시간이 매우 느려지기 때문이다. 우리는 (Webpack 2) 트리 쉐이킹을 해보자!에서 모듈 전체가 로딩 되는 CommonJS 방식에서모듈의 필요한 부분만 로딩하는 ES2015 Native Module 방식을 사용하는 법을 배웠다.(Tree Shaking)또한 (Webpack 2) 코드를 분할해보자!에서 공통된 라이브러리를 분리시켜 사용자가 재접속시 캐싱을 적극 활용하게 바꿨고,모든 페이지의 코드를 로딩하는 것이 아닌 페이지를 이동할 때마다 필요한 소스만 로딩하게 끔 청크 별로 코드를 분할하였다. (Code Splitting)그리고 Webpakc 2가 미완성이라 코드 스플리팅이 제대로 되지 않아 일일이 필요한 모듈 파일을 하나씩 명시해줬어야 했는데,이를 좀 더 똑똑하게 해주는 바벨 플러그인을 소개한 내용을 (Webpack 2) 트리 쉐이킹을 똑똑하게 해보자! 통해서 보았다.이번 포스트에서는 이와 더불어 조금이라도 더 소스 코드를 최적화하는 방법을 소개하도록 하겠다.별로 안 대단해보일 수 있지만, 필자는 상당히 흥미롭게 느낀 내용이다.혹시 위 3개 포스트를 보지 않은 사람은 따라하지는 않더라도 꼭 읽어보길 바란다. 예제는 아래 깃헙 저장소의 hot-3 브랜치를 기준으로 진행된다.https://github.com/perfectacle/react-router-4/tree/hot-3","text":"들어가기에 앞서이 포스트들에서 말하는 내용들은 전부 배포용 파일에 적합한 작업이다.이런 압축 작업을 개발용 버전에서 매번 빌드할 때마다 실행하면 빌드 시간이 매우 느려지기 때문이다. 우리는 (Webpack 2) 트리 쉐이킹을 해보자!에서 모듈 전체가 로딩 되는 CommonJS 방식에서모듈의 필요한 부분만 로딩하는 ES2015 Native Module 방식을 사용하는 법을 배웠다.(Tree Shaking)또한 (Webpack 2) 코드를 분할해보자!에서 공통된 라이브러리를 분리시켜 사용자가 재접속시 캐싱을 적극 활용하게 바꿨고,모든 페이지의 코드를 로딩하는 것이 아닌 페이지를 이동할 때마다 필요한 소스만 로딩하게 끔 청크 별로 코드를 분할하였다. (Code Splitting)그리고 Webpakc 2가 미완성이라 코드 스플리팅이 제대로 되지 않아 일일이 필요한 모듈 파일을 하나씩 명시해줬어야 했는데,이를 좀 더 똑똑하게 해주는 바벨 플러그인을 소개한 내용을 (Webpack 2) 트리 쉐이킹을 똑똑하게 해보자! 통해서 보았다.이번 포스트에서는 이와 더불어 조금이라도 더 소스 코드를 최적화하는 방법을 소개하도록 하겠다.별로 안 대단해보일 수 있지만, 필자는 상당히 흥미롭게 느낀 내용이다.혹시 위 3개 포스트를 보지 않은 사람은 따라하지는 않더라도 꼭 읽어보길 바란다. 예제는 아래 깃헙 저장소의 hot-3 브랜치를 기준으로 진행된다.https://github.com/perfectacle/react-router-4/tree/hot-3 너무나 많은 청크들위 저장소를 클론 받고 패키지를 전부 설치한 후에 번들링 해보자. 12npm inpm run build 청크 별로 코드를 분할 시켜서 로딩시간을 단축시켰다고 생각할 수 있지만 그렇지 않을 수도 있다.실제 코드를 로딩받는 시간보다 http 요청을 수십, 수백 회 증가시키는 행위가 오히려 더 로딩시간을 늘리게 될 수가 있다.http 1.1 스펙에서 하나의 요청당 하나의 응답(js 파일 등등)만 받아올 수 있는데 그 하나의 요청을 위한 비용은 어찌보면코드 하나를 다운받는 것보다 더 비싼 비용을 지불하게 될 경우가 있다.우리의 코드가 그렇다. 코드의 용량이 그렇게 크지가 않다면 차라리 하나의 요청으로 일정 크기를 한 번에 받아버리는 게 나을 수 있다.그렇다, 청크의 최소 용량을 정해주는 것이다. 아래와 같이 웹팩 배포용 설정 파일일 webpack.config.js의 plugins에 아래 내용을 추가해주자. 123new webpack.optimize.MinChunkSizePlugin(&#123; minChunkSize: 512000 // 50kb&#125;) 라우팅 된 컴포넌트의 코드 스플리팅이 안 된 것처럼 보이지만,앱이 점점 커지고 컴포넌트 수가 급격히 증가하고, 코드의 용량이 증가하다보면50kb짜리 코드 여러 개로 분할될 것이다. 자바스크립트 코드 압축의 3단계아래와 같은 코드를 짰다고 생각해보자. 123const num1 = 123;const num2 = 456;console.log(num1 + num2); // 579 minify(압축)시키면 아래와 같이 변한다. 1const num1=123;const num2=456;console.log(num1+num2) 여기서 한 단계 앞서 나가가서 보통 uglify(난독화)까지 하게 된다. 1const a=123;const b=456;console.log(a+b) 하지만 여기서 한 단계 더 압축할 수 있다는 사실이 존재한다.바로 gzip(GNU zip) 알고리즘을 써서 압축하는 것이다.아래 글을 통해 주의 사항들을 확인해보자.Gzip에 관하여주로 유닉스 기반의 운영 체제인 유닉스, 리눅스, 맥 등등에서 많이 쓰인다.이러한 알고리즘을 써서 js 파일을 gz 파일로 압축하고, 브라우저에서 이 gz 파일을 열게되는 것이다.브라우저 지원 현황은 아래와 같은데 IE4부터 지원한다니 말 다 했다.Which browsers can handle Content-Encoding: gzip ?이를 위해선 서버가 필요한데 섭알못(서버를 알지 못함)이고 자바스크립트가 익숙하기 때문에 노드 js 기반의 서버를 기준으로 설명하겠다. 우선 노드 js에서 gzip 파일을 불러오는 모듈과 웹팩에서 gz으로 압축해주는 플러그인을 설치하자. 1npm i -S compression compression-webpack-plugin 그리고 server.js를 아래와 같이 수정해주자. 1234567891011121314151617181920const express = require(&#x27;express&#x27;);const compression = require(&#x27;compression&#x27;);const app = express();const PORT = 3000;const DIST = `$&#123;__dirname&#125;/app/dist/`;// load *.gz// app.use(&#x27;/&#x27;, express.static(DIST)); 보다 위에 존재해야함.app.use(compression());// server-openapp.use(&#x27;/&#x27;, express.static(DIST));app.listen(PORT, () =&gt; &#123; console.log(&#x27;Express listening on port&#x27;, PORT);&#125;);// client routerapp.get(&#x27;*&#x27;, (req, res) =&gt; &#123; res.sendFile(DIST);&#125;); 그리고 웹팩 배포용 설정 파일인 webpack.config.js를 다음과 같이 수정하자. 12345678910const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);// ...// plugins에 아래 플러그인 추가new CompressionPlugin(&#123; asset: &quot;[path].gz[query]&quot;, algorithm: &quot;gzip&quot;, test: /\\.(js|html)$/, threshold: 10240, // 10kb minRatio: 0.8&#125;) 그럼 위와 같이 gz으로 압축된 vendor 파일을 볼 수 있다.파일 크기가 너무 작으면 압축을 해제하는데 더 큰 시간을 소모하므로 threshold를 잘 지정해주자. 실제 페이지를 보면 위와 같이 vendor.js의 파일 용량(받은 용량)이 179kb가 아닌 50kb임을 알 수 있다. 이 외에도 chunk의 최대 갯수(코드 스플리팅하는)를 제한하는 LimitChunkCountPlugin 등등이 있으니 궁금한 사람은 더 찾아보길 바란다. 참조 링크 SPA 초기 로딩 속도 개선하기 SPA 스크립트 용량 어디까지 줄일 수 있을까 Two Quick Ways To Reduce React App’s Size In Production 프로덕션 우수 사례: 성능 및 신뢰성 Gzip에 관하여 Webpack 2 - Plugins","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"Optimize","slug":"Optimize","permalink":"https://perfectacle.github.io/tags/Optimize/"},{"name":"gzip","slug":"gzip","permalink":"https://perfectacle.github.io/tags/gzip/"}]},{"title":"(ES6) Symbol","slug":"ES6-Symbol","date":"2017-04-16T15:15:31.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/04/16/ES6-Symbol/","link":"","permalink":"https://perfectacle.github.io/2017/04/16/ES6-Symbol/","excerpt":"목차 들어가기에 앞서 원시값(Primitive Value) 객체(Object) Symbol의 특성 Symbol의 탄생 배경 Symbol의 사용 사례 Symbol 파헤치기 프로퍼티의 은닉화? 들어가기에 앞서Symbol은 새로 생긴 7번 째 자료형이며 원시값(Primitive Value)이다.Symbol에 들어가기 전에 몸풀기로 ES5의 자료형부터 알아보고 가자.ES5에는 6가지 자료형이 있다.","text":"목차 들어가기에 앞서 원시값(Primitive Value) 객체(Object) Symbol의 특성 Symbol의 탄생 배경 Symbol의 사용 사례 Symbol 파헤치기 프로퍼티의 은닉화? 들어가기에 앞서Symbol은 새로 생긴 7번 째 자료형이며 원시값(Primitive Value)이다.Symbol에 들어가기 전에 몸풀기로 ES5의 자료형부터 알아보고 가자.ES5에는 6가지 자료형이 있다. Boolean Number String Null Undefined Object 원시값(Primitive Value)Object를 제외한 값들은 원시값이다.값이 유한하며, 그리고 값으로서 비교한다.(고 생각했지만 심볼을 보면 틀린 말 같다.심볼을 생각하면 원시값은 프로퍼티를 추가할 수 있느냐 없느냐와 불변값이냐로 나뉘는 것 같다.)다음 값은 모두 참이다. 12345console.log(false === false);console.log(&#x27;asdf&#x27; === &#x27;asdf&#x27;);console.log(null === null);console.log(undefined === undefined);console.log(1 === 1); 하지만 다음과 같은 예외(버그)가 존재한다. 123console.log(0 === -0); // trueconsole.log(NaN === NaN); // falseconsole.log(typeof null); // object typeof null을 제외하고 나머지 문제는 아래와 같이 해결할 수 있다. 1234console.log(Object.is(0, -0)); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(isNaN(NaN)); // trueconsole.log(Number.isNaN(NaN)); // true isNaN은 NaN인지 아닌지 구하기 위한 함수이며, ES6 들어서 Number.isNaN()과 Object.is() 메소드가 생겼다.isNaN과 Number.isNaN의 차이는 후자는 타입 검사(number인지 아닌지)까지 한다는 것이다.아래 링크를 통해 예제로 확인해보자.Number.prototype.isNaN() 하지만 typeof null을 개선하면 레거시 코드들이 문제가 있는지 아직도 고쳐지지 않았다.아래 링크를 참조해서 누가 번역을 해주면 고마울 것 같다.The history of “typeof null” 또한 원시값은 불변값(Immutable Value)이다.아래의 결과가 당연하다고 생각하는 사람은 객체에서는 어떻게 결과가 나타나는지 객체 파트를 보길 바란다. 12345var a = &#x27;strin&#x27;;var b = a;a += &#x27;g&#x27;;console.log(a); // &#x27;string&#x27;console.log(b); // &#x27;strin&#x27; 객체(Object)객체는 Boolean, Number, String, Null, Undefined를 제외한 자료형이다. 123456console.log(typeof function()&#123;&#125;); // functionconsole.log(typeof []); // objectconsole.log(typeof /\\d/); // objectconsole.log(typeof new Data()); // objectconsole.log(typeof &#123;&#125;); // object// ES6에서는 (Weak)Map/Set과 TypedArray까지 객체로 추가되었다. 어… Function은 타입이 function인데 Array나 RegExp, Date는 왜 object인지 아는 사람이 있으면 알려주길 바란다.일단 저 위에 있는 놈들은 객체이기 때문에 프로퍼티를 할당할 수 있다.콘솔 창에서 각각 a란 프로퍼티가 붙었는지 보자. 123456789101112131415var func = function()&#123;&#125;;var arr = [];var regExp = /\\d/;var date = new Date();var obj = &#123;&#125;;func.a = 1;arr.a = 1;regExp.a = 1;date.a = 1;obj.a = 1;console.dir(func);console.dir(arr);console.dir(regExp);console.dir(date);console.dir(obj); 또한 객체는 참조 타입인 것 같다.가지고 있는 값으로서 비교하는 게 아니라 저장된 메모리 주소를 참조하여 같은지 비교하는 것 같다.또한 갯수도 무한하다.다음은 모두 거짓을 반환한다. 12345console.log(function()&#123;&#125; === function()&#123;&#125;);console.log([] === []);console.log(/\\d/ === /\\d/);console.log(new Date() === new Date());console.log(&#123;&#125; === &#123;&#125;); 또한 객체는 참조 타입이기 때문에 불변값이 아니다. 123456var arr = [];var arr2 = arr;arr.push(1);// arr2에 넣지도 않은 1의 값이 들어가있다. // 이는 arr2가 arr의 값을 가져온 게 아니라 메모리 주소를 가져와 참조하고 있기 때문에 발생한다.console.log(arr2); // [1] 이런 객체 타입을 불변값으로 만드는 예제는 아래 링크를 참조하자.직접 구현해본 JS 객체, 배열의 깊은 복사하는 방법 Symbol의 특성여기서는 심볼에 대해 간략하게만 설명하겠다.백날 이론을 봐봤자 왜 써야하며 언제 써야하는지를 모르면 무의미하다고 여기기 때문이다.따라서 간단하게만 특성을 보고 탄생 배경과 사용 사례를 본 이후에 본격적인 설명을 하겠다.Symbol은 새로 생긴 7번 째 자료형이며 원시값(Primitive Value)이다.기존 원시값들은 위에서 보는 바와 같이 값으로서 비교를 했다.하지만 심볼은 원시값임에도 불구하고 객체와 같이 참조하는 메모리의 주소를 가지고 비교하는 것 같다. 1console.log(Symbol(&#x27;a&#x27;) === Symbol(&#x27;a&#x27;)); // false 심볼은 생성할 때마다 독자적인 메모리 공간을 가져서 고유함을 유지한다.그럼에도 불구하고 원시값이란다.내가 아는 원시값은 값으로서 비교하는 것 같았는데 그럼 얘는 왜 원시값이라 부르는 걸까?그건 아마도 심볼이 불변값이며 프로퍼티를 추가(객체의 특성)할 수 없기 때문이 아닐까 싶다. 123const a = Symbol(&#x27;a&#x27;);a.a = 1;console.dir(a); // a 프로퍼티가 안 찍혀서 나온다. Symbol의 탄생 배경이라고 하긴 뭐하고 어떤 문제점 때문에 심볼이란 놈이 생긴 건지 간단하게 다루어보았다.아래와 같은 코드를 보자. 1234567// ES5에서 Array인지 아닌지 구분하는 표준화된 방법이 없다. // typeof 연산자를 써도 object를 반환하기 때문에 구분해낼 방법이 없다. // 따라서 아래와 같이 함수화시켜서 라이브러리로 제작 후에 많은 사람에게 배포했다고 가정해보자. // 예제기 때문에 Boolean 대신에 String을 반환하게 했다는 점은 감안해주길 바란다.Array.isArray = function(arg) &#123; return (Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;) ? &#x27;Array&#x27; : &#x27;Not Array&#x27;;&#125;; 이 라이브러리는 전 세계의 수백만 개발자들이 쓰게 되었고, 많은 사람들이 아래와 같이 코드를 짜기 시작했다. 123var arr = [1, 2, 3];if(Array.isArray(arr) === &#x27;Array&#x27;) console.log(&#x27;나는 배열이당!&#x27;);else console.log(&#x27;나는 배열이 아니당!&#x27;); 하지만 ES6 들어서 위에 우리가 사용한 Array.isArray 메소드가 표준 메소드로 지정되었다!그리고 그 메소드는 우리가 예측한 문자열들이 아닌 Boolean 값을 반환하는 메소드다!따라서 우리 라이브러리를 사용해서 개발한 사용자들의 코드가 의도한 대로 작동하지 않을 가능성이 있다!하지만 다행히도 위 메소드는 덮어쓰기가 가능하다.그래도 우리 라이브러리를 쓰는 개발자가 ES6의 표준 메소드 작동 방식으로 Array.isArray를 썼다간 낭패를 볼 것이다. 1console.log(Object.getOwnPropertyDescriptor(Array, &#x27;isArray&#x27;).writable); // true 하지만 모든 프로퍼티가 덮어쓰기가 가능한 게 아니다.아래와 같이 상수(네이밍이 UPPER_SNAKE_CASE로 돼있다.) 프로퍼티도 존재하기 때문이다. 1console.log(Object.getOwnPropertyDescriptor(Number, &#x27;MAX_SAFE_INTEGER&#x27;).writable); // false Symbol의 사용 사례 표준 객체의 프로퍼티로 사용위에서 봤 듯이 표준 객체에 혹시 내가 쓴 프로퍼티가 표준 프로퍼티가 되는 불상사(?)가 생긴다면 코드가 의도치 않게 작동할 것이다.물론 매우 드문 일일 것이지만, 코드를 방어적으로 쓰는 습관은 항상 들여야하는 것 같다.위의 Array.isArray를 우리는 심볼을 사용해서 문제를 회피할 것이다. 12345678910const isArray = Symbol(&#x27;isArray&#x27;);Array[isArray] = arg =&gt; ( (Object.prototype.toString.call(arg) === &#x27;[object Array]&#x27;) ? &#x27;Array&#x27; : &#x27;Not Array&#x27;);// Array.isArray를 지원하는 모던 브라우저(크롬, 파폭의 최신 버전 등등)에서 아래 코드를 확인해보자.console.dir(Array);// 사용은 아래와 같이 하면 된다.const arr = &#123;&#125;;if(Array[isArray](arr) === &#x27;Array&#x27;) console.log(&#x27;나는 배열이당!&#x27;);else console.log(&#x27;나는 배열이 아니당!&#x27;); 이런 식으로 심볼을 사용하게 되면 표준 메소드 때문에 벌벌 떨며 염려할 필요가 사라진다.하지만 위 사례에서도 하나 문제점이 존재한다.바로 전역 공간에 심볼을 노출해야한다는 점이다.우리의 라이브러리가 점점 규모가 커져서 아래와 같이 다양한 타입을 검출한다고 가정해보자. 12345678910111213141516const isArray = Symbol(&#x27;isArray&#x27;);const isRegExp = Symbol(&#x27;isArray&#x27;);const isDate = Symbol(&#x27;isArray&#x27;);const isObject = Symbol(&#x27;isArray&#x27;);Array[isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[isObject] = arg =&gt; &#123; // 코드 작성&#125;; 이렇게 전역 공간에 심볼을 일일이 노출시키는 게 마음이 들지 않으므로 네임 스페이스 패턴을 사용해서 모듈을 구현할 수 있다.전역에는 단 하나의 변수인 $SYMBOL만 노출되므로 좀 더 안전하게 코드를 작성할 수 있다. 123456789101112131415161718const $SYMBOL = &#123; // 전역 공간에 노출되므로 그 어떤 이름과도 충돌이 나지 않게 지어야한다. isArray: Symbol(&#x27;isArray&#x27;), isRegExp: Symbol(&#x27;isArray&#x27;), isDate: Symbol(&#x27;isArray&#x27;), isObject: Symbol(&#x27;isArray&#x27;)&#125;;Array[$SYMBOL.isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[$SYMBOL.isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[$SYMBOL.isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[$SYMBOL.isObject] = arg =&gt; &#123; // 코드 작성&#125;; 좀 더 우아하게 코드를 작성하고 싶은 사람은 ES6의 import&#x2F;export(를 브라우저에서 미지원하므로 모듈 번들러인 Webpack 등등까지 사용)를 해보자. 1234567891011121314151617181920// symbol.jsexport const isArray = Symbol(&#x27;isArray&#x27;);export const isRegExp = Symbol(&#x27;isArray&#x27;);export const isDate = Symbol(&#x27;isArray&#x27;);export const isObject = Symbol(&#x27;isArray&#x27;);// lib.jsimport &#123;isArray, isRegExp, isDate, isObject&#125; from &#x27;./symbol&#x27;;Array[isArray] = arg =&gt; &#123; // 코드 작성&#125;;RegExp[isRegExp] = arg =&gt; &#123; // 코드 작성&#125;;Date[isDate] = arg =&gt; &#123; // 코드 작성&#125;;Object[isObject] = arg =&gt; &#123; // 코드 작성&#125;; 표준 심볼(Well-known Symbol)로써 사용ES6가 등장하기 전에 사람들의 필요에 의해 생성하거나 개발한 함수들이 많을 것이다.그 중에 공통된 함수들은 기능과 네이밍이 비슷한 경우가 많을 것이다. (내부 로직은 다를지라도)이렇게 많은 사람들이 쓴 함수의 이름 등등을 표준 프로퍼티로 만들고 나면?내부 로직이 다 같지는 않으므로 그 수많은 코드가 깨질 수 있다. (우리 Array.isArray와 마찬가지로 말이다.)따라서 기존 개발자들이 개발한 코드들의 안전성을 보장하고자 표준 프로퍼티를 심볼로 만든 경우가 있다.그 목록은 아래와 같다. Symbol.iterator(추후 다룰 예정) Symbol.unscopables Symbol.match Symbol.species Symbol.toPrimitive 등등… Symbol 파헤치기이제 왜 쓰는지를 알았으니 본격적으로 심볼에 대해 파헤쳐보자.심볼은 생성할 때마다 독자적인 영역을 가지지만 공유도 가능하다. 123456789101112const a = Symbol(&#x27;key&#x27;);const b = Symbol.for(&#x27;key2&#x27;);console.log(a === Symbol(&#x27;key&#x27;)); // falseconsole.log(b === Symbol.for(&#x27;key2&#x27;)); // true// usageconst obj = &#123; [a]: 1, [b]: 2&#125;;console.log(obj[a]); // 1console.log(obj[b]); // 2 또한 심볼의 타입은 symbol이며 new 연산자를 써서 생성하면 오류가 뜬다.(당연한 소리처럼 들리겠지만 ES5의 function의 경우를 생각하면 이런 오류 하나하나가 참 감사하다.) 123console.log(typeof Symbol(&#x27;a&#x27;)); // &#x27;symbol&#x27;// 이제 new 연산자는 클래스에서만 쓰자, 이제 자바스크립트가 꽃길만 걷길 바란다.const a = new Symbol(&#x27;a&#x27;); // Uncaught TypeError: Symbol is not a constructor 그럼 저 Symbol 안에 들어가는 문자열은 무엇에 쓰이는 물건인고?하면… 디버깅 용으로 쓰인다고 한다.개인적으로는 변수명만으로도 어떤 심볼인지 유추가 가능할 것 같은데 심볼의 문자열을 가지고 디버깅을 어떻게 하는지 모르겠지만…심볼의 문자열을 가지고 노는 방법은 아래와 같다. 12345678const asdf = Symbol(&#x27;asdf&#x27;);const qwer = Symbol.for(&#x27;qwer&#x27;);console.log(asdf); // Symbol(asdf), 문자열이 아닌 Symbol 타입이다.console.log(String(asdf)); // &#x27;Symbol(asdf)&#x27;console.log(asdf.toString()); // &#x27;Symbol(asdf)&#x27;console.log(&#x27;&#x27; + asdf); // Uncaught TypeError: Cannot convert a Symbol value to a stringconsole.log(asdf.toString().substr(7).slice(0, -1)); // &#x27;asdf&#x27;console.log(Symbol.keyFor(qwer)); // &#x27;qwer&#x27; 프로퍼티의 은닉화?심볼은 객체의 프로퍼티(메소드)에 쓸 때 우리는 그 값을 참조할 수 있을까?있다! 따라서 은닉화를 위해서 Symbol을 쓰는 건 올바른 방법이 아니다. 1234567891011121314151617181920212223const symbol = Symbol(&#x27;symbol&#x27;);const symbol2 = Symbol(&#x27;symbol2&#x27;);const obj = &#123; key: 1, method: () =&gt; console.log(2), [symbol]: 3, [symbol2]: () =&gt; console.log(4)&#125;;// Symbol은 객체의 표준 메소드나 기존의 방법으로는 노출되지 않는다. for(const key in obj) console.log(key); // &#x27;key&#x27; &#x27;method&#x27;console.log(Object.keys(obj)); // [&#x27;key&#x27;, &#x27;method&#x27;]console.log(Object.getOwnPropertyNames(obj)); // [&#x27;key&#x27;, &#x27;method&#x27;]// 하지만 그렇다고 해서 프로퍼티가 은닉화된 것은 아니다.// 아래와 같이 접근이 가능하기 때문이다.console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(symbol), Symbol(symbol2)]// 프로퍼티(키와 심볼)를 모두 가져오려면 Reflect 객체를 사용해야한다.// 레인보우 리플렉션(무지개 반사)을 초등학교 때 많이 썼는데, Reflect는 &#x27;비추다&#x27;란 뜻이다.// 즉 해당 객체를 비추어 안에 내용물을 다 본다고 생각하면 될 것 같다.console.log(Reflect.ownKeys(obj)); // [&#x27;key&#x27;, &#x27;method&#x27;, Symbol(symbol), Symbol(symbol2)] 이 이상 심볼에 대해 더 딥하게 다루기에는 실용성이 떨어질 것 같고 그 때 그 때 찾아보면 될 것 같다.사실 이터레이터 때문에 공부를 했지 실무에서 많이 쓸지는 잘 모르겠다.이 글을 읽고 난 독자는 다음 글을 읽기 바란다.(ES6) Iterator 참조 링크 Symbol - JavaScript | MDN ES6 In Depth: 심볼 (Symbol) ★ Mozilla 웹 기술 블로그 es6js&#x2F;07 심볼 at master · js-jsm&#x2F;es6js","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Symbol","slug":"Symbol","permalink":"https://perfectacle.github.io/tags/Symbol/"}]},{"title":"(Webpack 2) 트리 쉐이킹을 똑똑하게 해보자!","slug":"webpack2-smart-tree-shaking","date":"2017-04-12T09:10:25.000Z","updated":"2022-10-30T08:42:17.015Z","comments":true,"path":"2017/04/12/webpack2-smart-tree-shaking/","link":"","permalink":"https://perfectacle.github.io/2017/04/12/webpack2-smart-tree-shaking/","excerpt":"들어가기에 앞서이 포스트는 (Webpack 2) 트리 쉐이킹을 해보자!의 후속작이다.따라서 해당 포스트를 읽고 예제를 진행한 후에 보는 걸 추천한다.또한 내가 리액트 말고 할 줄 아는 게 별로 없어서 예제를 리액트로만 진행하다보니혹시 헷갈리면 다른 라이브러리로 진행해보길 바란다. 복습우리는 지난 포스트에서 리액트 라우터를 트리 쉐이킹하였다.아래와 같이 기존에 쓰던 방식대로 진행하면 쓰지도 않는 모듈들이 전부 번들링되는 참사가 발생한다.","text":"들어가기에 앞서이 포스트는 (Webpack 2) 트리 쉐이킹을 해보자!의 후속작이다.따라서 해당 포스트를 읽고 예제를 진행한 후에 보는 걸 추천한다.또한 내가 리액트 말고 할 줄 아는 게 별로 없어서 예제를 리액트로만 진행하다보니혹시 헷갈리면 다른 라이브러리로 진행해보길 바란다. 복습우리는 지난 포스트에서 리액트 라우터를 트리 쉐이킹하였다.아래와 같이 기존에 쓰던 방식대로 진행하면 쓰지도 않는 모듈들이 전부 번들링되는 참사가 발생한다. 1import &#123;Router, Route, hashHistory&#125; from &#x27;react-router&#x27;; 티끌 모아 태산이라고 우리의 앱이 쓰지도 않는 모듈들로 눈덩이처럼 불어날지도 모른다.따라서 우리는 아래와 같이 해주었다. 123import Router from &#x27;react-router/es/Router&#x27;;import Route from &#x27;react-router/es/Route&#x27;;import hashHistory from &#x27;react-router/es/hashHistory&#x27;; 매우 귀찮아보이지 않는가?패키지가 늘어나고, 불러올 모듈들이 증가하면 한 줄 한줄 일일이 입력해줘야한다. 실습그럼 이제 이를 어떻게 해결할지 간단한 예제를 만들자.프로젝트 폴더를 만들고 package.json 파일을 만들자.그리고 다음과 같은 패키지들을 설치해준다. 12npm i -S react react-dom react-router@^3.xnpm i -D babel-core babel-preset-env babel-preset-react babel-loader babel-plugin-transform-imports babel-plugin-transform-imports 요 녀석이 바로 핵심이다. 프로젝트 폴더에 .babelrc(바벨 설정 파일)을 만들어주자. 1234567891011121314151617181920&#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;&gt; 10%&quot;, &quot;ie 9&quot;], &quot;modules&quot;: false, &#125; ], &quot;react&quot; ], &quot;plugins&quot;: [ [&quot;transform-imports&quot;, &#123; &quot;react-router&quot;: &#123; &quot;transform&quot;: &quot;react-router/es/$&#123;member&#125;&quot;, &quot;preventFullImport&quot;: true &#125; &#125;] ]&#125; 플러그인 부분에 내용에 주목하자. 12345678910111213plugins: [ // 배열의 첫 번째 요소로 배열(transform-imports 플러그인 정보를 담은)이 옴. // 그 배열 안에는 transform-imports 플러그인 임을 알려주는 요소가 첫 번째로 들어와있고, // 두 번째 요소로 객체가 들어오는데 이는 react-router 모듈에 대한 객체이다. // transform 프로퍼티에서 어떤 폴더를 기점으로 모듈들을 일일이 불러올지 기술했다고 보면 될 것 같다. // preventFullImport, 쓰지도 않는 녀석은 불러오지 않는 걸(트리 쉐이킹) true로 지정했다. [&quot;transform-imports&quot;, &#123; &quot;react-router&quot;: &#123; &quot;transform&quot;: &quot;react-router/es/$&#123;member&#125;&quot;, &quot;preventFullImport&quot;: true &#125; &#125;]] webpack.config.js(웹팩 설정 파일)도 만들어주자. 12345678910111213141516171819202122232425262728293031323334353637383940const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: &#x27;./&#x27;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거를 하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don&#x27;t change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;) ], module: &#123; // 웹팩 1에서는 loaders를 썼지만 2에선 rules rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 쿼리가 필요한 로더는 loader로 써줘야함. // 쿼리가 필요 없는 로더는 use로 써도 된다. // 웹팩 2에선 babel-loader와 같이 -loader 생략이 불가능해졌다. use: &#x27;babel-loader&#x27; &#125; ] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는데 보기 싫다면 주석을 제거하면 된다.// process.noDeprecation = true; index.html도 만들어주자. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 엔트리(index.js) 파일도 만들어주자. 123456789101112import React from &#x27;react&#x27;;import &#123;render&#125; from &#x27;react-dom&#x27;;import &#123;Router, Route, hashHistory&#125; from &#x27;react-router&#x27;;const Comp = () =&gt; &lt;h2&gt;하이&lt;/h2&gt;;render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById(&#x27;app&#x27;)); 터미널을 키고 아래와 같이 타이핑해주자. 1./node_modules/webpack/bin/webpack.js 그리고나서 bundle.js 파일을 뒤져봐도 browserHistory에 대한 내용을 찾을 수 없다.즉, 모듈 별로 일일이 불러오지 않고도 트리 쉐이킹을 할 수 있게 된 것이다!물론 요렇게 해도 안 되는 녀석들도 있는 것 같다.아마 웹팩 2가 나오기 전에 만들어진 모듈이거나모듈 간에 의존성이 너무 높아서 하나만 불러와도 다른 모듈들까지 불러오지 않는 이상사용이 불가능한 모듈인 경우에 그런 것 같다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"https://perfectacle.github.io/tags/babel/"}]},{"title":"(ES6) Promise에 파라미터를 넘겨서 사용해보자","slug":"js-promise-param","date":"2017-04-04T21:09:43.000Z","updated":"2022-10-30T08:42:16.699Z","comments":true,"path":"2017/04/04/js-promise-param/","link":"","permalink":"https://perfectacle.github.io/2017/04/04/js-promise-param/","excerpt":"들어가기에 앞서어제 프라미스를 쓰면서 정리 해봤는데,또 파라미터를 넘겨서쓰거나 하려니 제대로 쓸 수가 없어서 정리해봤다.일단 reject 되는 경우는 생각하지 않고, 그냥 내가 짠 비동기 함수를 동기식으로 실행시키길 원했을 뿐이었다.지극히 사용 방법 위주로 적었으니 아래 링크들을 참조해서 이해하자.일단 구현이 먼저인 사람은 코드를 적극 참조하면 될 것 같다. Promise - JavaScript | MDN - Mozilla Developer Network 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야? | 감성 프로그래밍 Promise 를 사용하는 두 가지 방법, new Promise, Promise.resolve() 파라미터 없는 일반 비동기 함수","text":"들어가기에 앞서어제 프라미스를 쓰면서 정리 해봤는데,또 파라미터를 넘겨서쓰거나 하려니 제대로 쓸 수가 없어서 정리해봤다.일단 reject 되는 경우는 생각하지 않고, 그냥 내가 짠 비동기 함수를 동기식으로 실행시키길 원했을 뿐이었다.지극히 사용 방법 위주로 적었으니 아래 링크들을 참조해서 이해하자.일단 구현이 먼저인 사람은 코드를 적극 참조하면 될 것 같다. Promise - JavaScript | MDN - Mozilla Developer Network 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야? | 감성 프로그래밍 Promise 를 사용하는 두 가지 방법, new Promise, Promise.resolve() 파라미터 없는 일반 비동기 함수1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const f1 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(1); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(); &#125;, 1000)));const f2 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(2); res(); &#125;, 1000)));const f3 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(3); res(); &#125;, 1000)));const f4 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(4); res(); &#125;, 1000)));const f5 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(5); res(); &#125;, 1000)));const f6 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(6); res(); &#125;, 1000)));const f7 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(7); res(); &#125;, 1000)));const f8 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(8); res(); &#125;, 1000)));const f9 = () =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(9); res(); &#125;, 1000)));// 후속 함수에게 Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f1() // 1.then(f2) // 2.then(f3) // 3.then(f4) // 4.then(f5) // 5.then(f6) // 6.then(f7) // 7.then(f8) // 8.then(f9); // 9 파라미터가 있는 비동기 함수1234567891011121314151617181920const f = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(); &#125;, 1000)));// 후속 함수에게 new Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f(1) // 1.then(() =&gt; f(2)) // 2.then(() =&gt; f(3)) // 3.then(() =&gt; f(4)) // 4.then(() =&gt; f(5)) // 5.then(() =&gt; f(6)) // 6.then(() =&gt; f(7)) // 7.then(() =&gt; f(8)) // 8.then(() =&gt; f(9)); // 9 현재 함수의 변수를 후속 함수에게 넘겨줘야하는 경우12345678910111213141516171819202122232425262728const f = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); // 비동기 함수(setTimeout)의 콜백 함수 안에서 // resolve 시켜줘야 순서를 보장할 수 있음. // 덤으로 후속 함수에게 파라미터(++param)을 넘기고 있음. // 이 res 부분부터 then 안에 구문이 실행된다고 보면 된다. res(++param); &#125;, 1000)));const f2 = (param) =&gt; new Promise(res =&gt; ( setTimeout(() =&gt; &#123; console.log(param); res(); &#125;, 1000)));// 후속 함수에게 Promise를 리턴해주므로 thenable해서 계속 체이닝이 가능.f(1) // 1.then(param =&gt; f2(param)) // 2.then(() =&gt; f(3)) // 3.then(param =&gt; f2(param)) // 4.then(() =&gt; f(5)) // 5.then(param =&gt; f2(param)) // 6.then(() =&gt; f(7)) // 7.then(param =&gt; f2(param)) // 8.then(() =&gt; f(9)); // 9","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"},{"name":"callback","slug":"callback","permalink":"https://perfectacle.github.io/tags/callback/"}]},{"title":"(ES6+) 비동기 함수를 깔끔하게 처리해보자.","slug":"js-async-function","date":"2017-04-03T21:18:09.000Z","updated":"2022-10-30T08:42:16.691Z","comments":true,"path":"2017/04/03/js-async-function/","link":"","permalink":"https://perfectacle.github.io/2017/04/03/js-async-function/","excerpt":"전에 AJAX를 Promise와 Async&#x2F;Await로 처리하는 방법을 알아봤는데,setTimeout과 같은 비동기 함수를 처리하려니 또 버퍼링이 걸려서 정리해봤다.너무 사용법 위주로 공부하다보니 나중에 또 정리를 하게 될 것 같다.AJAX를 비동기로 처리하고 싶은 사람은 아래 글을 참조하자.(ES6) ajax 위주의 promise 실습(ES6+) ajax를 위한 fetch와 async&#x2F;await ~ES5(콜백 함수)순서가 보장되지만 피라미드 같이 생겼다.뎁스가 깊어질 수록 컨트롤하기가 어렵다.혹시 cb &amp;&amp; cb()의 동작 방식과 원리가 궁금한 사람은 아래 글을 참조하자.(ES) 똑똑한 논리 연산자 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);f1( () =&gt; f2( () =&gt; f3( () =&gt; f4( () =&gt; f5( () =&gt; f6( () =&gt; f7( () =&gt; f8( () =&gt; f9() ) ) ) ) ) ) ));","text":"전에 AJAX를 Promise와 Async&#x2F;Await로 처리하는 방법을 알아봤는데,setTimeout과 같은 비동기 함수를 처리하려니 또 버퍼링이 걸려서 정리해봤다.너무 사용법 위주로 공부하다보니 나중에 또 정리를 하게 될 것 같다.AJAX를 비동기로 처리하고 싶은 사람은 아래 글을 참조하자.(ES6) ajax 위주의 promise 실습(ES6+) ajax를 위한 fetch와 async&#x2F;await ~ES5(콜백 함수)순서가 보장되지만 피라미드 같이 생겼다.뎁스가 깊어질 수록 컨트롤하기가 어렵다.혹시 cb &amp;&amp; cb()의 동작 방식과 원리가 궁금한 사람은 아래 글을 참조하자.(ES) 똑똑한 논리 연산자 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);f1( () =&gt; f2( () =&gt; f3( () =&gt; f4( () =&gt; f5( () =&gt; f6( () =&gt; f7( () =&gt; f8( () =&gt; f9() ) ) ) ) ) ) )); ES6(Promise) 콜백 함수 패턴이 익숙해서 자주 쓰는데,뎁스가 깊어지니 뭔가 깔끔하게 정리해보고 싶었다.일단 나는 reject 되는 경우는 생각하지 않았다.그냥 내가 짠 비동기 함수를 동기식으로 실행시키길 원했을 뿐이니까...너무 사용 방법에만 치중하다보니 코드가 다소 복잡해보이기도 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const promise = cb =&gt; new Promise(res =&gt; &#123; // 콜백 함수 안에서 resolve 함수를 실행해야 순서가 보장됨. cb(res);&#125;);const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);promise(f1).then(() =&gt; promise(f2)).then(() =&gt; promise(f3)).then(() =&gt; promise(f4)).then(() =&gt; promise(f5)).then(() =&gt; promise(f6)).then(() =&gt; promise(f7)).then(() =&gt; promise(f8)).then(() =&gt; promise(f9)); ES2017(Async&#x2F;Await)크롬, 파폭, 사파리, 오페라 최신 버전에서는 지원하는 것 같은데 MS 진영은(엣지 포함) 암담하다.ECMAScript Next compatibility table MS나 하위 브라우저를 지원해야한다면Syntax async functions · Babel을 참고하자.Node.js LTS(v6.x)에서도 지원하지 않는 것 같으니 참고하자.Node.js ES2015&#x2F;ES6, ES2016 and ES2017 support 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const promise = cb =&gt; new Promise(res =&gt; &#123; // 콜백 함수 안에서 resolve 함수를 실행해야 순서가 보장됨. cb(res);&#125;);const f1 = cb =&gt; setTimeout(() =&gt; &#123; console.log(1); // setTimeout의 콜백 함수 안에서 // 콜백함수(f1 함수의 매개변수인 cb) // 를 실행해야 실행 순서가 보장됨. // 매개변수로 넘어온 콜백함수(cb) // 가 없으면 실행하지 않음. cb &amp;&amp; cb();&#125;, 1000);const f2 = cb =&gt; setTimeout(() =&gt; &#123; console.log(2); cb &amp;&amp; cb();&#125;, 1000);const f3 = cb =&gt; setTimeout(() =&gt; &#123; console.log(3); cb &amp;&amp; cb();&#125;, 1000);const f4 = cb =&gt; setTimeout(() =&gt; &#123; console.log(4); cb &amp;&amp; cb();&#125;, 1000);const f5 = cb =&gt; setTimeout(() =&gt; &#123; console.log(5); cb &amp;&amp; cb();&#125;, 1000);const f6 = cb =&gt; setTimeout(() =&gt; &#123; console.log(6); cb &amp;&amp; cb();&#125;, 1000);const f7 = cb =&gt; setTimeout(() =&gt; &#123; console.log(7); cb &amp;&amp; cb();&#125;, 1000);const f8 = cb =&gt; setTimeout(() =&gt; &#123; console.log(8); cb &amp;&amp; cb();&#125;, 1000);const f9 = cb =&gt; setTimeout(() =&gt; &#123; console.log(9); cb &amp;&amp; cb();&#125;, 1000);// async 함수 안에서 비동기 코드 앞에 await를 붙여주면 된다.// 안타깝게도 async &#x27;함수&#x27;라서 호출을 위해 즉시 실행함수를 사용했다.(async () =&gt; &#123; await promise(f1); await promise(f2); await promise(f3); await promise(f4); await promise(f5); await promise(f6); await promise(f7); await promise(f8); await promise(f9);&#125;)(); 참조 링크 Promise - JavaScript | MDN - Mozilla Developer Network 바보들을 위한 Promise 강의 - 도대체 Promise는 어떻게 쓰는거야? | 감성 프로그래밍 Promise 를 사용하는 두 가지 방법, new Promise, Promise.resolve()","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"},{"name":"ES6+","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"async","slug":"async","permalink":"https://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://perfectacle.github.io/tags/await/"},{"name":"callback","slug":"callback","permalink":"https://perfectacle.github.io/tags/callback/"}]},{"title":"(React Hot Loader) v3로 마이그레이션 해보자!","slug":"react-hot-loader-3","date":"2017-03-25T10:39:14.000Z","updated":"2022-10-30T08:42:16.879Z","comments":true,"path":"2017/03/25/react-hot-loader-3/","link":"","permalink":"https://perfectacle.github.io/2017/03/25/react-hot-loader-3/","excerpt":"들어가기에 앞서기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! 또한 리액트 라우터 v4 예제로 진행할 것이므로 아래 포스트를 참고하고 소스 코드를 클론하자.","text":"들어가기에 앞서기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! 또한 리액트 라우터 v4 예제로 진행할 것이므로 아래 포스트를 참고하고 소스 코드를 클론하자. (React Router) v4로 마이그레이션 해보자! 리액트 라우터 v4 소스 코드 리액트 핫 로더 v1지난 리액트 라우터 4 마이그레이션 포스트에서… 트리 쉐이킹 코드 스플리팅 HTML5 History API 까지 구현해보았다.이제 리액트의 컴포넌트를 Hot Module로 만들어서페이지 새로고침 없이도 수정 결과를 반영해주는 react-hot-loader를 사용해보자!리액트 핫 로더 v1 소스 코드에서 중간 중간 확인하면서 진행하도록 하자. 1npm i -D react-hot-loader 그리고 webpack.dev.config.js의 module 부분에서js 파일의 로더에 react-hot-loader를 추가하자. 123456789&#123; module: &#123; rules: [&#123; test: /\\.js$/, use: [&#x27;react-hot-loader&#x27;, &#x27;babel-loader&#x27;], exclude: /node_modules/, &#125;] &#125;&#125; 또한 리액트 핫로더 v1은 트리 쉐이킹을 사용하면 번들링에 실패하므로.babelrc에서 다음과 같이 트리쉐이킹을 꺼주자. 1234567891011121314&#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;&gt; 10%&quot;, &quot;ie 9&quot;] &#125; ], &quot;react&quot; ], &quot;plugins&quot;: [ &quot;syntax-dynamic-import&quot; ]&#125; 그리고 테스트를 위해 About.js를 다음과 같이 함수형 컴포넌트에서 일반 클래스 컴포넌트로 바꿔주자. 123456789101112import React, &#123;Component&#125; from &#x27;react/lib/React&#x27;;export default class About extends Component &#123; render() &#123; return( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; npm start를 쳐서 webpack-dev-server를 띄우고http://localhost:3001/about/name으로 접속해보자.그 다음에 About.js를 수정해보면 페이지 새로고침 없이도 수정 내역이 잘 반영된다.그럼 이번에는 함수형 컴포넌트인 Name.js를 수정해보자.아마도 페이지가 새로고침 되면서 수정 내역이 반영될 것이다.이렇듯 리액트 라우터 4와 리액트 핫 로더 1에서는 다음과 같은 문제점이 존재한다. 출처: Server-side rendering, code-splitting, and hot reloading with React Router v4 No hot reloading for functional components Problems with high order components HOC(High Order Components)는 뭔지 잘 몰라서 테스트 해보지 못했다. v3으로 마이그레이션 해보자!여튼 함수형 컴포넌트가 제대로 핫 로드 되지 않고, 트리 쉐이킹 문제점을리액트 핫 로더 3에서는 해결했다고 하니 한번 믿고 설치해보자.또한 중간 중간 리액트 핫 로더 v3 소스 코드와 비교해보자. 12npm un -D react-hot-loadernpm i -D react-hot-loader@next 마이그레이션 문서를 보고 하나하나 따라해보자. 바벨 설정 파일(.babelrc) 수정하기 1234567891011121314151617&#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;&gt; 10%&quot;, &quot;ie 9&quot;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ], &quot;plugins&quot;: [ &quot;react-hot-loader/babel&quot;, &quot;syntax-dynamic-import&quot; ]&#125; 플러그인에 react-hot-loader&#x2F;babel을 추가하고, 트리 쉐이킹도 켰다.혹은 바벨을 사용하지 않거나 ES6 없이 바벨을 쓴다면 webpack.dev.config.js에서js의 로더 부분에 react-hot-loader&#x2F;webpack을 추가해야한다.이번 포스트에서는 전자를 따르도록 하겠다. 123456789&#123; module: &#123; rules: [&#123; test: /\\.js$/, use: [&#x27;react-hot-loader/webpack&#x27;, &#x27;babel-loader&#x27;], exclude: /node_modules/, &#125;] &#125;&#125; 웹팩 개발용 설정 파일(webpack.dev.config.js) 엔트리 수정하기react-hot-loader&#x2F;patch를 엔트리 최상단에 넣어주자.혹시 바벨 폴리필을 쓴다면 그 이후에 넣어주면 된다. 1234567891011121314151617&#123; entry: [ &#x27;react-hot-loader/patch&#x27;, // activate HMR for React `webpack-dev-server/client?http://localhost:$&#123;port.dev&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint &#x27;webpack/hot/only-dev-server&#x27;, // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, &#x27;index-dev&#x27;) // the entry point of our app ]&#125; 엔트리(index.js) 수정하기 ES2015의 Native Module을 사용하지 않은 경우바벨 설정 파일에서 따로 ES2015 프리셋의 modules 속성을 건드리지 않은 경우가 이에 속한다.아마 바벨은 CommonJS 규격을 따라 모듈화를 진행하는 것 같다. 12345678910111213141516171819if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;));if (module.hot) &#123; module.hot.accept(&#x27;./App&#x27;, () =&gt; &#123; const NextApp = require(&#x27;./App&#x27;).default; render(&lt;NextApp/&gt;, document.getElementById(&#x27;app&#x27;)); &#125;);&#125; ES2015의 Native Module을 사용한 경우(우리 소스 코드에 해당)웹팩 2부터는 ES2015의 Native Module을 지원하기 시작하였다.바벨 설정 파일에서 ES2015 프리셋의 modules 속성을 false로 준 경우가 이에 해당한다. 123456789101112131415161718if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;));if (module.hot) &#123; module.hot.accept(&#x27;./App&#x27;, () =&gt; &#123; render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)); &#125;);&#125; AppContainer는 좀 이따 살펴보기로 하자. 리액트 라우터 4의 치명적인 단점은 코드 스플리팅과 리액트 핫 로더를 동시에 적용할 수 없다는 점이다. 정상적인 import 문으로 컴포넌트를 삽입하면 코드 스플리팅이 되지 않는다.따라서 const About2 = asyncComponent(() =&gt; import(&#39;./components/About&#39;).then(module =&gt; module.default));와 같이 써야한다.위와 같이 코드 스플리팅을 하면 왠지 모르겠으나 리액트 핫 로더가 먹히질 않는다.따라서 개발용 파일에서는 코드 스플리팅을 하지 않아야 정상적으로 리액트 핫 로더가 작동한다. 배포용 파일에서는 코드 스플리팅을 적용해 초기 로딩 시간을 단축시키고,개발할 용도가 아니기 때문에 리액트 핫 로더는 작동 안 해도 되니 붙이지 않으면 된다. app&#x2F;src 폴더에 AppDev.js를 만들자. 1234567891011121314151617181920212223242526272829303132333435363738import React from &#x27;react/lib/React&#x27;;// import &#123; BrowserRouter, HashRouter, Route, Redirect, Switch &#125; from &#x27;react-router-dom&#x27;;// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport BrowserRouter from &#x27;react-router-dom/es/BrowserRouter&#x27;;import HashRouter from &#x27;react-router-dom/es/HashRouter&#x27;;import Route from &#x27;react-router-dom/es/Route&#x27;;import Redirect from &#x27;react-router-dom/es/Redirect&#x27;;import Switch from &#x27;react-router-dom/es/Switch&#x27;;// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;const Router = isBrowserHistory ? BrowserRouter : HashRouter;import Menu from &#x27;./components/Menu&#x27;;import About from &#x27;./components/About&#x27;;import Home from &#x27;./components/Home&#x27;;import Name from &#x27;./components/Name&#x27;;import Portfolio from &#x27;./components/Portfolio&#x27;;const AppDev = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;Menu/&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/about/name&quot; component=&#123;Name&#125; /&gt; &lt;Switch&gt; &lt;Redirect to=&quot;/portfolio/0&quot; from=&quot;/about/redirect0&quot;/&gt; &lt;Redirect from=&quot;/about/redirect1&quot; to=&quot;/portfolio/1&quot;/&gt; &lt;/Switch&gt; &lt;Route exact path=&quot;/portfolio&quot; component=&#123;Portfolio&#125; /&gt; &lt;Route path=&quot;/portfolio/:id&quot; component=&#123;Portfolio&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);export default AppDev; 개발용 엔트리를 app&#x2F;src에 indexDev.js로 따로 파자.import 문은 모듈을 정적으로만 로딩 가능해서 부득이하게 엔트리를 하나 더 만들게 됐다. 123456789101112131415161718if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import AppDev from &#x27;./AppDev&#x27;;render(&lt;AppDev /&gt;, document.getElementById(&#x27;app&#x27;));if (module.hot) &#123; module.hot.accept(&#x27;./AppDev&#x27;, () =&gt; &#123; render(&lt;AppDev /&gt;, document.getElementById(&#x27;app&#x27;)); &#125;);&#125; 배표용 엔트리(index.js)에서는 리액트 핫 로더를 떼버리자. 123456789101112if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)); 웹팩 개발용 설정 파일(webpack.dev.config.js)에서 엔트리를 개발용 엔트리로 바꿔주자. 12345678910111213141516&#123; entry: [ &#x27;react-hot-loader/patch&#x27;, `webpack-dev-server/client?http://localhost:$&#123;PORT&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint &#x27;webpack/hot/only-dev-server&#x27;, // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, &#x27;indexDev&#x27;) // the entry point of our app ]&#125; 이제 모든 설정이 끝났다.npm start를 치면… 코드 스플리팅 X - 어차피 개발용이니 초기 로딩 속도는 크게 상관을 하지 않으면 됨. 리액트 핫 로더 O - 개발할 땐 이게 핵심이다. npm build를 치면… 코드 스플리팅 O - 실 사용자들에게 쾌적한 로딩 속도를 보장해줘야한다. 리액트 핫 로더 X - 배포용이기 때문에 내용을 수정하면서 확인할 일이 없다. AppConainer란?react-hot-loader v3은 redbox-react를 내장하고 있다. react-hot-loader v3에서 redbox-react를 사용하기 위해 AppContainer를 사용하는 것이다.소스맵을 붙이려면 express 프레임워크에 webpack-dev-server를 붙여야한다.안 그러면 위 스샷과 같이 소스맵이 붙질 않는다.또한 트랜스파일 이후의 코드를 가지고 소스맵을 붙이기 때문에 좀 헷갈리기도 한다.아직은 콘솔 창에 출력되게 끔 하는 게 더 나은 것 같지만…일단은 나와있으니 한 번 써보자.귀찮은 사람은 redbox-react 소스 코드를 클론 받자. indexDev.js에서 AppContainer를 갖다 붙이자. 123456789101112131415161718192021222324252627if( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import AppContainer from &#x27;react-hot-loader/lib/AppContainer&#x27;;import App from &#x27;./AppDev&#x27;;render( &lt;AppContainer&gt; &lt;App /&gt; &lt;/AppContainer&gt;, document.getElementById(&#x27;app&#x27;));if (module.hot) &#123; module.hot.accept(&#x27;./AppDev&#x27;, () =&gt; &#123; render( &lt;AppContainer&gt; &lt;App /&gt; &lt;/AppContainer&gt;, document.getElementById(&#x27;app&#x27;) ); &#125;);&#125; Home.js에서 일부러 오류를 내보자. 1234567import React from &#x27;react/lib/React&#x27;;const Home = () =&gt; ( &lt;h2&gt;&#123;aa()&#125;Home&lt;/h2&gt;);export default Home; webpack.dev.config에서 devtool을 eval로 바꿔주자.다른 소스맵은 제대로 소스맵이 붙질 않는다. server.js 파일을 수정해서 express에 webpack-dev-server를 붙여보자. 123456789101112131415161718192021222324252627282930const express = require(&#x27;express&#x27;);const app = express();const PORT = 3000;const DEV_PORT = 3001;const DIST = `$&#123;__dirname&#125;/app/dist/`;if(process.env.NODE_ENV === &#x27;development&#x27;) &#123; // dev-server config const Webpack = require(&#x27;webpack&#x27;); const WebpackDevServer = require(&#x27;webpack-dev-server&#x27;); const webpackConfig = require(&#x27;./webpack.dev.config&#x27;); const compiler = Webpack(webpackConfig); const devServer = new WebpackDevServer(compiler, webpackConfig.devServer); // dev-server open devServer.listen(DEV_PORT, () =&gt; &#123; console.log(&#x27;webpack-dev-server is listening on port&#x27;, DEV_PORT); &#125;);&#125; else &#123; // server-open app.use(&#x27;/&#x27;, express.static(DIST)); app.listen(PORT, () =&gt; &#123; console.log(&#x27;Express listening on port&#x27;, PORT); &#125;);// client router app.get(&#x27;*&#x27;, (req, res) =&gt; &#123; res.sendFile(DIST); &#125;);&#125; process.env가 뭐하는 놈인지 처음 본 사람은 아래 링크를 참조하자.Node.js 에서 NODE_ENV 값으로 배포&#x2F;개발 환경설정하기 이제 package.json의 start script 부분을 아래와 같이 수정해주자. 1234567&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;NODE_ENV=development node server&quot;, &quot;build&quot;: &quot;rm -rf app/dist &amp;&amp; node_modules/webpack/bin/webpack.js &amp;&amp; node server&quot; &#125;&#125; 이제 다 끝났다.npm start 치고 http://localhost:3001/로 접속하면 아래와 같은 화면이 뜰 것이다. 참조 링크 React Hot Loader 3 Server-side rendering, code-splitting, and hot reloading with React Router v4 redbox-react Node.js 에서 NODE_ENV 값으로 배포&#x2F;개발 환경설정하기","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://perfectacle.github.io/categories/Front-end/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"React","slug":"React","permalink":"https://perfectacle.github.io/tags/React/"},{"name":"Hot","slug":"Hot","permalink":"https://perfectacle.github.io/tags/Hot/"},{"name":"Loader","slug":"Loader","permalink":"https://perfectacle.github.io/tags/Loader/"}]},{"title":"(React Router) v4로 마이그레이션 해보자!","slug":"react-router-v4","date":"2017-03-25T09:39:14.000Z","updated":"2022-10-30T08:42:16.883Z","comments":true,"path":"2017/03/25/react-router-v4/","link":"","permalink":"https://perfectacle.github.io/2017/03/25/react-router-v4/","excerpt":"들어가기에 앞서~~React Router v4가 정식으로 나와서 3은 deprecated 된 거나 마찬가지라고 본다.~~~현재 React Router v3은 디프리케잇 되지 않고 React Router v4와 다른 노선을 탔을 뿐, 지원은 계속 해주는 것 같다.따라서 레거시 환경을 싫어하기도 해서 한 번 마이그레이션을 간단하게 해보았다.기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! v3으로 만들어보기","text":"들어가기에 앞서~~React Router v4가 정식으로 나와서 3은 deprecated 된 거나 마찬가지라고 본다.~~~현재 React Router v3은 디프리케잇 되지 않고 React Router v4와 다른 노선을 탔을 뿐, 지원은 계속 해주는 것 같다.따라서 레거시 환경을 싫어하기도 해서 한 번 마이그레이션을 간단하게 해보았다.기본적으로 웹팩, 바벨, 리액트 라우터 등등은 안다는 전제 하에 글을 썼다.웹팩 2에 대한 모르는 부분은 아래 글을 조금씩 참조하면 도움이 될 것이다. (Webpack 2) 트리 쉐이킹을 해보자! (Webpack 2) 코드를 분할해보자! v3으로 만들어보기소스 코드는 정재남 님께서 제공해주신 소스를 이용했다.v3으로 만든 라이브 데모에서 직접 내용을 확인해보고 시작하자.혹시 만들기 귀찮거나 중간중간 확인할 사람은 소스 코드를 보도록 하자.서버는 없으니 새로고침을 하면 제대로 정보를 표시 못 하지만, 우리가 실제 진행할 때는Node.js의 express 프레임워크를 사용해서 새로고침을 해도 제대로 작동하게 만들 것이다. 전체적인 프로젝트 구조는 다음과 같다. 일단 packge.json 파일을 만들고 다음 패키지들을 설치하자. 12npm i -D babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-env babel-preset-react webpack-dev-servernpm i -S express html-webpack-plugin react react-dom react-router@^3.x webpack babel-plugin-syntax-dynamic-import는 코드 스플리팅을 위해 추가한 플러그인이다..babelrc 파일을 만들고 아래와 같이 적어주자. 12345678910111213141516&#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;&gt; 10%&quot;, &quot;ie 9&quot;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ], &quot;plugins&quot;: [ &quot;syntax-dynamic-import&quot; ]&#125; presets 부분이 요상하게 적혀있는데 트리 쉐이킹을 위한 것이니 모르는 사람은(Webpack 2) 트리 쉐이킹을 해보자!을 참조하자. 이제 컴포넌트들을 하나 하나 작성해보자. 123456789101112// About.js// 프롭스 중에 children도 같이 렌더링한다.import React from &#x27;react/lib/React&#x27;;const About = (&#123;children&#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;div&gt;&#123;children&#125;&lt;/div&gt; &lt;/div&gt;);export default About; 1234567891011121314151617181920212223242526// Container.js// 상단에 메뉴(고정)들이 존재하고, 프롭스 중에 children 내용이 변경되면서 렌더링 된다.import React from &#x27;react/lib/React&#x27;;import Link from &#x27;react-router/es/Link&#x27;;const Container = (&#123;children&#125;) =&gt; ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/name&quot;&gt;About - Name&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/redirect0&quot;&gt;About - RedirectTo: Portfolio #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/redirect1&quot;&gt;About - RedirectTo: Portfolio #1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio&quot;&gt;Portfolio - All&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio/0&quot;&gt;Portfoilo - #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio/1&quot;&gt;Portfoilo - #1&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;div&gt; &#123;children&#125; &lt;/div&gt; &lt;/div&gt;);export default Container; 123456// Home.jsimport React from &#x27;react/lib/React&#x27;;const Home = () =&gt; (&lt;h2&gt;Home&lt;/h2&gt;);export default Home; 123456// Name.jsimport React from &#x27;react/lib/React&#x27;;const Name = () =&gt; (&lt;h2&gt;Name&lt;/h2&gt;);export default Name; 12345678910111213141516171819202122// Portfolio.jsimport React from &#x27;react/lib/React&#x27;;const Portfolio = (&#123;routeParams: &#123;id&#125;&#125;) =&gt; &#123; const allList = [ &#123; id: 0, text: &#x27;portfolio #0&#x27; &#125;, &#123; id: 1, text: &#x27;portfolio #1&#x27; &#125; ]; const filterList = id ? allList.filter(v =&gt; v.id === +id) : allList; const renderList = filterList.map(v =&gt; ( &lt;li key=&#123;v.id&#125;&gt;&#123;v.text&#125;&lt;/li&gt; ) ); return ( &lt;div&gt; &lt;h2&gt;Portfolio&lt;/h2&gt; &lt;ul&gt;&#123;renderList&#125;&lt;/ul&gt; &lt;/div&gt; );&#125;;export default Portfolio; id는 추후에 우리가 정할 파라미터이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// App.jsimport React from &#x27;react/lib/React&#x27;;// import &#123; Router, Route, IndexRoute, Redirect, browserHistory, hashHistory &#125; from &#x27;react-router&#x27;;// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport Router from &#x27;react-router/es/Router&#x27;;import Route from &#x27;react-router/es/Route&#x27;;import IndexRoute from &#x27;react-router/es/IndexRoute&#x27;;import Redirect from &#x27;react-router/es/Redirect&#x27;;import browserHistory from &#x27;react-router/es/browserHistory&#x27;;import hashHistory from &#x27;react-router/es/hashHistory&#x27;;// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;// 리액트 라우터 3에서 코드 스플리팅 하기.const loadRoute = callback =&gt; module =&gt; callback(null, module.default);const App = () =&gt; ( &lt;Router history=&#123;isBrowserHistory ? browserHistory : hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; getComponent=&#123; // component 대신에 getComponent를 써야 코드 스플리팅이 됨. (loaction, callback) =&gt; &#123; import(&#x27;./components/Container&#x27;).then(loadRoute(callback)) &#125;&#125;&gt; &lt;IndexRoute getComponent=&#123; // 요 아래 컴포넌트들은 전부 Container 라우트의 자식들이다. (loaction, callback) =&gt; &#123; import(&#x27;./components/Home&#x27;).then(loadRoute(callback)) &#125;&#125;/&gt; &lt;Route path=&quot;about&quot; getComponent=&#123; (loaction, callback) =&gt; &#123; import(&#x27;./components/About&#x27;).then(loadRoute(callback)) &#125;&#125;&gt; &lt;Route path=&quot;name&quot; getComponent=&#123; (loaction, callback) =&gt; &#123; import(&#x27;./components/Name&#x27;).then(loadRoute(callback)) &#125;&#125;/&gt; &lt;Route path=&quot;redirect0&quot; onEnter=&#123;(nextState, replace) =&gt; replace(&#x27;/portfolio/0&#x27;)&#125; /&gt; &lt;Redirect from=&quot;redirect1&quot; to=&quot;/portfolio/1&quot; /&gt; &lt;/Route&gt; &lt;Route path=&quot;portfolio(/:id)&quot; getComponent=&#123; // 파라미터 :id 때문에 위의 사진과 같이 파라미터가 id가 된 거다. // 괄호로 감쌌기 때문에 생략이 가능하다는 소리다. (loaction, callback) =&gt; &#123; import(&#x27;./components/Portfolio&#x27;).then(loadRoute(callback)) &#125;&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;);export default App; component 대신에 getComponent를 써서 코드 스플리팅을 하였다.또한 그 안에 import(component)와 같은 구문 때문에babel-plugin-syntax-dynamic-import를 쓰게 된 거다.혹시 코드 스플리팅에 대해 잘 모르는 사람은 (Webpack 2) 코드를 분할해보자!를 봐보자. 12345678910111213// index.jsif( // 배포할 때는 리액트 개발 도구를 죽여놔야함. process.env.NODE_ENV === &#x27;production&#x27; &amp;&amp; window.__REACT_DEVTOOLS_GLOBAL_HOOK__ &amp;&amp; Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length) window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers = &#123;&#125;;import React from &#x27;react/lib/React&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;)); 마지막으로 index.html도 만들어주자. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이제 웹팩의 개발용 설정 파일을 작성하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// webpack.dev.config.jsconst webpack = require(&#x27;webpack&#x27;);const &#123;resolve&#125; = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const PORT = 3001;const ROOT = &#x27;./app/src&#x27;;module.exports = &#123; devtool: &#x27;inline-source-map&#x27;, entry: [ `webpack-dev-server/client?http://localhost:$&#123;PORT&#125;`, // bundle the client for webpack-dev-server // and connect to the provided endpoint &#x27;webpack/hot/only-dev-server&#x27;, // bundle the client for hot reloading // only- means to only hot reload for successful updates resolve(ROOT, &#x27;index&#x27;) // the entry point of our app ], output: &#123; publicPath: &#x27;/&#x27;, filename: &#x27;bundle.js&#x27;, &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), // enable HMR globally new webpack.NamedModulesPlugin(), // prints more readable module names in the browser console on HMR updates new HtmlWebpackPlugin(&#123; template: `$&#123;ROOT&#125;/index.html` &#125;) ], module: &#123; rules: [&#123; test: /\\.js$/, use: [&#x27;babel-loader&#x27;], exclude: /node_modules/, &#125;] &#125;, devServer: &#123; hot: true, inline: true, port: PORT, historyApiFallback: true, contentBase: ROOT &#125;&#125;;process.noDeprecation = true; 이제 배포용 웹팩 설정 파일을 작성하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// webpack.config.js&#x27;use strict&#x27;;const webpack = require(&#x27;webpack&#x27;);const &#123;resolve&#125; = require(&#x27;path&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const ROOT = &#x27;./app/src&#x27;;const DIST = &#x27;app/dist&#x27;;module.exports = &#123; entry: &#123; app: ROOT + &#x27;/index.js&#x27;, &#125;, output: &#123; filename: &#x27;[name].[chunkhash].js&#x27;, path: resolve(__dirname, DIST), publicPath: &#x27;/&#x27; &#125;, plugins: [ new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, // 아래 부분이 핵심 minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf(&#x27;node_modules&#x27;) !== -1; &#125; &#125;), new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./app/src/index.html&#x27;, minify: &#123; collapseWhitespace: true, conservativeCollapse: true, keepClosingSlash: true, removeComments: true, removeRedundantAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true &#125; &#125;) ], module: &#123; rules: [&#123; test: /\\.js$/, use: [&#x27;babel-loader&#x27;], exclude: /node_modules/, &#125;] &#125;&#125;;process.noDeprecation = true; chunkhash가 뭔지 모르는 사람도 역시 (Webpack 2) 코드를 분할해보자!를 봐보자. 이제 배포용 파일을 테스트 하기 위해 express 프레임워크를 써서 서버 설정 파일을 작성하자. 12345678910111213141516// server.jsconst express = require(&#x27;express&#x27;);const app = express();const PORT = 3000;const DIST = `$&#123;__dirname&#125;/app/dist/`;// server-openapp.use(&#x27;/&#x27;, express.static(DIST));app.listen(PORT, () =&gt; &#123; console.log(&#x27;Express listening on port&#x27;, PORT);&#125;);// client routerapp.get(&#x27;*&#x27;, (req, res) =&gt; &#123; res.sendFile(DIST);&#125;); 작업을 편안하게 하기 위해 packge.json의 npm script를 수정해보자. 1234567&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;./node_modules/webpack-dev-server/bin/webpack-dev-server.js -d --config webpack.dev.config.js&quot;, &quot;build&quot;: &quot;rm -rf app/dist &amp;&amp; node_modules/webpack/bin/webpack.js &amp;&amp; node server&quot; &#125;&#125; npm start라고 치고 http://localhost:3001/에 접속하면 개발용 버전으로 볼 수 있고(소스맵, 리액트 개발 도구) npm build라고 치고 http://localhost:3000/에 접속하면 배포용으로 볼 수 있다. (소스맵 X, 리액트 개발 도구 X) 윈도우 유저는 rm -rf에 해당하는 다른 명령어로 build 스크립트를 수정해야할 것이다. 리액트 라우터 v4로 마이그레이션 하기리액트 라우터 v3로 만드는 것도 좀 귀찮았는데 아직 마이그레이션은 시작도 하지 않았다.리액트 라우터 v4에서는 바뀐 게 참 많아서… 수정해야할 부분이 참 많다.혹시 따라하기 귀찮거나 중간 중간 확인하고 싶은 사람은 소스 코드를 확인하자. v3 때는 react-router 하나 밖에 못 봤던 것 같은데… 5개나 됐다.대표적으로 react-router, react-router-dom, react-router-native만 알아봤다. react-router &#x3D; react-router-dom + react-router-native react-router-dom &#x3D; Web 용 react-router react-router-native &#x3D; App 용 react-router 나는 웹을 주로 사용하니 react-router-dom v4로 설치하자. 12npm un -S react-routernpm i -S react-router-dom Container.js를 Menu.js로 이름을 바꾼 후 다음과 같이 수정하자. 1234567891011121314151617181920212223// v4로 오면서 컨테이너로써의 기능을 상실하게 된다.// 즉 Route 컴포넌트는 자식을 가질 수 없게 됐다.import React from &#x27;react/lib/React&#x27;;import Link from &#x27;react-router-dom/es/Link&#x27;;const Menu = () =&gt; ( &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/name&quot;&gt;About - Name&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/redirect0&quot;&gt;About - RedirectTo: Portfolio #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/about/redirect1&quot;&gt;About - RedirectTo: Portfolio #1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio&quot;&gt;Portfolio - All&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio/0&quot;&gt;Portfoilo - #0&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/portfolio/1&quot;&gt;Portfoilo - #1&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;/div&gt;);export default Menu; 123456789101112131415161718192021// Portfolio.jsimport React from &#x27;react/lib/React&#x27;;const Portfolio = (&#123; match: &#123;params: &#123;id&#125;&#125; &#125;) =&gt; &#123; const allList = [ &#123; id: 0, text: &#x27;portfolio #0&#x27; &#125;, &#123; id: 1, text: &#x27;portfolio #1&#x27; &#125; ]; const filterList = id ? allList.filter(v =&gt; v.id === +id) : allList; const renderList = filterList.map(v =&gt; &lt;li key=&#123;v.id&#125;&gt;&#123;v.text&#125;&lt;/li&gt; ); return ( &lt;div&gt; &lt;h2&gt;Portfolio&lt;/h2&gt; &lt;ul&gt;&#123;renderList&#125;&lt;/ul&gt; &lt;/div&gt; );&#125;;export default Portfolio; App.js가 가장 수정 사항이 많다…나도 원리 보다는 사용방법 위주로 익혔으니 자세한 내용은 공식 사이트를 참조하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// App.jsimport React, &#123;Component&#125; from &#x27;react/lib/React&#x27;;// import &#123; BrowserRouter, HashRouter, Route, Redirect, Switch &#125; from &#x27;react-router-dom&#x27;;// 리액트 라우터를 코드 스플리팅 하려면 위 코드를 이렇게 하나씩 불러와야한다 귀찮 ㅠimport BrowserRouter from &#x27;react-router-dom/es/BrowserRouter&#x27;;import HashRouter from &#x27;react-router-dom/es/HashRouter&#x27;;import Route from &#x27;react-router-dom/es/Route&#x27;;import Redirect from &#x27;react-router-dom/es/Redirect&#x27;;import Switch from &#x27;react-router-dom/es/Switch&#x27;;import Menu from &#x27;./components/Menu&#x27;;// HTML5 History API 지원여부 파악const isBrowserHistory = history.pushState;const Router = isBrowserHistory ? BrowserRouter : HashRouter;// 리액트 라우터 4에서 코드 스플리팅 하기.// getComponent is a function that returns a promise for a component// It will not be called until the first mountconst asyncComponent = getComponent =&gt; ( class AsyncComponent extends Component &#123; constructor() &#123; super(); this.state = &#123;Component: AsyncComponent.Component&#125;; &#125; componentWillMount() &#123; if (!this.state.Component) &#123; getComponent().then(Component =&gt; &#123; AsyncComponent.Component = Component; this.setState(&#123;Component&#125;); &#125;); &#125; &#125; render() &#123; const &#123;Component&#125; = this.state; if(Component) &#123; return &lt;Component &#123;...this.props&#125; /&gt;; &#125; return null; &#125; &#125;);const About = asyncComponent(() =&gt; import(&#x27;./components/About&#x27;).then(module =&gt; module.default));const Home = asyncComponent(() =&gt; import(&#x27;./components/Home&#x27;).then(module =&gt; module.default));const Name = asyncComponent(() =&gt; import(&#x27;./components/Name&#x27;).then(module =&gt; module.default));const Portfolio = asyncComponent(() =&gt; import(&#x27;./components/Portfolio&#x27;).then(module =&gt; module.default));const App = () =&gt; ( // v3에는 Router 속성에 browserRouter or hashRouter가 들어갔는데, // v4에는 BrowserRouter or HashRouter가 Router까지 포함한다. // 또한 Router 안에는 하나의 컴포넌트만 들어가야한다. // 따라서 div 같은 컴포넌트로 그 안을 한 번 감싸줘야한다. // 또한 IndexRoute는 Route 컴포넌트의 exact라는 속성으로 대체되었다. // Redirect 컴포넌트는 Switch 컴포넌트로 감싸줘야 정상 작동한다. // 또한 파라미터는 괄호를 써서 생략 가능하던 것이 불가능해졌다. &lt;Router&gt; &lt;div&gt; &lt;Menu/&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/about/name&quot; component=&#123;Name&#125; /&gt; &lt;Switch&gt; &lt;Redirect to=&quot;/portfolio/0&quot; from=&quot;/about/redirect0&quot;/&gt; &lt;Redirect from=&quot;/about/redirect1&quot; to=&quot;/portfolio/1&quot;/&gt; &lt;/Switch&gt; &lt;Route exact path=&quot;/portfolio&quot; component=&#123;Portfolio&#125; /&gt; &lt;Route path=&quot;/portfolio/:id&quot; component=&#123;Portfolio&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);export default App; 이렇게 하면 일단 내가 먼저 react-router v3으로 작성했던 내용들은 마이그레이션 됐다.npm start와 npm build를 통해 확인해보자.더 자세한 사용 방법들은 무조건 공식 사이트를 참조하자. 그리고 여기서 끝난 게 아니다.리액트 라우터 4는 리액트 핫 로더와도 문제가 있어서 리액트 핫 로더 3에서 해결했다고는 하지만…이 또한 어느 정도 문제가 존재해 추후에 해당 내용을 다뤄봐야겠다. 참조 링크 React Router: Declarative Routing for React.js Server-side rendering, code-splitting, and hot reloading with React Router v4 Quick and dirty code splitting with React Router v4 React-Router v4 Pre-Release 사용해보기","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://perfectacle.github.io/categories/Front-end/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"React","slug":"React","permalink":"https://perfectacle.github.io/tags/React/"},{"name":"Router","slug":"Router","permalink":"https://perfectacle.github.io/tags/Router/"}]},{"title":"(Webpack 2) 코드를 분할해보자!","slug":"webpack2-code-splitting","date":"2017-03-13T09:32:22.000Z","updated":"2022-10-30T08:42:17.003Z","comments":true,"path":"2017/03/13/webpack2-code-splitting/","link":"","permalink":"https://perfectacle.github.io/2017/03/13/webpack2-code-splitting/","excerpt":"들어가기에 앞서웹팩 2, 웹팩 1, 바벨, 리액트 등등에 대해서 기본적인 부분은 설명하지 않는다.또한 (Webpack 2) 트리 쉐이킹을 해보자!를 보고 나서 이 포스팅을 읽는 걸 추천한다. 코드를 왜 분할하지? SPA(Single Page Application)은 한 번에 모든 리소스를 로딩해서초기 로딩 이후에 페이지 이동이 매우 빠르다는 장점을 가지고 있다.하지만 앱의 규모가 커지면 모든 리소스를 한 번에 로딩하므로초기 로딩이 느려져 사용자 이탈을 유발하는 양날의 검을 가지고 있다.","text":"들어가기에 앞서웹팩 2, 웹팩 1, 바벨, 리액트 등등에 대해서 기본적인 부분은 설명하지 않는다.또한 (Webpack 2) 트리 쉐이킹을 해보자!를 보고 나서 이 포스팅을 읽는 걸 추천한다. 코드를 왜 분할하지? SPA(Single Page Application)은 한 번에 모든 리소스를 로딩해서초기 로딩 이후에 페이지 이동이 매우 빠르다는 장점을 가지고 있다.하지만 앱의 규모가 커지면 모든 리소스를 한 번에 로딩하므로초기 로딩이 느려져 사용자 이탈을 유발하는 양날의 검을 가지고 있다. 1단계: 내 코드와 서드 파티(라이브러리&#x2F;프레임워크) 코드를 분리해보자.HTTP 1.1 프로토콜은 2개의 http 요청을 병렬로 수행하게 돼있지만,모던 브라우저는 4개의 http 요청을 병렬로 수행한다.아래 링크를 참조하자.브라우저의 리소스 병렬 다운로드를 가로막는 자바스크립트 | 감성 프로그래밍따라서 내 코드와 서드 파티 코드를 동시에 다운로드 받으면 더 빠른 로딩이 가능하다.따라서 내 코드(app)와 서드 파티 코드(vendor)를 하나의 bundle.js에서 분리시키는 단계가 필요하다.리액트 대신에 다른 서드 파티로 진행해도 무방하다. 일단 프로젝트를 생성하자. 123npm init --ynpm i -S react react-domnpm i -D babel-core babel-preset-env babel-preset-react babel-loader webapck 소스 코드는 src 폴더를 만들어 그 안에서 관리하도록 하겠다.엔트리의 진입점인 main.js를 만들자. 1234567import React from &#x27;react&#x27;;import &#123;render&#125; from &#x27;react-dom&#x27;;render( &lt;h2&gt;히히헤헤&lt;/h2&gt;, document.getElementById(&#x27;app&#x27;)); webpack.config.js를 만들자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, // 아래와 같이 수동적으로 서드 파티들을 다 추가해줘야한다. // 장점으로는 자기가 빼고 싶은 서드 파티만 지정할 수 있다는 점이다. // 자신의 앱과 벤더의 크기를 균형있게 맞출 수가 있다. vendor: [&#x27;react&#x27;, &#x27;react-dom&#x27;] &#125;, output: &#123; // entry에 존재하는 app.js, vendor.js로 뽑혀 나온다. filename: &#x27;[name].js&#x27;, path: &#x27;./dist/&#x27;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; // 위에 vendor와 통일시켜줘야한다. name: &#x27;vendor&#x27; &#125;), // 브라우저의 콘솔 창에 리액트를 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [ &quot;env&quot;, &#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 위와 같이 해줘도 되는데 일일이 서드 파티를 적기 귀찮은 사람은 아래와 같이 하면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, &#125;, output: &#123; // entry에 존재하는 app.js, // new webpack.optimize.CommonsChunkPlugin의 name 값인 vendor.js로 뽑혀 나온다. filename: &#x27;[name].js&#x27;, path: &#x27;./dist/&#x27;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 터미널 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, // 아래 부분이 핵심 minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf(&#x27;node_modules&#x27;) !== -1; &#125; &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [ &quot;env&quot;, &#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 빌드를 할 때 마다 dist 폴더를 제거해야하므로 npm 스크립트를 이용하자.packge.json의 scripts 부분을 다음과 같이 수정하자. 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;rm -rf dist &amp;&amp; ./node_modules/webpack/bin/webpack.js&quot;&#125; rm -rf는 유닉스 기반 명령어이기 때문에 Mac OS, Linux, Unix 등등에서만 쓸 수 있다.윈도우에서는 아마 아래와 같이 하면 될 거다. (될런지는 모르겠다.) 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;rmdir dist /s &amp;&amp; ./node_modules/webpack/bin/webpack.js&quot;&#125; 그리고 터미널에 아래와 같이 치면 npm script를 쓸 수 있다.test, build, start만 아래와 같이 칠 수 있고 나머지는npm run scriptName과 같이 입력해야한다. 1npm build 결과를 보면 벤더로 서드파티가 다 빠져서 파일 크기가 더 큰 걸 볼 수 있다.아마 우리가 작성한 앱은 아직 규모가 작기 때문일 것이다. 그리고 index.html을 만들어 테스트 해보자.vendor 보다 app이 더 먼저 삽입되면 오류가 난다. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./vendor.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 라우터의 코드를 분할해보자!모든 사용자가 우리 앱의 모든 페이지를 돌아다니지 않는다.하지만 app.js에는 우리 앱의 모든 페이지 코드가 담겨있다.라우터를 통해 구분했던 페이지대로 코드를 분할시켜보자! hash vs chunkhash hash가 뭐지??기본적으로 브라우저에는 임시 파일, 캐시 데이터라고 불리는 임시 저장공간이 존재한다.이 임시 저장공간은 자신의 하드 공간의 일부에 해당한다.브라우저 속성에서 찾아보면 나올 것이다.만약 파일에 대한 요청이 있으면 처음에는 웹서버에서 다운 받고 임시 저장공간에 저장한다.하지만 동일한 요청이 또 오면 웹서버를 거치지 않고 하드에 있는 임시 저장공간에서 뒤져서해당 파일을 응답해줘서 더 빠른 응답을 하기 위한 기법이다.하지만 파일의 내용이 바뀌었는데도 임시 저장 공간에 있는 내용을 내려줘서변경된 파일이 보이지 않아 당황한 적이 많을 것이다.이렇게 파일이 변경 됐음에도 반영되지 않는 걸 방지하고자파일 이름에 hash라는 걸 붙이는 방법이다.hash는 복잡한데 그냥 암호화된 문자라고 대충 생각하면 될 것 같다.하지만 파일이 변경되지 않았을 때도 계속해서 다른 해쉬를 생성해서캐시 데이터의 장점을 전혀 이용할 수가 없다.이래서 나온 게 chunkhash다. chunkhash 짱짱맨!chunkhash는 해당 파일이 변경 됐을 때만 파일에 hash를 바꿔서 저장하는 것이다.즉 파일이 바뀌지 않았으면 똑같은 파일 이름에 대한 요청이므로 캐시 데이터를 쓰고,파일이 바뀌었으면 다른 해쉬가 파일 이름에 들어가 웹서버에 새로 요청해서수정된 내용을 즉각적으로 볼 수 있는 것이다.그렇담 chunk는??나도 잘 모르는데 그냥 페이지 별로 소스를 나눈 게 청크인 것으로 안다. hash의 사용법은 어렵지 않으므로 chunkhash만 설명하겠다.일단 chunkhash를 테스트하기 위해 리액트 라우터를 설치하자.또한 HTML5의 History API(리액트 라우터의 browserHistory)를 사용하기 위해node.js의 http 모듈을 사용해서 서버를 띄워보자.쌩으로 코딩하면 번거로우니까 express 모듈을 사용하도록 하자.react-router v4는 너무 변경사항이 많아서 일단은 3 버전을 토대로 설명한다. 12npm i -S react-router@^3.xnpm i -D express 라우터를 테스트 하기 위해 두 개의 컴포넌트를 만들자.일단은 Comp.js 12345678import React from &#x27;react&#x27;;import Link from &#x27;react-router/es/Link&#x27;;const Comp = () =&gt; ( &lt;div&gt; &lt;h2&gt;&lt;Link to=&quot;aa/bb/cc&quot;&gt;하이&lt;/Link&gt;&lt;/h2&gt; &lt;/div&gt;); Comp2.js도 만들자. 12345678910import React from &#x27;react&#x27;;import Link from &#x27;react-router/es/Link&#x27;;const Comp2 = () =&gt; ( &lt;div&gt; &lt;h2&gt;&lt;Link to=&quot;/&quot;&gt;바이&lt;/Link&gt;&lt;/h2&gt; &lt;/div&gt;);export default Comp2; 엔트리의 진입점인 main.js도 수정하자.청크의 코드를 분할하는 방법에는 세 가지가 있다. System.importSystem.import is deprecateddeprecated 되었다. 쓰지 말자. import(module)Dynamic import귀찮다.바벨 플러그인(babel-plugin-syntax-dynamic-import)을 설치하고 설정해줘야 한다.청크의 이름을 지정할 수 없다.하지만 오류가 났을 때 catch()를 써서 처리 할 수 있다는데,뭐 그렇게 처리할만한 상황이 얼마나 있을까 싶다. require.ensure다른 거 설치 안 해도 되고, 청크의 이름을 지정할 수 있다.이 포스팅에서는 3번을 통해 청크 스플리팅을 해보겠다. 1234567891011121314151617181920212223242526import React from &#x27;react&#x27;;import &#123;render&#125; from &#x27;react-dom&#x27;;import Router from &#x27;react-router/es/Router&#x27;;import Route from &#x27;react-router/es/Route&#x27;;import browserHistory from &#x27;react-router/es/browserHistory&#x27;;render( // HTML5의 History API를 쓰기 위해 hashHistory 대신에 browserHistory를 사용하였다. &lt;Router history=&#123;browserHistory&#125;&gt; // component 대신에 getComponent를 사용하는 점을 주목하자. &lt;Route path=&quot;/&quot; getComponent=&#123;(location, callback) =&gt; &#123; // 아래 코드 부분이 핵심이다. // [] 부분 안에 디펜던시가 들어간다는데 언제 쓰게 되는지는 잘 모르겠다. require.ensure([], (require) =&gt; &#123; callback(null, require(&#x27;./Comp&#x27;).default); // 두 번째 인자로 청크의 이름이 들어간다. &#125;, &#x27;Comp&#x27;); &#125;&#125; /&gt; &lt;Route path=&quot;/aa/bb/cc&quot; getComponent=&#123;(location, callback) =&gt; &#123; require.ensure([], (require) =&gt; &#123; callback(null, require(&#x27;./Comp2&#x27;).default); &#125;, &#x27;Comp2&#x27;); &#125;&#125; /&gt; &lt;/Router&gt;, document.getElementById(&#x27;app&#x27;)); 이번엔 index.html를 수정하자.어떤 청크해쉬가 들어갈지 모르므로 script 태그를 빼버렸다. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이제 webpack.config.js를 수정해보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, &#125;, output: &#123; // 요 놈은 저 위에 엔트리의 app에 대한 내용 filename: &#x27;[name].[chunkhash].js&#x27;, // 요 놈은 페이지 별 청크에 대한 내용 chunkFilename: &#x27;[name].[chunkhash].js&#x27;, path: `./dist`, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf(&#x27;node_modules&#x27;) !== -1; &#125;, // 요 놈은 vendor에 대한 내용 fileName: &#x27;[name].[chunkhash]&#x27; &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [ &quot;env&quot;, &#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 이제 빌드를 해보자 1npm build 빌드된 파일을 보면 두 가지 문제점이 존재한다. 뒤에 해쉬 값을 예측할 수가 없다. html 파일이 dist에 복사되지 않는다. 이럴 때 필요한 것은 html-webpack-plugin!설치하자. 1npm i -D html-webpack-plugin webpack.config.js를 수정하자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; entry: &#123; app: &#x27;./src/main.js&#x27;, &#125;, output: &#123; // 요 놈은 저 위에 엔트리의 app에 대한 내용 filename: &#x27;[name].[chunkhash].js&#x27;, // 요 놈은 페이지 별 청크에 대한 내용 chunkFilename: &#x27;[name].[chunkhash].js&#x27;, path: &#x27;./dist&#x27;, // HTML5의 History API를 쓰다보면 라우터가 // http://localhost/aa/bb/cc 와 같이 뎁스가 깊어지는데 // 그럴 때 js 파일은 localhost를 기준으로 잡아야하므로 // 루트를 기준으로 잡아준 것이다. publicPath: &#x27;/&#x27; &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮아서 추가. unused: true // tree shaking &#125; &#125;), // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;), // app.js에 들어갈만한 내용을 vendor로 빼주는 플러그인 new webpack.optimize.CommonsChunkPlugin(&#123; name: &#x27;vendor&#x27;, minChunks: function (module) &#123; // this assumes your vendor imports exist in the node_modules directory return module.context &amp;&amp; module.context.indexOf(&#x27;node_modules&#x27;) !== -1; &#125;, // 요 놈은 vendor에 대한 내용 fileName: &#x27;[name].[chunkhash]&#x27; &#125;), // 브라우저의 콘솔 창에 프로덕션 모드로 빌드하라는 오류가 뜨는데 그걸 없애주는 플러그인 new webpack.DefinePlugin(&#123; &#x27;process.env&#x27;: &#123; NODE_ENV: JSON.stringify(&#x27;production&#x27;) &#125; &#125;), // htmlWebpackPlugin을 쓰면 html 파일 복사 및 js, css inject를 할 수 있다. // 물론 minify도 가능하다. new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ], module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [ [ &quot;env&quot;, &#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;], // tree shaking &quot;modules&quot;: false &#125; ], &quot;react&quot; ] &#125; &#125; ] &#125;&#125;;// 로더 개발자를 위한 로그 제거process.noDeprecation = true; 이제 빌드를 해보자. 1npm build dist 디렉토리를 보면 index.html이 생성되있고, 소스 코드를 봐보자. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/vendor.916f26b9c3a11d8f3204.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/app.f11205f23697a92f4153.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 해쉬가 정상적으로 붙어서 들어갔고, vendor가 먼저 들어갔고, 다른 페이지 청크는 들어가지 않았다.또한 루트 디렉토리를 뜻하는 &#x2F;도 정상적으로 들어가있다.HTML5의 History API를 확인해보려면 실제 서버를 띄워야하므로 서버 코드를 작성해보자.server.js를 프로젝트의 최상위 디렉토리에 만들자. 12345678910111213141516171819const express = require(&#x27;express&#x27;);const app = express();// 루트 디렉토리(/)로 오면 dist 디렉토리에 있는 index.html을 불러옴.// 서버 라우터일 거다. 아마도...app.use(&#x27;/&#x27;, express.static(__dirname + `/dist`));// 8080 포트로 서버 오픈app.listen(8080, () =&gt; &#123; console.log(&#x27;Express listening on port&#x27;, 8080);&#125;);// 클라이언트 라우터(일거다... 아마도...)인 react-router의 HTML5 History API를 사용하기 위함.// http 메소드 중에 get을 사용해서 모든 라우터(*)로 접근할 경우에(요청할 경우에)app.get(&#x27;*&#x27;, (req, res) =&gt; &#123; // 요청(request)에 대한 응답(response)으로 dist 디렉토리의 index.html을 돌려준다. // __dirname은 노드 js의 전역 변수인데 현재 디렉토리(풀 디렉토리, 절대 경로)를 반환하는 변수이다. res.sendFile(__dirname + &#x27;/dist/index.html&#x27;);&#125;); 터미널에서 이제 노드 서버를 켜보자. 1node server 브라우저에서 실제로 테스트 해보자.http://localhost:8080 으로 접속한 결과다. 크롬 개발자 도구의 네트워크 탭을 보면 Comp.[chunkhash]만 있고 Comp2는 로드하지 않았다.하이 라는 링크를 클릭하면 http://localhost:8080/aa/bb/cc로 이동한다.여기서 다시 네트워크 탭을 봐보자. 페이지를 처음부터 로딩하는 게 아니라 새로운 부분인Comp2.[chunkhash] 부분만 로딩한 것을 볼 수 있다.여기서 새로고침을 해보자. 역시 Comp2.[chunkhash]만 로드하고 Comp는 로드하지 않았다.바이 라는 링크를 클릭하면 http://localhost:8080/으로 이동한다. 역시 페이지를 처음부터 로딩하는 게 아니라 새로운 부분인Comp.[chunkhash] 부분만 로딩한 것을 볼 수 있다. 조금이나마 최적화에 한 단계 다가간 것 같아 뿌듯하다.끝 !! 참조링크 웹팩2로 청크 관리 및 코드 스플리팅 하기 브라우저의 리소스 병렬 다운로드를 가로막는 자바스크립트 | 감성 프로그래밍 Code Splitting - Libraries A beginner’s step-by-step guide to Code Splitting with Webpack 2 and React Router등등…","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"https://perfectacle.github.io/tags/babel/"}]},{"title":"(Webpack 2) 트리 쉐이킹을 해보자!","slug":"webpack2-tree-shaking","date":"2017-03-12T19:32:22.000Z","updated":"2022-10-30T08:42:17.015Z","comments":true,"path":"2017/03/12/webpack2-tree-shaking/","link":"","permalink":"https://perfectacle.github.io/2017/03/12/webpack2-tree-shaking/","excerpt":"들어가기에 앞서여기선 기본적으로 웹팩 1, 바벨, ES2015(ES6)을 알고 있다는 전제로 진행한다.리액트 대신에 다른 서드 파티(라이브러리&#x2F;프레임워크) 가지고 테스트하면서 이 글을 봐도 된다.또한 이 글을 보고 나서 (Webpack 2) 코드를 분할해보자!도 보는 걸 추천한다. 트리 쉐이킹(Tree Shaking)?? 트리 쉐이킹이란 나무를 흔들어서 필요없는 걸 떨어트리는 행위를 말한다.여기서 우리에게 필요없는 것이란 쓰지 않는 코드를 뜻한다.","text":"들어가기에 앞서여기선 기본적으로 웹팩 1, 바벨, ES2015(ES6)을 알고 있다는 전제로 진행한다.리액트 대신에 다른 서드 파티(라이브러리&#x2F;프레임워크) 가지고 테스트하면서 이 글을 봐도 된다.또한 이 글을 보고 나서 (Webpack 2) 코드를 분할해보자!도 보는 걸 추천한다. 트리 쉐이킹(Tree Shaking)?? 트리 쉐이킹이란 나무를 흔들어서 필요없는 걸 떨어트리는 행위를 말한다.여기서 우리에게 필요없는 것이란 쓰지 않는 코드를 뜻한다. 우리의 코드를 트리 쉐이킹 해보자기존 웹팩 1에서 번들링이 어떻게 이루어졌는지 보자. 우선 모듈을 하나 만들어보자. (module.js) 12export const a = 123123123123;export const b = 45645646456; 그리고 이 모듈을 불러다 쓰는 우리의 앱을 만들자. (app.js) 12import &#123;a&#125; from &#x27;./module&#x27;;console.log(a); 하지만 번들링을 해보면 아래와 같이 쓰지도 않은 b가 들어가있는 반쪽짜리 모듈화가 된 셈이다.아마 이게 ES2015의 Native Import가 아닌 CommonJS 스타일?인 것으로 알고 있다. 12345678910111213141516171819202122232425/************************************************************************//******/ ([/* 0 *//***/ function(module, exports, __webpack_require__) &#123; &#x27;use strict&#x27;; var _moduleA = __webpack_require__(1); console.log(_moduleA.a);/***/ &#125;,/* 1 *//***/ function(module, exports) &#123; &quot;use strict&quot;; Object.defineProperty(exports, &quot;__esModule&quot;, &#123; value: true &#125;); var a = exports.a = 123123123123; var b = exports.b = 45645646456;/***/ &#125;/******/ ]); 하지만 웹팩 2에서는 이런 ES2015 Native Import를 지원함으로써쓸 데 없는 녀석(const b)을 나무에서 떨어트리는 트리 쉐이킹이 가능해진 것이다.바로 알아보자! 일단 프로젝트를 하나 만들고 웹팩을 설치해보자. 12npm init --ynpm i -D webpack 위에 적어놓은 app.js와 module.js를 똑같이 만들자.그리고 webpack.config.js를 만들어서 아래와 같이 만들어주자.바벨 없이 import&#x2F;export를 쓸 수 있는 건 혁명이다!! 1234567module.exports = &#123; entry: &#x27;./app.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: `./` &#125;&#125;; 그리고 터미널에서 아래와 같이 번들링을 해보자. 1./node_modules/webpack/bin/webpack.js 하지만 번들링된 녀석을 보면 여전히 b가 남아있다. 12345678910111213141516171819202122232425/************************************************************************//******/ ([/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;const a = 123123123123;/* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = a;const b = 45645646456;/* unused harmony export b *//***/ &#125;),/* 1 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, &#123; value: true &#125;);/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__module__ = __webpack_require__(0);console.log(__WEBPACK_IMPORTED_MODULE_0__module__[&quot;a&quot;]);/***/ &#125;)/******/ ]); 트리 쉐이킹을 위해선 웹팩 2의 플러그인인 UglifyJS2를 이용하면 된다.이제 webpack.config.js를 수정해주자. 123456789101112131415161718192021222324252627const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./app.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: `./`, &#125;, // 여기부터 추가된 내용 plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don&#x27;t change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;) ]&#125;; 그리고 다시 아래와 같이 터미널에서 번들링을 해주자. 1./node_modules/webpack/bin/webpack.js 그럼 아래와 같은 로그가 터미널에 뜬다. 123WARNING in bundle.js from UglifyJsCollapsing constant a [bundle.js:75,60]Dropping unused variable b [bundle.js:77,6] Dropping unused variable b [bundle.js:77,6]위 부분이 핵심이다.다시 번들링 된 코드를 보면 깔끔하게 b가 제거된 것을 볼 수 있다. 1234567/* 0 *//***/function(module, __webpack_exports__, __webpack_require__) &#123; &quot;use strict&quot;; /* harmony export (immutable) */ __webpack_exports__.a = 123123123123;&#125; 서드파티(라이브러리&#x2F;프레임워크)를 트리 쉐이킹 해보자이 챕터는 다소 문제가 많다.서드파티마다 모듈화 한 방식이 제각각이라 트리 쉐이킹 하는 방법이 다양하고,나도 처음 접하다 보니 모든 서드 파티를 테스트 할 수가 없어서 대표적으로react-router(4는 너무 변경 사항이 많아서 3) 요 놈만 건드려보았다. react-router를 사용하기 위해 react를 설치해야 하고,react를 사용하려면 react-dom도 설치해야하고,또한 react를 쓰기 위해선 babel-preset-react를 설치해야하는데,babel-preset-react를 쓰기 위해선 babel-core도 설치해야하고,webpack에서 bable을 사용하기 위해선 bable-loader도 설치해야 하고,uglifyJS2가 ES2015를 완벽하게 지원하지 않아서babel-preset-2015(여기선 babel-preset-env)를 설치해야한다.위에 절차가 복잡하므로 이해하지 말고 그냥 설치해버리자. 12npm i -S react react-dom react-router@^3.xnpm i -D babel-core babel-preset-env babel-preset-react babel-loader index.html 파일을 만들자. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 라우팅 할 컴포넌트 Comp.js를 하나 만들자. 12345import React from &#x27;react&#x27;;const Comp = () =&gt; &lt;h2&gt;하이&lt;/h2&gt;;export default Comp; 그리고 app.js를 다음과 같이 수정해보자. 123456789101112import React from &#x27;react/lib/React&#x27;;import &#123;render&#125; from &#x27;react-dom/lib/ReactDOM&#x27;; import &#123;Router, Route, hashHistory&#125; from &#x27;react-router&#x27;;import Comp from &#x27;./Comp&#x27;;render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById(&#x27;app&#x27;)); webpack.config.json에 바벨 로더를 붙이자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./app.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: `./`, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; // 사실 아래와 같이만 써도 트리 쉐이킹이 된다. // compress: true compress: &#123; // warnings: false, // 콘솔 창에 출력되는 게 보기 귀찮다면 요 놈을 주석 제거를 하면 된다. unused: true // 요 놈이 핵심 &#125;, mangle: false, // DEMO ONLY: Don&#x27;t change variable names.(난독화) beautify: true, // DEMO ONLY: Preserve whitespace (가독성 좋게 함) output: &#123; comments: true // DEMO ONLY: Helpful comments (주석 삭제 안 함) &#125; &#125;), // 여기서부터 추가된 내용. // 로더들에게 옵션을 넣어주는 플러그인이다. new webpack.LoaderOptionsPlugin(&#123; minimize: true, &#125;), ], module: &#123; // 웹팩 1에서는 loaders를 썼지만 2에선 rules rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 쿼리가 필요한 로더는 loader로 써줘야함. // 쿼리가 필요 없는 로더는 use로 써도 된다. // 웹팩 2에선 babel-loader와 같이 -loader 생략이 불가능해졌다. loader: &#x27;babel-loader&#x27;, // babel-loader?머시기와 같은 쿼리나 query: 옵션 대신에 // 웹팩 2에선 options: 로 바뀜. // .babelrc로 따로 빼줘도 상관 없다. options: &#123; presets: [ [ &quot;env&quot;, &#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;], // babel-preset-2015에서는 Native Module을 쓰지 않는 것인지 // 아래 옵션을 주지 않으면 우리가 만든 코드(ES2015의 import/export Syntax)가 // 트리 쉐이킹 되질 않는다. &quot;modules&quot;: false &#125; ], &quot;react&quot; ] &#125; &#125; ] &#125;&#125;;// DeprecationWarning: loaderUtils.parseQuery() received a non-string value which can be problematic, see https://github.com/webpack/loader-utils/issues/56// parseQuery() will be replaced with getOptions() in the next major version of loader-utils.// 위와 같이 로더 개발자를 위한 로그가 뜨는데 보기 싫다면 주석을 제거하면 된다.// process.noDeprecation = true; 이제 번들링 된 파일을 보면 우리가 import 시키지도 않은 browserHistory가 들어있다. 12345678/* 211 *//***/function(module, __webpack_exports__, __webpack_require__) &#123; &quot;use strict&quot;; /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory__ = __webpack_require__(129), __WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory__), __WEBPACK_IMPORTED_MODULE_1__createRouterHistory__ = __webpack_require__(103); __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__createRouterHistory__.a)(__WEBPACK_IMPORTED_MODULE_0_history_lib_createBrowserHistory___default.a);&#125; 이렇듯 서드 파티들은 트리 쉐이킹이 제대로 되지 않는다.아마 서드파티 제작자들도 우리가 쓴 ES2015의 import&#x2F;export 문법을 썼지만 배포할 때는babel-preset-2015의 Native가 아닌 모듈로 트랜스파일 된 놈이 배포되기 때문에 그런 게 아닐까 싶다.따라서 아래와 같이 별개의 모듈일 일일이 불러오는 번거로운 작업을 해줘야한다. 1234567891011121314import React from &#x27;react/lib/React&#x27;;import &#123;render&#125; from &#x27;react-dom/lib/ReactDOM&#x27;;import Router from &#x27;react-router/es/Router&#x27;;import Route from &#x27;react-router/es/Route&#x27;;import hashHistory from &#x27;react-router/es/hashHistory&#x27;;import Comp from &#x27;./Comp&#x27;;render( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;Comp&#125; /&gt; &lt;/Router&gt;, document.getElementById(&#x27;app&#x27;)); 다른 서드 파티들은 바로 import 시켜도 트리 쉐이킹 되는 애들도 있을 것이지만,대부분의 서드 파티가 업데이트 되기 전까지는 저렇게 일일이 import 시켜줘야하는 번거로움이 있다. 참조 링크 웹팩2(Webpack) 설정하기 Webpack 2 Tree Shaking Configuration Webpack2 Guides UglifyJS2등등 너무 많아서 증발함… 혹시 틀린 내용이 있다면 무한 태클 환영입니다 ~","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"babel","slug":"babel","permalink":"https://perfectacle.github.io/tags/babel/"}]},{"title":"(자작) perf-chk (Node.js 애플리케이션)","slug":"perf-chk","date":"2017-03-01T16:24:02.000Z","updated":"2022-10-30T08:42:16.879Z","comments":true,"path":"2017/03/01/perf-chk/","link":"","permalink":"https://perfectacle.github.io/2017/03/01/perf-chk/","excerpt":"perf-chk (Performance Check)왜 perf-chk를 만들었나?나는 코드 실행 시간에 굉장히 관심이 많다.따라서 코드 실행 시간 측정을 위해 테스트를 종종 해보곤 한다.그럴 때 아래와 같은 코드를 사용하였다. 1234567891011const iterations = 10000000;console.time(&quot;function A&quot;);for(let i=0; i&lt;iterations; i++)&#123; // some code1&#125;console.timeEnd(&quot;function A&quot;); // &#x27;Function A: xxx.xxx ms&#x27;console.time(&quot;function B&quot;);for(let i=0; i&lt;iterations; i++)&#123; // some code2&#125;console.timeEnd(&quot;function B&quot;); // &#x27;Function B: xxx.xxx ms&#x27;","text":"perf-chk (Performance Check)왜 perf-chk를 만들었나?나는 코드 실행 시간에 굉장히 관심이 많다.따라서 코드 실행 시간 측정을 위해 테스트를 종종 해보곤 한다.그럴 때 아래와 같은 코드를 사용하였다. 1234567891011const iterations = 10000000;console.time(&quot;function A&quot;);for(let i=0; i&lt;iterations; i++)&#123; // some code1&#125;console.timeEnd(&quot;function A&quot;); // &#x27;Function A: xxx.xxx ms&#x27;console.time(&quot;function B&quot;);for(let i=0; i&lt;iterations; i++)&#123; // some code2&#125;console.timeEnd(&quot;function B&quot;); // &#x27;Function B: xxx.xxx ms&#x27; 하지만 위 코드를 엄청 자주 쓰지 않다보니 암기가 되질 않았다.따라서 매일 어디선가 복사 붙여넣기 해서 썼다.또한 함수명, 코드, 반복 횟수를 일일이 바꿔가는 것도 귀찮았다.이러한 귀찮음을 조금이라도 줄여보고자 perf-chk를 만들게 되었다. perf-chk는 무엇인가?Node.js에서 코드의 실행 시간을 측정해주는 CLI 도구이다.Node.js 어플리케이션이라고 하는 게 맞을라나…?여튼 내가 짠 코드 중에 어떤 코드가 더 빠른지 알아보고자 할 때 쓰면 된다. 시작하기perf-chk는 몇몇 ES6 문법들을 사용한다. (const, arrow function)따라서 Node.js v6.4.0 이상이 설치돼있어야만 한다. 설치 global로 설치하기 (권장)1npm i -g perf-chk local로 설치하기 1npm i -D perf-chk 사용법1. 테스트 할 코드를 생성하자. (모듈)1234567891011121314// some code// blahblahmodule.exports = &#123; methodA: function() &#123; // ES5 function 문법 // blahblah &#125;, methodB() &#123; // ES6 Method 문법 // blahblah &#125;, methodC: () =&gt; &#123; // ES6 Arrow Function 문법 // blahblah &#125;&#125; 참고 module.exports &#x3D; {} 는 node.js의 모듈 추출 문법이다.perf-chk는 node.js 어플리케이션이므로 이 문법을 준수해야만 정상 작동된다. 함수 문법은 입맛에 맞게 골라쓰면 된다. 2. 실행 시간을 체크하자. CLI 도구이므로 터미널을 열자. (윈도우에서는 cmd) 명령어를 아래와 같이 치자. 1perf-chk &#123;모듈_이름&#125; [반복_횟수] 만약 local로 설치했다면 아래와 같이 입력하자. 1./node_modules/perf-chk &#123;모듈_이름&#125; [반복_횟수] note모듈_이름은 필수적이고, &lt;파일이름&gt;.js나 &lt;파일이름&gt;과 같이 치면 된다.반복_횟수는 선택사항이며 기본 값은 100,000,000이다.반복_횟수는 신뢰할 수 있는 정수(자연수)여야만 하며,범위는 1 ~ 9,007,199,254,740,991까지다.만약 코드들의 실행 시간이 모두 비슷하다면 큰 차이가 없는 것이다.그럼에도 불구하고 코드들 사이의 실행 시간 차이를 알아보고 싶다면반복 횟수를 늘려가며 실험해보면 된다. 주의사항 실행 시간은 매번 동일하지 않다.이는 컴퓨터 사양에 따라 결과가 달라진다. (CPU, RAM 등등)또한 동일한 컴퓨터 사양이라고 해서 결과가 모두 같은 건 아니다.왜냐하면 CPU 사용량과 RAM 사용량이 항상 같은 것은 아니기 때문이다.따라서 실행 시간은 단순 참고용 정도로만 사용하자. perf-chk는 Node.js 위에서 돌아간다.따라서 브라우저 내장 객체인 DOM(Document Object Model, 예를 들면 document.getElementById),BOM(Browser Object Model, 예를 들면 window.alert)와 같은 걸 지원하지 않는다.오직 ECMAScript만 테스트 할 수 있다.Node.js 버전에 따라 ECMAScript 지원율도 다르다.궁금한 사람은 아래 링크를 참조하자.Node.js ECMAScript compatibility tables","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Performance","slug":"Performance","permalink":"https://perfectacle.github.io/tags/Performance/"},{"name":"CLI","slug":"CLI","permalink":"https://perfectacle.github.io/tags/CLI/"}]},{"title":"(ES) this","slug":"es-this","date":"2017-02-15T09:00:37.000Z","updated":"2022-10-30T08:42:16.599Z","comments":true,"path":"2017/02/15/es-this/","link":"","permalink":"https://perfectacle.github.io/2017/02/15/es-this/","excerpt":"자바스크립트에서 this는 상황에 따라 다른 값을 반환해서 아주 짜증나기 마련이다.이와 관련해서 하나하나 낱낱이 테스트해보자. ES5함수로서 호출할 때1234567&#x27;use strict&#x27;;var a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a();","text":"자바스크립트에서 this는 상황에 따라 다른 값을 반환해서 아주 짜증나기 마련이다.이와 관련해서 하나하나 낱낱이 테스트해보자. ES5함수로서 호출할 때1234567&#x27;use strict&#x27;;var a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); 생성자 함수로서 호출할 때123456789&#x27;use strict&#x27;;var b = function() &#123; // 생성자로서 호출할 때 this.a = &#x27;1&#x27;; this.b = function() &#123;&#125;; // this === &#123;a: 1, b: function() &#123;&#125;&#125; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 console.log(this);&#125;;new b(); 객체의 메소드로서 호출할 때123456789101112131415161718192021&#x27;use strict&#x27;;var C = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // C &#125;, b: function() &#123; // 메소드로서 호출할 때 var a = function() &#123; // 함수로서 호출해버리면 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, c: function() &#123; // 메소드로서 호출할 때 // 메소드를 호출 this.a(); // C &#125;&#125;;C.a();C.b();C.c(); ES6새로 나온 애로우 펑션은 this를 바인딩하지 않는다.call, apply, bind 메소드로도 강제 바인딩이 이루어지지 않는다.상위 스코프로부터 상속 받을 뿐이다. 일반 함수로서 호출할 때123456const a = function() &#123; // 함수로서 호출할 때 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this);&#125;;a(); 애로우 펑션으로서 호출할 때1234567891011121314const b = () =&gt; &#123; // 애로우 펑션은 strict mode 여부에 상관없이 Window // 전역에서 this가 Window이기 때문에 상속받는 것임. console.log(this); // Window&#125;;b();const _b = () =&gt; &#123; console.log(this);&#125;;// 전부 다 Window가 출력됨_b.call(&#123;a: 1&#125;);_b.apply(&#123;a: 1&#125;);_b.bind(&#123;a: 1&#125;)(); 클래스ES6 들어서 생성자 함수를 대체할 녀석으로 클래스가 등장하였다.이 클래스에서도 this를 낯낯이 파헤쳐보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 함수를 통해 객체의 인스턴스를 생성하던 것 대신에 클래스가 등장함.// 멤버: 변수와 메소드// 클래스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 동일한 값을 가짐.(공유함)// 클래스의 인스턴스가 생기기 전에도 클래스이름.멤버로 사용 가능.// static으로 생성된 메소드 및 prototype이 이에 해당.// 인스턴스 멤버: new 생성자 함수를 통해 생성된 인스턴스마다 다른 값을 가짐.(공유하지 않음)// 클래스의 인스턴스가 생기기 전에는 사용 불가능, 인스턴스이름.멤버로 사용 가능// 생성자 함수 내부에 작성된 애들이나 static 키워드를 쓰지 않고 생성한 메소드들이 해당됨.class C &#123; constructor() &#123; // 생성자 함수 외부에서 인스턴스 변수를 선언하지 못한다. this.a = 1; this.b = () =&gt; &#123;&#125;; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125; // 클래스 메소드의 this는 // 클래스 멤버(변수, 메소드) 등등을 담고있는 생성자 함수이다. // 클래스 변수는 클래스 내에서 선언하지 못하고, // className.prototype.variable = value 와 같이 선언한다. static a() &#123; // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125; static b() &#123; const a = function() &#123; // 함수로서 호출하면 this를 재바인딩 // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; static c() &#123; const a = () =&gt; &#123; // 애로우 펑션은 this를 상속받음. // function, 함수 또한 객체기 때문에 프로퍼티로 접근이 가능하다. console.log(typeof this); // new this(); 이렇게 생성자를 호출할 수도 있다. // __proto__는 상속받는 놈들이기 때문에 바로 this.머시기로 사용할 수 있었으나 // prototype은 상속해주는 놈들이기 때문에 this.prototype.머시기로 사용해야한다. // &#123; // a: function() &#123;&#125;, // b: function() &#123;&#125;, // c: function() &#123;&#125;, // prototype: &#123; // a: 1 // &#125; // &#125; console.dir(this); &#125;; a(); &#125; // 인스턴스 메소드의 this는 생성자 내의 this와 일치한다. d() &#123; // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.dir(this); &#125; e() &#123; const a = function() &#123; // 역시 ES5식 함수는 this를 덮어버린다. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125; f() &#123; const a = () =&gt; &#123; // 역시 애로우 펑션은 this를 상속 받음. // 인스턴스 멤버(변수, 메소드)를 포함하고 있는 객체 // &#123; // a: 1, // b: () =&gt; &#123;&#125;, // __proto__: &#123; // 상속받는 놈이기 때문에 바로 this.d()와 같이 사용 가능. // 위에 있는 놈들과 이름이 같다면 위에 있는 놈들이 우선 순위를 가짐. // d: function() &#123;&#125;, // e: function() &#123;&#125;, // f: function() &#123;&#125;, // g: function() &#123;&#125; // &#125; // &#125; console.log(this); &#125;; a(); &#125; g() &#123; // 인스턴스의 this에 클래스 멤버는 없다. // 따라서 클래스 멤버를 사용할 수는 없다. // this.a(); // 클래스 메소드 사용 불가. this.f(); // 인스턴스 멤버(메소드, 변수)는 사용 가능하다. &#125;&#125;// 클래스 변수는 클래스 내에서 선언하지 못함.// 레거시 환경을 지원하기 위해// 프로토타입 방식의 상속을 포기하지 못했기 때문인 걸까??C.prototype.q = 1;const c = new C();C.a();C.b();C.c();c.d();c.e();c.f();c.g(); 객체의 메소드로서 호출할 때ES6에서 객체의 메소드를key: function() {} 대신에key() {}와 같이 줄여쓸 수 있게 됐는데 두 개는 동일하다고 봐도 된다. 12345678910111213141516171819202122232425262728293031const d = &#123; a: function() &#123; // 메소드로서 호출할 때 console.log(this); // d &#125;, b: () =&gt; &#123; // 애로우 펑션은 바로 상위 스코프인 전역의 this를 상속받음. console.log(this); // Window &#125;, c() &#123; // a 메소드와 다를 바가 없다. console.log(this); // d &#125;, d() &#123; // 메소드로서 호출할 때 const a = function() &#123; // 역시 그냥 펑션은 this를 재바인딩함. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a(); &#125;, e() &#123; // 메소드로서 호출할 때 const a = () =&gt; &#123; // 애로우 펑션은 상위 스코프에 있는 this를 상속 받음. console.log(this); // d &#125;; a(); &#125;&#125;;d.a();d.b();d.c();d.d();d.e(); this를 바인딩하는 콜백함수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// [1].forEach()의 this인 &#123;a: &#x27;11&#x27;&#125;에 가려진다.// 그 이유는 forEach와 같은 함수는 자동으로 this를 바인딩하려는 성질이 있다.[0].forEach(d.a, &#123;a: &#x27;11&#x27;&#125;); // &#123;a: &#x27;11&#x27;&#125;// 콜백 함수 내부에서 써야 외부의 this로부터 영향을 받지 않는다.[0].forEach(function() &#123; d.e(); // d&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(() =&gt; d.e(), &#123;a: &#x27;11&#x27;&#125;); // d[0].forEach(function() &#123; // function() &#123;&#125;인데 this를 재바인딩하지 않고 &#123;a: &#x27;11&#x27;&#125;을 상속 받았다. // 이는 this를 바인딩 시키는 메소드로 this를 강제 바인딩 시킨 것으로 보인다. console.log(this); // &#123;a: &#x27;11&#x27;&#125;&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(function() &#123; const a = function() &#123; // this를 재바인딩해버렸음. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a();&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(function() &#123; const a = () =&gt; &#123; // this를 상속받는 애로우 펑션 console.log(this); // &#123;a: &#x27;11&#x27;&#125; &#125;; a();&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(() =&gt; &#123; // 애로우 펑션이라 this 바인딩 함수가 먹히지 않는다. // 즉 두 번째 매개변수는 무시된다. // 전역의 this인 Window를 상속받는다. console.log(this); // Window&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(() =&gt; &#123; const a = function() &#123; // this를 재바인딩해버렸음. // strict mode에서는 undefined // non-strict mode에서는 Window console.log(this); &#125;; a();&#125;, &#123;a: &#x27;11&#x27;&#125;);[0].forEach(() =&gt; &#123; // 애로우 펑션이라 Function.prototype.bind가 먹히지 않는다. // 즉 두 번째 매개변수는 무시된다. // 전역의 this인 Window를 상속받는다. const a = () =&gt; &#123; // this를 상속받는 애로우 펑션 console.log(this); // Window &#125;; a();&#125;, &#123;a: &#x27;11&#x27;&#125;); 별도의 컨텍스트를 만드는 함수setTimeout, setInterval 함수는 함수 선언 시점과 함수 호출 시점에별개의 컨텍스트를 가지는 대표적인 함수이다. 123456789101112131415161718192021222324252627282930const e = &#123; a() &#123; console.log(this); &#125;, b() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. setTimeout(this.a, 1000); &#125;, c() &#123; setTimeout(function() &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. console.log(this); &#125;, 2000); &#125;, d() &#123; setTimeout(() =&gt; &#123; // setTimeout은 별개의 컨텍스트를 만든다. // 바로 실행시점에 컨텍스트를 만드는데, // 실행 시점의 this는 전역의 this(Window)가 된다. // 하지만 애로우 펑션을 쓰면 클로저가 형성된다. // 실행 시점의 this(Window)와 선언 시점의 this(e 객체)가 달라서 // 그것을 동기화(?)시키기 위해서 클로저가 형성되는 게 아닐까...싶다. console.log(this); // e &#125;, 3000); &#125;&#125;; 함수 선언 시점의 this는 e object이다. 하지만 함수 실행 시점의 this는 window가 된다.바로 setTimeout이 별도의 컨텍스트를 만들기 때문이다. 함수로 래핑해봐도 마찬가지다. 하지만 애로우 펑션으로 래핑하면 클로저를 형성해서 우리가 원하는 결과를 얻어낼 수 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"this","slug":"this","permalink":"https://perfectacle.github.io/tags/this/"}]},{"title":"(ES) ~(Tilde) 연산자","slug":"es-tilt-operator","date":"2017-02-13T22:01:37.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2017/02/13/es-tilt-operator/","link":"","permalink":"https://perfectacle.github.io/2017/02/13/es-tilt-operator/","excerpt":"우리는 주로 ~라는 문자를 물결이라고 읽었다.하지만 영어권 국가에서는 Tilde(틸드)라고 읽는다.따라서 해당 연산자를 틸드 연산자라고 부른다.해당 연산자가 기본적으로 어떤 일을 하는지 보자. 뭐하는 놈이니?~ 연산자는 비트 단위의 연산자이다.즉, 10진수를 2진수로 바꿔버린 후 연산을 진행한다는 것이다.비트 단위의 연산자 중에 Not을 진행하는 연산자이다.Not 연산자이므로 단항 연산자이다.간단하게 어떻게 작동하는지 보자. 1console.log(~1); // -2","text":"우리는 주로 ~라는 문자를 물결이라고 읽었다.하지만 영어권 국가에서는 Tilde(틸드)라고 읽는다.따라서 해당 연산자를 틸드 연산자라고 부른다.해당 연산자가 기본적으로 어떤 일을 하는지 보자. 뭐하는 놈이니?~ 연산자는 비트 단위의 연산자이다.즉, 10진수를 2진수로 바꿔버린 후 연산을 진행한다는 것이다.비트 단위의 연산자 중에 Not을 진행하는 연산자이다.Not 연산자이므로 단항 연산자이다.간단하게 어떻게 작동하는지 보자. 1console.log(~1); // -2 일단 1을 2진수로 바꿔보자.00000001여기서 틸드 연산자를 쓰면~00000001Not 연산자 이므로 0을 1로, 1을 0으로 역전시킨다.11111110위에 2진수가 -2인지 확인해보자. -1의 비밀유독 자바스크립트의 메소드를 보면 -1을 반환하는 녀석들이 많다. String.prototype.indexOf() String.prototype.charAt() String.prototype.search() Array.prototype.indexOf() Array.prototype.findIndex() 뭐 이외에도 더 있는지 모르겠지만 내가 아는 범위 내에서는 이게 끝이다.주로 검색과 관련된 메소드 중에서인덱스(number)를 반환하는 메소드에서존재하면 해당 인덱스틀, 존재하지 않는다면 -1을 반환한다.단순히 인덱스가 0부터 정수로 쭉쭉 뻗어가니존재하지 않으면 0에서 가장 가까운 -1을 반환하는 게 타당해보인다.하지만 틸드 연산자와 생각해보면 이 -1이란 녀석을 이용해먹을 수 있다. 일단 -1을 2진수로 표현하면11111111인데 틸드 연산자를 써서 역전시켜버리면00000000정수 0이 돼버린다.0은 형변환 했을 때 false로 취급되는 falsy value이다.~-1 === 0이라는 점을 이용하면 조건식을 간결하게 만들 수 있다. 123456789101112131415const str = &#x27;나는바보입니다&#x27;;let search = &#x27;냐&#x27;;if(str.indexOf(search) === -1) console.log(&#x27;없다&#x27;);// ~ 연산자를 쓰면 아래와 같이 줄일 수 있다.// ~-1 === 0 == false이기 때문에 논리 부정 연산자(!)를 썼다.if(!~str.indexOf(search)) console.log(&#x27;없다&#x27;);search = &#x27;바보&#x27;;if(str.indexOf(search) !== -1) console.log(&#x27;있다&#x27;);// ~ 연산자를 쓰면 아래와 같이 줄일 수 있다.// str.indexOf(search) === 2// -1이 아닌 값에 틸드 연산자를 쓰면 0은 안 나옴.// ~str.indexOf(search) === 0은 무조건 안 나옴.// 0이 아닌 숫자는 무조건 true로 형변환 하게 돼있음.if(~str.indexOf(search)) console.log(&#x27;있다&#x27;); 연산 속도를 한번 비교해보자. 12345678910111213141516171819202122232425// 큰 차이는 없다.const iterations = 10000000;const str = &#x27;나는바보입니다&#x27;;let search = &#x27;냐&#x27;;console.time(&quot;===&quot;);for(let i=0; i&lt;iterations; i++)&#123; if(str.indexOf(search) === -1); // ===: 610.604ms&#125;console.timeEnd(&quot;===&quot;);console.time(&quot;!~&quot;);for(let i=0; i&lt;iterations; i++)&#123; if(!~str.indexOf(search)); // !~: 578.663ms&#125;console.timeEnd(&quot;!~&quot;);search = &#x27;바보&#x27;;console.time(&quot;!==&quot;);for(let i=0; i&lt;iterations; i++)&#123; if(str.indexOf(search) !== -1); // !==: 607.395ms&#125;console.timeEnd(&quot;!==&quot;);console.time(&quot;~&quot;);for(let i=0; i&lt;iterations; i++)&#123; if(~str.indexOf(search)); // ~: 619.903ms&#125;console.timeEnd(&quot;~&quot;); ~의 ~(~~)기본적으로 Tilde 연산자는 소수점 아래 비트를 버리는 성질을 가진다. 12console.log(~1.1); // -2console.log(~1); // -2 Not 연산은 기본적으로 두 번 사용하면 원본값을 반환하는 성질을 가진다. 12console.log(!true); // falseconsole.log(!!true); // true 논리 부정 연산인 !은 단순히 true를 false로, false를 true로 역전시킬 뿐이지만비트 논리 부정 연산자인 ~는 조금 다르다.위에서 보다 싶이 소수점 아래 비트를 아예 버려버리는 성질이 있기 때문에이 점을 이용하면 다음과 같은 효과를 낼 수 있다. 123456789101112131415161718// ES6에서 추가된 Math.trunc를 바벨이나 Polyfill을 쓰지 않아도 된다.console.log(Math.trunc(45.6)); // 45console.log(~~45.6); // 45console.log(Math.trunc(-45.6)); // -45console.log(~~-45.6); // -45// 역시 비트 단위의 논리 연산자라서 메소드 호출보다 연산 속도가 훨씬 빠르다.const iterations = 10000000;console.time(&quot;Math.trunc()&quot;);for(let i=0; i&lt;iterations; i++)&#123; Math.trunc(-45.6); // Math.trunc: 124.700ms&#125;console.timeEnd(&quot;Math.trunc()&quot;);console.time(&quot;~~&quot;);for(let i=0; i&lt;iterations; i++)&#123; ~~-45.6; // ~~: 21.944ms&#125;console.timeEnd(&quot;~~&quot;);","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"Operator","slug":"Operator","permalink":"https://perfectacle.github.io/tags/Operator/"}]},{"title":"(Java) 자바의 정석 3판 010일차 - 생성자, this, 멤버 변수 초기화","slug":"Java-study-010day","date":"2017-02-13T13:53:36.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/02/13/Java-study-010day/","link":"","permalink":"https://perfectacle.github.io/2017/02/13/Java-study-010day/","excerpt":"생성자(Constructor)인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드인스턴스 변수 초기화 작업에 주로 사용된다. 생성자는 인스턴스를 생성하지 못한다!나는 생성자로 인스턴스를 생성하고new 연산자가 C언어의 &amp;(주소값 반환) 역할을 하는 줄 알았는데new 연산자가 있어야 인스턴스를 생성하면서 그 주소값을 반환하게 하는 연산자인 것 같다.생성자는 인스턴스 변수 초기화이지 그 이상(인스턴스 생성)도 그 이하도 아닌 것 같다.","text":"생성자(Constructor)인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드인스턴스 변수 초기화 작업에 주로 사용된다. 생성자는 인스턴스를 생성하지 못한다!나는 생성자로 인스턴스를 생성하고new 연산자가 C언어의 &amp;(주소값 반환) 역할을 하는 줄 알았는데new 연산자가 있어야 인스턴스를 생성하면서 그 주소값을 반환하게 하는 연산자인 것 같다.생성자는 인스턴스 변수 초기화이지 그 이상(인스턴스 생성)도 그 이하도 아닌 것 같다. 기본값 생성자1234567class a &#123; // 아무런 생성자가 없으므로 기본 생성자가 생성됨.&#125;class b &#123; // 생성자가 1개 이상 존재하면 기본 생성자는 만들어지지 않음. b(int x) &#123;&#125;&#125; 사용 예제1234567891011121314151617181920class Car &#123; String color; String gearType; int cntDoor; Car() &#123;&#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args)&#123; Car c1 = new Car(); c1.color = &quot;black&quot;; c1.gearType = &quot;manual&quot;; c1.cntDoor = 4; // 위 코드보다 생성자를 이용하면 간결하게 작성이 가능하다. Car c2 = new Car(&quot;red&quot;, &quot;auto&quot;, 4); &#125;&#125; 123456789101112131415161718192021class Car &#123; String color; String gearType; int cntDoor; Car() &#123; // 생성자 내에서 다른 생성자 호출은 첫 줄에서만 가능함. this(&quot;white&quot;, &quot;auto&quot;, 4); // 아래와 같이도 가능하다. // color = &quot;white&quot;; // gearType = &quot;auto&quot;; // cntDoor = 4; &#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args)&#123; Car c1 = new Car(); &#125;&#125; thisJS에서는 this가 호출하는 놈에 따라서 유동적으로 변해서 아주 골치가 아팠는데Java에서는 클래스의 인스턴스만 가리키므로 명확하다.이러한 이유로 static 메소드에서는 this를 쓸 수 없다.static 메소드 호출을 클래스의 인스턴스 생성 이전에도 가능하나this는 클래스의 인스턴스를 가리키므로 클래스의 인스턴스 생성 이후에만 사용 가능하기 때문이다.생성자를 포함한 모든 인스턴스 메소드에는 해당 클래스의 인스턴스를 가리키는this 지역변수가 숨겨진 채로 존재할 뿐이다.static 메소드는 인스턴스 멤버와 관련된 작업을 하지 않는 애들이기 때문에this 지역변수가 존재하지 않을 뿐이다.또한 this에는 인스턴스의 주소가 저장돼있다.즉 this는 참조 변수이고, this()는 생성자이다. 인스턴스의 복사클래스 인스턴스 간의 차이점을 보면static 멤버(변수 메소드)와 인스턴스 메소드는 모두 같다.인스턴스 변수만 서로 다른 값을 가지고 있을 뿐이다.즉, 인스턴스를 복사할 때는 인스턴스 변수만 복사하면 된다. 12345678910111213141516171819202122class Car &#123; String color; String gearType; int cntDoor; Car(Car c) &#123; color = c.color; gearType = c.gearType; cntDoor = c.cntDoor; // 사실 위와 같이 하는 것 보다는 // 기존의 코드를 재활용하는 것이 유지보수 측면에서 좋다. // 미연의 실수도 방지하고... // this(c.color, c.gearType, c.cntDoor); // 위와 같이 써줘야하고 생성자의 제일 첫줄에 적어줘야한다. // 왜냐하면 여태까지 초기화한 내역 이후에 또 다시 생성자로 다시 인스턴스를 초기화할 필요는 없기 때문이다. // Car(c.colr, c.gearType, c.cntDoor); 라고 쓰면 오류가 난다. &#125; Car(String color, String gearType, int cntDoor) &#123; this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125;&#125; 변수의 초기화멤버 변수(클래스 변수, 인스턴스 변수)와 배열은 기본값으로 초기화가 이루어지지만,지역 변수(배열 빼고)는 기본값으로 초기화가 이루어지지 않는다.즉, 멤버 변수와 배열의 초기화는 선택적이지만(초기화를 권장한단다)지역 변수의 초기화는 필수적이다.또한 멤버 변수의 초기화에는 다음 세 가지 방법이 존재한다. 명시적 초기화가장 기본적이면서 간단한 방법이다. 12345class Car &#123; String color = &quot;black&quot;; String gearType = &quot;manual&quot;; int cntDoor = 4;&#125; 초기화 블럭예외 처리나 반복, 조건문 등등의 복잡한 작업을 통해 초기화 해야할 경우이러한 블럭&#123;&#125;을 사용해서 초기화를 진행하면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940class Car &#123; static int cntCar; // 현재 자동차가 몇 대 생성되었는지 static &#123; // 클래스 초기화 블럭 // 프로그램이 실행되면 단 한 번만 실행된다. System.out.println(&quot;이렇게 함수 실행도 된다.&quot;); cntCar = 0; &#125; String color; String gearType; int cntDoor; &#123; // 인스턴스 초기화 블럭 // 인스턴스가 생성될 때마다 실행된다. if(true) &#123; System.out.println(&quot;조건문도 쓸 수 있네?&quot;); &#125; cntCar++; // 생성자마다 중복된 코드를 여기다가 빼면 된다. &#125; Car() &#123; // cntCar++; // 차가 생성됐으므로 1대 추가, 생성자마다 중복된 코드다. color = &quot;white&quot;; gearType = &quot;auto&quot;; cntDoor = 4; &#125; Car(String color, String gearType, int cntDoor) &#123; // cntCar++; // 차가 생성됐으므로 1대 추가, 생성자마다 중복된 코드다. this.color = color; this.gearType = gearType; this.cntDoor = cntDoor; &#125; public static void main(String[] args) &#123; // 이렇게 함수도 실행된다. // 조건문도 쓸 수 있네? Car c = new Car(); // 조건문도 쓸 수 있네? Car c2 = new Car(&quot;black&quot;, &quot;manual&quot;, 3); &#125;&#125; 생성자인스턴스 변수를 초기화하기 위해 쓴다고 위에 설명했으므로자세한 설명은 생략한다. 멤버 변수의 초기화 시기와 순서 클래스 변수의 초기화 시점클래스 변수가 처음 로딩될 때 단 한 번 초기화 된다. 인스턴스 변수의 초기화 시점인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다. 클래스 변수의 초기화 순서기본값 - 명시적 초기화 - 클래스 초기화 블럭 인스턴스 변수의 초기화 순서기본값 - 명시적 초기화 - 인스턴스 초기화 블럭 - 생성자 1234567891011121314151617class InitTest &#123; static int cv = 1; int iv = 1; static &#123; cv = 2; &#125; &#123; iv = 2; &#125; InitTest() &#123; iv = 3; &#125; public static void main(String[] args) &#123; InitTest i = new InitTest(); &#125;&#125; 클래스 초기화인스턴스 초기화기본값명시적 초기화클래스 초기화 블럭기본값명시적 초기화인스턴스 초기화 블럭생성자cv: 0cv: 1cv: 2cv: 2cv: 2cv: 2cv: 2iv: 0iv: 1iv: 2iv: 31234567","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"}]},{"title":"(ES) 똑똑한 논리 연산자","slug":"es-logical-operator","date":"2017-02-13T09:01:37.000Z","updated":"2022-10-30T08:42:16.599Z","comments":true,"path":"2017/02/13/es-logical-operator/","link":"","permalink":"https://perfectacle.github.io/2017/02/13/es-logical-operator/","excerpt":"오늘은 기본값을 위해 많이 쓰던 논리 연산자인||와 &amp;&amp;을 집중 탐구해보았다.우선 위에 있는 녀석들은 어떨 때 쓰는지 알아보자. 사용 사례 네임 스페이스 패턴(~ES5)웹팩을 사용하면 js 파일을 모듈 단위로 사용할 수 있지만,그럴 환경이 안 되면 아래와 같은 우회 방법을 통해서 전역 스코프를 최대한 덜 더럽힐 수 있다.ES6에는 모듈 import, export 기능이 있어서 ~ES5라고 써놓긴 했지만…아직 지원하는 브라우저가 없는 걸로 안다. (17년 2월 기준) 1234567891011// 전역 스코프에는 namespace와 namespace2 모듈만이 존재한다.// func라는 충돌나기 쉬운 네이밍이 전역에 존재하지 않으므로 충돌이 일어나지 않는다.// 즉 네이밍을 고민할 염려가 조금은 줄어들게 된다. 뭐 그 외에 장점도 많지만...// script src 태그를 통해 미리 namespace 모듈을 불러온 경우에는 전역에는 변수 namespace가 존재한다.// || 연산자를 써서 전역에 namespace라는 변수(모듈)가 존재하면 그 모듈을 변수에 할당하고,// 존재하지 않는다면 빈 객체를 변수에 할당하는 패턴이다.const namespace = namespace || &#123;&#125;;namespace.func = function() &#123;&#125;;const namespace2 = namespace2 || &#123;&#125;;namespace2.func = function() &#123;&#125;; 함수의 매개변수 기본값 설정(~ES5)ES6를 통해서는 아래와 같은 게 가능하지만, 1const func = (param1 = 0, param2 = &#x27;&#x27;) =&gt; &#123;&#125;; 바벨을 사용할 수 없고, IE 하위 브라우저까지 크로스 브라우징을 하는 환경에서는아래와 같이 처리해줘야한다. 12345var func = function(param1, param2) &#123; // || 뒤에 오는 애가 기본 값이다. param1 = param1 || 0; param2 = param2 || &#x27;&#x27;;&#125;; 함수의 인자로 기본값 설정위에서는 함수를 선언할 때 매개변수의 기본값을 설정한 경우지만이 경우는 함수를 호출할 때 인자의 기본값을 설정한 경우이다.둘의 차이는 뭐 없다고 봐도 무방하지 않을까…싶다. 12345const obj = &#123;name: &#x27;&#x27;&#125;;const func = age =&gt; console.log(age);// obj 객체에 age라는 키가 없으므로 undefined를 반환한다.// undefined는 형변환 했을 때 false로 간주되므로 기본값인 1이 넘어간다.func(obj.age || 1); // 1 함수의 기본 반환값 설정함수의 반환값이 매개 변수에 따라서 오류를 뿜는 경우가 존재한다.그런 오류를 방지하고자 기본값을 설정하곤 하는데 어떤 경우인지 보자. 123456const cntOccurrences = (regExp, str) =&gt; ( // 정규표현식과 매치되는 결과가 없어서 null을 반환할 경우 // null.length는 오류를 반환하므로 기본값으로 빈 배열을 넣어줘서 오류를 방지함. (str.match(regExp) || []).length);console.log(cntOccurrences(/\\d/g, &#x27;asdf&#x27;)); // 0, 기본값이 없었다면 오류가 난다. 거짓 기본값 설정하기말이 이상한데…만약 해당 변수가 거짓이라면 더 이상의 판별을 하지 않고자 할 때 쓰면 된다. 12345678910111213141516const arr = [1, 2, &#x27;q&#x27;, 4];// 배열이 숫자로만 이루어진 건지 아닌지 판별하는 함수const isNumArr = arr =&gt; &#123; let isNum = true; // 모든 값이 숫자인지 아닌지 판별하는 flag 변수 arr.forEach(v =&gt; &#123; // 만약에 한 번이라도 숫자가 아닌 값이 있었다면 // 그 아래에 있는 구문들을 실행할 필요가 없으므로 // return으로 함수를 조기 종료. if(!isNum) return; // 현재 값이 숫자인지 판단하여 변수에 저장. isNum = isNaN(v); &#125;); return isNum;&#125;console.log(isNumArr(arr)); // false 위와 같은 코드가 있을 때 &amp;&amp; 논리 연산자를 쓰면 코드를 줄일 수 있다.퍼포먼스 측면에서는 맞는지 잘 모르겠다…","text":"오늘은 기본값을 위해 많이 쓰던 논리 연산자인||와 &amp;&amp;을 집중 탐구해보았다.우선 위에 있는 녀석들은 어떨 때 쓰는지 알아보자. 사용 사례 네임 스페이스 패턴(~ES5)웹팩을 사용하면 js 파일을 모듈 단위로 사용할 수 있지만,그럴 환경이 안 되면 아래와 같은 우회 방법을 통해서 전역 스코프를 최대한 덜 더럽힐 수 있다.ES6에는 모듈 import, export 기능이 있어서 ~ES5라고 써놓긴 했지만…아직 지원하는 브라우저가 없는 걸로 안다. (17년 2월 기준) 1234567891011// 전역 스코프에는 namespace와 namespace2 모듈만이 존재한다.// func라는 충돌나기 쉬운 네이밍이 전역에 존재하지 않으므로 충돌이 일어나지 않는다.// 즉 네이밍을 고민할 염려가 조금은 줄어들게 된다. 뭐 그 외에 장점도 많지만...// script src 태그를 통해 미리 namespace 모듈을 불러온 경우에는 전역에는 변수 namespace가 존재한다.// || 연산자를 써서 전역에 namespace라는 변수(모듈)가 존재하면 그 모듈을 변수에 할당하고,// 존재하지 않는다면 빈 객체를 변수에 할당하는 패턴이다.const namespace = namespace || &#123;&#125;;namespace.func = function() &#123;&#125;;const namespace2 = namespace2 || &#123;&#125;;namespace2.func = function() &#123;&#125;; 함수의 매개변수 기본값 설정(~ES5)ES6를 통해서는 아래와 같은 게 가능하지만, 1const func = (param1 = 0, param2 = &#x27;&#x27;) =&gt; &#123;&#125;; 바벨을 사용할 수 없고, IE 하위 브라우저까지 크로스 브라우징을 하는 환경에서는아래와 같이 처리해줘야한다. 12345var func = function(param1, param2) &#123; // || 뒤에 오는 애가 기본 값이다. param1 = param1 || 0; param2 = param2 || &#x27;&#x27;;&#125;; 함수의 인자로 기본값 설정위에서는 함수를 선언할 때 매개변수의 기본값을 설정한 경우지만이 경우는 함수를 호출할 때 인자의 기본값을 설정한 경우이다.둘의 차이는 뭐 없다고 봐도 무방하지 않을까…싶다. 12345const obj = &#123;name: &#x27;&#x27;&#125;;const func = age =&gt; console.log(age);// obj 객체에 age라는 키가 없으므로 undefined를 반환한다.// undefined는 형변환 했을 때 false로 간주되므로 기본값인 1이 넘어간다.func(obj.age || 1); // 1 함수의 기본 반환값 설정함수의 반환값이 매개 변수에 따라서 오류를 뿜는 경우가 존재한다.그런 오류를 방지하고자 기본값을 설정하곤 하는데 어떤 경우인지 보자. 123456const cntOccurrences = (regExp, str) =&gt; ( // 정규표현식과 매치되는 결과가 없어서 null을 반환할 경우 // null.length는 오류를 반환하므로 기본값으로 빈 배열을 넣어줘서 오류를 방지함. (str.match(regExp) || []).length);console.log(cntOccurrences(/\\d/g, &#x27;asdf&#x27;)); // 0, 기본값이 없었다면 오류가 난다. 거짓 기본값 설정하기말이 이상한데…만약 해당 변수가 거짓이라면 더 이상의 판별을 하지 않고자 할 때 쓰면 된다. 12345678910111213141516const arr = [1, 2, &#x27;q&#x27;, 4];// 배열이 숫자로만 이루어진 건지 아닌지 판별하는 함수const isNumArr = arr =&gt; &#123; let isNum = true; // 모든 값이 숫자인지 아닌지 판별하는 flag 변수 arr.forEach(v =&gt; &#123; // 만약에 한 번이라도 숫자가 아닌 값이 있었다면 // 그 아래에 있는 구문들을 실행할 필요가 없으므로 // return으로 함수를 조기 종료. if(!isNum) return; // 현재 값이 숫자인지 판단하여 변수에 저장. isNum = isNaN(v); &#125;); return isNum;&#125;console.log(isNumArr(arr)); // false 위와 같은 코드가 있을 때 &amp;&amp; 논리 연산자를 쓰면 코드를 줄일 수 있다.퍼포먼스 측면에서는 맞는지 잘 모르겠다… 1234567891011121314const arr = [1, 2, &#x27;q&#x27;, 4];// 배열이 숫자로만 이루어진 건지 아닌지 판별하는 함수const isNumArr = arr =&gt; &#123; let isNum = true; // 모든 값이 숫자인지 아닌지 판별하는 flag 변수 // &amp;&amp; 연산은 false인 값을 반환하려는 성질이 있는데 // 둘 다 false이면 앞에 놈을 반환한다. // 만약 앞에 놈이 true이면 무조건 뒤에 놈을 반환한다. // 일단 false 값을 반환하는지 검사를 돌리다가 한 번이라도 false가 나오면 // 뒤에 놈이 true여도 한 번 false인 놈은 계속 false로 만들고 싶을 때 쓰면 된다. arr.forEach(v =&gt; isNum = isNum &amp;&amp; isNaN(v)); return isNum;&#125;console.log(isNumArr(arr)); // false 원리 파악x || y &#x3D;&gt; x가 참이면 무조건 참.즉 x가 참이면 y는 평가(실행)하지도 않음.x &amp;&amp; y &#x3D;&gt; x가 거짓이면 무조건 거짓.즉 x가 거짓이면 y는 평가(실행)하지도 않음.이렇게 좌변에 어떤 값을 넣는가에 따라서 연산 속도에 영향을 미침. 검증이 말이 사실인가 한 번 아래 예제를 실행해보자. 123456789101112131415161718192021222324// 기본적으로 console.log()는 반환값이 없으므로 false로 취급한다.// true || false!console.log(&#x27;a&#x27;) || console.log(&#x27;b&#x27;); // a// true || true!console.log(&#x27;a&#x27;) || !console.log(&#x27;b&#x27;); // a// false || falseconsole.log(&#x27;a&#x27;) || console.log(&#x27;b&#x27;); // a b// false || trueconsole.log(&#x27;a&#x27;) || !console.log(&#x27;b&#x27;); // a b// false &amp;&amp; falseconsole.log(&#x27;a&#x27;) &amp;&amp; console.log(&#x27;b&#x27;); // a// false &amp;&amp; trueconsole.log(&#x27;a&#x27;) &amp;&amp; !console.log(&#x27;b&#x27;); // a// true &amp;&amp; false!console.log(&#x27;a&#x27;) &amp;&amp; console.log(&#x27;b&#x27;); // a b// true &amp;&amp; true!console.log(&#x27;a&#x27;) &amp;&amp; !console.log(&#x27;b&#x27;); // a b 논리 연산자는 좌변에 따라서 우변이 실행되느냐 마느냐가 달려있다.그럼 반환은 어떻게 하는지 살펴보자. 12345678910111213141516let a = 1 || false; // true || falseconsole.log(a); // 1a = &#123;&#125; || []; // true || trueconsole.log(a); // &#123;&#125;a = null || undefined; // false || falseconsole.log(a); // undefineda = 0 || function()&#123;&#125;; // false || trueconsole.log(a); // function()&#123;&#125;a = NaN &amp;&amp; 0; // false &amp;&amp; falseconsole.log(a); // NaNa = &#x27;&#x27; &amp;&amp; new Map(); // false &amp;&amp; trueconsole.log(a); // &#x27;&#x27;a = new Map() &amp;&amp; null; // true &amp;&amp; falseconsole.log(a); // nulla = new Set() &amp;&amp; new Array(); // true &amp;&amp; trueconsole.log(a); // [] 왜 위와 같은 값을 반환하게 됐는지 한번 원리와 연관 지어서 생각해보자. x || y|| 연산자는 좌변이 true이면 우변을 평가, 실행하지 않는다고 했다.즉, 좌변이 true이면 우변은 없는 놈 취급하기 때문에 바로 x가 반환(평가, 실행)되는 것이다.하지만 좌변이 false이면 우변을 평가, 실행하게 된다.이렇게 되면 좌변은 아예 없는 놈 취급하게 된다.즉, 좌변이 false이면 우변의 값은 뭐든간에 상관 없이 항상 우변이 반환(평가와 실행은 말할 것도 없이)된다. x &amp;&amp; y&amp;&amp; 연산자는 좌변이 false이면 우변을 평가, 실행하지 않는다고 했다.즉, 좌변이 false이면 우변은 없는 놈 취급하기 때문에 바로 x가 반환(평가, 실행)되는 것이다.하지만 좌변이 true이면 우변을 평가, 실행하게 된다.이렇게 되면 좌변은 아예 없는 놈 취급하게 된다.즉, 좌변이 true이면 우변의 값은 뭐든간에 상관 없이 항상 우변이 반환(평가와 실행은 말할 것도 없이)된다. 쓸 데 없는 실험12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849for(let i=0; i&lt;10; i++) console.log(i);// 1차 줄임for(let i=0; i&lt;10;) console.log(i++);// 2차 줄임for(let i=0; i&lt;10; console.log(i++));// 3차 줄임 ver 1.// 좌변이 참일 동안 반복함.// 좌변이 참이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변은 무조건 true로 만들어줘야함.for(let i=0; (i&lt;10) &amp;&amp; !console.log(i++););// 3차 줄임 ver 2.// 우변이 참일 동안 반복함.// 좌변이 거짓이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변을 실행시키기 위해 좌변은 무조건 false로 만들어줘야함.for(let i=0; console.log(i++) || (i&lt;10););let i=0;while(i&lt;10) &#123; console.log(i); i++;&#125;// 1차 줄임i=0;while(i&lt;10) &#123; console.log(i++);&#125;// 2차 줄임 ver 1.i=0;// 좌변이 참일 동안 반복함.// 좌변이 참이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변은 무조건 true로 만들어줘야함.while((i&lt;10) &amp;&amp; !console.log(i++));// 2차 줄임 ver 2.i=0;// 우변이 참일 동안 반복함.// 좌변이 거짓이면 우변은 무조건 실행함.// 우변을 실행한다는 것은 우변을 반환한다는 의미이므로// 우변을 실행시키기 위해 좌변은 무조건 false로 만들어줘야함.while(console.log(i++) || (i&lt;10));","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"Operator","slug":"Operator","permalink":"https://perfectacle.github.io/tags/Operator/"}]},{"title":"(ES5) 배열의 순회 메소드에서 break 기능 구현하기","slug":"ES5-array-loop-method-break","date":"2017-02-12T22:51:05.000Z","updated":"2022-10-30T08:42:16.075Z","comments":true,"path":"2017/02/12/ES5-array-loop-method-break/","link":"","permalink":"https://perfectacle.github.io/2017/02/12/ES5-array-loop-method-break/","excerpt":"이 글은 Outsider 님의 블로그 포스트 중forEach에 break문 대신 some 사용하기를 보고 큰 감명을 받아내가 이해한 내용을 토대로 정리해 본 글이다. for loopfor 반복문을 써서 배열을 순회하는 것은 할당, 프로퍼티 참조, 조건 분기 등등의 잡다한 일을 해야한다.이러한 잡다한 일을 실수로 코딩을 잘못하면 원하지 않는 결과가 나오고, 귀찮음이 몰려오기 마련이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum = arr =&gt; &#123; let isNum = true; // 프로그래머가 실수로 let i = 1;이라고 초기화한다면? // 실수로 i&lt;arr.length+1; 이라고 조건식을 잘못 입력한다면? // i+=2; 라고 증감식을 잘못 입력한다면? // arr[i+1]로 잘못 참조한다면? // 이렇게 일일이 초기화, 조건식 지정, 증감식 지정 등등을 일일이 해줘야하므로 귀찮다. for(let i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]); if(!isNaN(arr[i])) &#123; // 숫자라면 // 아래 있는 코드는 실행할 필요 없이 다음 요소를 검사해야함. // 즉 다음 반복문을 실행. continue; &#125; // 숫자가 아니라면 isNum = false; // 바로 반복문을 종료해야함. break; &#125; return isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum(arr));// 사실은 아래와 같이 break와 continue를 쓸 필요도 없는 예제긴 하다.const isArrNum2 = arr =&gt; &#123; for(let i=0; i&lt;arr.length; i++) &#123; if(isNaN(arr[i])) &#123; // 숫자가 아니라면 // 반복문 탈출이고 나발이고 return으로 바로 함수를 조기 종료 시키면서 // false를 반환하게 하면됨. return false; &#125; &#125; // 반복문이 무사히 끝났으면 모든 게 숫자였다고 판단하여 true를 반환. return true;&#125;;","text":"이 글은 Outsider 님의 블로그 포스트 중forEach에 break문 대신 some 사용하기를 보고 큰 감명을 받아내가 이해한 내용을 토대로 정리해 본 글이다. for loopfor 반복문을 써서 배열을 순회하는 것은 할당, 프로퍼티 참조, 조건 분기 등등의 잡다한 일을 해야한다.이러한 잡다한 일을 실수로 코딩을 잘못하면 원하지 않는 결과가 나오고, 귀찮음이 몰려오기 마련이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum = arr =&gt; &#123; let isNum = true; // 프로그래머가 실수로 let i = 1;이라고 초기화한다면? // 실수로 i&lt;arr.length+1; 이라고 조건식을 잘못 입력한다면? // i+=2; 라고 증감식을 잘못 입력한다면? // arr[i+1]로 잘못 참조한다면? // 이렇게 일일이 초기화, 조건식 지정, 증감식 지정 등등을 일일이 해줘야하므로 귀찮다. for(let i=0; i&lt;arr.length; i++) &#123; console.log(arr[i]); if(!isNaN(arr[i])) &#123; // 숫자라면 // 아래 있는 코드는 실행할 필요 없이 다음 요소를 검사해야함. // 즉 다음 반복문을 실행. continue; &#125; // 숫자가 아니라면 isNum = false; // 바로 반복문을 종료해야함. break; &#125; return isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum(arr));// 사실은 아래와 같이 break와 continue를 쓸 필요도 없는 예제긴 하다.const isArrNum2 = arr =&gt; &#123; for(let i=0; i&lt;arr.length; i++) &#123; if(isNaN(arr[i])) &#123; // 숫자가 아니라면 // 반복문 탈출이고 나발이고 return으로 바로 함수를 조기 종료 시키면서 // false를 반환하게 하면됨. return false; &#125; &#125; // 반복문이 무사히 끝났으면 모든 게 숫자였다고 판단하여 true를 반환. return true;&#125;; continue 기능만 있는 배열 순회 메소드(ES5, IE9+)따라서 그런 점을 해소하고자 ES5(IE9+)에서는 배열의 순환 메소드인forEach, reduce, map, filter 등등이 추가됐다.하지만!이 메소드는 continue는 지원하지만 break는 지원하지 않는다.또한 continue 기능은 continue 대신에 함수를 종료 시키는return 키워드를 사용하며 반환하는 값은 중요치 않다.(continue 시키는 데에 있어서는)return 키워드로 함수를 조기 종료 시켜도, 현재 요소에 대한 콜백 함수(continue)를 종료 시킨 것이지모든 요소에 대한 콜백 함수(break)를 종료시켜버리는 것이 아니기 때문에 바로 다음 콜백함수의 실행이 일어난다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum3 = arr =&gt; &#123; let isNum = true; // forEach, map, reduce, filter 메소드가 // continue만 지원하고, break를 지원하지 않아 콘솔창을 보면 비효율적임을 보여준다. arr.forEach(v =&gt; &#123; // 배열 중에 숫자가 아닌 값이 있어도 배열의 요소 끝까지 콜백 함수가 돈다. console.log(v); // forEach, map, filter, reduce에서 return은 continue와 같다. // 반환값은 중요치 않고, break를 지원하지 않는다. // return으로 함수를 종료 해도 해당 인덱스의 콜백함수이기 때문에 // 다음 요소의 콜백 함수가 돈다. // 배열 요소 중 숫자가 아닌 값이 있었다면 그 아래 값들은 실행할 필요가 없어짐. if(!isNum) return; // 숫자가 아니라면 if(isNaN(v)) isNum = false; &#125;); return isNum;&#125;;// 0// 1// 2// 3// q// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// 5// 6// 3.3// falseconsole.log(isArrNum3(arr));// 사실은 return으로 continue 시킬 것도 없는 예제이다.const isArrNum4 = arr =&gt; &#123; let isNum = true; arr.forEach(v =&gt; isNum = isNum &amp;&amp; !isNaN(v)); return isNum;&#125;; break 기능까지 있는 배열 순회 메소드(ES5, IE9+) falsy values: boolean으로 형변환 했을 때 false로 취급되는 값들 false, 0, ‘’, null, undefined, NaN truthy values: boolean으로 형변환 했을 때 true로 취급되는 값들 falsy value가 아닌 모든 값들. some콜백함수가 반환하는 값이 하나라도 true인지 파악하는 메소드하나라도 truthy value를 반환하는 순간 콜백함수를 멈춤.12345678910111213141516171819202122232425262728293031const arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum5 = arr =&gt; &#123; const isNum = arr.some(v =&gt; &#123; console.log(v); if(isNaN(v)) &#123; // 숫자가 아니라면 // some에서 truthy value를 반환하면 break와 동일함. return true; &#125; // some에서 falsy value를 반환하면 continue와 동일함. return false; &#125;); // 숫자가 아니라면 some은 true를 반환하므로 not 연산자(!)를 써서 반환해줘야함. return !isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum5(arr));// 사실 아래와 같이 줄여쓸 수 있는 예제이다.const isArrNum6 = arr =&gt; !arr.some(v =&gt; isNaN(v)); every콜백함수가 반환하는 값이 모두 true인지 파악하는 메소드하나라도 falsy value를 반환하는 순간 콜백함수를 멈춤.123456789101112131415161718192021222324252627282930const arr = [ 0, 1, 2, 3, &#x27;q&#x27;, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3, 5, 6, 3.3];// 배열이 숫자로만 이루어져있는지 파악하는 함수const isArrNum7 = arr =&gt; &#123; const isNum = arr.every(v =&gt; &#123; console.log(v); if(isNaN(v)) &#123; // 숫자가 아니라면 // every에서 falsy value를 반환하면 break와 동일함. return false; &#125; // every에서 truthy value를 반환하면 continue와 동일함. return true; &#125;); return isNum;&#125;;// 0// 1// 2// 3// q// falseconsole.log(isArrNum7(arr));// 사실 아래와 같이 줄여쓸 수 있다.const isArrNum8 = arr =&gt; arr.every(v =&gt; !isNaN(v));","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"Array","slug":"Array","permalink":"https://perfectacle.github.io/tags/Array/"},{"name":"ES5","slug":"ES5","permalink":"https://perfectacle.github.io/tags/ES5/"}]},{"title":"양 보다는 꾸준히","slug":"blahblah01","date":"2017-02-11T15:19:18.000Z","updated":"2022-10-30T08:42:16.183Z","comments":true,"path":"2017/02/11/blahblah01/","link":"","permalink":"https://perfectacle.github.io/2017/02/11/blahblah01/","excerpt":"자바를 공부하면서 느낀 것이다. 초반엔 내가 아는 내용이니 하루에 한 챕터씩 나가야지.. 하지만 내가 아는 게 다가 아니었다.다 안다고 생각했지만 그 속에는 모르는 내용들이 너무 많았다.하루 한 챕터를 정리해가면서 연습문제까지 풀어가기에는 정말 힘들었다.초반에는 재밌어서 그래도 거의 한 챕터씩 나갔다.하지만 가면 갈 수록 그 양에 질리고, 시간은 더욱 오래 걸렸다.공부를 하는 것도 매일 매일이 아니라 그냥 생각날 때, 시간 날 때만 했다.오늘 공부를 하다보니 이제는 지쳐서 2시간이 되자 책장을 넘기면서 이 챕터는 도대체 언제 끝나나…다음 챕터는 얼마나 될라나…","text":"자바를 공부하면서 느낀 것이다. 초반엔 내가 아는 내용이니 하루에 한 챕터씩 나가야지.. 하지만 내가 아는 게 다가 아니었다.다 안다고 생각했지만 그 속에는 모르는 내용들이 너무 많았다.하루 한 챕터를 정리해가면서 연습문제까지 풀어가기에는 정말 힘들었다.초반에는 재밌어서 그래도 거의 한 챕터씩 나갔다.하지만 가면 갈 수록 그 양에 질리고, 시간은 더욱 오래 걸렸다.공부를 하는 것도 매일 매일이 아니라 그냥 생각날 때, 시간 날 때만 했다.오늘 공부를 하다보니 이제는 지쳐서 2시간이 되자 책장을 넘기면서 이 챕터는 도대체 언제 끝나나…다음 챕터는 얼마나 될라나… 라면서 멘붕에 빠지게 되었다.초반에 자바 공부를 할 때는 하루에 5~6시간씩 몰입을 했었지만 지쳤다.가면 갈 수록 집중해지는 시간이 짧아지는 것을 느꼈다.하루에 한 공부에만 몰두할 게 아니라 체계적으로 나눠야할 것 같다.하루에 다 끝낸다는 생각보다는 꾸준히 해서 끝까지 마무리할 생각을 해야겠다.하루에 조금이라도 하는 습관을 길러야겠다.내가 지쳐서 못해먹겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"https://perfectacle.github.io/tags/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}]},{"title":"(Java) 자바의 정석 3판 009일차 - 재귀함수, 클래스 설계, 오버로딩, 가변 인자","slug":"Java-study-009day","date":"2017-02-11T13:07:43.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/02/11/Java-study-009day/","link":"","permalink":"https://perfectacle.github.io/2017/02/11/Java-study-009day/","excerpt":"어제는 친구들이랑 노느라 공부를 조금 밖에 못 했다.그만큼 오늘은 좀 빡시게 달려야겠다. 재귀함수(recursive function)함수 내에서 자기 자신을 호출하는 것이다.배열의 요소를 모두 더하는 메소드는 아래와 같이 작성이 가능하다. 1234567891011121314class test &#123; static int sumArr(int[] arr) &#123; int sum = 0; for(int num : arr) &#123; sum += num; &#125; return sum; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1, 2, 4, 5 , 8, 9&#125;; int sum = sumArr(arr); System.out.println(sum); &#125;&#125;","text":"어제는 친구들이랑 노느라 공부를 조금 밖에 못 했다.그만큼 오늘은 좀 빡시게 달려야겠다. 재귀함수(recursive function)함수 내에서 자기 자신을 호출하는 것이다.배열의 요소를 모두 더하는 메소드는 아래와 같이 작성이 가능하다. 1234567891011121314class test &#123; static int sumArr(int[] arr) &#123; int sum = 0; for(int num : arr) &#123; sum += num; &#125; return sum; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1, 2, 4, 5 , 8, 9&#125;; int sum = sumArr(arr); System.out.println(sum); &#125;&#125; 이걸 재귀함수로 바꾸면 아래와 같다. 1234567891011121314class test &#123; static int sumArr(int[] arr, int i) &#123; if(i &lt; arr.length) &#123; // 재귀함수를 호출하는 조건 return arr[i] + sumArr(arr, i+1); &#125; // 재귀함수를 탈출하는 조건 return 0; &#125; public static void main(String[] args) &#123; int arr[] = &#123;1, 2, 4, 5 , 8, 9&#125;; int sum = sumArr(arr, 0); System.out.println(sum); &#125;&#125; 위에서 보듯이 재귀 함수에서는 두 가지 조건이 중요하다. 호출 조건이게 없으면 재귀함수를 호출하지 않을 것이고, 재귀함수라 불릴 수가 없다. 탈출 조건이게 없으면 stack에 무한정 재귀함수가 쌓이게 될 것이다.이렇게 되면 가용 가능한 메모리 영역을 넘어설 것이다.이 때 stack overflow가 발생하는 것이다.아래와 같이 말이다. 123456class test &#123; public static void main(String[] args) &#123; // Exception in thread &quot;main&quot; java.lang.StackOverflowError main(null); &#125;&#125; for문에 비해 재귀함수는 stack의 많은 공간을 차지하게 된다.또한 매개 변수 복사 및 복귀할 주소 저장 등등의 추가적인 작업이 발생해서 더 느리다.그럼에도 불구하고 재귀함수가 존재하는 이유는 논리적인 간결함이 있기 때문이다.즉 가독성이 좋아져서 유지 보수 함에 있어서 한결 용이해진다는 소리이다.반복문을 썼을 때 코드가 복잡해져서 한 눈에 파악하기 어려운 경우,재귀함수를 한번 고려해보면 좋을 것 같다.하지만 재귀함수는 퍼포먼스가 안 좋아지고, 엄청난 반복을 통해 호출하는 경우에는stack overflow 등등 고려해야할 내용이 있다는 점은 유념해서 써야한다. 클래스 설계하기멤버 변수(클래스 변수 &amp; 인스턴스 변수) 설계하기 모든 인스턴스에 공통적으로 사용해야하는 변수에는 static 키워드를 붙여 클래스 변수로 만들어준다.인스턴스가 생성되기 전에 프로그램이 시작되면 자동적으로 메모리의 Method Area(Data) 영역에 적재된다.모든 인스턴스가 동일한 주소를 참조하므로 값을 공유하게 된다.공통적으로 사용하려면 값을 공유해야하므로 클래스 변수로 만들어줘야한다.프로그램이 종료될 때까지 메모리에 계속 적재돼있는다.클래스 이름.변수와 같이 사용한다. 인스턴스 마다 따로 사용해야하는 변수에는 static을 붙이지 않아 인스턴스 변수로 만들어준다.프로그램이 시작되어도 메모리에 자동적으로 적재되지 않는다.new 연산자와 생성자 호출로 인스턴스를 생성해야 비로소 메모리의 Heap 영역에 적재된다.각각의 인스턴스가 다른 주소를 참조하므로 개별적으로 값을 가지게 된다.참조 관계가 끊기는 순간 가비지 컬렉터가 메모리에서 자동적으로 회수해간다.(해제한다.)인스턴스 이름.변수와 같이 사용한다. 메소드(멤버 함수, 클래스 메소드 &amp; 인스턴스 메소드) 설계하기 인스턴스 변수를 사용하지 않는 메소드는 static 키워드를 붙여 클래스 메소드로 만드는 게 일반적이다.인스턴스가 생성되기 전에 프로그램이 시작되면 자동적으로 메모리의 Method Area(Data) 영역에 적재된다.하지만 인스턴스 변수가 메소드 내에 존재한다면,존재하지 않는 변수(메모리 공간 상에 할당되지 않은 변수)를참조해야하는 경우가 생기게 되므로 오류를 유발하게 된다.또한 static 키워드를 붙이지 않으면 실행 시 호출되어야할메소드를 찾는 과정이 추가적으로 필요해 퍼포먼스 적으로 안 좋다.프로그램이 종료될 때까지 메모리에 계속 적재돼있는다.클래스 이름.메소드()와 같이 사용한다. 인스턴스 변수를 사용하는 경우에는 static 키워드를 붙이지 않아 인스턴스 메소드로 만들어야한다.프로그램이 시작되어도 메모리에 자동적으로 적재되지 않는다.생성자 함수를 호출해서 인스턴스를 생성해야 비로소 메모리의 Heap 영역에 적재된다.인스턴스 변수는 인스턴스가 생성되어야지만 메모리에 적재되고, 비로소 사용할 수 있게 된다.이런 인스턴스 변수를 쓰려면 인스턴스가 생성된 이후이므로,메소드도 인스턴스 변수가 생성된 이후에 사용이 가능해지는 것이므로클래스 메소드(인스턴스 변수가 생성되기 이전에 생성됨)로 선언하면 안된다.참조 관계가 끊기는 순간 가비지 컬렉터가 메모리에서 자동적으로 회수해간다.(해제한다.)인스턴스 이름.메소드()와 같이 사용한다. 123456789101112131415161718192021222324class test &#123; // 멤버 변수 중 인스턴스 변수 int a=3, b=2; // 인스턴스 변수를 쓰므로 인스턴스 메소드로 만들어줌. int add() &#123; return a+b; // 인스턴스 변수 &#125; // 인스턴스 변수를 쓰지 않으므로 클래스 메소드로 만들어줌. static int add(int a, int b) &#123; // 매개 변수(Parameter) a, b return a + b; // 지역 변수 &#125; public static void main(String[] args) &#123; // 클래스 변수(변수, 메소드)는 프로그램이 실행되는 순간 자동적으로 메모리의 Method Area(Data)에 할당된다. // 같은 클래스 내에 존재하는 클래스 변수(변수, 메소드)는 클래스 이름 생략이 가능하다. System.out.println(add(1, 2)); // 3, 인자(Argument)로 1과 2를 넘겨준 클래스 메소드 // 인스턴스 변수(변수, 메소드)는 생성자를 통해 인스턴스를 생성하기 전까지 메모리의 Heap에 할당되지 않는다. test t = new test(); System.out.println(t.add()); // 5, 인스턴스 변수인 t.a와 t.b를 이용한 인스턴스 메소드 &#125;&#125; 1234567891011121314151617181920212223class test &#123; // 멤버 변수 중 인스턴스 변수 int a=3, b=2; // static int c = a; // 에러 // static 컨텍스트에서는 인스턴스 멤버를 사용하려면 먼저 인스턴스를 생성해줘야함. static int c = new test().a; int add() &#123; // 인스턴스 컨텍스트에서는 따로 처리해주지 않아도 됨. // 인스턴스 멤버가 존재한다는 것은 // 클래스 멤버도 존재한다는 가정이기 때문. return a+b+c; &#125; static int add2() &#123; // return c + a + b; // 에러 // static 컨텍스트에서는 인스턴스 멤버를 사용하려면 먼저 인스턴스를 생성해줘야함. // 클래스 멤버가 존재해도 인스턴스 멤버가 존재하지 않을 수도 있기 때문임. // 이럴 경우에는 클래스 메소드가 아닌 인스턴스 메소드를 권장하는 바임. test t = new test(); return t.a + t.b + c; &#125;&#125; 메소드 오버로딩(overloading)과 오버라이딩(overriding)두 개가 너무 헷갈려서 간단하게 정리한다. 오버 라이딩ride: 타다부모 클래스로 올라탄다라는 생각으로 외웠다.상속받은 부모 클래스의 메소드를 재정의하는 것. 오버 로딩다형성, 메소드 이름이 똑같아도매개 변수의 타입, 매개 변수의 갯수에 따라호출되는 메소드가 다른 것을 의미.매개 변수의 이름과 반환 타입은 중요치 않다.load: 적재하다원래는 하나의 메소드 이름에는 하나의 메소드만 적재해야하는데그걸 초과한 하나의 메소드 이름에 여러 메소드를 적재하기 때문에이런 이름이 붙은 게 아닐까 싶다.이는 동적 타입 언어인 JS에는 없는 기능이다. 가변 인자(variable arguments)정적 타입 언어인 Java에서는 매개 변수의 갯수가 고정적이었다.동적 타입 언어인 JS를 먼저 접한 나로선 매우 빡빡하다고 생각이 들었다.하지만 Java5부터는 동적으로 지정해줄 수 있게 됐다. 1234567891011121314class test &#123; static String concatenate(String str, String str2) &#123; return str + str2; &#125; static String concatenate(String str, String str2, String str3) &#123; return str + str2 + str3; &#125; static String concatenate(String str, String str2, String str3, String str4) &#123; return str + str2 + str3 + str4; &#125; // 매개변수가 n개인 메소드를 계속 오버로딩할 것인가?&#125; 가변인자를 쓰면 아래와 같이 바꿀 수 있다. 123456789class test &#123; static String concatenate(String ...str) &#123; String result = &quot;&quot;; for(String arg : str) &#123; result += arg; &#125; return result; &#125;&#125; 가변인자는 내부적으로 배열을 생성한다.이런 비효율이 존재하므로 꼭 필요한 경우에만 가변 인자를 사용해야한다. 123456789101112131415161718192021222324252627282930313233class test &#123; // 가변 인자는 제일 나중에 선언해야 한다. static String concatenate(String ...str, int num) &#123; // 에러 String result = &quot;&quot;; for(String arg : str) &#123; result += arg; &#125; return result; &#125; static String concatenate(String string, String... str) &#123; String result = &quot;&quot;; for(String arg : str) &#123; result += arg; &#125; return result; &#125; static String concatenate(String... str) &#123; String result = &quot;&quot;; for(String arg : str) &#123; result += arg; &#125; return result; &#125; public static void main(String[] args) &#123; // String concatenate(String string, String... str) // String concatenate(String... str) // 둘 중에 뭘 호출해야할지 모르므로 컴파일 에러 System.out.println(concatenate(&quot;2&quot;, &quot;aass&quot;)); &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"}]},{"title":"(Java) 자바의 정석 3판 008일차 - JVM의 메모리 구조","slug":"Java-study-008day","date":"2017-02-10T10:20:35.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/02/10/Java-study-008day/","link":"","permalink":"https://perfectacle.github.io/2017/02/10/Java-study-008day/","excerpt":"","text":"JVM의 메모리 구조이 글을 보기 전에 아래 글을 참조하면 더 이해가 잘 간다.(C&#x2F;C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) Method Area클래스 데이터가 들어간다.즉 클래스 변수(static 변수)가 들어간다.프로그램 실행되자마자 적재되고 끝날 때까지 사라지지 않는 놈이다.기본적인 메모리 영역의 Data 영역에 해당한다. Call Stack메소드가 호출되면 해당 메소드를 콜스택에 push한다.제어권이 이전에 실행 중이던 메소드에서 Stack의 top에 위치한 메소드로 이동하게 된다.이전에 실행 중이던 메소드는 대기 상태가 되고 호출한 메소드의 작업이 끝날 때까지 대기하게 된다.그러면서 해당 메소드 만의 스코프를 생성한다.별도의 스코프를 생성하므로 지역 변수가 이곳에 존재한다.해당 메소드 아래 있는 메소드가 해당 메소드를 호출한 메소드가 된다.JVM은 프로그램이 실행되면 일단 main 메소드를 찾아 콜 스택에 push하게 된다.그리고 메소드의 작업에 필요한 메모리 공간을 콜스택이 제공해주고,작업을 마치게 되면 할당 되었던 메모리 공간은 반한된다.기본적인 메모리 영역의 Stack에 해당한다. Heap클래스의 인스턴스가 생성되는 공간.인스턴스 변수들이 들어간다.new 연산자를 쓰므로 동적 할당이라고 할 수 있다.메모리 상에서 해제는 가비지 컬렉터가 자동으로 수행한다.기본적인 메모리 영역의 Heap에 해당한다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"}]},{"title":"(C++) 참고용 정리 - 클래스의 두 가지 생성 방법","slug":"Cpp-ref-002","date":"2017-02-09T15:55:22.000Z","updated":"2022-10-30T08:42:16.071Z","comments":true,"path":"2017/02/09/Cpp-ref-002/","link":"","permalink":"https://perfectacle.github.io/2017/02/09/Cpp-ref-002/","excerpt":"학교에서 클래스를 할당하는 한 가지 방법 밖에 배우지 않았다.동적 할당에 대해서 배우지 않았기 때문인데…왜 학교에서는 이런 심도있는 내용들은 1도 가르쳐주지 않는 걸까?학교에서 이런 내용까지 알려준다면 좀 더 재미나게 수업에 임할 수 있을텐데…정말 안타깝다 ㅠㅠ이해를 돕기 위해 아래 포스트를 한 번 보는 걸 추천한다.(C&#x2F;C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) 학교에서 배운 방법(정적 할당)123456789101112131415161718#include &lt;iostream&gt;using namespace std; class test &#123;private: int num;public: void setNum(int n) &#123;num = n;&#125; int getNum() &#123;return num;&#125;&#125;; int main() &#123; test t; t.setNum(22); cout &lt;&lt; t.getNum() &lt;&lt; endl; cout &lt;&lt; t; // 에러, t가 가지고 있는 순수 값은 못 본다. 왜일까? ㅠㅠ return 0;&#125; test 클래스의 인스턴스인 t는 스택 영역에 올라가게 된다.사실 자바를 먼저 배우고 C++을 그 이후에 배워서…자바에서는 저렇게 선언하면 참조변수만 선언한 격이라클래스의 인스턴스가 생성되지 않아서 할 수 있는 게 1도 없었는데…자바에서는 클래스의 정적 할당이 없어서 그랬나 보다.","text":"학교에서 클래스를 할당하는 한 가지 방법 밖에 배우지 않았다.동적 할당에 대해서 배우지 않았기 때문인데…왜 학교에서는 이런 심도있는 내용들은 1도 가르쳐주지 않는 걸까?학교에서 이런 내용까지 알려준다면 좀 더 재미나게 수업에 임할 수 있을텐데…정말 안타깝다 ㅠㅠ이해를 돕기 위해 아래 포스트를 한 번 보는 걸 추천한다.(C&#x2F;C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) 학교에서 배운 방법(정적 할당)123456789101112131415161718#include &lt;iostream&gt;using namespace std; class test &#123;private: int num;public: void setNum(int n) &#123;num = n;&#125; int getNum() &#123;return num;&#125;&#125;; int main() &#123; test t; t.setNum(22); cout &lt;&lt; t.getNum() &lt;&lt; endl; cout &lt;&lt; t; // 에러, t가 가지고 있는 순수 값은 못 본다. 왜일까? ㅠㅠ return 0;&#125; test 클래스의 인스턴스인 t는 스택 영역에 올라가게 된다.사실 자바를 먼저 배우고 C++을 그 이후에 배워서…자바에서는 저렇게 선언하면 참조변수만 선언한 격이라클래스의 인스턴스가 생성되지 않아서 할 수 있는 게 1도 없었는데…자바에서는 클래스의 정적 할당이 없어서 그랬나 보다. 학교에서 배우지 않은 방법(동적 할당)1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class test &#123;private: int num;public: void setNum(int n) &#123;num = n;&#125; int getNum() &#123;return num;&#125;&#125;;int main() &#123; test *t; t = new test(); t -&gt; setNum(22); cout &lt;&lt; t -&gt; getNum() &lt;&lt; endl; // 22 cout &lt;&lt; t; // 주소값이 나옴. delete t; return 0;&#125; test 클래스의 인스턴스인 t는 힙 영역에 올라가게 된다.즉 메모리 동적 할당을 하게 된 것이고,delete 해주기 전까지 메모리에서 해제되지 않는다. 동적 메모리 할당의 과정위 코드는 포인터, 자바와도 관련이 있다.어떻게 메모리에 할당되는지 과정을 지켜보자.1.test *t; 변수의 타입을 test로 지정했다.즉 내가 참조해서 쓸 변수의 타입은 test이다.하지만 test라는 변수 타입은 없으므로 참조 타입이라고 봐야할 것 같다.그 참조 타입은 클래스의 이름인 것 같다. 2.t = new test();를 두 가지 관점에서 나눠 보자. t &#x3D; new test(); t = new test(); 즉 new는 &amp;와 같은 역할을 하는 녀석인 것 같다.기본형 변수 앞에는 &amp;가, 참조형 변수 앞에는 new 가 붙는 것 같다.이는 포인터에 변수의 주소를 할당하는 과정과 매우 유사한 것 같다.메모리 공간에 포인터 변수와 실제 변수 두 공간이 필요하게 되고,클래스의 동적 할당에서도 마찬가지로 포인터 변수와 클래스의 인스턴스 두 공간이 필요하기 때문이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"https://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"https://perfectacle.github.io/tags/Static/"}]},{"title":"(C/C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap)","slug":"C-ref-004","date":"2017-02-09T14:31:26.000Z","updated":"2022-10-30T08:42:16.063Z","comments":true,"path":"2017/02/09/C-ref-004/","link":"","permalink":"https://perfectacle.github.io/2017/02/09/C-ref-004/","excerpt":"프로그램을 실행하게 되면 OS는 메모리(RAM)에 공간을 할당해준다.할당해주는 메모리 공간은 4가지(Code, Data, Stack, Heap)으로 나눌 수 있다. 이미지 출처: C언어의 메모리 구조 Code","text":"프로그램을 실행하게 되면 OS는 메모리(RAM)에 공간을 할당해준다.할당해주는 메모리 공간은 4가지(Code, Data, Stack, Heap)으로 나눌 수 있다. 이미지 출처: C언어의 메모리 구조 Code우리가 작성한 소스 코드가 들어간다.또한 상수도 여기에 들어간다고 한다.물론 컴파일 된 기계어가 들어갈 것이다.프로그램이 끝날 때까지 메모리에 계속 적재돼있는 놈들이다. Data전역 변수, static 변수 등등이 저장된다.프로그램이 끝날 때까지 메모리에 계속 적재돼있는 놈들이다. Stack지역 변수, 매개 변수, 리턴 값 등등이 저장된다.함수 호출 시 생성되고, 함수가 종료되면 시스템에 반환된다.프로그램이 자동으로 사용하는 임시 메모리 영역이다.또한 이름에서 보듯이 Stack 자료구조를 이용해 구현한 것 같다.컴파일 시에 크기가 결정된다. Heap프로그래머가 할당&#x2F;해제하는 메모리 공간이다.malloc() 또는 new 연산자를 통해 할당하고,free() 또는 delete 연산자를 통해서만 해제가 가능하다.Java에서는 가비지 컬렉터가 자동으로 해제하는 것 같기도 하다.이 공간에 메모리 할당하는 것을 동적 할당(Dynamic Memory Allocation)이라고도 부른다.런타임 시에 크기가 결정된다. Stack 영역이 크면 클 수록 Heap 영역이 작아지고, Heap 영역이 크면 클 수록 Stack 영역이 작아진다. 그럼 Heap 영역, 동적 할당은 왜 필요한 것일까? 메모리를 효율적으로 관리할 수 있기 때문이지 않을까?임베디드 시스템을 개발하다보면 하드웨어 크기가 매우 작은 경우가 많다.하드웨어 크기가 작다는 것은 메모리의 용량도 작음을 의미한다.뭐 메모리 용량이 클 수도 있지만, 가격이 매우 비싸질 것이다.여튼 그러한 작은 메모리 공간에 프로그래머가 메모리 관리의 달인이라면…컴파일러가 자동으로 할당해주는 것보다 더 효율적인 관리가 가능하지 않을까? 배열의 길이를 사용자가 직접 정하고 싶을 경우이는 매우 단적인 예이고, 실용성이 있는지는 잘 모르겠지만…Heap 영역의 존재 이유를 설명하는 좋은 예가 될 것 같아서 가져와봤다.소스 코드 출처: C언어의 메모리 구조 123456789101112131415#include &lt;stdio.h&gt;int main() &#123; // 정상적인 배열 선언 int arr[10]; // 비정상적인 배열 선언 int i = 0; scanf(&quot;%d&quot;, &amp;i); int arr2[i]; printf(&quot;\\nsizeof(i): %d&quot;, sizeof(i)); // 4 printf(&quot;sizeof(arr): %d&quot;, sizeof(arr)); // 40 printf(&quot;\\nsizeof(arr2): %d&quot;, sizeof(arr2)); // 뭐라 꼬집어 말할 수 있을까? return 0;&#125; main 함수 내부에 있는 변수 i와 arr, arr2는 스택 영역에 올라간다.함수 내부에서 쓰인 지역 변수이기 때문이다.이는 컴파일 시에 그 크기가 결정된다.i의 크기는 int이기 때문에 4byte,arr의 크기는 int형 변수 10개가 들어간 것이기 때문에sizeof(int) * 10 &#x3D; 40byte.arr2의 크기는…?stack 영역에 올라가는 arr2의 크기가 사용자의 입력에 따라서 유동적으로 바뀌게 된다.이는 정상적인 메모리 할당이라고 볼 수 없다.컴파일 시에 메모리의 크기가 결정되는 stack 영역에 올라갔음에도 불구하고,런타임 시에 메모리의 크기가 결정되기 때문에 이는 힙 영역에 올리는 게 맞다고 본다.아직 동적 할당을 제대로 배우지 않았기 때문에 이 이상의 설명과 이해는 힘들 것 같다. 참고 링크 C언어의 메모리 구조 메모리 영역(code, data, stack, heap) 동적할당과 정적할당 [C&#x2F;C++] 데이터, 스택(Stack), 힙(Heap) 영역 메모리 영역 (Code, Data, BSS, HEAP, Stack), Little Endian, Stack의 이해","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"https://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"https://perfectacle.github.io/tags/Static/"}]},{"title":"(Java) 자바의 정석 3판 007일차 - OOP(객체, 클래스, 인스턴스), new 연산자, 참조 타입, 클래스 변수","slug":"Java-study-007day","date":"2017-02-09T13:53:40.000Z","updated":"2022-10-30T08:42:16.095Z","comments":true,"path":"2017/02/09/Java-study-007day/","link":"","permalink":"https://perfectacle.github.io/2017/02/09/Java-study-007day/","excerpt":"드디어 오늘부터 객체지향 프로그래밍(OOP, Object Oriented Programming) 파트를 나가기 시작했다.이전까지는 다른 언어에도 대부분 있는 개념이었는데,이제부터는 자바의 특성을 배울 차례인 것 같다.객체 지향 언어는 C++&#x2F;Javascript 등등이 있으므로 다른 언어를 배울 때도 유익할 것 같다. 객체? 클래스? 인스턴스?객체지향하면 사람들은 클래스를 먼저 떠오르기 마련인 것 같다.하지만 객체 != 클래스이다.객체지향 언어의 하나인 자바스크립트를 통해 보도록 하자.출처: JavaScript : 프로토타입(prototype) 이해 JavaScript는 클래스라는 개념이 없습니다.그래서 기존의 객체를 복사하여(cloning)새로운 객체를 생성하는 프로토타입 기반의 언어입니다.프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냅니다.이렇게 생성된 객체 역시 또 다른 객체의 원형이 될 수 있습니다.프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줍니다.","text":"드디어 오늘부터 객체지향 프로그래밍(OOP, Object Oriented Programming) 파트를 나가기 시작했다.이전까지는 다른 언어에도 대부분 있는 개념이었는데,이제부터는 자바의 특성을 배울 차례인 것 같다.객체 지향 언어는 C++&#x2F;Javascript 등등이 있으므로 다른 언어를 배울 때도 유익할 것 같다. 객체? 클래스? 인스턴스?객체지향하면 사람들은 클래스를 먼저 떠오르기 마련인 것 같다.하지만 객체 != 클래스이다.객체지향 언어의 하나인 자바스크립트를 통해 보도록 하자.출처: JavaScript : 프로토타입(prototype) 이해 JavaScript는 클래스라는 개념이 없습니다.그래서 기존의 객체를 복사하여(cloning)새로운 객체를 생성하는 프로토타입 기반의 언어입니다.프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냅니다.이렇게 생성된 객체 역시 또 다른 객체의 원형이 될 수 있습니다.프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줍니다. 즉, 클래스는 객체를 구현하기 위한 하나의 수단이지 그 자체가 객체는 아니란 것이다.객체는 상태와 행위를 가지는 유형과 무형의 개념(?)이다.실세계에 존재하지 않는 것들이 프로그래밍 세계에서는 객체로서 존재하기도 한다.실세계의 객체로선 불가능한 것이 프로그래밍 세계의 객체로선 가능하기도 하다.하지만 사람들의 이해를 돕기 위해서 실세계와 비교하다보니 오해가 빚어지기도 하는 것 같다.또한 객체를 구현하기 위해 클래스가 월등히 많이 쓰이다 보니 중요하지 않은 것은 아니다. 이렇게 클래스를 통해 만들어진 놈을 인스턴스라고 부른다.TV(객체) -&gt; TV 설계도(클래스) -&gt; LCD TV(인스턴스)TV(객체) -&gt; TV 설계도(클래스) -&gt; LED TV(인스턴스)뭐 나는 이정도로 이해를 했는데 맞는지 모르것다… new 연산자이는 기본형(bool, char, byte, short, int, long, float, double)이 아닌 경우에 모두 해당하는 내용이다.기본형이 아닌 경우에 모두 참조 변수이기 때문에클래스의 인스턴스틑 new 연산자를 통해 생성된다.(고 생각할 수 있다. 그 오해를 아래에서 풀어봤다.)+ 170213 내용 추가 그 오해가 오해가 아니었다. 생성자로는 인스턴스 생성이 아닌 인스턴스 변수 초기화만 해준다. new 자체가 인스턴스 생성 + 주소값 반환까지 해주는 녀석이란다.예외로 String 클래스는String str &#x3D; new String(“asdf”);String str &#x3D; “asdf”;두 가지 모두 허용한다.또한 자바에서 모든 참조 변수는 클래스이다.심지어 문자’열’도 클래스, 즉 참조 변수라는 사실을 알아둬야한다.JS의 Object, Array, Function, RegExp도 해당하는 내용일지는 모르겠으나 아마 해당하지 않을까…싶다. 기본적으로 클래스를 만들어서 쓰는 과정은 아래와 같다.응집도와 결합도에 내한 내용은 아래 링크를 참조하자. 결합도(Coupling), 응집도(Cohesion) getter와 setter에 대한 이유는 아래 링크를 참조하자. 인스턴스 변수의 getter, setter 설정의 궁금증123456789101112131415161718192021// test 패키지 내에 TV 클래스// 디폴트 패키지의 클래스는 어떻게 import가 안 되는 것 같다.package test;public class TV &#123; // 외부(test 클래스와 같이)에서는 상태(power, channel 등)는 알 필요 없고, // 행위(메소드)와 행위 수행을 위한 입출력 값만 알면 되기 때문에 // 상태는 숨기고, 행위를 드러내야 // 결합도는 낮추게 되고, 응집도를 높이게 되므로 유지 보수가 좋은 프로그램이 된다고 알고 있다. // 하지만 상태를 알아내야 할 필요도 있기 때문에 getter 메소드를 만드는 것으로 알고 있다. // getter와 setter가 존재하는 이유가 // 나중에 확장성을 고려했기 때문이라는데 실제로 뭐 그렇게 쓰는지는 모르겠다... // 기본 생성자가 없기 때문에 기본값인 false와 0으로 초기화 된다. private boolean power; private int channel; public void powerOnOff() &#123; power = !power; &#125; public void channelUp() &#123; channel++; &#125; public void channelDown() &#123; channel--; &#125; public int getChannel() &#123;return channel; &#125;&#125; 1234567891011121314import test.TV;class test &#123; public static void main(String[] args) &#123; // TV t = new TV(); 와 같이 한 줄로 줄여쓰는 게 편하다. TV t; // 1번 t = new TV(); // 2번 t.channelUp(); t.channelUp(); t.channelUp(); t.channelUp(); System.out.println(t.getChannel()); // 4 &#125;&#125; C++의 클래스를 보고 나니 이 역시 메모리의 동적 할당(heap 영역에 할당)되는 것 같다.자세한 내용은 아래 두 포스트에 설명해놓았다. (C&#x2F;C++) 참고용 정리 - 메모리 영역(Code, Data, Stack, Heap) (C++) 참고용 정리 - 클래스의 두 가지 생성 방법 new 연산자의 오해나 또한 이런 오해를 가지고 있었다.new 연산자를 통해 클래스의 인스턴스가 생성되는구나!완전히 틀렸다.new 없이도 클래스의 인스턴스의 생성은 가능하다.그 말 뜻을 한 번 파헤쳐보자.오해가 아니라 맞는 말이었다. TV t; 변수의 타입을 TV로 지정했다.하지만 TV라는 변수 타입은 없으므로 참조 타입이라고 봐야할 것 같다.그 참조 변수의 타입은 클래스의 이름인 것 같다.참조 변수는 값을 가지는 게 아니라 참조할 메모리의 주소값을 가진다.하지만 아직 참조 변수 선언만 했으므로 안에는참조 변수의 기본 값인 null이 들어가있을 것이다. t = new TV();이 부분을 세 가지 관점에서 나눠서 보고자 한다. t &#x3D; new TV(); TV()라는 생성자(여기서는 기본 생성자)만 호출해도클래스의 인스턴스는 생성되게 된다.인스턴스 변수의 초기화(생성자 호출)만 이루어진다. t &#x3D; new TV();new라는 키워드는 C언어의 &amp;와 비슷하다고 보면 될 것 같다.해당 변수가 할당된 메모리 상의 주소값을 얻어오는 연산자이다.즉 저 키워드를 씀으로써 rvalue에는 0x1234가 들어가게 된다.위와 더불어 인스턴스 생성까지 이루어진다. t = new TV();&#x3D; 이라는 대입, 할당 연산자를 사용하여rvalue인 0x1234를 lvalue인 t에 할당, 대입하면서클래스의 인스턴스의 주소를 할당하게 되는 것이다. 즉, new 연산자를 통해 클래스의 인스턴스가 생성되는 게 아니라 맞다!!주소값만을 얻어내는 연산자이지, 실제로는생정자(TV())를 통해 만들어지게 되는 것이었다게 아니라 생성자로는 인스턴스 변수의 초기화만 이루어진다!! 데이터 저장 개념의 발전 과정 변수, 하나의 데이터만 저장 가능.123456int a = 1;int b = 2;int c = 3;double d = 1.2;double e = 3.3;double f = 4.4; 배열, 동일한 데이터의 타입들을 저장 가능.12int a[] = &#123;1, 2, 3&#125;;double b[] = &#123;1.2, 3.3, 4.4&#125;; 구조체(C언어에서 등장함), 동일하지 않은 데이터의 타입들도 저장 가능.1234struct a &#123; int arr[]; double arr2[];&#125;; 클래스, 동일하지 않은 데이터 타입들 + 함수1234567class a &#123; int a[] = &#123;1, 2, 3&#125;; double b[] = &#123;1.2, 3.3, 4.4&#125;; void println() &#123; System.out.println(&quot;얀냐셈!&quot;); &#125;;&#125; C언어와 같은 절차 지향 언어에서는 데이터는 데이터끼리, 함수는 함수끼리 따로 생각을 하였다.하지만 함수는 주로 데이터를 가지고 작업을 하기 때문에객체 지향 언어인 C++과 Java에서는 이 둘을 합친 Class가 등장하게 된 것이다.절차 지향 언어인 C언어에서는 문자열이 문자의 배열에 그치는데 반해객체 지향 언어인 Java에서는 문자열(데이터)과 문자열과 관련된 함수(메소드)를 같이 모아String 클래스로 따로 뺀 이유가 위와 같다. 사용자 정의 타입기본형(Primitive type) 외에 프로그래머가 서로 관련된 변수들을 묶어서하나의 타입으로 새로 추가하는 것을 사용자 정의 타입(User-defined type)이라고 한다.자바와 같은 객체 지향 언어에서는 클래스가 곧 사용자 정의 타입이다.이 사용자 정의 타입은 프로그래머에 의해 만들어지므로 갯수에 제한이 없다. 클래스 변수클래스의 변수는 멤버 변수(클래스 변수, 인스턴스 변수), 지역 변수로 나뉜다. 123456789class tt &#123; // 우리 둘은 멤버 변수 int a; // 나는 멤버 변수 중에 인스턴스 변수 static int b; // 나는 멤버 변수 중에 클래스 변수 void test() &#123; int t; // 나는 지역 변수 &#125;&#125; 클래스 변수는 클래스가 메모리에 적재되는 순간(import건 class를 선언했건) 만들어진다. 12345package test;public class TV &#123; public static int a;&#125; 123456class test &#123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 &#125;&#125; 12345678910class TV &#123; static int a;&#125;class test &#123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 &#125;&#125; 하지만 인스턴스 변수는 클래스의 인스턴스를 생성(TV())해야지만 만들어진다.또한 인스턴스 변수는 클래스의 인스턴스마다 고유한 값을 가지지만,클래스 변수는 같은 클래스의 인스턴스라면 모두 그 값을 공유하게 된다.클래스 변수(static 변수)는 같은 주소를 참조하기 때문이다.사용할 때 클래스의 변수는 TV.b와 같이 클래스 이름.변수와 같이 사용하지만인스턴스 변수는 t.a와 같이 인스턴스 이름.변수와 같이 사용한다.물론 클래스 변수도 인스턴스 이름.변수와 같이 사용할 수 있지만,인스턴스 변수와 헷갈리므로 추천하지 않는다. 궁금해서 예제를 만들어보았으니 C언어의 static 변수와 비교해보면 참 재밌다. 12345678910111213141516171819202122232425262728293031class TV &#123; // Java에서는 클래스 외부에 변수를 선언할 수 없다. // static 변수는 마치 전역변수와 같다. // 왜냐면 다른 클래스에서도 사용이 가능하기 때문이다. static int a; int b = 22;&#125;class TV2 &#123; // static 변수는 어디서나 참조가 가능하다.(물론 접근 지정자에 따라 다르지만) // 난 그래서 이 static 변수가 진정한 의미의 전역 변수이고, // 인스턴스 변수는 인스턴스가 생성되어야만 사용할 수 있고, 값의 공유가 되지 않기 때문에 // 가짜 전역 변수라고 생각한다. int b = TV.a; int c = new TV().b;&#125;class test &#123; static int ii = 123; public static void main(String[] args) &#123; TV.a = 4; System.out.println(TV.a); // 4 TV2 t = new TV2(); // TV.a == 4 TV.a = 33; TV2 t2 = new TV2(); // TV.a == 33 System.out.println(t.b); // 4 System.out.println(t2.b); // 33 System.out.println(t2.c); // 22 System.out.println(ii); // 123, 같은 클래스 내의 static 변수는 클래스 이름 생략이 가능함. &#125;&#125; 우선 C언어의 static 변수는 스코프가 지역 변수의 성향을 띄는데 반해Java의 static 변수는 전역 변수의 성향을 띈다.어디서나 접근이 가능하다.하지만 사용하려면 클래스 이름.변수로 적어야해서 좀 불편시럽긴 하다. 또 하나 특징이 있다. 12345678910111213141516171819class test2234 &#123; void a() &#123; int a; &#125; // static이 붙지 않은 메소드끼리 호출 가능. void c() &#123; a(); &#125; // static이 붙지 않은 메소드에서 static 메소드 호출 가능. void b() &#123; d(); &#125; // static이 붙은 메소드에서 static이 붙지 않은 메소드 호출 불가능. static void d() &#123; a(); // 에러당! &#125;&#125; 170211, 내용 추가위 코드에 대한 이유는 아래 링크에서 설명하고 있다.(Java) 자바의 정석 3판 009일차 정리 머리가 아프당…나머지 개념은 내일이나 나중에 정리해야겠다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"}]},{"title":"(자작) 동적 테이블 생성기","slug":"dynamic-table-generator","date":"2017-01-31T09:59:04.000Z","updated":"2022-10-30T08:42:16.383Z","comments":true,"path":"2017/01/31/dynamic-table-generator/","link":"","permalink":"https://perfectacle.github.io/2017/01/31/dynamic-table-generator/","excerpt":"개발 배경예전부터 테이블 태그는 참 헷갈렸다.어떤 게 행이고 어떤 게 열인지…가끔은 행과 열 조차도 헷갈렸다. scope&#x3D;”row”, scope&#x3D;”col” rowspan, colspan row, col 그래서 그냥 내 맘대로 합치고 바꾸고 제목 설정하고 싶었다.한글이나 엑셀에서는 가능한 것 같지만 HTML에서는 불가능 한 것 같았다.그러한 불편함을 감수하고자 1년 전에 몇 시간동안 간단히 만든 적이 있다.동적 테이블 생성 초기 버전","text":"개발 배경예전부터 테이블 태그는 참 헷갈렸다.어떤 게 행이고 어떤 게 열인지…가끔은 행과 열 조차도 헷갈렸다. scope&#x3D;”row”, scope&#x3D;”col” rowspan, colspan row, col 그래서 그냥 내 맘대로 합치고 바꾸고 제목 설정하고 싶었다.한글이나 엑셀에서는 가능한 것 같지만 HTML에서는 불가능 한 것 같았다.그러한 불편함을 감수하고자 1년 전에 몇 시간동안 간단히 만든 적이 있다.동적 테이블 생성 초기 버전 하지만 그냥 써보기만 해도 문제가 참 많다는 걸 알 수 있다.그렇게 기억 속에 묻혀있었는데, 어느 한 분께서 친절하게 해당 사항에 대해 얘기를 꺼내셨고,설날에 잉여였던 나는 길어야 2일 걸릴 줄 알았는데, 4일 밤낮을 샌 것 같다…동적 테이블 생성기 v1.0 혹시 미천한 프로젝트가 궁금하시거나 개선하고 싶으신 분은 아래 링크로 들어가길 바란다.(스타도 박아주심 헤헤헤…)동적 테이블 깃헙 링크 사용 방법기본 사용 방법기본적인 사용 방법은 아래와 같다.제목행(th scope&#x3D;”col”), 제목열(th scope&#x3D;”row”)캡션, colspan, rowspan에 중점을 뒀다. 수정 모드초기 버전과는 다르게 수정모드도 붙여 보았다.엔터를 누르면 저장, ESC를 누르면 취소가 된다. JSON, 사용자 편의 고려표가 복잡하면 다시 새롭게 만들기 귀찮은데,이런 유저를 위해 제이슨 형태로 저장할 수 있게 제공하였다. 하지만 가독성이 구린 문제점이… 지못미…제이슨에서 다른 셀과 구분 짓기 위해 병합된 셀의 정보는 다음과 같이 나타난다.%데이터:rowspan,colspan%병합된 셀은 %collapsedCell%과 같이 나타냈다.가독성이 안 좋지만 딱히 방법이 떠오르지 않았다… ㅠㅠ여하튼 이렇게 가독성이 구린 데이터를 함부로 손 댔다가는 테이블 조차 만들 수도 없을 것이다. 셀 병합에 있어서 또 다른 문제점또한 제목 행은 &lt;thead&gt; 안에 있고, 나머지 행은 &lt;tbody&gt;에 있기 때문에제목 행과 다른 행을 합칠 순 없다. 백업은 필수테이블을 새로 생성하면 기존 데이터는 날아가기 때문에귀찮더라도 제이슨 데이터는 항상 백업해두자. 마치며…내가 이 짓을 할 시간에 리액트, 자바, ES6 등등을 공부했더라면엄청나게 많은 지식을 습득했을 것 같은데 그래도 후회는 없다. 일단 지금 공부하고 있는 자스민, 카르마를 연동해서 TDD를 해보았다.(+ESLint)TDD가 없었다면 이 많은 케이스를 테스트 할 엄두가 나지 않았을 것이다.물론 아직도 귀찮거나 미처 테스트하지 못한 케이스들이 존재할테지만…어느정도 예상 가는 부분드은 중간중간 앱을 먼저 개발하기도 했다.또한 처음엔 규모가 별로 크지 않을 줄 알고 script.js 파일 하나 안에 다 때려 박았다가도저히 감당이 안 돼서 객체 지향의 원리를 곱씹어봐서 쪼개긴 했는데…매우 허술하고 설계를 먼저 끝내고 코딩을 한 게 아니라생각나는 대로 쪼개고 귀찮으면 하나에 몰아넣기도 한 것 같다.또한 모듈로 쪼개다보니 어쩔 수 없이 웹팩을 쓰게 됐고 바벨까지 얹어서복습할 좋은 기회가 된 것 같다.또한 뷰나 리액트로 만들었으면 좋았을 것 같은데, 너무 산으로 가는 느낌과공부하려면 시간이 곱절로 들 것 같아서 일단 포기. 주절주절 많은 걸 쓰고 느낀 것 같다…이런 것도 포트폴리오로 쓸 수 있으려나??","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"HTML","slug":"HTML","permalink":"https://perfectacle.github.io/tags/HTML/"},{"name":"Table","slug":"Table","permalink":"https://perfectacle.github.io/tags/Table/"}]},{"title":"(ES6+) ajax를 위한 fetch와 async/await","slug":"ES6-ajax-with-fetch","date":"2017-01-25T18:37:49.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/01/25/ES6-ajax-with-fetch/","link":"","permalink":"https://perfectacle.github.io/2017/01/25/ES6-ajax-with-fetch/","excerpt":"이 글을 읽기 전에 (ES6) ajax 위주의 promise 실습를 먼저 읽을 것을 권한다.ajax(XMLHttpRequest)와 promise에 대한 기본적인 이해가 있다면 상관없긴 하다.조현영 님의 제보에 의하면 ie에서 fetch가 안 되고,async&#x2F;await 크롬과 오페라에서만 된다고 한다.아래 사이트에서 확인 가능하다.https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#Browser_compatibilityECMAScript Next compatibility table fetch다시 공부하다보니 XMLHttpRequest와 Fetch는 ECMAScript가 아니라고 한다.브라우저에서만 쓰이는 API이기 때문에 babel에서도 지원해주지 않기 때문에크로스 브라우징을 위해선 window.fetch polyfill을 쓰자.우선 기존에 우리가 ajax를 하기 위해서 어떻게 했는지 보자. 12345678910111213141516171819202122const jsonURL = &quot;https://perfectacle.github.io/mock/test.json&quot;;const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;getDataAjax(jsonURL);","text":"이 글을 읽기 전에 (ES6) ajax 위주의 promise 실습를 먼저 읽을 것을 권한다.ajax(XMLHttpRequest)와 promise에 대한 기본적인 이해가 있다면 상관없긴 하다.조현영 님의 제보에 의하면 ie에서 fetch가 안 되고,async&#x2F;await 크롬과 오페라에서만 된다고 한다.아래 사이트에서 확인 가능하다.https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#Browser_compatibilityECMAScript Next compatibility table fetch다시 공부하다보니 XMLHttpRequest와 Fetch는 ECMAScript가 아니라고 한다.브라우저에서만 쓰이는 API이기 때문에 babel에서도 지원해주지 않기 때문에크로스 브라우징을 위해선 window.fetch polyfill을 쓰자.우선 기존에 우리가 ajax를 하기 위해서 어떻게 했는지 보자. 12345678910111213141516171819202122const jsonURL = &quot;https://perfectacle.github.io/mock/test.json&quot;;const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;getDataAjax(jsonURL); 이 복잡한 getDataAjax 부분을 줄여보자. 123456789101112const jsonURL = &quot;https://perfectacle.github.io/mock/test.json&quot;;const getDataAjaxFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));getDataAjaxFetch(jsonURL).then(data =&gt; &#123; for(let key in data) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;).catch(err =&gt; console.error(err)); fetch API는 XMLHttpRequest를 대신하기 위한 방안 중 하나이다.아직 표준안은 아니고, 크롬에서 당장 사용이 가능하다.자세한 설정은 fetch API을 확인하자. 그럼 대충 fetch를 뜯어보자. 1console.dir(fetch(&quot;https://perfectacle.github.io/mock/test.json&quot;)); Promise 인스턴스가 반환된다.Promise에서 실제로 쓰고 싶은 값은 [[PromiseValue]]에 들어있는데 이를 직접 접근하지 못한다.따라서 then() 메소드를 써야한다. 12fetch(&quot;https://perfectacle.github.io/mock/test.json&quot;).then(res =&gt; console.dir(res)); ![크롬 콘솔창에서 본 [[PromiseValue]]의 반환값](ES6-ajax-with-fetch&#x2F;02.png)반환된 결과를 보니 Response의 인스턴스가 반환됐다.처음 보는 놈이다.뭐 쓰고 싶은 값을 찾아낼 수가 없다.여기서 또 하나의 메소드를 쓰면 된다. 12fetch(&quot;https://perfectacle.github.io/mock/test.json&quot;).then(res =&gt; console.dir(res.json())); Response 인스턴스는 문자열이 아니다.따라서 toJSON() 대신에 json() 메소드를 쓰면 json 형태로 바꿀 수 있다.바꿨더니 또 promise 인스턴스다.[[PromiseValue]]를 한 번 더 벗겨야한다. 123fetch(&quot;https://perfectacle.github.io/mock/test.json&quot;).then(res =&gt; res.json()).then(data =&gt; console.dir(data)); ![또 다시 벗겨낸 [[PromiseValue]]](ES6-ajax-with-fetch&#x2F;04.png)드디어 우리가 원하는 값을 얻어냈다.기존의 XMLHttpRequest와 Promise를 사용했을 때보다 then을 한 번 더 타야한다는 단점이 있다.근데 뭐 간단해지니 장점이 더 많은 것 같다. 그럼 기존 XMLHttpRequest와 Fetch를 비교해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];// promise에 파라미터를 넘겨주기 위해선 밖에서 함수로 한 번 래핑해줘야 함.const getDataAjaxPromise = url =&gt; ( // thenable하게 하기 위해 Promise 인스턴스를 리턴. new Promise((res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send(); &#125;));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjaxPromise(jsonURL[0]).then(data =&gt; &#123; res(data); // promise 인스턴스에 파라미터를 넘기기 위해선 다시 함수를 호출해야하고, // thenable 하게 만들어야하기 때문에 함수의 반환값(프라미스 인스턴스)을 리턴해줘야함. return getDataAjaxPromise(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;)// 더 이상 비동기로 처리할 내용이 없으므로 return문은 필요 없어짐..then(data =&gt; res(data)).catch(err =&gt; console.error(`http status code: $&#123;err&#125;`)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;const getDataFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));// 이 부분은 promise와 크게 차이나진 않는다.getDataFetch(jsonURL[0]).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataFetch(jsonURL[0]);&#125;).then(data =&gt; res(data)).catch(err =&gt; console.error(err)); async &amp; await (ES2017)여기서 끝내기 아쉬우니 한번 코드를 Promise의 단점을 보완해보자.요놈은 아직 표준 확정은 아니다. (ES2017이 나온 게 아니니…)그래도 뭐 크롬에서 돌아가니 한 번 알아보자. 12345678910111213141516171819202122232425262728293031323334353637const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];const getDataFetch = url =&gt; ( fetch(url).then(res =&gt; res.json()));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// async 함수 안에서 비동기 코드 앞에 await를 붙여주면 된다.// 안타깝게도 async &#x27;함수&#x27;라서 호출을 위해 즉시 실행함수를 사용했다.(async () =&gt; &#123; // try-catch 문으로도 완벽하게 오류를 잡아낸다. // 하지만 에러코드가 제대로 출력되지 않는다. try &#123; await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi await getDataFetch(jsonURL[0]).then(data =&gt; res(data)); // test: hi await getDataFetch(jsonURL[1]).then(data =&gt; res(data)); // test2: hi &#125; catch(err) &#123; // 하나의 통신이라도 실패하면 뒤에 오는 통신은 씹어버린다. console.error(err); // 직접 URL을 틀리게 입력해서 오류를 뭐라고 뿜는지 보자. &#125;&#125;)(); 마치며Promise, Fetch, Async&#x2F;Await 모두 수박 겉핥기 식으로 공부해서글에 부족한 부분이 매우 많을 것이니 무한 태클 환영합니다~제가 들은 말로 정리를 해보자면… 콜백 함수ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ㄴ Promise(Fetch 또한 Promise를 쓰는 것)ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ&amp;nbsp;&amp;nbsp;ㄴ Async&#x2F;Awaitㄴㄴㄴㄴㄴㄴㄴㄴㄴ","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ajax","slug":"ajax","permalink":"https://perfectacle.github.io/tags/ajax/"},{"name":"ES6+","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015+","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"}]},{"title":"(C/C++) 참고용 정리 - 전역 변수 vs 지역 변수 vs static 변수","slug":"C-ref-003","date":"2017-01-25T09:31:26.000Z","updated":"2022-10-30T08:42:16.059Z","comments":true,"path":"2017/01/25/C-ref-003/","link":"","permalink":"https://perfectacle.github.io/2017/01/25/C-ref-003/","excerpt":"전역 변수(Global Variable) 1234567891011121314#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; var++; // 어디서나 접근 가능 printf(&quot;%d\\n&quot;, var); // 4&#125;int main() &#123; add(); printf(&quot;%d&quot;, var); // 4, 값의 유지 return 0;&#125; 값의 유지 어디에서든 접근 가능 main 함수 실행 전에, 프로그램이 실행되자 마자 메모리에 할당됨. 프로그램이 끝나는 순간 메모리에서 해제됨. 메모리의 Data 영역에 적재됨.&amp;nbsp;2번의 이유로 인해서 변수의 스코프가 더럽혀진다.더럽혀진다는 의미는 변수 이름의 충돌 가능성이 존재하고,그로 인해 변수 이름 짓기에 큰 시간을 할애해야 하며,변수의 이름이 길어지거나 이상해지는 경우도 존재한다.어디서나 접근 가능하기 때문에 실수로 변수의 값이 바뀔 가능성이 존재한다.뭐 그렇다고 해서 꼭 안 좋은 것만은 아니기 때문에 적절히 활용하면 된다. 지역 변수(Local Variable) 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; int var = 4; var++; // 지역 변수의 우선순위가 전역 변수보다 높음. printf(&quot;%d\\n&quot;, var); // 5&#125;int main() &#123; &#123; // block scope int asdf = 33; printf(&quot;%d&quot;, asdf); &#125; // printf(&quot;%d&quot;, asdf); // 스코프를 벗어나서 컴파일 오류가 남. add(); printf(&quot;%d\\n&quot;, var); // 3, 값의 유지가 안 됨. int i = 0; // 지역 변수 i의 scope 시작 for(int i=0; i&lt;3; i++) &#123; printf(&quot;%d &quot;, i); // 0 1 2 &#125; // 지역 변수 i의 scope 끝 printf(&quot;\\n%d&quot;, i); // 0, 여기서 나온 건 전역 변수 i return 0;&#125; 매번 새로운 값 생성, 값의 유지가 안 됨. 지정된 블록 스코프(제어문, 함수 등등)에서만 접근 가능 함수가 실행되는 순간마다 메모리에 할당됨. 함수가 종료되는 순간마다 메모리에서 해제됨. 메모리의 Stack 영역에 적재됨.&amp;nbsp;값이 유지되지 않기 때문에 함수를 실행할 때마다 매번 똑같은 값을 써야할 때 쓴다.스코프 내에서만 접근 가능하기 때문에 유지보수에 용이하다.가능하면 스코프의 범위는 좁은 게 유지보수하기 편하다고 들었다.","text":"전역 변수(Global Variable) 1234567891011121314#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; var++; // 어디서나 접근 가능 printf(&quot;%d\\n&quot;, var); // 4&#125;int main() &#123; add(); printf(&quot;%d&quot;, var); // 4, 값의 유지 return 0;&#125; 값의 유지 어디에서든 접근 가능 main 함수 실행 전에, 프로그램이 실행되자 마자 메모리에 할당됨. 프로그램이 끝나는 순간 메모리에서 해제됨. 메모리의 Data 영역에 적재됨.&amp;nbsp;2번의 이유로 인해서 변수의 스코프가 더럽혀진다.더럽혀진다는 의미는 변수 이름의 충돌 가능성이 존재하고,그로 인해 변수 이름 짓기에 큰 시간을 할애해야 하며,변수의 이름이 길어지거나 이상해지는 경우도 존재한다.어디서나 접근 가능하기 때문에 실수로 변수의 값이 바뀔 가능성이 존재한다.뭐 그렇다고 해서 꼭 안 좋은 것만은 아니기 때문에 적절히 활용하면 된다. 지역 변수(Local Variable) 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int var = 3; // 전역변수void add() &#123; int var = 4; var++; // 지역 변수의 우선순위가 전역 변수보다 높음. printf(&quot;%d\\n&quot;, var); // 5&#125;int main() &#123; &#123; // block scope int asdf = 33; printf(&quot;%d&quot;, asdf); &#125; // printf(&quot;%d&quot;, asdf); // 스코프를 벗어나서 컴파일 오류가 남. add(); printf(&quot;%d\\n&quot;, var); // 3, 값의 유지가 안 됨. int i = 0; // 지역 변수 i의 scope 시작 for(int i=0; i&lt;3; i++) &#123; printf(&quot;%d &quot;, i); // 0 1 2 &#125; // 지역 변수 i의 scope 끝 printf(&quot;\\n%d&quot;, i); // 0, 여기서 나온 건 전역 변수 i return 0;&#125; 매번 새로운 값 생성, 값의 유지가 안 됨. 지정된 블록 스코프(제어문, 함수 등등)에서만 접근 가능 함수가 실행되는 순간마다 메모리에 할당됨. 함수가 종료되는 순간마다 메모리에서 해제됨. 메모리의 Stack 영역에 적재됨.&amp;nbsp;값이 유지되지 않기 때문에 함수를 실행할 때마다 매번 똑같은 값을 써야할 때 쓴다.스코프 내에서만 접근 가능하기 때문에 유지보수에 용이하다.가능하면 스코프의 범위는 좁은 게 유지보수하기 편하다고 들었다. static 변수 12345678910111213#include &lt;stdio.h&gt;void add() &#123; static int var = 4; var++; printf(&quot;%d\\n&quot;, var); &#125;int main() &#123; add(); // 5 add(); // 6 return 0;&#125; 값의 유지 지정된 블록 스코프(제어문, 함수 등등)에서만 접근 가능 main 함수 실행 전에, 프로그램이 실행되자 마자 메모리에 할당됨. 프로그램이 끝나는 순간 메모리에서 해제됨. 메모리의 Data 영역에 적재됨.&amp;nbsp;값이 유지돼야 하지만, 유지보수 등등 때문에 전역변수도, 지역변수도 마땅치 않을 때가 있다.이럴 때 쓰는 게 static 변수이다.값이 유지 된다는 전역 변수의 특징과 지정된 스코프에서만 접근 가능하다는 지역 변수가 짬뽕된 케이스이다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"https://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"https://perfectacle.github.io/tags/Static/"}]},{"title":"(Java) 자바의 정석 3판 006일차 - 배열","slug":"Java-study-006day","date":"2017-01-24T10:17:58.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/01/24/Java-study-006day/","link":"","permalink":"https://perfectacle.github.io/2017/01/24/Java-study-006day/","excerpt":"배열Java에서는 길이가 0인 배열의 선언도 가능하다.또한 길이는 int 범위의 양의 정수이다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 둘 다 가능하지만 후자가 C/C++에서 먹히는 스타일이라 이식성이 높다고 생각한다. int[] num = new int[5]; boolean flag[] = new boolean[5]; // 배열을 초기화하지 않으면 기본값으로 초기화 돼서 나온다. for(int i=0; i&lt;num.length; i++) System.out.println(num[i]); // 0 for(int i=0; i&lt;flag.length; i++) System.out.println(flag[i]); // false double num2[] = new double[]&#123;1.1, 4.5&#125;; // 선언과 동시에 초기화. double num3[] = new double[5]&#123;1.1, 4.5&#125;; // 길이를 지정해주면 오류가 난다. double num4[] = &#123;1.5, 3.14, 15&#125;; // 선언과 동시에 초기화 할 때는 new 연산자를 뺄 수 있다. // 선언과 초기화를 따로 할 때는 new 연산자를 써서 할당까지 해주어야 한다. double num5[]; num5 = new double[]&#123;33.123, 51.792&#125;; // 아래와 같은 경우를 불허한다. double num6[] = new double[123]; num6 = &#123;123.22, 33&#125;; // 수정할 때는 new 연산자를 써서 새로 만들어줘야한다. num2 = new double[]&#123;123, 456, 111.33&#125;; // 아래 세 문장은 배열의 길이가 0이다. int num7[] = new int[]&#123;&#125;; int num8[] = new int[0]; int num9[] = &#123;&#125;; // import java.util.Arrays; // java 패키지의 utill 패키지의 Arrays 클래스에 있는 toString이라는 메소드를 쓴다. System.out.println(Arrays.toString(num4)); // [1.5, 3.14, 15.0] // char 배열은 for 문이나 다른 메소드를 안 써도 된다. char ch[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;; System.out.println(ch); // hello &#125;&#125; 배열을 복사하는 방법","text":"배열Java에서는 길이가 0인 배열의 선언도 가능하다.또한 길이는 int 범위의 양의 정수이다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 둘 다 가능하지만 후자가 C/C++에서 먹히는 스타일이라 이식성이 높다고 생각한다. int[] num = new int[5]; boolean flag[] = new boolean[5]; // 배열을 초기화하지 않으면 기본값으로 초기화 돼서 나온다. for(int i=0; i&lt;num.length; i++) System.out.println(num[i]); // 0 for(int i=0; i&lt;flag.length; i++) System.out.println(flag[i]); // false double num2[] = new double[]&#123;1.1, 4.5&#125;; // 선언과 동시에 초기화. double num3[] = new double[5]&#123;1.1, 4.5&#125;; // 길이를 지정해주면 오류가 난다. double num4[] = &#123;1.5, 3.14, 15&#125;; // 선언과 동시에 초기화 할 때는 new 연산자를 뺄 수 있다. // 선언과 초기화를 따로 할 때는 new 연산자를 써서 할당까지 해주어야 한다. double num5[]; num5 = new double[]&#123;33.123, 51.792&#125;; // 아래와 같은 경우를 불허한다. double num6[] = new double[123]; num6 = &#123;123.22, 33&#125;; // 수정할 때는 new 연산자를 써서 새로 만들어줘야한다. num2 = new double[]&#123;123, 456, 111.33&#125;; // 아래 세 문장은 배열의 길이가 0이다. int num7[] = new int[]&#123;&#125;; int num8[] = new int[0]; int num9[] = &#123;&#125;; // import java.util.Arrays; // java 패키지의 utill 패키지의 Arrays 클래스에 있는 toString이라는 메소드를 쓴다. System.out.println(Arrays.toString(num4)); // [1.5, 3.14, 15.0] // char 배열은 for 문이나 다른 메소드를 안 써도 된다. char ch[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;; System.out.println(ch); // hello &#125;&#125; 배열을 복사하는 방법 하드코딩(비효율적) 12345678910111213141516171819202122import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 배열의 길이를 늘리고 싶다고 생각하면 아래와 같이 복사해야한다. int arrNum[] = &#123;1, 2, 3, 4, 5&#125;; int arrNumLen = arrNum.length; // 배열의 길이가 너무 길어지면 메모리에 부담이 되므로 x2 정도가 적당하다. int tmp[] = new int[arrNumLen*2]; // for 문을 돌리는 부분에서도 상당한 비용을 소모한다. for(int i=0; i&lt;arrNumLen; i++) &#123; tmp[i] = arrNum[i]; &#125; arrNum = tmp; // 원본 배열과의 참조 관계가 끊겼다는 걸 알 수 있다. // 즉 원본 배열 [1, 2, 3, 4, 5]는 가비지 컬렉팅 대상이 된다. System.out.println(arrNum.length); // 10 System.out.println(Arrays.toString(arrNum)); // [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] &#125;&#125; 내장된 API 사용(효율적) 12345678910111213141516171819202122import java.util.Arrays;public class test2 &#123; public static void main(String[] args) &#123; // 배열의 길이를 늘리고 싶다고 생각하면 아래와 같이 복사해야한다. int arrNum[] = &#123;1, 2, 3, 4, 5&#125;; int arrNumLen = arrNum.length; // 배열의 길이가 너무 길어지면 메모리에 부담이 되므로 x2 정도가 적당하다. int tmp[] = new int[arrNumLen*2]; // for 문은 요소 하나하나마다 접근하지만 // 배열은 연속된 메모리 공간이라는 점을 활용하여 // arraycopy 메소드는 하나의 값으로 취급하여 접근한다고 한다. System.arraycopy(arrNum, 0, tmp, 0, arrNumLen); arrNum = tmp; // 원본 배열과의 참조 관계가 끊겼다는 걸 알 수 있다. // 즉 원본 배열 [1, 2, 3, 4, 5]는 가비지 컬렉팅 대상이 된다. System.out.println(arrNum.length); // 10 System.out.println(Arrays.toString(arrNum)); // [1, 2, 3, 4, 5, 0, 0, 0, 0, 0] &#125;&#125; String 클래스의 배열1234567891011public class test2 &#123; public static void main(String[] args) &#123; String str[] = new String[3]; // [null, null, null] // String은 기본형이 아니기 때문에 전자와 같이 써야하지만 후자와 같이 간편히 쓰는 걸 허용한다. // 그리고 기본형이 아닌 참조 변수이기 때문에 값이 아닌 주소가 아닌 객체의 주소가 담겨있다. // 객체의 주소는 그냥 임의대로 넣은 거니 크게 의미를 담지 말길 바란다. String str2[] = &#123;new String(&quot;asdf&quot;), new String(&quot;qwer&quot;)&#125;; // [0x100, 0x200] String str3[] = &#123;&quot;asdf&quot;, &quot;qwer&quot;&#125;; // [0x400, 0x500] &#125;&#125; String 클래스는 char 배열에 기능을 추가하여 확장한 것.객체 지향 이전의 절차 지향의 C언어의 경우에는데이터와 기능을 따로 다루었지만(그래서 char 배열로 문자열을 표현),객체 지향 개념인 Java에서는 데이터와 그와 관련된 기능을 하나의 클래스로 묶음.기능 &#x3D; 함수 &#x3D; 메소드라고 보면 된다. 하지만 char 배열과 달리 String 클래스는 내용의 변경이 불가능하다.변경 가능한 String 클래스는 StringBuffer라는 클래스가 따로 있다. 1234567public class test2 &#123; public static void main(String[] args) &#123; String str = &quot;asd&quot;; str += &quot;8&quot;; // 변경되는 게 아니라 새로운 문자열이 생성된 것이다. System.out.println(str); // asd8 &#125;&#125; String 클래스와 char 배열의 변환은 아래와 같다. 1234567public class test2 &#123; public static void main(String[] args) &#123; char ch[] = &#123;&#x27;h&#x27;, &#x27;i&#x27;&#125;; String str = new String(ch); char ch2[] = str.toCharArray(); &#125;&#125; 향상된 for문12345678910111213141516171819202122232425public class test2 &#123; public static void main(String[] args) &#123; int nums[] = &#123;4, 5, 6&#125;; for(int num : nums) &#123; num = 1; // 값이 변경 될까? &#125; for(int num : nums) &#123; System.out.print(num ); // 4 5 6 &#125; System.out.println(); int nums2[][] = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125; &#125;; // 이중 배열 안에 있는 놈도 배열이므로 // int num2[]와 같이 해줘야 함. for(int num2[] : nums2) &#123; for(int num : num2) &#123; System.out.print(num); &#125; System.out.println(); &#125; &#125;&#125; 다차원 배열12345678910111213141516171819public class test2 &#123; public static void main(String[] args) &#123; int nums[][] = new int[3][]; // 아래와 같은 형태의 배열이 됨. // 정사각형이 아닌 배열을 만들 수 있게 됨. // int int // int int int // int int int int nums[0] = new int[2]; nums[1] = new int[3]; nums[2] = new int[4]; // 아래와 같은 것도 가능하다. int nums2[][] = &#123; &#123;1, 2&#125;, &#123;1, 2, 3&#125;, &#123;1, 2, 3, 4&#125; &#125;; &#125;&#125; 가변 배열 문제만 보고 있다보니 드럽게 재미없다.좀 쉬다가 다른 공부나 해야지… + 내용 추가(170125) 연습문제 오답 정리 배열의 잘못된 선언 및 초기화b. int[] arr &#x3D; {1,2,3,}; &#x2F;&#x2F; 마지막의 쉼표는 있어도 상관없음.d. int[] arr &#x3D; new int[5]{1,2,3,4,5}; &#x2F;&#x2F; 두 번째 대괄호[]에 숫자 넣으면 안됨.e. int arr[5]; &#x2F;&#x2F; 배열을 선언만 할 때는 배열의 크기를 지정할 수 없음.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"배열","slug":"배열","permalink":"https://perfectacle.github.io/tags/%EB%B0%B0%EC%97%B4/"}]},{"title":"(ASM) 참고용 정리 - 리틀 엔디안, 빅 엔디안","slug":"ASM-ref-002","date":"2017-01-24T09:52:21.000Z","updated":"2022-10-30T08:42:16.055Z","comments":true,"path":"2017/01/24/ASM-ref-002/","link":"","permalink":"https://perfectacle.github.io/2017/01/24/ASM-ref-002/","excerpt":"엔디안은 시스템 프로그래밍에서 많이 쓰이는 용어이다.엔디안은 메모리의 저장 및 처리 방식을 말하는 것이다.이는 바이트 순서(Byte Order)와도 큰 관련이 있다. 빅 엔디안(Big Endian)메모리의 높은 번지 부터 저장하는 방식MSB(Most Significant Byte), 최상위 바이트부터 차례로 저장한다. 리틀 엔디안(Little Endian)메모리의 낮은 번지 부터 저장 하는 방식LSB(Least Significant Byte), 최하위 바이트부터 차례로 저장한다. 4바이트에 값이 저장되는 방식을 알아보자. 10진수 빅 엔디안 리틀 엔디안 0 0x00000000 0x00000000 1 0x00000001 0x01000000 2 0x00000002 0x02000000 3 0x00000003 0x03000000 4 0x00000004 0x04000000 5 0x00000005 0x05000000 6 0x00000006 0x06000000 7 0x00000007 0x07000000 8 0x00000008 0x08000000 9 0x00000009 0x09000000 10 0x0000000A 0x0A000000 11 0x0000000B 0x0B000000 12 0x0000000C 0x0C000000 13 0x0000000D 0x0D000000 14 0x0000000E 0x0E000000 15 0x0000000F 0x0F000000","text":"엔디안은 시스템 프로그래밍에서 많이 쓰이는 용어이다.엔디안은 메모리의 저장 및 처리 방식을 말하는 것이다.이는 바이트 순서(Byte Order)와도 큰 관련이 있다. 빅 엔디안(Big Endian)메모리의 높은 번지 부터 저장하는 방식MSB(Most Significant Byte), 최상위 바이트부터 차례로 저장한다. 리틀 엔디안(Little Endian)메모리의 낮은 번지 부터 저장 하는 방식LSB(Least Significant Byte), 최하위 바이트부터 차례로 저장한다. 4바이트에 값이 저장되는 방식을 알아보자. 10진수 빅 엔디안 리틀 엔디안 0 0x00000000 0x00000000 1 0x00000001 0x01000000 2 0x00000002 0x02000000 3 0x00000003 0x03000000 4 0x00000004 0x04000000 5 0x00000005 0x05000000 6 0x00000006 0x06000000 7 0x00000007 0x07000000 8 0x00000008 0x08000000 9 0x00000009 0x09000000 10 0x0000000A 0x0A000000 11 0x0000000B 0x0B000000 12 0x0000000C 0x0C000000 13 0x0000000D 0x0D000000 14 0x0000000E 0x0E000000 15 0x0000000F 0x0F000000 빅 엔디안 방식이 우리가 자주 생각하는 저장 방식이다.빅 엔디안은 가독성이 뛰어나고 대소 비교도 편하고 등등의 장점이 많다.또한 네트워크 통신에서는 빅 엔디안 방식을 이용하자고 약속하였다.0x00000001을 A 컴퓨터는 빅 엔디안 방식으로 숫자 ‘1’을 보낸것인데리틀 엔디안 방식인 컴퓨터 B는 데이터를 받을 때 0x01000000으로 받는다.그럼 A는 숫자 ‘1’을 보냈는데 컴퓨터 B는 ‘268435456’을 받은 꼴이 돼버리기 때문이다. 그럼 리틀 엔디안은 왜 나왔을까…?가산기를 설계할 때 올림수를 계산하기 편하고, 빠르기 위함이란다.15 + 1 을 빅 엔디안 방식으로 계산하면0x0000000F + 0x00000001 &#x3D; 0x00000010으로 계산 후 최하위 바이트로 이동해서 올림수가 발생한다.이번앤 리틀 엔디안 방식으로 계산해보자.0x0F000000 + 0x01000000 &#x3D; 0x10000000올림수를 계산할 때 최상위 바이트에서 바로 올림수가 가능하기 때문이다.라고 이해했는데 뭐 케바케기도 할 것 같고 요즘엔 둘 사이에 차이가 거의 없다고 한다. 또한 이런 엔디안은 CPU에 의존적이다.주로 인텔 CPU가 리틀 엔디안 방식을 사용한다고 한다.비디오 게임기인 SFC, NDS 등등에서도 리틀 엔디안 방식을 사용하는 경우가 많으니 참고하자. 참조 링크 시스템 프로그래밍 리틀 엔디안(Little Endian), 빅 엔디안(Big Endian) 리틀 엔디안 VS 빅 엔디안","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ASM","slug":"Programming/ASM","permalink":"https://perfectacle.github.io/categories/Programming/ASM/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"https://perfectacle.github.io/tags/ASM/"},{"name":"Assembly","slug":"Assembly","permalink":"https://perfectacle.github.io/tags/Assembly/"},{"name":"Endian","slug":"Endian","permalink":"https://perfectacle.github.io/tags/Endian/"}]},{"title":"(상식) 무선 공유기 암호와 속도에 관한 진실","slug":"Wifi-password-fact","date":"2017-01-24T09:02:39.000Z","updated":"2022-10-30T08:42:16.127Z","comments":true,"path":"2017/01/24/Wifi-password-fact/","link":"","permalink":"https://perfectacle.github.io/2017/01/24/Wifi-password-fact/","excerpt":"공유기에 암호를 걸어놓는다는 것의 의미 무선 공유기의 보안 때문에 AP에 암호를 걸어놓는 경우가 많다.여기서 무선 공유기에 암호를 건다는 것은… 무선 공유기에 타인이 접속하는 걸 방지하고자 암호를 건다.(WPA2PSK와 같은 방식으로…) 송수신하는 데이터(평문으로 된 개인정보 등등)을 암호화 하고자 데이터를 암호화 한다.(AES와 같은 알고리즘으로…)","text":"공유기에 암호를 걸어놓는다는 것의 의미 무선 공유기의 보안 때문에 AP에 암호를 걸어놓는 경우가 많다.여기서 무선 공유기에 암호를 건다는 것은… 무선 공유기에 타인이 접속하는 걸 방지하고자 암호를 건다.(WPA2PSK와 같은 방식으로…) 송수신하는 데이터(평문으로 된 개인정보 등등)을 암호화 하고자 데이터를 암호화 한다.(AES와 같은 알고리즘으로…) 하지만 암호를 걸어놓음으로써 인터넷 속도가 줄어든다는 사실을 알고 있는가?Why?우리가 보내는 데이터 -&gt; 암호화 -&gt; 전송과 같이‘암호화’의 단계가 포함되기 때문에 당연히 느려질 수 밖에 없다.그럼으로 인해서 아예 암호를 걸어놓지 않고 사용하는 사람들이 있다. 공유기에 암호 걸지 않고 사용하기이러한 방법은 매우 위험하다.타인이 나의 AP로 접근하여 동영상 등등의 기타 데이터를 마구 발생시키고 있다면자신이 쓸 수 있는 속도가 줄어든다.10MiB&#x2F;s를 두 명이 나눠쓰면 5MiB&#x2F;s로 줄어들거나동영상을 받고 있는 유저가 거의 10MiB&#x2F;s 가까이 끌어다 쓰는 등등…혹은 한 AP에 접속된 기기가 많을 수록 혼선이 발생되는 등등 인터넷 접속이 불안정해지게 된다. 이를 해결하기 위한 여러가지 방안이 있지만 대표적인 몇 가지를 소개하고자 한다.물론 암호화를 진행하고 이 방안까지 쓴다면 보안에 금상첨화이다. MAC 주소 인증MAC 주소는 컴퓨터 부품 중 하나인 LAN 카드에 있는 ‘고유’한 정보로서,IP 주소와 달리 LAN 카드를 바꾸지 않는한 영구적이다.또한 MAC 주소는 전 세계적으로 유일한 번호이므로 어찌 보면 ‘개인 정보’ 영역에도 속해서액티브 X 등등을 쓰지 않는 한 보안상 수집을 할 수 없다.이러한 MAC 주소의 ‘유일성’을 통해서 ‘인증된 MAC 주소’만 접속을 허용하게끔 하는 것이다.물론 MAC 주소를 바꾸는 방법이 존재하긴 하지만,인증된 MAC 주소를 알아내는 건 그리 쉬운 일이 아니다.또한 새로운 기기를 추가할 때마다 MAC 주소를 추가해야된다는 번거로움이 존재한다. SSID 숨기기.이 방법은 SSID 이름을 맞춰야만 해당 AP로 접속할 수 있게 하는 방법이다.사람들이 쉽게 생각할 수 없는 문자(특수문자)들의 조합으로SSID를 지정하면 쉽게 찾아낼 수가 없을 것이다. 공유기에 암호를 걸지 않는 것의 의미우리가 흔히 쓰는 무선 공유기는 송수신 하는 패킷(메시지, 데이터를 자잘하게 쪼갠 단위)을 기본적으로 암호화하지 않는다.잘 만들어진 사이트는 사이트 자체적(https 프로토콜 등등)으로 패킷을 암호화 하는 방법을 통해 보안을 유지하고 있다.하지만 우리가 사용하는 사이트가 모두 그렇게 잘 만들어진 사이트인가?보안에 그만큼 신경 쓴 사이트라면 비용이 비쌀테니 개인이나 소규모 기업 같은 경우에는크게 신경을 쓰지 않는 경우도 많다.잘 만들어진 사이트인지 일일이 확인하고 쓰기도 번거로울 뿐더러 알아내기도 쉽지 않다.즉 그러한 사이트를 이용하면 우리의 개인정보가고스란히 평문으로써 보이지 않는 공간에 날아다니게 된다.이러한 패킷들을 가로채는 건 해커들에겐 식은 죽 먹기다.흔히 생각하는 ‘무선 공유기 암호’는 ‘AP의 접근 인증’ 외에도&#39;송수신 패킷(데이터) 암호화&#39;도 포함돼있다.공짜라고, 비밀번호가 걸려있지 않다고, 옆 집에 있는 와이파이를 훔쳐쓰다가친구한테 몰래 보낸 메일이나 사이트의 비밀번호 등등이 크래커에게 고스란히 노출될 수 있다.옆 집 사람이 크래커라서 의도적으로 공개를 해놓은 건지도 모른다.공개 AP를 쓸 때는 보안에 민감하지 않은 작업만 하자. 공유기 암호화에 대한 다른 비밀암호화 방법이 여러 개 있고, 암호화 방법에 따라서 인터넷 속도도 천차 만별이다.출처는 아래 링크와 같다.iptime 암호화 방법에 따라 속도 차이가 엄청나군요. 복잡한 알고리즘, 안전한 알고리즘일 수록 느리지 않을까…뭐 꼭 그렇다는 것만은 아니지만… 하지만 여러 가지의 암호화 방법 중 ‘안전하지 않은’ 암호화 방식도 있다.이 말은 암호화를 걸었는데 이미 크래커들에게 뚫린 방식일 수도 있다는 뜻이다.802.11N 방식(100메가 광랜)에서는 WPA2PSK + AES 방식을 쓰는 게 가장 좋을 것 같다.WiFi 공유기 암호방식, 꼭 WPA2-AES를 써야하는 이유는?802.11AC 방식(기가 광랜)에서는 어떤 방식이 제일 좋은지는 모르겠다.TKIP 방식의 암호화 알고리즘은 802.11N 방식을 지원하지 않는다는 것 같다.공유기 암호화방법 변경으로 무선&#x2F;WIFI 속도 제대로 활용하기! 비밀번호를 걸지 않고, 송수신 데이터만 암호화 하는 방법이 존재하는지 모르겠지만,어지간하면 비밀번호가 걸려있지 않은 공개 AP는 쓰지 않는 게 좋고,꼭 써야한다면 보안에 민감하지 않은 작업만 하자.또한 소 잃고 외양간 고치기 싫은 사람들은 무선 공유기를 WPA2PSK + AES 방식의 암호화 방법을 적용시키거나… 속도를 포기하기 싫으신 분은 귀찮으시더라도 유선랜을 쓰도록 하자… 참조 링크 iptime 암호화 방법에 따라 속도 차이가 엄청나군요. WiFi 공유기 암호방식, 꼭 WPA2-AES를 써야하는 이유는? 공유기 암호화방법 변경으로 무선&#x2F;WIFI 속도 제대로 활용하기!","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"인터넷","slug":"인터넷","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%84%B0%EB%84%B7/"},{"name":"속도","slug":"속도","permalink":"https://perfectacle.github.io/tags/%EC%86%8D%EB%8F%84/"},{"name":"암호","slug":"암호","permalink":"https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8/"},{"name":"보안","slug":"보안","permalink":"https://perfectacle.github.io/tags/%EB%B3%B4%EC%95%88/"}]},{"title":"(상식) 인터넷 속도에 대한 진실","slug":"giga-internet-fact","date":"2017-01-23T18:55:53.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2017/01/23/giga-internet-fact/","link":"","permalink":"https://perfectacle.github.io/2017/01/23/giga-internet-fact/","excerpt":"이제는 100메가 광랜을 넘어서 기가의 시대가 열렸다.100메가 광랜을 쓸 적에 100 메가의 속도를 느껴본 적이 있는가?이론상 저항 등등에 의해 불가능하지만 그에 준하는 속도라도 느껴본 적 있는가?그럼 현재 기가에 조금 못 미치더라도 그에 준하는 속도를 느끼고 있는가?오늘은 그 진실과 상술과 마주해보자.결론부터 쉽게 풀어서 말하자면100메가 광랜의 이론상 최대 속도(나올 수가 없음)은 11.9메가이고,1기가 광랜의 이론상 최대 속도(이 또한 나올 수가 없음)은 119메가이다. b와 B사람들이 컴퓨터의 용량을 표기할 때 대소문자를 크게 여기지 않는다.물론 킬로를 뜻하는 k를 K로 적어도 kilo의 의미가 그대로 담겨있다.하지만 바이트를 뜻하는 B를 b로 적으면 bit의 뜻이 된다.일반인들은 잘 모르지만 그게 표준인지는 모르지만 표준과 같이 쓰이고 있다.인터넷 업체들은 b(it)라고 적으면서 사람들은 B(yte)로 받아들이는 것이다.8bit &#x3D; 1Byte, 8배의 속도 차이가 나게 되는 것이다.1Gb&#x2F;s &#x3D; 1Gbps &#x3D; 10³Mbps &#x3D; 1000Mbps &#x3D; 1000&#x2F;8(MBps) &#x3D; 125MBps &#x3D; 125MB&#x2F;s즉 1Gb&#x2F;s는 125MB&#x2F;s로 환산되어 우리가 피부로 느끼는 속도가 된다. iB와 B","text":"이제는 100메가 광랜을 넘어서 기가의 시대가 열렸다.100메가 광랜을 쓸 적에 100 메가의 속도를 느껴본 적이 있는가?이론상 저항 등등에 의해 불가능하지만 그에 준하는 속도라도 느껴본 적 있는가?그럼 현재 기가에 조금 못 미치더라도 그에 준하는 속도를 느끼고 있는가?오늘은 그 진실과 상술과 마주해보자.결론부터 쉽게 풀어서 말하자면100메가 광랜의 이론상 최대 속도(나올 수가 없음)은 11.9메가이고,1기가 광랜의 이론상 최대 속도(이 또한 나올 수가 없음)은 119메가이다. b와 B사람들이 컴퓨터의 용량을 표기할 때 대소문자를 크게 여기지 않는다.물론 킬로를 뜻하는 k를 K로 적어도 kilo의 의미가 그대로 담겨있다.하지만 바이트를 뜻하는 B를 b로 적으면 bit의 뜻이 된다.일반인들은 잘 모르지만 그게 표준인지는 모르지만 표준과 같이 쓰이고 있다.인터넷 업체들은 b(it)라고 적으면서 사람들은 B(yte)로 받아들이는 것이다.8bit &#x3D; 1Byte, 8배의 속도 차이가 나게 되는 것이다.1Gb&#x2F;s &#x3D; 1Gbps &#x3D; 10³Mbps &#x3D; 1000Mbps &#x3D; 1000&#x2F;8(MBps) &#x3D; 125MBps &#x3D; 125MB&#x2F;s즉 1Gb&#x2F;s는 125MB&#x2F;s로 환산되어 우리가 피부로 느끼는 속도가 된다. iB와 B여기서 한 번 더 의구심을 품어야한다.1Gb&#x2F;s &#x3D; 1Gbps &#x3D; 2¹⁰Mbps &#x3D; 1024Mbps가 아니다.즉!1GB(1024MB)의 파일을 1Gb&#x2F;s(125MBps)로는 8초만에 받을 수 없다는 사실이다!이 또한 상술이다.생각해보면 참 나쁜 놈들이다.2중 상술을 썼다.위 용량 관련된 글을 아래 링크를 참조하자.(상식) 컴퓨터 용량 단위에 대한 진실 b 단위 &#x3D; bit 단위 &#x3D; 1kb &#x3D; 1kilobit &#x3D; 125byte &#x3D; 1000bit B 단위(SI 단위) &#x3D; Byte 단위(10진 배수) &#x3D; 1kB &#x3D; 1kiloByte &#x3D; 1000Byte &#x3D; 8000bit iB 단위(IEC 이진 접두어) &#x3D; Byte 단위(2진 배수) &#x3D; 1KiB &#x3D; 1KibiByte &#x3D; 1024Byte &#x3D; 8192bit 우리는 파일 용량에 있어서 B 단위를 쓰면서 iB라고 생각하고 실제로도 iB 단위이다.컴퓨터의 저장 장치는 B 단위를 쓰고 우리는 iB라고 생각하지만 실제로는 B 단위이다.인터넷 전송 속도는 b 단위를 쓰고 우리는 iB라고 생각하지만 실제 단위는 b이다.이게 참 혼동이 온다.즉 인터넷 업자들은 B 단위 대신에 b 단위를 써서 우리를 한 번 속였고,iB 단위도 쓰지 않아서 우리를 두 번 속인 꼴이 된다.따라서 100메가 광랜은 100Mbps &#x3D; 12.5MBps ≒ 11.9MiBps1기가 광랜은 1Gbps &#x3D; 125MBps ≒ 119MiBps가 된다.하지만 위의 상황도 이론상 최대 속도이지손실 없이 온전하게 전달하는 방법은 초전도체 뿐이지 않을까 싶지만…초전도체를 상온(20±5°C)에서 쓰는 방법은 없는 것으로 알고 있고,비용도 매우 비쌀 것이므로 사람들은 대부분 어느 정도 손실을 감수하고 사용하고 있다. 119MiB&#x2F;s 인터넷의 속도를 방해하는 요소들아래 두 환경이 받춰주지 않는다면 119MiB/s의 가짜 기가 광랜 사용을 하고 싶어도 할 수 없다. ISP(Internet Service Provider)에서 깔아주는 망(케이블, 선)ISP는 그냥 LG U+, KT Olleh, SK Broadband 요런 애들이라고 보면 된다.요즘 인터넷이 무선으로 와이파이 통신을 한다고들 하지만 사실 완전한 무선은 아니다.ISP로부터 우리 집&#x2F;사무실까지 유선으로 쭉~오게 된다.외국과 통신을 한다고 해서 예외가 아니다.태평양 심해 어딘가에는 광 케이블이 깔려있다.우선 ISP에서 쓰는 케이블이 초전도체가 아니기 때문에 1차적으로 속도 손실이 일어나지 않을까 싶다.또한 여러 유저가 동시에 몰리다 보면 100% 속도를 내기는 힘들지 않을까… 싶다.또한 아파트나 자신이 사는 동네에 기가 망 구축이 돼있어야 한다.요즘 같은 경우에 11.9MiB&#x2F;s 광랜은 대부분 구축이 돼있는데,기가 망은 비용과 케이블이 두껍다보니 미관상의 이유로 깔리기를 반대하는 사람들이 있다.대표적으로 우리 아파트는 집 값 떨어진다고 못 깔고 있다고 한다… 에휴 ㅠㅠISP나 경비실에 문의해서 확실히 알아보고 신청해야 할 사항이다. 다운로드 속도는 괜찮은데 업로드 속도는…?혹은 그 반대인 경우가 있는데 이 경우들을 비대칭이라고 한다.지금은 잘 모르겠는데 과거에 주택 같은 경우에는 대칭형이었으나아파트가 주로 비대칭형이었다.대부분의 사람들이 동영상이나 파일을 받는 다운로드 속도에는 집착하지만인터넷 방송을 하는 스트리머의 경우나 대용량 파일을 메일로 보내는 등등의 행위에서는업로드 속도가 중요하다.하지만 대부분은 업로드 속도는 신경쓰지 않다보니 이것 또한 상술인지기술적 or 환경 문제인지 제대로 제공해주지 않는 ISP들이 있는 것으로 알고 있다.아니면 추가 과금을 통해서 개선이 된다거나…잘은 모르겠으나 직접 가입할 때 확인해야할 사항인 것 같다. 이제부터 나오는 네 가지 사항은 본인의 장비에 문제가 있는 경우이다.일단은 다운로드와 유선에 한해서 설명한다. 우리 집에 있는 랜선의 종류는?랜선은 랜선이지 무슨 또 종류가 있담?랜선에 따라서도 지원되는 속도가 있고, 가격도 다르다.물론 내구성과 안정성에 따라서도 달라지겠지만…UTP &gt; FTP &gt; STP 순으로 비싸지지만, (내구성&#x2F;안정성 측면)일반 가정과 사무실에서는 가격을 이유로 UTP 케이블을 쓴다.아래 링크를 참조하자.랜선의 종류와 각종 개념정리이번에는 속도 측면에서 보자.출처는 아래와 같다.랜선의 종류와 구분 (UTP&#x2F;STP&#x2F;FTP 차이점) 대역폭은 길이 좁냐 넓냐인데 이 또한 속도와도 관련이 있다고만 보면 된다.자신의 집이 아마 UTP 쓸테고, 그럼 CAT 어느 규격의 랜선을 쓰고 있는지를 알아야랜선을 새로 사야할지, 기가 광랜을 설치할지 말지를 결정할 수 있다. 내 컴퓨터의 랜카드 종류는?아니 랜카드가 랜카드지 또 종류가 있다고?구글링을 통해 내 랜카드가 1Gbps를 지원하는지 확인해야 한다.윈 7이나 10이나 비슷할테니 아래 링크를 참조하고, 리눅스나 맥은 따로 확인하길 바란다.기가랜을 사용하려면 랜카드 확인하고 설치하세요.만약에 본인의 컴퓨터에 장착된 랜카드가 기가 광랜을 지원하지 않는다면PCI-Express 슬롯에 장착할 수 있는 기가 랜카드를 사서 장착 후 그 곳에 랜선을 꽂거나USB 3.0용 랜카드를 사야한다.USB 2.0의 스펙상 쓰기 속도가 119MiB&#x2F;s가 되지 않기 때문에 USB 3.0 용으로 사야한다.USB 3.0 미지원 메인보드면 PCI-Express용을 사거나 메인보드를 USB 3.0 지원용으로 바꾸자. 내가 파일을 저장하는 공간의 쓰기 속도는?이게 뭔소린지 모를 수도 있다.간단하게 CrystalDiskMark라는 프로그램을 써서내가 파일 저장하려는 공간의 읽기&#x2F;쓰기 속도를 체크할 수 있다. 대충 seq를 기준으로 잡으면 되지 않을까 싶다.다운로드는 아래 페이지를 이용하자.CrystalDiskMark즉, 내가 SSD에 저장할 때는 기가 광랜의 속도를 충분히 활용할 수 있는데,SD 카드나 USB, 외장 하드에 파일을 저장할 때는 기가 광랜의 속도가 안 날 수도 있다는 거다.기가 광랜 빵빵하게 이용하고 싶으면 쓰기 속도가 119MiB&#x2F;s(125MB&#x2F;s)를 넘는SSD나 USB 3.0 용량 큰 거 하나 장만하자. 우리집 공유기의 종류는?대부분이 집에 PC 한 대 이상은 있을 거다.그래서 IP 공유기&#x2F;인터넷 공유기 하나 쯤은 대부분 있을 거다.근데 이 공유기가 자세히 보면 기가 광랜을 지원하지 않는 경우가 있다.판매처나 제조업체 홈페이지&#x2F;메뉴얼에서 스펙을 보도록 하자.그리고 제대로 지원하지 않으면 그냥 하나 사자. 이제부터 나오는 가지 사항은 무선과 다운로드/업로드에 해당하는 내용이다. 우리집 무선 랜카드의 종류는?대부분의 휴대 기기(노트북, 태블릿, 스마트폰)에는 무선 랜카드가 내장돼있다.노트북은 유선 랜카드도 내장된 경우가 많고, 데스크탑에는 대부분 유선 랜카드만 내장돼있다.따라서 본인이 와이파이를 이용하는 경우에는 무선 랜카드를 쓴다고 보면 된다.본인 무선 랜카드가 기가 광랜의 속도를 지원하는지,지원하지 않는다면 데스크탑의 경우에는 PCI-Express나 USB 3.0,랩탑의 경우에는 USB 3.0 무선 랜카드 밖에 방법이 없을 것이다.스마트폰이나 태블릿의 경우에는 오히려 번거롭거나 비싸거나 존재 자체가 없지 않을까 싶다… 공유기와 내 컴퓨터 사이의 거리는? 장애물의 종류와 갯수는?여기서 말하는 컴퓨터는 와이파이를 사용하는 모든 기기를 총칭한다.무선의 경우에는 거리가 멀어지면 멀어질 수록 안정성이 떨어짐과 동시에 속도가 느려진다.기본적으로 유선은 거리에 제약이 없지만 무선은 거리에 제약이 존재하기도 하고,속도나 안정성 측면(자주 끊긴다거나 보안)에서도 구리다.또한 공유기와 컴퓨터 직선거리 사이에 장애물(대표적인 게 벽)이 많고 두껍고,투과하기 힘든 그런 물체일 수록 더 속도와 안정성 측면에서 안 좋아진다.신호 증폭기를 사용하거나 공유기를 중간에 하나 더 설치하거나 공유기 위치를 옮겨보자.공유기는 한 쪽 방향으로 신호를 쏘는 게 아니라 자신을 중심으로사방 팔방으로 신호를 쏴대는 것으로 알고 있다.따라서 공유기의 위치는 집의 정중앙이 제일 이상적이다. (케바케긴 하지만…) 공유기와 랜카드의 신호 세기는?공유기와 컴퓨터 사이가 그리 멀지도 않거나 장애물도 없는데 속도가 느리면애초에 공유기나 무선 랜카드가 안 좋아서 신호가 약한 경우이다.한 쪽이 뛰어나도 한 쪽이 받춰주지 못하면 제대로 된 속도가 나오지 않을 것이다.대표적으로 안테나가 여러 개 달려있는 등의 제품이 신호 세기가 강하다.하지만 이런 무선 신호가 너무 세면 신체에 악영향을 끼칠지도 모른다는 글을 본 것 같다. 공유기의 지원 접속 모드와 설정된 값은?무선 통신의 전송 방식 표준에는 B&#x2F;G&#x2F;N&#x2F;AC 모드가 있다.각각에 대한 확인은 아래 링크에서 하자.IEEE 802.11 - 전송 방식 표준과거에는 N모드가 짱짱맨이었는데 기가 광랜이 나오면서 AC 모드를 지원해야 짱짱맨인 것 같다.공유기 설정에서도 AC 모드가 아닌 다른 모드로 설정돼있는지 봐보자. 이제부터 나오는 내용은 다운로드/업로드와 관련된 내용이다. 다운로드와 업로드를 동시에 하면…?대부분이 토렌트를 써봤을 거다.자신이 다운로드하면서 업로더도 되기도 한다.하지만 만약에 10MiB&#x2F;s가 본인의 인터넷 최대 속도라고 해보자.10MiB&#x2F;s로 다운로드 하다가 다른 사람이 다운로드 요청을 해서5MiB&#x2F;s의 속도로 업로드 하면 동시에 5MiB&#x2F;s로 다운로드 속도도 줄어든다.안 그런 컴퓨터나 네트워크 환경도 있겠지만 대부분이 이렇다.이는 업로드를 하다가 동시에 다운로드를 해도 마찬가지이다. 여러가지 파일을 동시에 다운로드 하면…?만약에 10MiB&#x2F;s가 본인의 인터넷 최대 속도라고 해보자.A란 파일을 10MiB&#x2F;s의 속도로 다운받고 있었다.B란 파일을 받으면 A란 파일의 다운로드 속도가 5MiB&#x2F;s로 떨어지고B란 파일의 속도도 5MiB&#x2F;s의 속도로 다운받게 된다.안 그런 컴퓨터나 네트워크 환경도 있겠지만 대부분이 이렇다.이는 업로드를 하다가 동시에 다른 파일이나 다른 유저에게 업로드를 해도 마찬가지이다. 우리 가족이나 룸메 중에 누가 인터넷으로 동영상을 본다면?만약에 10MiB&#x2F;s가 본인의 인터넷 최대 속도라고 해보자.혹은 대용량 메일을 보낸다면?둘이 다른 네트워크(공유기, 모바일 네트워크)에 접속돼있으면 상관 없지만대부분 공유기는 1대일 것이고 공유기가 달라도 메인으로 쏴주는 ISP 제공 장비(모뎀 같은 놈)같은 게 같다면 무용지물이다.대부분의 공유기는 더미 허브이다.(뭐 몰라도 된다.)인터넷 속도를 1&#x2F;N한다.1명만 쓰고 있을 때는 10MiB&#x2F;s의 속도를 보장 받지만2명이 같이 쓴다면 각자 5MiB&#x2F;s의 속도를 보장 받게 될 것이다. 파일을 다운로더에게 직접 쏴주는 경우&#x2F;BJ가 방송하는 경우이 경우에는 본인의 업로드 속도도 중요하지만 상대방의 다운로드 속도도 중요하다.다운로드 속도는 위에 말했다 싶이 아주 다양한 요인에 따라 달라진다.메일이나 클라우드 서버에 올리는 경우가 아니라 1대1로 쏘는 경우가 이에 속한다.또한 BJ가 방송을 송출할 때는 업로드 속도도 중요하지만,방송을 보는 시청자의 다운로드 속도 또한 버퍼링의 큰 요인이다. 참조 링크 랜선의 종류와 각종 개념정리 랜선의 종류와 구분 (UTP&#x2F;STP&#x2F;FTP 차이점) 기가랜을 사용하려면 랜카드 확인하고 설치하세요. 기가 인터넷 시대, 궁금증 해결하자 IEEE 802.11","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"용량","slug":"용량","permalink":"https://perfectacle.github.io/tags/%EC%9A%A9%EB%9F%89/"},{"name":"상식","slug":"상식","permalink":"https://perfectacle.github.io/tags/%EC%83%81%EC%8B%9D/"},{"name":"인터넷","slug":"인터넷","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%84%B0%EB%84%B7/"},{"name":"속도","slug":"속도","permalink":"https://perfectacle.github.io/tags/%EC%86%8D%EB%8F%84/"}]},{"title":"(상식) 컴퓨터 용량 단위에 대한 진실","slug":"Computer-capacity-fact","date":"2017-01-23T17:57:03.000Z","updated":"2022-10-30T08:42:16.071Z","comments":true,"path":"2017/01/23/Computer-capacity-fact/","link":"","permalink":"https://perfectacle.github.io/2017/01/23/Computer-capacity-fact/","excerpt":"이제 사람들이 IT에 많은 관심이 생겨서1TB 짜리 저장장치를 사도 온전히 1TiB가 아님을 알 수 있다.내가 여기서 TB와 TiB를 사용했는데, 이에 대해 알아보자. SI 단위프랑스어로 Système international d’unités현 과학계에서 사용하는 표준단위.표준화의 대표적인 성공사례이자 현재의 국제 과학계가 있을 수 있게 해 준 일등공신.컴퓨터 용량과 관련된 단위들만 살펴보자. 단위 이름 배수(10진법) 배수(2진법) Y yotta 1024 ≒280 Z zetta 1021 ≒270 E exa 1018 ≒260 P peta 1015 ≒250 T tera 1012 ≒240 G giga 109 ≒230 M mega 106 ≒220 k kilo 103 ≒210","text":"이제 사람들이 IT에 많은 관심이 생겨서1TB 짜리 저장장치를 사도 온전히 1TiB가 아님을 알 수 있다.내가 여기서 TB와 TiB를 사용했는데, 이에 대해 알아보자. SI 단위프랑스어로 Système international d’unités현 과학계에서 사용하는 표준단위.표준화의 대표적인 성공사례이자 현재의 국제 과학계가 있을 수 있게 해 준 일등공신.컴퓨터 용량과 관련된 단위들만 살펴보자. 단위 이름 배수(10진법) 배수(2진법) Y yotta 1024 ≒280 Z zetta 1021 ≒270 E exa 1018 ≒260 P peta 1015 ≒250 T tera 1012 ≒240 G giga 109 ≒230 M mega 106 ≒220 k kilo 103 ≒210 위와 같이 SI 단위의 접두어는 과학계에서 사용하는 표준 단위이다.참고로 k는 온도를 나타내는 K와 헷갈린다고 소문자로 표기하였다.저장장치 제조 회사는 이를 저장장치의 용량을 표기하는데 사용했다.저장장치 제조 회사가 말하는 1kB &#x3D; 103Byte &#x3D; 1000Byte하지만 전기회로는 전압이 불안정해서 컴퓨터에서도 전압을 두 가지로만 나누었다.이게 컴퓨터가 0과 1로만 이루어진 까닭이다.이러한 탓에 컴퓨터는 1kB &#x3D; 210Byte &#x3D; 1024Byte로 인식한다.우리가 생각하는 1024Byte에서 24Byte의 오차가 생긴다.1000Byte ≒ 1024Byte1kB니까 24Byte의 차이 밖에 안 나는데, 1TB라면…?240 - 1012 &#x3D; 99511627776(Byte) &#x3D; 92.6774253845214844(GB)의 오차가 난다.물론 저장 장치에 따라 달라지기도 한다.내가 보기엔 이거 분명 상술이다.애초에 십진 표기법을 사용하는 SI 단위를 이진 표기법을 사용하는 컴퓨터에 사용하는 것 자체가 맞지 않았다.이진 표기법의 표준이 정해지기 전에 컴퓨터가 나와서 어쩔 수 없었을지도 모르기도 하지만… IEC 표준 접두어(IEC 60027-2)국제 전기 기술위원회(International Electrotechnical Commission, IEC)에서 정의한 이진 표준 접두어이다. 단위 이름 배수(10진법) 배수(2진법) Yi yobi 280 ≒1024 Zi zebi 270 ≒1021 Ei exbi 260 ≒1018 Pi pebi 250 ≒1015 Ti tebi 240 ≒1012 Gi gibi 230 ≒109 Mi mebi 220 ≒106 Ki kibi 210 ≒103 1KiB &#x3D; 210Byte &#x3D; 1024Byte로 우리가 생각하는 단위가 맞다. 그나마 다행인 것은 하드 디스크나 플래시 메모리(USB, SD 카드, SSD 등등)과는 달리RAM이나 CD(거의 쓰지 않게 됐지만…)는 SI 단위를 쓰면서 IEC 표준 접두어와 같은 결과를 낸다고 한다.쉽게 말해 RAM이나 CD는 상술을 쓰지 않는다는 뜻이다.아마 RAM의 경우에는 메모리 주소와 관련이 있지도 않을까… 싶다. 하지만 이름이 뭔가 이상하고 어색해서 많이들 쓰지 않는다.이러면 이럴 수록 그들의 상술에 놀아나기 때문에 조금이라도 써야겠다. 또한 이러한 상술은 인터넷 업체에서도 쓰고 있다.아래 링크를 참조하자.(상식) 인터넷 속도에 대한 진실 참조 링크 SI 단위 이진 접두어","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"용량","slug":"용량","permalink":"https://perfectacle.github.io/tags/%EC%9A%A9%EB%9F%89/"},{"name":"상식","slug":"상식","permalink":"https://perfectacle.github.io/tags/%EC%83%81%EC%8B%9D/"}]},{"title":"(C/C++) 참고용 정리 - 변수와 리터럴, 그리고 메모리","slug":"C-ref-002","date":"2017-01-23T14:17:09.000Z","updated":"2022-10-30T08:42:16.059Z","comments":true,"path":"2017/01/23/C-ref-002/","link":"","permalink":"https://perfectacle.github.io/2017/01/23/C-ref-002/","excerpt":"변수변수라 함은 자바에서 정리했 듯이 아래와 같다. 짧게 얘기하면 변하는 수길게 얘기하면 단 하나의 값을 저장할 수 있는 메모리 상의 공간. 리터럴","text":"변수변수라 함은 자바에서 정리했 듯이 아래와 같다. 짧게 얘기하면 변하는 수길게 얘기하면 단 하나의 값을 저장할 수 있는 메모리 상의 공간. 리터럴리터럴이라 함은 자바에서 정리했 듯이 아래와 같다. 짧게 얘기하면 변하지 않는 값 길게 얘기하면 우리는 변하지 않는 값을 일상생활에서는 상수라고 불렀다. 하지만 상수는 프로그래밍 세계에서는 좀 다른 뜻으로 불리기 때문에 그와 차별성을 부여하기 위해 리터럴이라고 붙였다. “ch”, ‘c’, 123, 123.55 등등 모두 리터럴이다. 내가 위에서 정의한 말들이 맞을까?좀 부족한 부분이 있는 것 같다.아래의 경우를 보자. 1234567#include &lt;stdio.h&gt;int main() &#123; int num = 1 + 2; printf(&quot;%p&quot;, &amp;num); num의 주소값이 나온다. return 0;&#125; num은 변수기 때문에 메모리를 4byte 잡아먹고 그 안에00000000 00000000 00000000 00000011이런 값이 들어있다.그럼 리터럴인 1과 2는 메모리 상에 적재되지 않는 걸까…?CPU에서 연산을 하기 위해서는 메모리 상에 있는 데이터들을 끌고 와야한다.메모리 상에 없는 데이터는 CPU에서 끌고 올 수가 없으니 연산 및 처리가 불가능하다.따라서 리터럴인 1과 2도 메모리 상에 올라가야한다는 것이다.이 1과 2도 메모리 상의 어딘가에 적재가 된다.그 어디가 어딘지는 아무도 모른다.(메인)메모리(RAM, Random Access Memory)의 특성상비어있는 공간 랜덤한 부분에 적재되지 않을까 싶다.정수 리터럴의 기본 크기는 모르지만 아마 4byte이지 않을까… 싶다.즉 1을 저장할 4byte 공간, 2를 저장할 4byte 공간이 따로 필요하게 된다.그리고 이러한 연산이 끝난 이후에는 가비지 컬렉팅 대상이 되어 소멸되게 되는 것이다.즉 리터럴도 메모리 상에 할당이 되고, 변수도 메모리 상에 할당이 된다.그럼 그 차이점을 아래의 표로 나타내보았다. | 변수 | 리터럴— | — | —할당 형태 | 정적 할당 | 동적 할당메모리 주소&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; | 알 수 있음(재호출 가능) | 알 수 없음(재호출 불가)가비지 컬렉팅 | 자세히 모르겠음 | 연산 되자마자캐싱 | 메모리 주소에만 접근하면 되므로 캐싱을 함 | 매번 새로운 메모리 공간을 만들어야 하므로 캐싱하지 않음","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"https://perfectacle.github.io/tags/Variable/"},{"name":"Literal","slug":"Literal","permalink":"https://perfectacle.github.io/tags/Literal/"},{"name":"Memory","slug":"Memory","permalink":"https://perfectacle.github.io/tags/Memory/"}]},{"title":"(C/C++) 참고용 정리 - 포인터와 배열","slug":"C-ref-001","date":"2017-01-23T11:00:21.000Z","updated":"2022-10-30T08:42:16.059Z","comments":true,"path":"2017/01/23/C-ref-001/","link":"","permalink":"https://perfectacle.github.io/2017/01/23/C-ref-001/","excerpt":"윤성우 님의 열혈 C 프로그래밍 동영상 강좌를 열심히 보고 있다.자바는 메모리 관리를 안 해도 된다지만 공부하면 할 수록 메모리에 자꾸만 관심이 갔다.그러한 갈증에 대한 해소를 C언어에서 할 수 있었다. 포인터메모리 주소의 값을 가지고 있는 변수이다.주된 용도는 특정 변수의 메모리 주소의 값을 가지고 있는 변수이지만,아래와 같은 것도 가능하다. 123456789101112#include &lt;stdio.h&gt;int main() &#123; // 0x00000013이 어떤 영역인지 모른다. // 만약 OS영역이라면 치명적인 오류가 나고, 시스템이 뻗을 수도 있다. // 하지만 요즘 OS들은 다들 방어적으로들 행동한다고 한다. // 혹시 모르니 아래 코드는 권장하지 않는다. long* ptr = 0x00000013; // 에러를 뿜는 컴파일러도 있으니 권장하지 않음. *ptr = 13; return 0;&#125;","text":"윤성우 님의 열혈 C 프로그래밍 동영상 강좌를 열심히 보고 있다.자바는 메모리 관리를 안 해도 된다지만 공부하면 할 수록 메모리에 자꾸만 관심이 갔다.그러한 갈증에 대한 해소를 C언어에서 할 수 있었다. 포인터메모리 주소의 값을 가지고 있는 변수이다.주된 용도는 특정 변수의 메모리 주소의 값을 가지고 있는 변수이지만,아래와 같은 것도 가능하다. 123456789101112#include &lt;stdio.h&gt;int main() &#123; // 0x00000013이 어떤 영역인지 모른다. // 만약 OS영역이라면 치명적인 오류가 나고, 시스템이 뻗을 수도 있다. // 하지만 요즘 OS들은 다들 방어적으로들 행동한다고 한다. // 혹시 모르니 아래 코드는 권장하지 않는다. long* ptr = 0x00000013; // 에러를 뿜는 컴파일러도 있으니 권장하지 않음. *ptr = 13; return 0;&#125; 위와 같은 코드는 OS 영역을 건들지도 모르므로 매우 위험하다.따라서 아래와 같이 써야한다. 12345678910111213#include &lt;stdio.h&gt;int main() &#123; long num = 123; long* ptr = &amp;num; *ptr = 13; // %p의 크기는 운영체제의 bit에 따라, 값은 실행할 때마다 달라질 수 있다. // 핵심은 ptr에 저장된 값과 num의 메모리 번지수가 동일하다는 것이다. // 0x7fff588a2ad8 0x7fff588a2ad8 printf(&quot;%p %p&quot;, &amp;num, ptr); return 0;&#125; 크기위에서 보듯이 포인터는 실수가 아닌 정수이다.하지만 그 크기가 1byte인지 2byte인지 어떻게 알 수 있을까?그 크기는 OS에 의존적이다.OS를 깔 때 32bit 버전, 64bit 버전의 컴퓨터를 본 적이 있다.32bit는 OS에서 한 번에 처리할 수 있는 데이터의 양은 32bit, 즉 4byte이다.왜냐하면 CPU가 처리하는 데이터의 최소 단위인 Register의 크기가 몇 bit인지에서 나오기 때문이다.또한 한 번에 이동시킬 수 있는 데이터의 양 또한 32bit라고 한다.데이터 버스를 이용하는 건지 뭔지는 잘 모르겠다.이는 메인 메모리(RAM, Random Access Memory)의 인식과도 관련이 있다.참고로 메인 메모리의 주소 체계는 1byte 단위이다.232Byte &#x3D; 222Kilobyte &#x3D; 212Megabyte &#x3D; 22Gigabyte &#x3D; 4GB 잠시 다른 이야기, 왜 32비트 컴퓨터를 x86이라고 부를까?통칭 x86계열의 CPU가 32비트까지 나와있고, 여기서 64비트를 지원하도록 확장된게 x86-64죠. 그래서 x86-64를 줄여서 간단히 x64…8080 - 8086 - 80186 - 80286 - 80386 - 80486 - 80586 등으로 나가는 인텔의 CPU를 통칭해서 x86이라고 부름 그렇다면 64bit의 경우에는 어떨까?64bit를 지원하는 CPU에 64bit의 OS가 깔린 경우라는 가정하에…CPU의 Register의 크기가 64bit라서 한 번에 연산(처리)할 수 있는 데이터의 양은 64bit, 즉 8byte.한 번에 이동시킬 수 있는 데이터의 양 또한 64bit.이론 상으로 인식할 수 있는 메인 메모리의 크기는264Byte &#x3D; 254Kilobyte &#x3D; 244Megabyte &#x3D; 234Gigabyte &#x3D; 224Terabyte&#x3D; 214Petabyte &#x3D; 24Exabyte &#x3D; 16EB 참고로 말하자면 int의 크기 또한 OS의 bit에 의존적이지 않다!!같은 64bit지만 컴파일러에 따라서 int의 크기가 달라지기도 하는 것 같다.하지만 표준이나 요새 상황은 잘 모르겠다. 엄밀하게는 컴파일러에 따라 int 크기가 다르다…가 답일거 같군요. http://stackoverflow.com/questions/10197242/what-should-be-the-sizeofint-on-a-64-bit-machine Sang-Kyu Ahn님 C99 표준에 따르면 sizeof(char)&#x3D;1이란 것만 정해져 있고, char는 최소 8비트 라는 것이 정해져 있습니다(limits.h를 통해). 그 다음부터는 상대적인 크기로만 되어 있죠. 보통은 그래서 char가 8비트이지만, 16비트 char를 쓴다고 해서 표준 위반은 아니죠. short는 마찬가지 방식으로 16비트 이상이면 되고, int는 기계가 다루는 가장 자연스러운(?) 크기(보통은 CPU레지스터나 데이터 버스 크기에 따르겠죠)면서 최소 16비트, long은 int보다 크거나 같은 크기이면서 32비트, long long은 long보다 크거나 같으면서 최소 64비트… 따라서 64비트 머신이라면 64비트 char, short, int, long, long long 도 표준 위반이 아닙니다. Hyunsok Oh님 이미지와 소스 코드의 출처는 32bit와 64bit의 C 자료형(Data Type) 크기 차이이다. 1234567891011121314151617181920#include&lt;stdio.h&gt;int main() &#123; printf (&quot;\\n-- General Data Type Size --\\n&quot;); printf (&quot;char size : %d byte\\n&quot;, (int)sizeof(char)); printf (&quot;short size : %d byte\\n&quot;, (int)sizeof(short)); printf (&quot;int size : %d byte\\n&quot;, (int)sizeof(int)); printf (&quot;long size : %d byte\\n&quot;, (int)sizeof(long)); printf (&quot;double size : %d byte\\n&quot;, (int)sizeof(double)); printf (&quot;long double size : %d byte\\n&quot;, (int)sizeof(long double)); printf (&quot;\\n-- Pointer Data Type Size -- \\n&quot;); printf (&quot;char* size : %d byte\\n&quot;, (int)sizeof(char*)); printf (&quot;short* size : %d byte\\n&quot;, (int)sizeof(short*)); printf (&quot;int* size : %d byte\\n&quot;, (int)sizeof(int*)); printf (&quot;long* size : %d byte\\n&quot;, (int)sizeof(long*)); printf (&quot;double* size : %d byte\\n&quot;, (int)sizeof(double*)); printf (&quot;long double* size : %d byte\\n&quot;, (int)sizeof(long double*)); return 0;&#125; 포인터 변수 타입에 대한 이해32bit에서는 포인터 변수의 크기가 4byte, 64bit에서는 포인터 변수의 크기가 8byte다.포인터의 크기는 OS에 의존적인데 그럼 그 변수의 타입도 OS에 의존적인 타입만 써야하지 않을까…? NO!!32bit OS에서 놓고 포인터 변수의 크기도 4byte, long의 크기도 4byte이다.64bit OS에서 놓고 포인터 변수의 크기도 8byte, long의 크기도 8byte이다.따라서 포인터 변수의 타입은 무조건 long이면 될 것 같다.그런데 왜 char*, short*, int*, float*, double* 요런 놈이 존재하는 걸까…?그건 포인터를 쓰는 근본적인 목적인 메모리 주소에 대한 접근 때문이다. 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; double num = 123.2; // 컴파일 되지않는 컴파일러도 있지만, 메모리 주소인 정수값을 long에 담는 것이니 상관이 없다고 여긴다. long ptr = &amp;num; // 해당 주소로 접근해서 그 주소에 있는 값을 바꾸려고 한다. // 하지만 ptr이란 놈은 num의 주소만 알고있을 뿐이지 어떤 타입인지 알지 못한다. // 메모리에는 0과 1의 값만 잔뜩 들어가있는데 그러한 정보를 알 수 없다. // 따라서 에러가 나거나 원하는 결과가 나오지 않을 것이다. *ptr = 13.4; return 0;&#125; 위의 예제에서 알 수 있듯이 메모리 주소만으로는 해당 메모리 주소가 가리키는 공간이 어떠한 타입인지즉 몇 byte를 조작해야 내가 원하는 결과가 나올지, 문자일지 숫자일지 등등을 판단하기 힘들다.즉 포인터의 타입은 포인터가 가리키는 곳의 타입을 알고 있는 것이지,포인터의 크기를 알고 있는 아이가 아니다.포인터의 크기는 신경쓸 필요도 없고 컴파일러가 알아서 처리하는 것 같다.포인터 변수의 데이터 타입이 달라도 컴파일이 되는 경우도 있지만 추천하지 않는다. 12345678910111213141516171819#include &lt;stdio.h&gt;int main() &#123; // int형 1은 // 00000000 00000000 00000000 00000001 int num = 1; // int*이 아니지만 컴파일 되는 컴파일러도 있다. // short*이라고 선언했기 때문에 2byte라고 인식한다. short* ptr = &amp;num; // short형 2는 // 00000000 00000010 *ptr = 2; // 따라서 num은 아래와 같이 바뀌어있다. // 00000000 00000010 00000000 00000001 // 정수로 131073 // 컴파일이 되는 경우도 있지만 올바른 값이 나오지 않으므로 권장하지 않는다. return 0;&#125; 배열배열은 연속된 메모리 공간에 할당하는 것을 뜻한다.연속해서 메모리 공간에 할당하는 이유는 두가지가 아닐까 싶다. 중간 중간 이빨이 나가지 않아 메모리 단편화가 안 일어나지 않을까? 반복문 측면에서 주소값+배열 타입만 하면 되기 때문이지 않을까?또한 변수를 하나만 선언해도 된다는 장점이 존재한다. 그리고 배열의 이름도 포인터이다.하지만 포인터와의 차이점이라면 포인터 상수라는 점이다. 12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; int num[] = &#123;1, 2, 3&#125;; // 0x7fff58f16acc 0x7fff58f16acc // &amp;연산자를 붙이지도 않았는데 변수의 이름이 주소값을 가리킨다. // 즉 배열의 이름은 배열의 첫번째 요소의 주소값(포인터)와 같다. printf(&quot;%p %p&quot;, num, &amp;num[0]); // 포인터이기 때문에 메모리 주소로 접근이 가능하다. *num = 3; printf(&quot;%d %d %d&quot;, *num, *&amp;num[0], num[0]); // 하지만 포인터 상수이기 때문에 컴파일 에러가 난다. num = &amp;num[2]; return 0;&#125; C언어에서 배열의 이름은 포인터 상수라고 했기 때문에 아래와 같은 게 불가능하다. 123456789101112#include &lt;stdio.h&gt;int main() &#123; int num[2]; // 배열의 이름은 포인터 상수라서 컴파일 에러. num = &#123;1, 3&#125;; // 따라서 아래와 같이 해줘야하는데 매우 귀찮아지므로 선언과 동시에 초기화해주는 것이 좋다. num[0] = 1; num[1] = 3; return 0;&#125; 포인터의 덧셈, 뺄셈, 증감 연산자(+, -, ++, –)포인터에서 포인터 ± n은 다음과 같은 의미를 가진다.주소값 ± n * sizeof(포인터 변수 타입) 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; int num = 123; int* ptr = &amp;num; // 0x7fff5fb37adc printf(&quot;%p\\n&quot;, ptr); // 0x7fff5fb37adc + sizeof(int) // 0x7fff5fb37adc + 4 // 즉, 0x7fff5fb37ae0 ptr += 1; printf(&quot;%p\\n&quot;, ptr); // 0x7fff5fb37ae0 + 4 // 즉, 0x7fff5fb37ae4 printf(&quot;%p\\n&quot;, ++ptr); return 0;&#125; 배열의 이름 또한 상수이지만 일단은 포인터이기 때문에 덧셈, 뺄셈 연산자를 사용할 수 있다. 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int num[] = &#123;1, 3, 5&#125;; // c언어에서는 배열의 length를 구하는 api가 없다. int length = sizeof(num) / sizeof(int); // 배열의 이름이 포인터이기 때문에 &amp;를 안 붙여도 됨. int* ptr = num; for(int i=0; i&lt;length;) printf(&quot;%d &quot;, num[i++]); // 1 3 5 printf(&quot;\\n&quot;); // 배열의 이름은 포인터이기 때문에 *를 붙여줘야 함. // 또한 덧셈 연산자나 증감 연산자 보다 * 연산자의 우선순위가 더 높아서 괄호로 우선순위를 명시해줘야 함. for(int i=0; i&lt;length;) printf(&quot;%d &quot;, *(num + (i++))); // 1 3 5 printf(&quot;\\n&quot;); for(int i=0; i&lt;length;) printf(&quot;%d &quot;, *(ptr + (i++))); // 1 3 5 printf(&quot;\\n&quot;); // 배열의 이름은 포인터 상수이기 때문에 아래와 같은 것이 불가능하다. for(int i=0; i++&lt;length;) printf(&quot;%d &quot;, *(num++)); // ptr은 포인터 변수이기 때문에 아래와 같은 것이 가능하다. for(int i=0; i++&lt;length;) printf(&quot;%d &quot;, *(ptr++)); // 1 3 5 printf(&quot;\\n&quot;); num[0] = 5; *(num+1) = 3; // num[1]과 동일함, 괄호 빼면 안 된다. *(--ptr) = 1; // ptr++를 3번 해줘서 ptr+3이 되었으므로 배열의 범위를 벗어났으니 한 번 빼줘야 함. for(int i=0; i&lt;length;) printf(&quot;%d &quot;, *(num + (i++))); // 5 3 1 return 0;&#125; 참조 링크 Windows 환경에서 32 bit 와 64 bit 왜 32비트 환경을 x86이라고 하는걸까요? 32bit와 64bit의 C 자료형(Data Type) 크기 차이 32bit 자료형 &#x2F; 64bit 자료형의 크기 정리 64bit 머신에서 int형이 64bit가 아닌가요? long과 int는 크기가 같은데 왜 존재하나요? C에서 상수 포인터는 무엇입니까?","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Pointer","slug":"Pointer","permalink":"https://perfectacle.github.io/tags/Pointer/"},{"name":"Address","slug":"Address","permalink":"https://perfectacle.github.io/tags/Address/"},{"name":"Array","slug":"Array","permalink":"https://perfectacle.github.io/tags/Array/"}]},{"title":"(ES6) ajax 위주의 promise 실습","slug":"ES6-Promise-with-ajax","date":"2017-01-21T09:09:50.000Z","updated":"2022-10-30T08:42:16.083Z","comments":true,"path":"2017/01/21/ES6-Promise-with-ajax/","link":"","permalink":"https://perfectacle.github.io/2017/01/21/ES6-Promise-with-ajax/","excerpt":"들어가기에 앞서집중력을 위해 짧은 글을 지향하여 Promise 문법을 설명하지는 않았다.간단히 jQuery를 사용해본 사람이라면 쉽게 이해할 수 있을 것이다.내가 찾아본 대부분의 Promise 관련 예제가 setTimeout 위주여서ajax 위주의 예제를 한 번 정리해보았다. 비동기 코드를 동기식으로 작성하면?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;// 콘솔창을 키고 새로고침을 10번 정도 해보자.// 콘솔창에 계속해서 동일한 결과가 출력되는가??// 비동기 작업이기 때문에 순서를 보장하기 힘들다.// 원래는 아래와 같이 나와야한다.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);","text":"들어가기에 앞서집중력을 위해 짧은 글을 지향하여 Promise 문법을 설명하지는 않았다.간단히 jQuery를 사용해본 사람이라면 쉽게 이해할 수 있을 것이다.내가 찾아본 대부분의 Promise 관련 예제가 setTimeout 위주여서ajax 위주의 예제를 한 번 정리해보았다. 비동기 코드를 동기식으로 작성하면?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];const getDataAjax = url =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful for(let key in xhr.response) &#123; // 받아온 json 데이터의 키와 값의 쌍을 모두 출력. if(xhr.response.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;xhr.response[key]&#125;`); &#125; &#125; else &#123; // 통신 상에 오류가 있었다면 오류 코드를 출력. console.error(`http status code: $&#123;xhr.status&#125;`); &#125; &#125; &#125;; xhr.send();&#125;;// 콘솔창을 키고 새로고침을 10번 정도 해보자.// 콘솔창에 계속해서 동일한 결과가 출력되는가??// 비동기 작업이기 때문에 순서를 보장하기 힘들다.// 원래는 아래와 같이 나와야한다.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]);getDataAjax(jsonURL[0]);getDataAjax(jsonURL[1]); 비동기 코드를 비동기식(콜백 함수)으로 작성하면? (ES5)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];// 따라서 아래와 같이 콜백 함수를 이용하여야 한다...const getDataAjaxCallback = (url, res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send();&#125;;// 성공과 에러 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; if(data.hasOwnProperty(key)) console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;const rej = err =&gt; console.error(`http status code: $&#123;err&#125;`);// 새로고침 10번을 해보고도 아래와 같은 순서로 나오는지 확인해보자.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: hi// 함수 안에 매개변수로 콜백함수가 들어가있다.getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[0], data =&gt; &#123; res(data); // 순서를 보장하기 위해 콜백함수 안에 또 콜백함수가 들어가있다. getDataAjaxCallback(jsonURL[1], data =&gt; &#123; res(data); &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err)) &#125;, err =&gt; rej(err))&#125;, err =&gt; rej(err)); 비동기식 코드의 순서를 아름답게 보장하려면…? (ES6)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const jsonURL = [ &quot;https://perfectacle.github.io/mock/test.json&quot;, &quot;https://perfectacle.github.io/mock/test2.json&quot;];// 위 코드를 보면 가독성이 매우매우매우 안 좋다.// 이를 위해 등장한 것이 promise.// promise에 파라미터를 넘겨주기 위해선 밖에서 함수로 한 번 래핑해줘야 함.const getDataAjaxPromise = url =&gt; ( // thenable하게 하기 위해 Promise 인스턴스를 리턴. new Promise((res, rej) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, url, true); xhr.responseType = &quot;json&quot;; xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 4) &#123; // 4 means request is done. if(xhr.status === 200) &#123; // 200 means status is successful res(xhr.response); // 성공했을 시 실행할 콜백 함수. &#125; else &#123; rej(xhr.status); // 실패했을 시 실행할 콜백 함수. &#125; &#125; &#125;; xhr.send(); &#125;));// 성공 콜백함수는 공통 함수로 빼버렸다.const res = data =&gt; &#123; for(let key in data) &#123; console.log(`$&#123;key&#125;: $&#123;data[key]&#125;`); &#125;&#125;;// 코드가 한결 우아해지지 않았는가?// 새로고침 10번을 해보고도 아래와 같은 순서로 나오는지 확인해보자.// test: hi// test2: hi// test: hi// test: hi// test2: hi// test2: hi// test: hi// test2: hi// test: hi// test2: higetDataAjaxPromise(jsonURL[0]).then(data =&gt; &#123; res(data); // promise 인스턴스에 파라미터를 넘기기 위해선 다시 함수를 호출해야하고, // thenable 하게 만들어야하기 때문에 함수의 반환값(프라미스 인스턴스)을 리턴해줘야함. return getDataAjaxPromise(jsonURL[1]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0]);&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[0])&#125;).then(data =&gt; &#123; res(data); return getDataAjaxPromise(jsonURL[1])&#125;)// 더 이상 비동기로 처리할 내용이 없으므로 return문은 필요 없어짐..then(data =&gt; res(data)).catch(err =&gt; console.error(`http status code: $&#123;err&#125;`)); 마치며콜백 함수를 Promise로 바꾸긴 했지만 그래도 좀 번거로운 건 어쩔 수 없을까…?그에 대한 해답이라고 하긴 뭐하지만(ES6+) ajax를 위한 fetch와 async&#x2F;await에서 해결방안을 보자.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"ajax","slug":"ajax","permalink":"https://perfectacle.github.io/tags/ajax/"},{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"}]},{"title":"(Java) 자바의 정석 3판 005일차 - 반복문(for, while, do-while), continue와 break","slug":"Java-study-005day","date":"2017-01-20T15:31:25.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/01/20/Java-study-005day/","link":"","permalink":"https://perfectacle.github.io/2017/01/20/Java-study-005day/","excerpt":"반복문for문12345678910111213141516171819202122232425public class test2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;i \\t i % 3 \\t i / 3&quot;); for(int i=0; i&lt;12;) System.out.printf(&quot;%d \\t %d \\t %d%n&quot;, i, i%3, i++/3); /* i % n에서 % 연산자는 n개의 숫자가 연속적으로 순환하면서 나오고 i / n에서 / 연산자는 동일한 숫자가 n번 연속해서 나온다. 알고리즘 어딘가 쓰일지 모르니 기억해두자. i i % 3 i / 3 0 0 0 1 1 0 2 2 0 3 0 1 4 1 1 5 2 1 6 0 2 7 1 2 8 2 2 9 0 3 10 1 3 11 2 3 */ &#125;&#125; 향상된 for문","text":"반복문for문12345678910111213141516171819202122232425public class test2 &#123; public static void main(String[] args) &#123; System.out.println(&quot;i \\t i % 3 \\t i / 3&quot;); for(int i=0; i&lt;12;) System.out.printf(&quot;%d \\t %d \\t %d%n&quot;, i, i%3, i++/3); /* i % n에서 % 연산자는 n개의 숫자가 연속적으로 순환하면서 나오고 i / n에서 / 연산자는 동일한 숫자가 n번 연속해서 나온다. 알고리즘 어딘가 쓰일지 모르니 기억해두자. i i % 3 i / 3 0 0 0 1 1 0 2 2 0 3 0 1 4 1 1 5 2 1 6 0 2 7 1 2 8 2 2 9 0 3 10 1 3 11 2 3 */ &#125;&#125; 향상된 for문배열이나 컬렉션을 순회할 때만 사용할 수 있다.es6의 for of와 유사하다. 1234567const nums = [1, 2, 3];/* 1 2 3 */for(const num of nums) console.log(num); 1234567891011public class test2 &#123; public static void main(String[] args) &#123; int nums[] = &#123;4, 5, 6&#125;; /* 4 5 6 */ for(int num : nums) System.out.println(num); &#125;&#125; while문for문과 while문은 항상 변환이 가능하다.for는 반복할 횟수에 포커스를, while은 조건에 포커스를 뒀다. 연습문제 오답 char 범위 구하기자꾸만 아스키 코드의 함정에 갇혀있다.오답은 아닌데 어차피 int로 변환되므로 굳이 아스키코드로 대조하지 않아도숫자인지 영어인지 비교가 가능했다.ch &gt; 47 &amp;&amp; ch &lt; 58가 아니라&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;=&#39;9&#39;(ch &gt; 64 &amp;&amp; ch &lt; 91) || ( ch &gt; 96 &amp;&amp; ch &lt; 123)가 아니라(&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;z&#39;) || (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;Z&#39;) boolean형 변수 powerOn가 false일 때 true인 조건식한 가지 경우밖에 떠올리지 못했다. !powerOn powerOn &#x3D;&#x3D; false powerOn !&#x3D; true 정수, 음수 교차 합산 문제또 한번 나의 머리를 강타한 문제다.내가 굉장히 편협한 사고 방식을 가지고 있는 게 아닐까 하는 생각이 들었다.정답을 살짝 보고 나와 다른 것 같아서 아무리 생각해봤지만…저자의 발끝만치도 따라오지 못했다.정말 반성해야겠다.&amp;nbsp;1+(-2)+3+(-4)+… 과 같은 식으로 계속 더해나갔을 때, 몇까지 더해야 총합이 100이상이 되는지 구하시오.&amp;nbsp;내가 생각한 답안 1234567891011public class test2 &#123; public static void main(String[] args) &#123; int i=1, sum=0; while(sum &lt; 100) &#123; sum += i; i = i&gt;0 ? -(++i) : -(--i); &#125; i = i&gt;0 ? i : -i; System.out.printf(&quot;sum: %d, i: %d&quot;, sum, --i); &#125;&#125; 저자가 제시한 답안s라는 부호 변수를 놓고, 토글시키면서 쓸 줄은 전혀 몰랐다… 12345678910public class test2 &#123; public static void main(String[] args) &#123; int i = 0, s = 1, sum = 0; while(sum &lt; 100) &#123; sum += ++i * s; s = -s; &#125; System.out.printf(&quot;sum: %d, i: %d&quot;, sum, i); &#125;&#125; 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수필요없는 sum을 선언했었다.다른 곳에서 쓰지 않는 변수는 따로 캐싱을 하지 않아도 된다. 1234567public class test2 &#123; public static void main(String[] args) &#123; for(int i=0; ++i&lt;6;) for(int j=0; ++j&lt;6;) if(i+j == 6) System.out.printf(&quot;i: %d, j: %d%n&quot;, i, j); &#125;&#125; 정수형 변수에 랜덤한 값 담기. 12// 형변환을 꼭 해줘야하고, + 이전까지가 실수이므로 랩핑은 거까지만 해주면 됨.int rnd = (int)(Math.random() * 6) + 1; 문자를 정수로 바꾸기.parseInt가 만능이 아니었다. 123char ch = &#x27;4&#x27;;int num = Integer.parseInt(&quot;&quot; + ch);int num2 = ch - &#x27;0&#x27;; // - 연산에 의해 int로 둘 다 형변환 되서 연산이 진행됨. 정수의 각 자릿수 구하기.문자열이면 정수로 바꾸고 진행하는 게 맘 편하다. 12345678910public class test &#123; public static void main(String[] args)&#123; int num = 12345; while(num &gt; 0) &#123; // 이 놈의 조건이 참 유용하다. 괜히 for로 해서 변수 선언할 필요 없다. System.out.println(num % 10); num /= 10; // 결국 마지막엔 10 이하의 값을 나누게 되므로 0이 된다. &#125; &#125;&#125; continue와 break이중 반복문이 있을 때 반복문에 이름을 붙이고, continue와 break 뒤에 반복문의 이름을 붙이면 해당 반복문을 탈출한다. 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; /*00 01 10 11*/ outer: for(int i=0; i&lt;2; i++) &#123; for(int j=0; j&lt;4; j++) &#123; if(j == 2) &#123; continue outer; &#125; System.out.print(i); System.out.println(j); &#125; &#125; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"반복문","slug":"반복문","permalink":"https://perfectacle.github.io/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"}]},{"title":"(ASM) 참고용 정리 - 기계어와 ASM, 고급 언어의 관계","slug":"ASM-ref-001","date":"2017-01-06T09:06:13.000Z","updated":"2022-10-30T08:42:16.055Z","comments":true,"path":"2017/01/06/ASM-ref-001/","link":"","permalink":"https://perfectacle.github.io/2017/01/06/ASM-ref-001/","excerpt":"가상 기계(Virtual Machine)기계를 추상화한 것.소프트웨어일 수도, 하드웨어일 수도 있다.각각의 가상 기계는 대응되는 언어들이 존재한다.아래의 표에서 레벨에 해당하는 것들이 가상 기계이다. Level Language High-Level Language Java, C, etc. Assembly Language x86 ASM, 65c816 ASM, etc. Instruction Set Architecture(ISA) Machine Code Digital Logic ??? 어셈블리어(Low-Level Language)","text":"가상 기계(Virtual Machine)기계를 추상화한 것.소프트웨어일 수도, 하드웨어일 수도 있다.각각의 가상 기계는 대응되는 언어들이 존재한다.아래의 표에서 레벨에 해당하는 것들이 가상 기계이다. Level Language High-Level Language Java, C, etc. Assembly Language x86 ASM, 65c816 ASM, etc. Instruction Set Architecture(ISA) Machine Code Digital Logic ??? 어셈블리어(Low-Level Language)기계어고급 언어로 만들던, 저급 언어(ASM)으로 만들던 어차피 기계어로 바뀌어 실행되게 된다. 즉 프로그래머는 무엇을 만들던 간에 사실 위와 같이 코딩하는 것이다.컴퓨터는 0과 1로 이루어진 전자 계산기이기 때문에 사실 0과 1만으로 이루어진기계어만으로 코딩이 가능하다는 사실이다.단, 가독성이 매우 안 좋아서 시간이 엄청 걸린다는 단점이 존재한다.이러한 단점을 보완하고자 기계어와 1:1로 매칭되는 어셈블리어를 만들고,그 어셈블리어를 기계어로 해석해주는 가상 기계를 만들게 된 것이다.하지만 특정 프로세서에 의존적이기 때문에 이식성이 없다. 고급 언어(High-Level Language)컴퓨터의 성능이 비약적으로 발전함에 따라 단순한 어플리케이션이 아니라방대한 규모의 어플리케이션들을 개발하기 시작했다.하지만 기계어와 1:1로 매칭되는 어셈블리어로 개발하기에는시간과 유지보수 측면에서 너무나 많은 제약이 존재하였다.이러한 단점을 보완하고자 어셈블리어를 좀 더 추상화 시킨 고급 언어가 등장하게 된다.고급 언어는 어셈블리어와 일대다 관계를 가지고,이는 기계어와도 일대다 관계를 가진다는 것을 뜻한다.아래 예시를 통해 무슨 말인지 이해하자. 12int Y;int X = (Y + 4) * 3; 고급 언어로는 딱 2줄에 불과한 코드이다.이 코드가 기계어와 1대1로 매칭되는 어셈블리어로 변환시켜 보자. 12345mov eax, Y ; move Y to the EAX registeradd eax, 4 ; add 4 to the EAX registermov ebx, 3 ; move 3 to the EBX registerimul ebx ; multiply EAX by EBXmov X, eax ; move EAX to X 위와 같이 단 2줄의 고급 언어 코드는 5줄의 어셈블리어와 매칭이 되는 걸 볼 수 있다. 어셈블리어는 왜 쓸까?누가 요새 저렇게 무식(?)한 문법으로 코딩을 하냐고 비아냥 할 수 있다.생산성이 무지 낮은 건 사실이다.하지만 고급 언어에서 불가능한 것이 있다.바로 하드웨어의 직접 접근을 제공하지 않는 경우가 많다.하드웨어, 장치 드라이버, 펌웨어 등등을 개발할 때하드웨어로 직접 접근하지 못한다는 것은 매우 치명적이다.또한 메모리를 매우 경제적으로 사용하기 때문에소량의 메모리를 가지고 있는 전화기, 냉장고 등등의임베디드 프로그램을 작성할 때 제격이다. 장치 드라이버일반적인 운영체제 명령어에 대응하는 구체적인 하드웨어 동작으로 변환하는 프로그램.똑같은 장치라 하더라도 운영체제에 따라서 다른 장치 드라이버를 개발해야한다. 저는 임베디드나 하드웨어 쪽 개발을 안 할건데요?어셈블리어를 배우면 하드웨어, 운영체제, 응용 프로그램 간의상호 작용을 전체적으로 이해하는데 큰 도움을 준다.지금 당장은 어렵고 지루하더라도 훗날에 큰 도움이 되리라 믿고 있다. 각 가상 기계별 언어 호환 방법?기계어의 상위 언어(저급, 고급 언어)들은 L1이라고 칭하겠다. 해독(Interpretation) - 인터프리터??L1 프로그램이 실행됨에 따라 L1의 각 명령어는기계어로 작성된 프로그램에 의해서 해독(decode)되기 때문에실행이 가능해진다.L1 프로그램은 즉시 실행되기 시작하지만각 명령어는 먼저 해동되어야 실행될 수 있다. 변환(Translation) - 컴파일??L1 프로그램 전체가 특별히 설계된 기계어 프로그램에 의해기계어 프로그램으로 변환된다.그 후 변환된 기계어 프로그램은 컴퓨터 하드웨어에서 직접 실행될 수 있다. 어셈블러, 링커, 디버거 어셈블러 (Assembler)어셈블리 언어로 작성된 소스 코드를 기계어로 변환하는 유틸리티 프로그램 링커 (Linker)어셈블러가 생성한 각각의 파일들을 하나의 실행 파일로 합치는 유틸리티 프로그램 디버거 (Debugger)프로그램이 실행되는 동안 프로그램을 단계적으로 실행하고,레지스터와 메모리를 살펴보는 유틸리티 프로그램 javap를 이용해서 자바 클래스를 역어셈블(Deassemble)해보자.Javap 란? (자바 역어셈블러)역어셈블은 바이트 코드로 변환된 class 파일을원본인 고급 언어(java)로 역컴파일(Decompile) 하는 게 아니라클래스 파일 내부의 기본 구조와 역어셈블 코드(JVM의 바이너리 코드)만 나오게 된다.클래스 내부의 상수와 함수들의 목록을 볼 때 유용하게 쓰인단다. 123456public class test2 &#123; public static void main(String[] args) &#123; int Y = 6; int X = (Y + 4) * 3; &#125;&#125; 12345678910javap -c test20: bipush 6 // 6을 push??2: istore_1 // 1번 레지스터에 저장3: iload_1 // 1번 레지스터를 로드4: iconst_4 // 상수 45: iadd // 로드한 값(1번 레지스터와 상수 4)을 덧셈한 값을 1번 레지스터에 저장.6: iconst_3 // 상수 37: imul // 로드한 값(1번 레지스터와 상수 3)을 곱한 값을 1번 레지스터에 저장.8: istore_2 // 로드한 값(1번 레지스터)를 2번 레지스터에 저장.9: return // 함수 종료 진수 변환하기이는 프로그래밍 언어마다 대체적으로 내장된 라이브러리들이 있다.하지만 진수를 손으로 변환하는 알고리즘을 그대로 옮긴다고 생각하고,즉 내장된 라이브러리를 직접 구현한다는 생각으로 코딩을 해보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class test &#123; // Integer.toParseInt(String int, int radix)를 구현(radix는 2로 고정) // 2진수 문자열을 10진수 정수로 반환. int binToDec(String bin) &#123; int decimal = 0; int bitIdx; for(int i=0; i&lt;bin.length(); i++) &#123; // 비트 별로 하나씩 뽑아서 문자를 정수로 변경. bitIdx = Integer.parseInt(bin.substring(i, i+1)); // 2^n-1-i * bitIdx; if(bitIdx != 0) decimal += Math.pow(2, bin.length()-1-i) * bitIdx; &#125; return decimal; &#125; // Integer.toParseInt(String hex, int radix)를 구현(radix는 16으로 고정) // 16진수 문자열을 10진수 정수로 반환. static int hexToDec(String hex) &#123; int decimal = 0; int bitIdx; for(int i=0; i&lt;hex.length(); i++) &#123; // 비트 별로 하나씩 뽑아서 문자를 정수로 변경. switch (hex.substring(i, i+1)) &#123; case &quot;A&quot;: case &quot;a&quot;: bitIdx = 10; break; case &quot;B&quot;: case &quot;b&quot;: bitIdx = 11; break; case &quot;C&quot;: case &quot;c&quot;: bitIdx = 12; break; case &quot;D&quot;: case &quot;d&quot;: bitIdx = 13; break; case &quot;E&quot;: case &quot;e&quot;: bitIdx = 14; break; case &quot;F&quot;: case &quot;f&quot;: bitIdx = 15; break; default: bitIdx = Integer.parseInt(hex.substring(i, i+1)); &#125; // 16^n-1-i * bitIdx; if(bitIdx != 0) decimal += Math.pow(16, hex.length()-1-i) * bitIdx; &#125; return decimal; &#125; // Integer.toBinaryString(int dec)를 구현. // 10진수 정수를 2진수 문자열로 반환. String decToBin(int dec) &#123; int quot = dec; String rest = &quot;&quot;; while(quot &gt; 1) &#123; rest = quot % 2 + rest; quot = quot / 2; &#125; return quot + rest; &#125; // Integer.toHexString(int dec)를 구현. // 10진수 정수를 16진수 문자열로 반환. String decToHex(int dec) &#123; int quot = dec; String rest = &quot;&quot;; while(quot &gt; 15) &#123; switch (quot % 16) &#123; case 10: rest = &quot;A&quot; + rest; break; case 11: rest = &quot;B&quot; + rest; break; case 12: rest = &quot;C&quot; + rest; break; case 13: rest = &quot;D&quot; + rest; break; case 14: rest = &quot;E&quot; + rest; break; case 15: rest = &quot;F&quot; + rest; break; default: rest = quot % 16 + rest; &#125; quot = quot / 16; &#125; switch (quot) &#123; case 10: return &quot;A&quot; + rest; case 11: return &quot;B&quot; + rest; case 12: return &quot;C&quot; + rest; case 13: return &quot;D&quot; + rest; case 14: return &quot;E&quot; + rest; case 15: return &quot;F&quot; + rest; default: return quot + rest; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ASM","slug":"Programming/ASM","permalink":"https://perfectacle.github.io/categories/Programming/ASM/"}],"tags":[{"name":"ASM","slug":"ASM","permalink":"https://perfectacle.github.io/tags/ASM/"},{"name":"Assembly","slug":"Assembly","permalink":"https://perfectacle.github.io/tags/Assembly/"}]},{"title":"(C++) 참고용 정리 - 변수의 주소","slug":"Cpp-ref-001","date":"2017-01-02T09:59:21.000Z","updated":"2022-10-30T08:42:16.071Z","comments":true,"path":"2017/01/02/Cpp-ref-001/","link":"","permalink":"https://perfectacle.github.io/2017/01/02/Cpp-ref-001/","excerpt":"","text":"12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int num2 = 11; int num = 11; int num3 = num; // 같은 값이던 변수를 참조하던 다른 메모리 공간을 차지함. cout &lt;&lt; &amp;num2 &lt;&lt; endl; // 0x7FFF5322DAD8 cout &lt;&lt; &amp;num &lt;&lt; endl; // 0x7FFF5322DAD4 cout &lt;&lt; &amp;num3 &lt;&lt; endl; // 0x7FFF5322DAD0 return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Pointer","slug":"Pointer","permalink":"https://perfectacle.github.io/tags/Pointer/"},{"name":"Address","slug":"Address","permalink":"https://perfectacle.github.io/tags/Address/"}]},{"title":"(Java) 자바의 정석 3판 004일차 - 연산자(우선 순위 및 결합 규칙), switch 문","slug":"Java-study-004day","date":"2017-01-02T09:05:49.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/01/02/Java-study-004day/","link":"","permalink":"https://perfectacle.github.io/2017/01/02/Java-study-004day/","excerpt":"연산자 우선순위x &lt;&lt; 2 **+** 1 &#x3D;&gt; x &lt;&lt; (2 + 1)data &amp; 0xFF **&#x3D;&#x3D;** 0 &#x3D;&gt; data &amp; (0xFF &#x3D;&#x3D; 0)x &lt; -1 || x &gt; 3 &amp;&amp; x &lt; 5 &#x3D;&gt; x &lt; -1 || (x &gt; 3 &amp;&amp; x &lt; 5) 괄호는 연산자가 아닌 우선순위를 임의로 정하는 기호임. 연산자 결합 규칙","text":"연산자 우선순위x &lt;&lt; 2 **+** 1 &#x3D;&gt; x &lt;&lt; (2 + 1)data &amp; 0xFF **&#x3D;&#x3D;** 0 &#x3D;&gt; data &amp; (0xFF &#x3D;&#x3D; 0)x &lt; -1 || x &gt; 3 &amp;&amp; x &lt; 5 &#x3D;&gt; x &lt; -1 || (x &gt; 3 &amp;&amp; x &lt; 5) 괄호는 연산자가 아닌 우선순위를 임의로 정하는 기호임. 연산자 결합 규칙x &#x3D; y &#x3D; 3 &#x3D;&gt; x &#x3D; 3 &#x3D;&gt; x &#x3D; 3, y &#x3D; 3식을 평가하면 단 하나의 결과를 얻을 수 있음.할당 연산자인 y &#x3D; 3도 하나의 식으로 쓸 수 있으며저장된 값, 즉 3을 결과로 반환함. 123456public class test &#123; public static void main(String[] args) &#123; int num; System.out.println(num = 3); // 3 &#125;&#125; 형변환타입이 다른 피 연산자끼리의 연산은 값 손실 최소화를 위해 큰 타입으로 자동 변환.형변환 연산자 생략해도 자동으로 붙음.연산 결과도 큰 타입의 결과로 반환.1.1f + 1L &#x3D;&gt; 1.1f + (float)1L &#x3D;&gt; 1.1f + 1.0f &#x3D; 2.1fint보다 작은 byte, short, char는 자동으로 int로 바뀜.1 + ‘A’ &#x3D;&gt; 1 + (int)’A’ &#x3D;&gt; 1 + 65 &#x3D; 66boolean을 제외한 기본형은 연산이 가능함. 1234567891011public class test &#123; public static void main(String[] args) &#123; boolean j = true; // 다 오류다. System.out.println(j + &#x27;A&#x27;); System.out.println(j + 1); System.out.println(j + 2.1); System.out.println(++j); System.out.println(j &lt;&lt; 0); &#125;&#125; 산술 연산0으로 나눴을 때 무조건 오류가 나는 게 아니었다. 123456public class test &#123; public static void main(String[] args) &#123; System.out.println(3.0 / 0); // Infinity, 3.0 / 0.0 으로 형변환이 일어나기 때문. System.out.println(3 / 0); // java.lang.ArithmeticException: / by zero &#125;&#125; 나머지 연산자도 한번 보자. 123456public class test &#123; public static void main(String[] args) &#123; System.out.println(3.0 % 0); // NaN System.out.println(3 % 0); // java.lang.ArithmeticException: / by zero &#125;&#125; int 보다 작은 타입끼리의 연산은 형변환이 필수적이다. 1234567891011public class test &#123; public static void main(String[] args) &#123; byte num = 1, num2 = 3, num3; num3 = 1 + 2; // 에러 발생 안함. num3 = (byte)(num + num2); // 이렇게 해줘야함. // (byte)num + num2 =&gt; (byte)num + (int)num2 =&gt; (int)num + (int)num2와 같아짐. num3 = (byte)num + num2; // 에러 발생. // + 때문에 형변환이 발생. num3 = num + num2; // (int)num + (int)num2 =&gt; (int)(num + num2)가 됨. &#125;&#125; 더 큰 타입으로 선언했다고 해도 형변환 연산을 적절하게 써줘야 손실이 일어나지 않는다. 123456789101112131415public class test &#123; public static void main(String[] args) &#123; int num = 1000000; int num2 = 2000000; // int 형을 long으로 변환 후에 저장. (long)(num * num2) // 이미 오버플로우가 발생한 int를 long으로 변환한들 원래 값으로 돌아오지 않음. long num3 = num * num2; System.out.println(num3); // -1454759936 // 아래 3가지 중 하나처럼 하면 됨. num3 = (long)num * num2; num3 = num * (long)num2; num3 = (long)num * (long)num2; System.out.println(num3); &#125;&#125; 리터럴과 상수 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에컴파일러가 미리 덧셈 연산을 수행한 후 그 결과를 저장함.int num &#x3D; 11 * 11이라고 치면 컴파일 후에는int num &#x3D; 121이 저장되는 거임.하지만 변수가 들어간 연산은 계산 결과를 예측할 수가 없음.int num &#x3D; num2 * 11이라고 치면 컴파일 후에도int num &#x3D; num2 * 11이 저장됨. 위와 같은 이유로 리터럴과 상수 간의 연산은 계산 결과를 예측가능하기 때문에형변환 연산자가 생략이 가능한 경우도 있음. 1234567891011public class test &#123; public static void main(String[] args)&#123; char c1 = &#x27;a&#x27;; final char c2 = &#x27;b&#x27;; char c3 = &#x27;a&#x27; + 1; // 리터럴 간의 연산이므로 컴파일 후엔 &#x27;b&#x27;가 저장됨. char c4 = c2 + 1; // 상수와 리터럴 간의 연산이므로 컴파일 후엔 &#x27;c&#x27;가 저장됨. // 에러, 변수가 껴있는 연산이므로 컴파일 후에도 c1 + 1로 저장됨. // 컴파일 후에 c1이 int보다 작으므로 (int)c1 + 1과 같이 변하게 됨. char c5 = c1 + 1; &#125;&#125; 문자열 비교 메소드 equals()문자열 클래스 String은 기본형이 아니다.따라서 String 클래스의 인스턴스들은 참조형이다.참조형은 변수, 상수에 값을 저장하는 게 아니라 주소(번지)를 저장한다. 123456789101112public class test &#123; public static void main(String[] args)&#123; String str = new String(&quot;ab&quot;); String str2 = new String(&quot;ab&quot;); System.out.println(str == str2); // false, 둘은 다른 주소값을 참조함. System.out.println(str.equals(str2)); // true, 둘은 같은 문자열을 갖고 있음. str = str2 = &quot;ab&quot;; // new 키워드를 쓰지 않으면 클래스의 인스턴스가 되지 않아서인지 둘 다 true System.out.println(str == str2); // true System.out.println(str.equals(str2)); // true &#125;&#125; 문자가 숫자인가? 영문자인가?123456789public class test &#123; public static void main(String[] args)&#123; char ch = &#x27;1&#x27;; System.out.println(&#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;); // 숫자면 true ch = &#x27;c&#x27;; // 괄호가 없어도 되지만 가독성을 위해 넣음. System.out.println((&#x27;A&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;Z&#x27;) || (&#x27;a&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;z&#x27;)); // 영어 대소문자면 true &#125;&#125; 효율적인 논리 연산자x || y &#x3D;&gt; x가 참이면 무조건 참.즉 x가 참이면 y는 평가하지도 않음.x &amp;&amp; y &#x3D;&gt; x가 거짓이면 무조건 거짓.즉 x가 거짓이면 y는 평가하지도 않음.이렇게 좌변에 어떤 값을 넣는가에 따라서 연산 속도에 영향을 미침. 1234567891011121314151617181920public class test &#123; public static void main(String[] args)&#123; int num = 0, num2 = 1; System.out.println(num == 0 || ++num2 != 0); // num == 0이 참이되자 ++num2는 실행도 안 됨. System.out.println(num + &quot; &quot; + num2); // 0 1 System.out.println(num != 0 || ++num2 == 0); // num != 0이 거짓이되자 ++num2가 실행됨. System.out.println(num + &quot; &quot; + num2); // 0 2 System.out.println(num != 0 &amp;&amp; ++num2 == 0); // num != 0이 거짓이되자 ++num2는 실행도 안 됨. System.out.println(num + &quot; &quot; + num2); // 0 2 System.out.println(num == 0 &amp;&amp; ++num2 == 0); // num == 0이 참이되자 ++num2가 실행 됨. System.out.println(num + &quot; &quot; + num2); // 0 3 &#125;&#125; 비트 연산자전자 계산기를 배우니까 드디어 이해가 간다.논리 게이트에서 AND 연산자(&amp;)특정 비트의 값을 뽑아낼 때 사용. OR 연산자(|)특정 비트의 값을 변경할 때 사용. XOR 연산자(^)XOR을 한 번 때리면 암호화, 두 번 때리면 복호화 NOT 연산자(~)1의 보수를 얻을 때 사용.십진수를 이진수로 바꾼 후 각 비트별로 연산을 때린 후 다시 십진수로 바꾼 결과를 반환한다.123456789101112131415161718192021222324252627282930313233343536373839public class test &#123; static String toBinaryString(int num) &#123; String zero = &quot;00000000000000000000000000000000&quot;; String tmp = zero + Integer.toBinaryString(num); return tmp.substring(tmp.length()-32); &#125; public static void main(String[] args)&#123; /* num = 0XAB 00000000000000000000000010101011 num2 = 0XF 00000000000000000000000000001111 0XAB &amp; 0XF = 0XB 00000000000000000000000000001011 0XAB | 0XF = 0XAF 00000000000000000000000010101111 0XAB ^ 0XF = 0XA4 00000000000000000000000010100100 0XAB ^ 0XF ^ 0XF = 0XAB 00000000000000000000000010101011 num3 = 0X2 00000000000000000000000000000010 ~num3 = -3 11111111111111111111111111111101 num3 + ~num3 = -1 11111111111111111111111111111111 ~num3 + 1 = -2 11111111111111111111111111111110 */ int num = 0xAB, num2 = 0xF, num3 = 2; System.out.printf(&quot;num = %#X\\t\\t\\t\\t\\t%s%n&quot;, num, toBinaryString(num)); System.out.printf(&quot;num2 = %#X\\t\\t\\t\\t\\t%s%n&quot;, num2, toBinaryString(num2)); // 1인 비트들만 뽑아냄. System.out.printf(&quot;%#X &amp; %#X = %#X\\t\\t\\t%s%n&quot;, num, num2, num &amp; num2, toBinaryString(num &amp; num2)); // 특정 비트들을 1로 바꿈. System.out.printf(&quot;%#X | %#X = %#X\\t\\t\\t%s%n&quot;, num, num2, num | num2, toBinaryString(num | num2)); // 간단한 암호화. System.out.printf(&quot;%#X ^ %#X = %#X\\t\\t\\t%s%n&quot;, num, num2, num ^ num2, toBinaryString(num ^ num2)); // 간단히 암호화한 것을 복호화. System.out.printf(&quot;%#X ^ %#X ^ %#X = %#X\\t\\t%s%n&quot;, num, num2, num2, num ^ num2 ^ num2, toBinaryString(num ^ num2 ^ num2)); System.out.printf(&quot;num3 = %#X\\t\\t\\t\\t\\t%s%n&quot;, num3, toBinaryString(num3)); // 1의 보수를 구함. System.out.printf(&quot;~num3 = %d\\t\\t\\t\\t\\t%s%n&quot;, ~num3, toBinaryString(~num3)); // 직접 더해보니 모든 비트가 1이 되는 걸 보니 1의 보수가 맞음. System.out.printf(&quot;num3 + ~num3 = %d\\t\\t\\t%s%n&quot;, num3 + ~num3, toBinaryString(num3 + ~num3)); // 1의 보수에 1을 더하면 2의 보수, 즉 음수를 구할 수 있음. System.out.printf(&quot;~num3 + 1 = %d\\t\\t\\t\\t%s%n&quot;, ~num3 + 1, toBinaryString(~num3 + 1)); &#125;&#125; 쉬프트 연산자연산 속도가 상당히 빠르다.하지만 가독성이 안 좋다.피연산자의 타입을 일치시키지 않는다.byte, short, char는 int로 자동 형변환이 일어난다.속도가 엄청 중요시되는 곳이 아니면 곱셈, 나눗셈을 쓰자. 삼항 연산자역시 형변환이 일어난다. 12345public class test &#123; public static void main(String[] args) &#123; System.out.println(true ? 0 : .1); // 0.0 &#125;&#125; 대입 연산자(할당 연산자)lvalue &#x3D; rvaluel은 left, r은 right의 준말.lvalue에는 변수와 이 값을 변경할 수 있는 것만 들어갈 수 있고,rvalue에는 변수 뿐만 아니라 식, 상수, 리터럴 등등이 가능하다. x &#x3D; y &#x3D; 3 y &#x3D; 3 &#x3D;&gt; 3 x &#x3D; 3 복합 연산자123456789public class test &#123; public static void main(String[] args) &#123; int i = 1, j = 2; i += 1 + j; // i = i + (1 + j) = i + 1 + j System.out.println(i); // 4 i *= 1 + j; // i = i * (1 + j) System.out.println(i); // 12 &#125;&#125; 반복문 - switch장단점 가독성이 좋아짐. 조건을 한 번만 검사하면 돼서 속도가 빠름. if 문으로 표현 가능하나 switch 문으로 표현 불가능한 경우가 있음. 제약조건 switch 조건식은 (정수)리터럴, 변수, 상수, (문자)리터럴, 변수, 상수, (문자열)리터럴, 변수, 상수만 가능 case 문의 값은 정수 리터럴, 정수 상수, 문자 리터럴, 문자 상수, 문자열 리터럴, 문자열 상수만 가능함. 문자는 자동으로 int형으로 변환돼서 정수와 같이 취급됨. 자바7부터 문자열 관련 내용이 추가됨.123456789101112131415161718public class test &#123; public static void main(String[] args) &#123; final int num = 48; int num2 = 47; switch (&#x27;1&#x27;) &#123; case 49: // 조건식은 char이지만 int와 호환 가능 System.out.println(&quot;str&quot;); break; case num: // num은 final 지정 예약어를 써서 상수로 만들었으므로 가능함. System.out.println(&quot;str&quot;); break; case num2: // 변수는 불가능! System.out.println(&quot;str&quot;); break; case &quot;asdf&quot;: // 조건식은 char인데 값은 string이라서 오류. &#125; &#125;&#125; 연습 문제 오답 연산자의 우선 순위사칙 연산이 시프트 연산자보다 우선순위가 높다. 1234567public class test &#123; public static void main(String[] args) &#123; int x = 2; // int는 32비트, 33 % 32 = 1; System.out.println(1 + x &lt;&lt; 33); // 3 &lt;&lt; 33 = 3 &lt;&lt; 1 = 3 * 2^1 = 3 * 2 = 6 &#125;&#125; 나의 머리를 때린 문제 아래는 변수 num의 값보다 크면서도 가장 가까운 10의 배수에서 변수 num의 값을뺀 나머지를 구하는 코드이다. 예를 들어 24의 크면서도 가장 가까운 10의 배수는 30이다.19의 경우 20이고, 81의 경우 90이 된다. 30에서 24를 뺀 나머지는 6이기 때문에변수 num의 값이 24라면 6을 결과로 얻어야 한다. 123456789public class test &#123; public static void main(String[] args) &#123; int num = 24; // 내가 생각한 답. System.out.println((num / 10 + 1) * 10 - num); // 저자가 생각한 답. 진짜 천재다. 문제는 함정 투성이었다 ㅠㅠ System.out.println(10 - num%10); &#125;&#125; 실수형 비교boolean result &#x3D; d&#x3D;&#x3D;f2; → boolean result &#x3D; (float)d&#x3D;&#x3D;f2;비교연산자도 이항연산자이므로 연산 시에 두 피연산자의 타입을 맞추기 위해 형변환이 발생한다.그래서 double과 float의 연산은 double과 double의 연산으로 자동형변환 되는데실수는 정수와 달리 근사값으로 표현을 하기 때문에 float를 double로 형변환했을 때 오차가 발생할 수 있다.그래서 float값을 double로 형변환하기 보다는 double값을 유효자리수가 적은float로 형변환해서 비교하는 것이 정확한 결과를 얻는다.&amp;nbsp;이제부터 나만의 해설.같은 수가 있을 때 float로 표현한 실수가 double로 표현한 실수보다 오차가 클 수 있다.따라서 오차가 큰 float를 double로 바꿔도 오차가 큰 double이 된다.따라서 float를 double로 바꿨다 하더라도오차가 큰 double와 오차가 작은 double을 비교하면 신뢰할 수 없는 값이 나온다.그럼 역으로 오차가 작은 double을 오차가 큰 float로 형변환 시키는 것이다.이러한 역발상을 통해 둘 다 오차가 큰 float로 만들어서 비교하면 신뢰할 수 있는 결과가 나온다.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"연산자","slug":"연산자","permalink":"https://perfectacle.github.io/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"조건문","slug":"조건문","permalink":"https://perfectacle.github.io/tags/%EC%A1%B0%EA%B1%B4%EB%AC%B8/"}]},{"title":"(Java) 자바의 정석 3판 003일차 - 형변환, 정규화, 연산자","slug":"Java-study-003day","date":"2017-01-01T20:00:22.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2017/01/01/Java-study-003day/","link":"","permalink":"https://perfectacle.github.io/2017/01/01/Java-study-003day/","excerpt":"형변환(캐스팅, Casting)기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 형변환이 가능.역시 자스를 먼저 배우고 나니 자스의 자유로운 형변환이 그리울 때가 있다.또한 기본형과 참조형(reference type)간의 형변환은 불가능하다.또한 실수형을 정수형으로 바꾸면 반올림 하지 않고 소수점 이하를 다 짜른다.왜냐하면 정수형에서는 소수점 이하를 표현할 방법이 없기 때문이다.형변환을 할 때 캐스팅 연산자를 써줘야하지만 생략하면 자동으로 컴파일러가 붙여준다.하지만 손실이 발생할 수 있는 경우에는 오류가 발생한다.따라서 손실이 발생하는 경우에는 무조건 캐스팅 연산자를 써줘야한다. 1234567891011121314151617public class test &#123; public static void main(String[] args) &#123; char ch = &#x27;A&#x27;; short num = 255; int num2 = num; num2 = ch; long num3 = 12345678781234L; // float은 4byte지만 부동 소수점 형태로 표현되기 때문에 8byte인 long보다 더 넓은 범위를 표현할 수 있다. // 하지만 정밀도 때문에 오차가 발생할 수는 있다. float num4 = num3; double num5 = num3; // ch와 num은 둘 다 2byte지만 ch는 unsigned short와 같이 부호가 없으므로 표현 범위가 다름. // 따라서 서로 손실이 발생하므로 형변환 연산자가 꼭 존재해야함. ch = (char)num; num = (short)ch; &#125;&#125; 십진수를 2진수로 보기","text":"형변환(캐스팅, Casting)기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 형변환이 가능.역시 자스를 먼저 배우고 나니 자스의 자유로운 형변환이 그리울 때가 있다.또한 기본형과 참조형(reference type)간의 형변환은 불가능하다.또한 실수형을 정수형으로 바꾸면 반올림 하지 않고 소수점 이하를 다 짜른다.왜냐하면 정수형에서는 소수점 이하를 표현할 방법이 없기 때문이다.형변환을 할 때 캐스팅 연산자를 써줘야하지만 생략하면 자동으로 컴파일러가 붙여준다.하지만 손실이 발생할 수 있는 경우에는 오류가 발생한다.따라서 손실이 발생하는 경우에는 무조건 캐스팅 연산자를 써줘야한다. 1234567891011121314151617public class test &#123; public static void main(String[] args) &#123; char ch = &#x27;A&#x27;; short num = 255; int num2 = num; num2 = ch; long num3 = 12345678781234L; // float은 4byte지만 부동 소수점 형태로 표현되기 때문에 8byte인 long보다 더 넓은 범위를 표현할 수 있다. // 하지만 정밀도 때문에 오차가 발생할 수는 있다. float num4 = num3; double num5 = num3; // ch와 num은 둘 다 2byte지만 ch는 unsigned short와 같이 부호가 없으므로 표현 범위가 다름. // 따라서 서로 손실이 발생하므로 형변환 연산자가 꼭 존재해야함. ch = (char)num; num = (short)ch; &#125;&#125; 십진수를 2진수로 보기123456789public class test &#123; public static void main(String[] args) &#123; int num = (int)-2.8d; // num = 11111111111111111111111111111110 System.out.println(&quot;num = &quot; + Integer.toBinaryString(num)); num = (int)2.8d; System.out.println(&quot;num = &quot; + Integer.toBinaryString(num)); // num = 10 &#125;&#125; 정규화정규표현식의 정규는 많이 들어봤는데 그것과는 많이 다른 것이다.기본적으로 부동소수점에 대한 이해를 하고 있어야한다.우선 정의부터 살펴보면 2진수로 변환된 실수를 저장기 전에 1.xxx x 2n의 형태로 변환하는 과정.2진수로 변환된 실수를 정수부에 1만 남기고 소수점에 관한 정보는 2n으로 표현한 것. 십진 실수 10.625를 2진 실수로 바꾸면 1010.101이다.2진수로 변환된 실수를 정규화하면 1.010101 x 23가 된다.이를 지수 표기법(Exponential Notation)으로 바꾸면 1.010101e3이 된다.이 정규화된 수를 토대로 IEE754로 표기하여 저장하는 것이다. 연산자(operator) 식(expression)연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것.2+3 등등 식을 평가(evaluation)하다.식을 계산하여 결과를 얻는 것단 하나의 식을 평가(계산)하면 단 하나의 결과를 얻음. 문(statement)식을 프로그램에 포함시키려면 식의 끝에 세미콜론을 붙여 하나의 문으로 만들어야함.2+3; 등등하지만 결과를 얻었지만 쓰이지 않고 사라지기 때문에 무의미함.나중에 사용하기 위해 메모리 상의 공간(변수, 상수)에 저장한 후 꺼내 쓰면 됨.int num &#x3D; 1 + 2;int num2 &#x3D; num * 3;변수 선언 &#x3D; 식; &#x3D;&gt; 하나의 문장.하지만 다른 곳에서도 쓰이지 않을 결과라면 굳이 식을 문으로 바꾸지 않아도 됨.아래와 같이 메소드의 매개변수로 쓰이는 등등의 경우와 같음.System.out.println(2+3);식을 혼자 쓴 게 아니라 문 안에 식이 쓰인 것이다. 연습문제 오답 char의 형변환! 12345678public class test &#123; public static void main(String[] args) &#123; System.out.println(&#x27;A&#x27; + &#x27;B&#x27;); // 65 + 66 = 131 System.out.println(&#x27;1&#x27; + 2); // 49 + 2 = 51 System.out.println(&#x27;1&#x27; + &#x27;2&#x27;); // 49 + 50 = 99 System.out.println(&quot;&quot; + true); // &quot;true&quot; &#125;&#125; 문자열 + any type → 문자열 + 문자열 → 문자열any type + 문자열 → 문자열 + 문자열 → 문자열 System은 키워드가 아니었다! 참조형 변수(reference type) 4byte이다!!JAVA 변수타입참조형 변수는 null 또는 객체의 주소(4 byte, 0x0~0xffffffff)를 값으로 갖는다.null은 어떤 값도 갖고 있지 않음, 즉 어떠한 객체도 참조하고 있지 않다는 것을 뜻한다. 캐스팅 연산자 생략 1234567public class test &#123; public static void main(String[] args) &#123; int num = 0; // 표현할 수 있는 범위더라도 int =&gt; 4byte, byte =&gt; 1byte 이므로 캐스팅 연산자 꼭 써줘야함. byte num2 = num; &#125;&#125; 접근 지정자, 지정 예약어, 메소드접근 지정자 - public, protect, default, private지정 예약어 - this, static, final메소드 - 리턴타입 이름(매개변수) {}지정 예약어 this를 빼고 설명. 지정 예약어끼리는 순서 상관 없음 &#x3D;&gt; static final이던 final static이던 접근 지정자와 지정 예약어도 순서 상관 없음 &#x3D;&gt; public static이던 static public이던 하지만 메소드는 무조건 접근 지정자와 지정 예약어 뒤에 와야함. 접근 지정자를 생략하면 default 접근 지정자가 적용됨. 지정 예약어는 생략 가능하며 생략해도 기본값이 없음. 메소드에서는 매개변수를 제외한 모든 것은 생략 불가능. 즉 기본 값이 없음. 변수의 기본값 참조형 - null 기본형 boolean - false char - ‘\\u0000’ byte - 0 short - 0 int - 0 long - 0L or 0l float - 0.0F or 0.0f double - 0.0 or 0.0D or 0.0dbyte, short는 컴파일 할 때 자동으로 int 타입으로 바꿈.long에 접미어 L을 붙이는 이유는 int와 다른 메모리 공간을 차지하게 하기 위함.float도 double과 차별을 두기 위해 접미어를 붙이게 끔 설계됨.","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"형변환","slug":"형변환","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EB%B3%80%ED%99%98/"},{"name":"정규화","slug":"정규화","permalink":"https://perfectacle.github.io/tags/%EC%A0%95%EA%B7%9C%ED%99%94/"},{"name":"연산자","slug":"연산자","permalink":"https://perfectacle.github.io/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"}]},{"title":"(Java) 자바의 정석 3판 002일차 - char의 형변환과 실수형(부동 소수점)","slug":"Java-study-002day","date":"2016-12-31T18:12:20.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2016/12/31/Java-study-002day/","link":"","permalink":"https://perfectacle.github.io/2016/12/31/Java-study-002day/","excerpt":"char의 연산자별 형변환.전위&amp;후위 연산자는 형변환을 하지 않고기타 연산자는 int로 형변환을 함. 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; char ch = 65; System.out.println(ch++); // &#x27;A&#x27; System.out.println(ch); // &#x27;B&#x27; System.out.println(++ch); // &#x27;C&#x27; ch = 65; System.out.println(ch); // &#x27;A&#x27; System.out.println(ch+0); // 65 System.out.println(+ch); // 65 System.out.println(-ch); // -65 System.out.println(ch &lt;&lt; 1); // 130 System.out.println(ch); // &#x27;A&#x27; short num = 0; // num = ch + 1; // error int num2 = 0; num2 = ch + 1; // 에러가 나지 않음. &#125;&#125; 170102 내용 수정형변환은 쉬프트 연산자(&lt;&lt;, &gt;&gt;), 증감 연산자(++, –)에서만 일어나지 않음.","text":"char의 연산자별 형변환.전위&amp;후위 연산자는 형변환을 하지 않고기타 연산자는 int로 형변환을 함. 12345678910111213141516171819public class test &#123; public static void main(String[] args) &#123; char ch = 65; System.out.println(ch++); // &#x27;A&#x27; System.out.println(ch); // &#x27;B&#x27; System.out.println(++ch); // &#x27;C&#x27; ch = 65; System.out.println(ch); // &#x27;A&#x27; System.out.println(ch+0); // 65 System.out.println(+ch); // 65 System.out.println(-ch); // -65 System.out.println(ch &lt;&lt; 1); // 130 System.out.println(ch); // &#x27;A&#x27; short num = 0; // num = ch + 1; // error int num2 = 0; num2 = ch + 1; // 에러가 나지 않음. &#125;&#125; 170102 내용 수정형변환은 쉬프트 연산자(&lt;&lt;, &gt;&gt;), 증감 연산자(++, –)에서만 일어나지 않음. 오버 플로우(overflow)정수형최대값 + 1 &#x3D;&#x3D; 최소값최소값 - 1 &#x3D;&#x3D; 최대값 실수형최대값 + @ &#x3D;&#x3D; Infinity최소값 - @ &#x3D;&#x3D; -Infinity표현할 수 없는 아주 작은 0에 수렴하는 값 &#x3D;&#x3D; 0.0(underflow) 12345678public class test &#123; public static void main(String[] args) &#123; System.out.println(Float.MAX_VALUE * 2); // Infinity System.out.println(Float.MAX_VALUE * -2); // -Infinity System.out.println(Float.MIN_VALUE * 0.1f); // 0.0 (underflow) System.out.println(Float.MIN_VALUE * -0.1f); // -0.0 (underflow) &#125;&#125; 실수형의 오차IEEE 754전기 전자 기술자 협회(IEEE)에서 개발했고, 컴퓨터에서 부동 소수점을 표기하기 위한 표준.실수를 표기하는 데는 위와 같이 부동 소수점이 있고, 고정 소수점이 있다.고정 소수점은 매우 직관적이라는 장점이 있지만범위가 작고, 정밀도가 낮다.(이 말은 오차 없이 표현해낼 수 있는 수의 범위가 매우 좁다고 이해하면 되려나??)그에 따라 부동 소수점이 현재 쓰이는 것으로 알고 있다. 나는 정밀도(precision)에 대해 이해하지 못해서 정리를 해보자 한다.float 정밀도: 7자리double 정밀도: 15자리나는 아래와 같이 소수점을 제외한 십진수 7개를 뜻하는 줄 알았다.xxxx.xxxx.xxxxxx 뭐 반은 맞고 반은 틀렸달까… 예제를 보고 이해해보자. 123456789101112public class test &#123; public static void main(String[] args) &#123; // 정밀도는 오차 없이 표현하는 10진수의 갯수이다. // 오차가 있을 수도, 없을 수도 있다. // 10진수 8개를 오차없이 표현해냈다. System.out.println(1.2345678e-3f); // 0.0012345678 // 10진수 8개를 오차있이 표현해냈다. System.out.println(1.2345679e-3f); // 0.001234568 // double은 15자리의 정밀도를 가지므로 10진수 8개 정도는 거뜬하다. System.out.println(1.2345679e-3); // 0.0012345679 &#125;&#125; 또한 소수점 계산시 오차가 발생한다.0.1 + 0.2 &#x3D;&#x3D; 0.30000000000000004아주 괴랄한 숫자가 나온다.왜 나오는지 파악해보자.는 귀찮으니 아래 글들을 참고하자.소수점 때문에 바보가 되는 컴퓨터??컴퓨터에서는 0.1을 어떻게 저장&#x2F;표현 하나요?!10진수 소수점을 2진수 변환소수점끼리의 계산은 끝자리가 5로 끝나는 (0.00005, 0.231423415 등등) 숫자들끼리의 연산이 아니고서는정확한 값이 나온다는 확신을 가질 수가 없다.왜냐하면 5로 끝나지 않는 0.1 같은 십진 소수를 이진 소수로 바꿀 방법이 없다.10진수로는 유한소수여도 2진수로는 무한 소수인 경우가 존재하기 때문에…2진수로도 무한 소수가 아니더라도 가수를 저장할 수 있는 공간이 한정돼있기 때문에버려지는 수에 의해 오차가 발생하기도 한다.아마 같은 수라도 고정 소수점에서는 오차가 발생하지 않을 수도 있지 않을까.. 하는 생각을 한다.이는 부동 소수점이 가지는 단점이며 소수를 정수로 바꿔서 연산 후 다시 소수로 바꾸는 방법이 있다.정수는 오차가 없기 때문이다. 실수형의 정밀도왜 float은 7자리, double은 15자리의 정밀도를 가질까?그것은 float은 1자리의 부호 비트, 8자리의 지수 비트, 23자리의 가수 비트 &#x3D; 32비트23자리의 2진수 &#x3D;&gt; 약 7자리의 10진수가 표현이 가능하기 때문이다.double도 찾아보면 마찬가지의 공식으로 결과가 나온다. 바이어스 표기법부동소수점에 대한 이해위 링크를 참조하자. 부동 소수점에서 지수부를 표현할 때는 바이어스 표기법을 사용한다.바이어스 표기법 &#x3D; 2의 보수 + 바이어스 상수. 바이어스 상수: 2n-1-1n은 지수를 나타내는 비트의 갯수.음의 지수를 나타내기 위해 n비트로 나타낼 수 있는 갯수를 반으로 쪼개고(n-1)0이 포함돼있기 때문에 -1을 해준다.정수를 표현할 때는 음수가 표현할 수 있는 갯수가 1개가 더 많았는데실수의 지수를 표현할 때는 양수가 표현할 수 있는 갯수가 1개 더 많은 차이점이 존재한다. float: 28-1-1 &#x3D; 27-1 &#x3D; 128-1 &#x3D; 127(-127~128의 지수 표현 가능)double: 252-1-1 &#x3D; 251-1 &#x3D; 알아서 계산하지만 자바에서는 마지막 끝 값들인 -2n-1-1 ~ 2n-1은 NaN, ±Infinity를 표현하는데 쓰임.따라서 실제로 쓰이는 범위는-2n-1 + 1 ~ 2n-1-1 이라고 보면 됨 double은 너무 크니까 float를 기준으로 설명.3을 바이어스 표기법으로 나타내면3 + 127 &#x3D; 00000101 + 01111111 &#x3D; 10000010위와 같이 하면 어려우니까 그냥 아래와 같이 계산하는 게 훨씬 쉽다.지수 + 바이어스 상수 &#x3D; 10진수 &#x3D;&gt; 2의 보수법으로 변경3 + 127 &#x3D; 130 &#x3D; 10000010-126 &#x3D; -126 + 127 &#x3D; 1 &#x3D; 00000001128 &#x3D; 128 + 127 &#x3D; 255 &#x3D; 11111111","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"부동소수점","slug":"부동소수점","permalink":"https://perfectacle.github.io/tags/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90/"}]},{"title":"(Java) 자바의 정석 3판 001일차 - 컴퓨터 이론, 리터럴 & 변수 & 변수","slug":"Java-study-001day","date":"2016-12-30T17:18:24.000Z","updated":"2022-10-30T08:42:16.091Z","comments":true,"path":"2016/12/30/Java-study-001day/","link":"","permalink":"https://perfectacle.github.io/2016/12/30/Java-study-001day/","excerpt":"컴퓨터는 왜 2진수를 사용할까?10진법이 익숙한 이유는 손가락이 10개이기 때문이지 않을까?에니악은 10진법 체계였지만 전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는데 한계가 있음에드박은 단 두가지 단계, 전기가 흐르면 1, 전기가 흐르지 않으면 0만으로 동작하게 설계되었다따라서 컴퓨터와 같은 전기회로는 2진 체계를 사용하게 되었다. 그렇다면 8진수와 16진수는 왜 생겼을까?2진수는 숫자를 표현하기 위해 상당히 많은 자릿수를 차지한다.코딩할 때도 이렇게 많은 자릿수는 가독성을 해칠 수 있다.따라서 이런 단점을 보완하기 위해 8진수와 16진수가 등장했다.그렇다면 왜 8진수와 16진수일까?2진수 2자리로는 4진수를2진수 3자리로는 8진수를2진수 4자리로는 16진수를 표현할 수 있다.2진수 2자리는 그닥 많은 자릿수를 절약할 수 없어서 사용을 안 하게 된 게 아닐까 싶다…8진수를 사용하는 대표적인 예는 리눅스나 FTP 등에서 파일이나 폴더에 관한 권한을 표현하기 위해 많이 쓰인다.777 을 예로 들면r 읽기 허용(4) w 쓰기 허용(2) x 실행 허용(1) 을 다 더하면 7이 나오고u 사용자(소유자) g 그룹 o 기타(사용자와 그룹을 제외한 사람) 순서로 기술하면 된다.16진수를 사용하는 대표적인 예는 rgb 컬러 코드(#ff00ff), 유니코드(\\u0061, U+0061, 0x0061 등등)에서 쓰인다.","text":"컴퓨터는 왜 2진수를 사용할까?10진법이 익숙한 이유는 손가락이 10개이기 때문이지 않을까?에니악은 10진법 체계였지만 전기회로는 전압이 불안정해서 전압을 10단계로 나누어 처리하는데 한계가 있음에드박은 단 두가지 단계, 전기가 흐르면 1, 전기가 흐르지 않으면 0만으로 동작하게 설계되었다따라서 컴퓨터와 같은 전기회로는 2진 체계를 사용하게 되었다. 그렇다면 8진수와 16진수는 왜 생겼을까?2진수는 숫자를 표현하기 위해 상당히 많은 자릿수를 차지한다.코딩할 때도 이렇게 많은 자릿수는 가독성을 해칠 수 있다.따라서 이런 단점을 보완하기 위해 8진수와 16진수가 등장했다.그렇다면 왜 8진수와 16진수일까?2진수 2자리로는 4진수를2진수 3자리로는 8진수를2진수 4자리로는 16진수를 표현할 수 있다.2진수 2자리는 그닥 많은 자릿수를 절약할 수 없어서 사용을 안 하게 된 게 아닐까 싶다…8진수를 사용하는 대표적인 예는 리눅스나 FTP 등에서 파일이나 폴더에 관한 권한을 표현하기 위해 많이 쓰인다.777 을 예로 들면r 읽기 허용(4) w 쓰기 허용(2) x 실행 허용(1) 을 다 더하면 7이 나오고u 사용자(소유자) g 그룹 o 기타(사용자와 그룹을 제외한 사람) 순서로 기술하면 된다.16진수를 사용하는 대표적인 예는 rgb 컬러 코드(#ff00ff), 유니코드(\\u0061, U+0061, 0x0061 등등)에서 쓰인다. boolean은 1bit가 아닌 왜 1byte일까?Why is a boolean 1 byte and not 1 bit of size?CPU가 메모리(RAM)의 주소(address)에 접근해야하는데하나의 메모리 주소가 가지는 데이터의 크기는 1byte(8bit)이다.따라서 CPU가 메모리 주소에 접근해서 사용할 수 있는 최소한의 단위는 1byte가 된다.따라서 boolean은 1bit가 아니라 1byte가 된 것이다. 1byte는 왜 8bit일까?아스키(Ascii)메모리 하나당 차지하는 바이트 수에 대해 궁금한 점이 있습니다.메모리 주소당 데이터용량이 1바이트인 이유가 먼가요??1바이트는 왜 8비트일까?과거에는 1byte가 7bit, 9bit 등등이던 시절이 있다고 하지만 현재는 8비트로 거의 표준이 된 것 같다.이에 대한 이유로 내 나름대로 결론을 내린 것은 미국에서 컴퓨터를 개발했기 때문이라고 본다.미국에서 문자를 사용하기 위한 코드로 ascii 코드(7bit)가 있는데왜 7bit가 아닌 8bit가 1byte가 되었을까?내 나름대로 추측을 해보자면 데이터 송수신의 오류를 검출하기 위한 패리티 비트로 1비트가 추가됐다. 유럽권을 고려해서 확장 아스키 코드를 베이스로 정했다. 정확히 뭔지는 모르겠으나 ascii 코드를 베이스로 1byte의 bit수가 정해진 것에는 틀림이 없는 것 같다. 리터럴, 변수, 상수 리터럴 - 짧게 얘기하면 변하지 않는 값길게 얘기하면 우리는 변하지 않는 값을 일상생활에서는 상수라고 불렀다.하지만 상수는 프로그래밍 세계에서는 좀 다른 뜻으로 불리기 때문에그와 차별성을 부여하기 위해 리터럴이라고 붙였다.“ch”, ‘c’, 123, 123.55 등등 모두 리터럴이다. 변수 - 짧게 얘기하면 변하는 수길게 얘기하면 단 하나의 값을 저장할 수 있는 메모리 상의 공간.int num &#x3D; 2;int num;까지만 하면 램(RAM, Random Access Memory)에서사용 중이지 않은 주소 4개를 랜덤하게 접근해서 공간 확보만 함.램은 여러 프로그램이 공유하는 자원이므로 이전에 다른 프로그램에 의해 저장된 값이 남아있을 수 있음.그 다른 프로그램에 의해 저장된 알 수 없는 값을 쓰레기값(garbage value)이라고 함. 상수 - 짧게 얘기하면 변하지 않는 수길게 얘기하면 단 하나의 변하지 않는 값을 저장할 수 있는 메모리 상의 공간.상수가 필요한 이유는 리터럴에 의미있는 이름을 붙여서 가독성을 높이기 위함이다. 1234567891011121314// 상수를 사용하지 않음.public class test &#123; public static void main(String[] args) &#123; int triangleArea = 20 * 10 / 2; &#125;&#125;// 상수를 사용함.public class test &#123; public static void main(String[] args) &#123; final int WIDTH = 20; final int HEIGHT = 10; int triangleArea = WIDTH * HEIGHT / 2; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"}]},{"title":"(ES6) Interface","slug":"es6-interface","date":"2016-12-25T22:17:14.000Z","updated":"2022-10-30T08:42:16.607Z","comments":true,"path":"2016/12/25/es6-interface/","link":"","permalink":"https://perfectacle.github.io/2016/12/25/es6-interface/","excerpt":"이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.이터레이터 인터페이스와 이터러블 인터페이스는 다음 포스트에서 정리할 예정이다.이 글을 읽고난 후에 (ES6) Symbol에 대한 글부터 읽어보길 바란다.다소 짧아서 어디 공유하기 부끄럽지만 이렇게 짧은 내용들이 집중해서 읽기에 참 좋은 것 같다. InterfaceECMAScript2015(이하 ES6) 들어서서 인터페이스는 고유 명사가 되었다. 고유명사(固有名詞)낱낱의 특정한 사물이나 사람을 다른 것들과 구별하여 부르기 위하여 고유의 기호를 붙인 이름.","text":"이 포스트는 GDG 2016에서 발표하신 맹기완 님의 발표를 듣고 감명을 받아 정리해본 글이다.이터레이터 인터페이스와 이터러블 인터페이스는 다음 포스트에서 정리할 예정이다.이 글을 읽고난 후에 (ES6) Symbol에 대한 글부터 읽어보길 바란다.다소 짧아서 어디 공유하기 부끄럽지만 이렇게 짧은 내용들이 집중해서 읽기에 참 좋은 것 같다. InterfaceECMAScript2015(이하 ES6) 들어서서 인터페이스는 고유 명사가 되었다. 고유명사(固有名詞)낱낱의 특정한 사물이나 사람을 다른 것들과 구별하여 부르기 위하여 고유의 기호를 붙인 이름. Java에서 Interface는 다음과 같은 명세를 준수해야 Interface라고 부른다.자바 허접이라 다음 링크를 참조하였다.JAVA 강좌 21편. 인터페이스(Interface)Interface는 객체인가? 메소드는 public abstract로 선언된 추상 메소드만을 가진다. 변수는 public static final로 선언된 상수만을 가진다. 위 2가지 조건만 만족하면 자바에서는 인터페이스라고 불리운다.나머지는 인터페이스의 특징인 것 같아 생략하였다. (다중 상속 등등)자바에서 인터페이스는 고유 명사이며 위와 같은 의미를 가진다. 이와 같이 ES6에서도 이제 인터페이스는 자바와 같이 고유 명사가 되었다.그 말은 ES6에서의 인터페이스는 다른 곳에서 쓰이는 인터페이스와는 다른 것이라는 걸 뜻한다.아래 사이트를 가도 볼 수 있다.http://www.ecma-international.org/ecma-262/6.0/#sec-iteration그럼 ES6에서 말하는 인터페이스는 무엇인지 살펴보자. 객체가 가져야하는 키를 명시. 그 키가 가져야 하는 값을 명시. 위 조건만 만족하면 ES6에서는 인터페이스라고 불리울 수 있다.인터페이스는 객체나 클래스가 아닌 하나의 명세라고 보면 될 것 같다.그럼 test 인터페이스를 정의해보자.안타깝게도 사용자 인터페이스를 정의할 방법은 없는 것 같지만,설명을 위해 작성해보았다. test와 testing이라는 키를 가짐. test는 매개변수로 숫자를 받고 매개변수의 제곱한 결과를 반환함. testing은 boolean 값을 가짐. 하나만 하면 심심하니 test2라는 인터페이스도 정의해보자. name과 age라는 키를 가짐. name은 string 값을 가짐. age는 number 값을 가짐. 그럼 위 인터페이스를 충족하는 객체를 만들어보자. 1234567const obj = &#123; test: num =&gt; Math.pow(num, 2), testing: false, name: &quot;양간장&quot;, age: 24, etc: &quot;위 키들을 제외하고는 어떠한 키가 오던 상관이 없다.&quot;&#125; obj 객체는 test와 test2 인터페이스 조건을 충족하므로 test, test2 인터페이스를 따르는 객체이다. test 인터페이스의 조건을 충족하므로 test 인터페이스를 따르는 객체이다. test라는 키를 가지고 있다. test라는 키의 값은 숫자를 매개변수로 받고 매겨변수로 받은 숫자를 제곱해서 반환한다. testing이라는 키를 가지고 있다. testing이라는 키의 값은 boolean 값을 가진다. test2 인터페이스의 조건을 충족하므로 test2 인터페이스를 따르는 객체이다. name이라는 키를 가지고 있다. name이라는 키의 값은 string 값을 가진다. age라는 키를 가지고 있다. age라는 키의 값은 number 값을 가진다. 그 이외에 키에 관해서는 test와 test2 인터페이스에서 명세한 바가 없으므로 전혀 상관이 없다.이는 마치 덕타이핑(duck typing)과 매우 유사한 것 같다. 덕 타이핑(duck typing)오리처럼 생겨서 오리처럼 걷고 오리처럼 꽥꽥 소리를 낸다면 그건 오리다라는 속담에서 유래됐다고 한다. name, age 키가 있고 그 키에 맞는 값들을 가진다면 그건 test2 인터페이스를 따르는 것이다.다른 어떠한 키가 오더라도 위 두개의 키만 조건을 준수한다면 test2 인터페이스를 따른다는 것이다.좀 다른 건가…? 역시 남이 떠다 먹여주는 정보들만 받아 먹다보니 혼자서 탐구하는 것은 정말 어려운 것 같다. 뭐 여하튼 이렇듯 ES6에서는 사용자가 인터페이스를 정의할 수 없다보니표준으로 정의해놓은 인터페이스가 있는데 그게 바로이터러블 인터페이스와 이터레이터 인터페이스인데 길어서 인터페이스는 빼는 것 같다.위 두 인터페이스 외에도 많은 것 같은데(사실 모른다.)대표적인 두 인터페이스만 다음 포스트에서 다뤄야할 것 같다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Interface","slug":"Interface","permalink":"https://perfectacle.github.io/tags/Interface/"}]},{"title":"(ES6) Number 객체와 함수","slug":"ES6-Number-object-and-function","date":"2016-12-24T15:11:28.000Z","updated":"2022-10-30T08:42:16.079Z","comments":true,"path":"2016/12/24/ES6-Number-object-and-function/","link":"","permalink":"https://perfectacle.github.io/2016/12/24/ES6-Number-object-and-function/","excerpt":"(ES6) 숫자형을 보고 이 글을 보는 걸 추천한다. 목차 Number 객체(Global 객체) Properties Methods Number 함수 함수 생성자 Number ↔ String Number 객체(Global 객체)","text":"(ES6) 숫자형을 보고 이 글을 보는 걸 추천한다. 목차 Number 객체(Global 객체) Properties Methods Number 함수 함수 생성자 Number ↔ String Number 객체(Global 객체)ES5까지 Number 객체는 거의 래퍼 객체의 역할만을 수행했다.하지만 ES6에 들어서면서 다양한 프로퍼티와 메소드들이 생기면서래퍼 객체 이상의 역할을 수행하는 전역 객체와 같이 쓸 수 있게 되었다.래퍼 객체는 원시 타입의 값을 객체로 다루기 위한 객체이며,래퍼 객체의 진가는 prototype 프로퍼티를 통해 드러나게 된다.래퍼 객체를 어떻게 사용하는지는 나중에 보도록 하고,일단 Number 객체의 구조를 보도록 하자. 1console.dir(Number); Properties* 표시는 ES6에서 새로 추가됨. Number.POSITIVE_INFINITY Number.NEGATIVE_INFINITY Number.NaN Number.MIN_VALUE Number.MAX_VALUE Number.MIN_SAFE_INTEGER * Number.MAX_SAFE_INTEGER * Number.EPSILON * Number.prototype 표준 프로퍼티들은 상수이다.즉 변경이 불가능하다. 12Number.EPSILON = &quot;asdf&quot;; // 오류는 나지 않는다.console.log(Number.EPSILON); // 2.220446049250313e-16 Number.POSITIVE_INFINITY &amp; Number.NEGATIVE_INFINITY &amp; Number.NaN123console.log(Number.POSITIVE_INFINITY === Infinity); // trueconsole.log(Number.NEGATIVE_INFINITY === -Infinity); // trueconsole.log(isNaN(Number.NaN)); // true Number.MIN_VALUE &amp; Number.MAX_VALUEProblem in ES부동 소수점에 대한 이해수의 표현범위가 다른 int와 float, 그리고 신뢰할 수 없는 부동소수점 123456console.log(Number.MIN_VALUE); // 5e-324console.log(Number.MIN_VALUE - 1); // -1console.log(Number.MIN_VALUE + 1); // 1console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1 === Number.MAX_VALUE - 1); // true Number.MIN_SAFE_INTEGER * &amp; Number.MAX_SAFE_INTEGER *Solution in ES612345678console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991console.log(-(Math.pow(2, 53) - 1)); // -9007199254740991console.log(Number.MIN_SAFE_INTEGER !== Number.MIN_SAFE_INTEGER + 1); // trueconsole.log(Number.MIN_SAFE_INTEGER - 1 !== Number.MIN_SAFE_INTEGER - 2); // falseconsole.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Math.pow(2, 53) - 1); // 9007199254740991console.log(Number.MAX_SAFE_INTEGER !== Number.MAX_SAFE_INTEGER - 1); // trueconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true Polyfill123456789101112131415161718if(!Number.MIN_SAFE_INTEGER) &#123; if(!Object.create) &#123; // in ES3 Number.MIN_SAFE_INTEGER = -(Math.pow(2, 53) - 1); &#125; else &#123; // in ES5 Object.defineProperty(Number, &quot;MIN_SAFE_INTEGER&quot;, &#123; value: -(Math.pow(2, 53) - 1) &#125;); &#125;&#125;if(!Number.MAX_SAFE_INTEGER) &#123; if(!Object.create) &#123; // in ES3 Number.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; &#125; else &#123; // in ES5 Object.defineProperty(Number, &quot;MAX_SAFE_INTEGER&quot;, &#123; value: Math.pow(2, 53) - 1 &#125;); &#125;&#125; Number.EPSILON *Problem in ES12console.log(.1 + .2); // 0.30000000000000004console.log(0.1 + 0.2 === 0.3); // false ES에서는 위와 같이 소수점 계산에서 고질적인 문제를 안고 있다.이는 아마 IEEE에서 제정한 부동소수점 표현 형식인 IEE754의 고질적인 문제라고 보여진다.실수 표현 문제 발생 이유 or 오차 발생 이유 자바스크립트의 숫자는 십진 부동 소수점 숫자로 접근하는데 반해 그 내부 동작 원리는 이진 부동 소수점 숫자이기 때문에 오차가 발생한다.원문 보기JavaScript’s numbers are usually entered as decimal floating-point numbers,but they are internally represented as binary floating-point numbers.That leads to imprecision. 위와 같은 문제는 IEE754를 사용하는 Java에서도 동일하게 발생한다. 123456public class test &#123; public static void main(String[] args) &#123; System.out.println(0.1 + 0.2); // 0.30000000000000004 System.out.println(0.3 == 0.1+0.2); // false &#125;&#125; 어찌보면 0.00000000000000004 정도의 오차는 무시되도 되는 작은 숫자이다. Solution in ES6Number.EPSILON은 오차없이 나타낼 수 있는 가장 작은 양의 소수를 나타낸다.이렇게 무시되어도 될 정도의 작은 오차를 구분하기 위해 등장한 프로퍼티이다. 123456console.log(5e2); // 500console.log(5e-2); // 0.05console.log(0.5e2); // 50console.log(Number.EPSILON); // 2.220446049250313e-16console.log(Number.EPSILON.toFixed(20)); // 0.00000000000000022204 과연 0.0000000000000004는 무시돼도 될 정도로 작은 오차인지 살펴보자. 12345/* * 0.00000000000000004 * 0.00000000000000022204 */console.log(0.0000000000000004 &lt; Number.EPSILON); // true 즉 좌변에 있는 값이 우변에 있는 Number.EPSILON 보다도 작다면 무시해도 되는 오차다. Usage1234567// 이 함수가 true를 반환하면 formula와 result는 동일하다고 보면 됨.// Number.EPILON은 항상 양수이기 때문에 Math.abs 메소드를 사용하여// 계산식의 결과를 절대값으로 바꾼 후 오차를 비교해야함.const isEqual = (formula, result) =&gt; Math.abs(formula - result) &lt; Number.EPSILON;console.log(isEqual(0.1 + 1 - 2.2, -1.1)); // trueconsole.log(isEqual(0.1 + 1 - 2.2, -1.2)); // false Polyfill123456789if(!Number.EPSILON) &#123; if(!Object.create) &#123; // in ES3 Number.EPSILON = 2.220446049250313e-16; &#125; else &#123; // in ES5 Object.defineProperty(Number, &quot;EPSILON&quot;, &#123; value: 2.220446049250313e-16 &#125;); &#125;&#125; Number.prototype숫자가 상속받는 프로퍼티와 메소들을 정의해놓은 프로퍼티이다.표준 메소드 및 프로퍼티가 미리 정의돼있으며, 사용자가 직접 정의하려면 아래와 같이 하면 된다. 1234Number.prototype.lastNum = function() &#123; return this % 10;&#125;;console.log(12.0.lastNum()); // 2 Methods* 표시는 ES6에서 새로 추가됨. Number.isFinite() * Number.isInteger() * Number.isNaN() * Number.isSafeInteger() * Number.parseInt() * Number.parseFloat() * Number.prototype.toFixed() Number.prototype.toPrecision() Number.prototype.toExponential() Number.prototype.toString() Number.prototype.valueOf() Number.prototype.toLocaleString() 메소드는 수정 가능하다. 12Number.isFinite = () =&gt; &quot;a&quot;;console.log(Number.isFinite(123)); // &quot;a&quot; Number.isFinite() *in ES1234567891011console.log(isFinite(0)); // trueconsole.log(isFinite(255)); // trueconsole.log(isFinite(-254)); // trueconsole.log(isFinite(&quot;1&quot;)); // trueconsole.log(isFinite(NaN)); // falseconsole.log(isFinite(Infinity)); // falseconsole.log(isFinite(-Infinity)); // falseconsole.log(isFinite(null)); // trueconsole.log(isFinite(&#123;&#125;)); // falseconsole.log(isFinite(undefined)); // falseconsole.log(isFinite([])); // true in ES61234567891011console.log(Number.isFinite(0)); // trueconsole.log(Number.isFinite(255)); // trueconsole.log(Number.isFinite(-254)); // trueconsole.log(Number.isFinite(&quot;1&quot;)); // falseconsole.log(Number.isFinite(NaN)); // falseconsole.log(Number.isFinite(Infinity)); // falseconsole.log(Number.isFinite(-Infinity)); // falseconsole.log(Number.isFinite(null)); // falseconsole.log(Number.isFinite(&#123;&#125;)); // falseconsole.log(Number.isFinite(undefined)); // falseconsole.log(Number.isFinite([])); // false Polyfill123Number.isFinite = Number.isFinite || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isFinite(value);&#125; Number.isInteger() *123456789101112console.log(Number.isInteger(0)); // trueconsole.log(Number.isInteger(255)); // trueconsole.log(Number.isInteger(-254)); // trueconsole.log(Number.isInteger(1.1)); // falseconsole.log(Number.isInteger(&quot;1&quot;)); // falseconsole.log(Number.isInteger(NaN)); // falseconsole.log(Number.isInteger(Infinity)); // falseconsole.log(Number.isInteger(-Infinity)); // falseconsole.log(Number.isInteger(null)); // falseconsole.log(Number.isInteger(&#123;&#125;)); // falseconsole.log(Number.isInteger(undefined)); // falseconsole.log(Number.isInteger([])); // false Polyfill12345Number.isInteger = Number.isInteger || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isFinite(value) &amp;&amp; Math.floor(value) === value;&#125;; Number.isNaN() *Problem1console.log(NaN === NaN); // false in ES123456789101112console.log(isNaN(0)); // falseconsole.log(isNaN(-Infinity)); // falseconsole.log(isNaN(&quot;1.1&quot;)); // falseconsole.log(isNaN(NaN)); // trueconsole.log(isNaN(&quot;NaN&quot;)); // trueconsole.log(isNaN(&quot;a&quot;)); // trueconsole.log(isNaN(0 / 0)); // trueconsole.log(isNaN(&#123;&#125;)); // trueconsole.log(isNaN([])); // falseconsole.log(isNaN(undefined)); // trueconsole.log(isNaN(null)); // falseconsole.log(isNaN(/a/)); // true in ES6123456789101112console.log(Number.isNaN(0)); // falseconsole.log(Number.isNaN(-Infinity)); // falseconsole.log(Number.isNaN(&quot;1.1&quot;)); // falseconsole.log(Number.isNaN(NaN)); // trueconsole.log(Number.isNaN(&quot;NaN&quot;)); // falseconsole.log(Number.isNaN(&quot;a&quot;)); // falseconsole.log(Number.isNaN(0 / 0)); // trueconsole.log(Number.isNaN(&#123;&#125;)); // falseconsole.log(Number.isNaN([])); // falseconsole.log(Number.isNaN(undefined)); // falseconsole.log(Number.isNaN(null)); // falseconsole.log(Number.isNaN(/a/)); // false Polyfill12345678Number.isNaN = Number.isNaN || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isNaN(value);&#125;;// OrNumber.isNaN = Number.isNaN || function(value) &#123; return value !== value;&#125;; Number.isSafeInteger() *12345678console.log(Number.isSafeInteger(3)); // trueconsole.log(Number.isSafeInteger(Math.pow(2, 53))); // falseconsole.log(Number.isSafeInteger(Math.pow(2, 53) - 1)); // trueconsole.log(Number.isSafeInteger(NaN)); // falseconsole.log(Number.isSafeInteger(Infinity)); // falseconsole.log(Number.isSafeInteger(&quot;3&quot;)); // falseconsole.log(Number.isSafeInteger(3.1)); // falseconsole.log(Number.isSafeInteger(3.0)); // true Polyfill123Number.isSafeInteger = Number.isSafeInteger || function (value) &#123; return Number.isInteger(value) &amp;&amp; Math.abs(value) &lt;= Number.MAX_SAFE_INTEGER;&#125;; Number.parseInt() *Syntax1Number.parseInt(string[, radix]) Parameters string: 문자열 radix: 2~36진수, 10이 기본값. Example123456789101112console.log(Number.parseInt === parseInt); // trueconsole.log(Number.parseInt(&quot;11&quot;)); // 11console.log(Number.parseInt(&quot;11.11&quot;)); // 11console.log(Number.parseInt(&quot;11A&quot;)); // 11console.log(Number.parseInt(&quot;A11&quot;)); // NaNconsole.log(Number.parseInt(&quot;11A1&quot;)); // 11console.log(Number.parseInt(&quot;11.A&quot;)); // 11console.log(Number.parseInt(&quot;011&quot;)); // 11console.log(Number.parseInt(&quot;11 0&quot;)); // 11console.log(Number.parseInt(&quot;0xFF&quot;)); // 255console.log(Number.parseInt(true)); // NaNconsole.log(Number.parseInt(new Date())); // NaN Problem1234console.log(Number.parseInt(&quot;0b111&quot;)); // 0console.log(Number.parseInt(&quot;0b111&quot;, 2)); // 0console.log(Number.parseInt(&quot;0o10&quot;)); // 0console.log(Number.parseInt(&quot;0o10&quot;, 8)); // 0 Solution12345678console.log(Number.parseInt(&quot;111&quot;, 2)); // 7console.log(new Number(&quot;0b111&quot;).valueOf()); // 7console.log(Number(&quot;0b111&quot;)); // 7console.log(+&quot;0b111&quot;); // 7console.log(Number.parseInt(&quot;10&quot;, 8)); // 8console.log(new Number(&quot;0o10&quot;).valueOf()); // 8console.log(Number(&quot;0o10&quot;)); // 8console.log(+&quot;0o10&quot;); // 8 Polyfill1Number.parseInt = Number.parseInt || parseInt; Number.parseFloat() *123456789101112console.log(Number.parseFloat === parseFloat); // trueconsole.log(Number.parseFloat(&quot;11&quot;)); // 11console.log(Number.parseFloat(&quot;11.11&quot;)); // 11.11console.log(Number.parseFloat(&quot;11A&quot;)); // 11console.log(Number.parseFloat(&quot;A11&quot;)); // NaNconsole.log(Number.parseFloat(&quot;11A1&quot;)); // 11console.log(Number.parseFloat(&quot;11.A&quot;)); // 11console.log(Number.parseFloat(&quot;011&quot;)); // 11console.log(Number.parseFloat(&quot;11 0&quot;)); // 11console.log(Number.parseFloat(&quot;0xFF&quot;)); // 0console.log(Number.parseFloat(true)); // NaNconsole.log(Number.parseFloat(new Date())); // NaN Polyfill1Number.parseFloat = Number.parseFloat || parseFloat; Number.prototype.toFixed() &amp; Number.prototype.toPrecision()실수를 반올림 할 때 쓰인다. 123456const num = 123.45678;console.log(num.toFixed()); // &quot;123&quot;console.log(num.toPrecision()); // &quot;123.45678&quot;console.log(num.toString()); // &quot;123.45678&quot;console.log(num.toFixed(4)); // &quot;123.4568&quot;console.log(num.toPrecision(4)); // &quot;123.5&quot; Number.prototype.toExponential숫자를 지수를 통해 표현할 때 쓰인다. 123456let num = 7817.1278;console.log(num.toExponential()); // &quot;7.8171278e+3&quot;console.log(num.toExponential(2)); // &quot;7.82e+3&quot;console.log(num.toExponential(6)); // &quot;7.817128e+3&quot;num = 0.1445;console.log(num.toExponential()); // &quot;1.445e-1&quot; Number.prototype.toString()숫자를 문자열로 바꿀 때 쓰인다. 1234567console.log(1.1.toString()); // &quot;1.1&quot;console.log(1.0.toString()); // &quot;1&quot;console.log(0b11.toString()); // &quot;3&quot;console.log(NaN.toString()); // &quot;NaN&quot;console.log(Infinity.toString()); // &quot;Infinity&quot;console.log(-Infinity.toString()); // -Infinityconsole.log(0.0.toString()); // &quot;0&quot; Number.prototype.valueOf()숫자 객체의 인스턴스에서 숫자값을 얻어올 때 쓰인다. 123console.log(new Number(11).valueOf()); // 11console.log(new Number(0b11).valueOf()); // 3console.log(new Number(&#123;&#125;).valueOf()); // NaN Number.prototype.toLocaleString()Syntax1Number.prototype.toLocaleString([locales [, options]]); Parameters localesBCP 47 language taglanguage[-script][-region]*(-variant)*(-extension)[-privateuse]“en-US”, “en-CA”, “tlh-Kore-AQ-fonipa”, “ja-JP”, “zh-Hans-CN”, etc. Optionsstyle: “currency”, “percent”, “decimal”(default)currency: Current currency &amp; funds code list“USD”, “EUR”, “KRW”, “JPY”, “CNY”, etc.etc options. Checking for support1234567const isSupportToLocaleString = () =&gt; !!(Intl &amp;&amp; typeof Intl === &quot;object&quot; &amp;&amp; typeof Intl.NumberFormat === &quot;function&quot;);if(isSupportToLocaleString()) &#123; // if support toLocaleString() // blahblah...&#125; else &#123; // if not support toLoacleString() // blahblah...&#125; Usage12345678const num = 123456.789;console.log(num.toLocaleString(&quot;en-US&quot;)); // &quot;123.456.789&quot;console.log(num.toLocaleString(&quot;zh-Hans-CN-u-nu-hanidec&quot;)); // &quot;一二三,四五六.七八九&quot;console.log(num.toLocaleString(&quot;en-US&quot;, &#123;style: &quot;currency&quot;, currency: &quot;USD&quot;&#125;)); // &quot;$123,456.79&quot;console.log(num.toLocaleString(&quot;en-UK&quot;, &#123;style: &quot;currency&quot;, currency: &quot;EUR&quot;&#125;)); // &quot;€123,456.79&quot;console.log(num.toLocaleString(&quot;tlh-Kore-AQ-fonipa&quot;, &#123;style: &quot;currency&quot;, currency: &quot;KRW&quot;&#125;)); // &quot;₩123,457&quot;console.log(num.toLocaleString(&quot;ja-JP&quot;, &#123;style: &quot;currency&quot;, currency: &quot;JPY&quot;&#125;)); // &quot;￥123,457&quot;console.log(num.toLocaleString(&quot;zh-Hans-CN&quot;, &#123;style: &quot;currency&quot;, currency: &quot;CNY&quot;&#125;)); // &quot;￥123,456.79&quot; Number 함수 함수 생성자 함수Syntax1Number(value); Parametervalue: 어떠한 데이터 타입의 값도 올 수 있다. Usage매개변수로 넘긴 값들을 숫자로 바꿀 때 사용한다. Example123456789101112console.log(Number(&quot;11&quot;)); // 11console.log(Number(&quot;11.11&quot;)); // 11.11console.log(Number(&quot;11A&quot;)); // NaNconsole.log(Number(&quot;A11&quot;)); // NaNconsole.log(Number(&quot;11A1&quot;)); // NaNconsole.log(Number(&quot;11.A&quot;)); // NaNconsole.log(Number(&quot;011&quot;)); // 11console.log(Number(true)); // 1console.log(Number(new Date())); // 1481186433309console.log(Number([0, 1])); // NaNconsole.log(Number(&#123;a: &quot;b&quot;&#125;)); // NaNconsole.log(Number(11)); // 11 생성자Syntax1new Number(value); Parametervalue: 어떠한 데이터 타입의 값도 올 수 있다. Structure123const objNum = new Number(11);console.log(typeof objNum); // &quot;object&quot;console.dir(objNum); __proto__12const objNum = new Number(11);console.log(Number.prototype === objNum.__proto__); // true 숫자의 래퍼 객체(Number)에서 미리 정의해놓은 프로퍼티(prototype)이다.이 프로퍼티에는 숫자의 표준 메소드와 프로퍼티가 정의돼있다.숫자 객체의 인스턴스(new Number())는 숫자 래퍼 객체(Number)로부터prototype 프로퍼티를 __proto__라는 이름으로 상속받는다. NecessityThe Secret Life of JavaScript PrimitivesES에서 숫자 원시값의 프로퍼티와 메소드를 사용할 때 내부 동작 원리는 아래와 같다. 123456789// 우리가 알던 방식대로 메소드 사용해보자.11.1.toString(); // &quot;11.1&quot;;/* * Number.prototype.toString() 메소드를 쓰기 위해서 * 원시값인 11.1을 Number 객체로 바꿔줘야한다. * 따라서 위 내용은 아래와 같이 자동으로 동작하게 된다. */new Number(11.1).toString(); // 11.1 Number ↔ String123456const num1 = &quot;10&quot;;const num2 = &quot;10&quot;;const sum = num1 + num2; // &quot;1010&quot;const sub = num1 - num2; // 0const mul = num1 * num2; // 100const div = num1 / num2; // 1 String to Number Number.parseInt(string[, radix]) Number.parseFloat(string) new Number(string).valueOf() Number() +string, 1*string Number.parseInt(str[, radix])12345678910console.log(Number.parseInt(&quot;11&quot;)); // 11console.log(Number.parseInt(&quot;11.11&quot;)); // 11console.log(Number.parseInt(&quot;11A&quot;)); // 11console.log(Number.parseInt(&quot;A11&quot;)); // NaNconsole.log(Number.parseInt(&quot;11A1&quot;)); // 11console.log(Number.parseInt(&quot;11.A&quot;)); // 11console.log(Number.parseInt(&quot;011&quot;)); // 11console.log(Number.parseInt(&quot;11 0&quot;)); // 11console.log(Number.parseInt(&quot;0b11&quot;)); // 0console.log(Number.parseInt(&quot;0o11&quot;)); // 0 Number.parseFloat(str)12345678910console.log(Number.parseFloat(&quot;11&quot;)); // 11console.log(Number.parseFloat(&quot;11.11&quot;)); // 11.11console.log(Number.parseFloat(&quot;11A&quot;)); // 11console.log(Number.parseFloat(&quot;A11&quot;)); // NaNconsole.log(Number.parseFloat(&quot;11A1&quot;)); // 11console.log(Number.parseFloat(&quot;11.A&quot;)); // 11console.log(Number.parseFloat(&quot;011&quot;)); // 11console.log(Number.parseFloat(&quot;11 0&quot;)); // 11console.log(Number.parseFloat(&quot;0b11&quot;)); // 0console.log(Number.parseFloat(&quot;0o11&quot;)); // 0 new Number(string).valueOf()12345678910console.log(new Number(&quot;11&quot;).valueOf()); // 11console.log(new Number(&quot;11.11&quot;).valueOf()); // 11.11console.log(new Number(&quot;11A&quot;).valueOf()); // NaNconsole.log(new Number(&quot;A11&quot;).valueOf()); // NaNconsole.log(new Number(&quot;11A1&quot;).valueOf()); // NaNconsole.log(new Number(&quot;11.A&quot;).valueOf()); // NaNconsole.log(new Number(&quot;011&quot;).valueOf()); // 11console.log(new Number(&quot;11 0&quot;).valueOf()); // NaNconsole.log(new Number(&quot;0b11&quot;).valueOf()); // 3console.log(new Number(&quot;0o11&quot;).valueOf()); // 9 Number(string)123456789console.log(Number(&quot;11&quot;)); // 11console.log(Number(&quot;11.11&quot;)); // 11.11console.log(Number(&quot;11A&quot;)); // NaNconsole.log(Number(&quot;A11&quot;)); // NaNconsole.log(Number(&quot;11A1&quot;)); // NaNconsole.log(Number(&quot;11.A&quot;)); // NaNconsole.log(Number(&quot;011&quot;)); // 11console.log(Number(&quot;0b11&quot;)); // 3console.log(Number(&quot;0o11&quot;)); // 9 +string, 1*string123456789console.log(+&quot;11&quot;); // 11console.log(+&quot;11.11&quot;); // 11.11console.log(+&quot;11A&quot;); // NaNconsole.log(+&quot;A11&quot;); // NaNconsole.log(+&quot;11A1&quot;); // NaNconsole.log(+&quot;11.A&quot;); // NaNconsole.log(+&quot;011&quot;); // 11console.log(+&quot;0b11&quot;); // 3console.log(+&quot;0o11&quot;); // 9 Performance123456789101112131415161718192021222324252627282930313233343536const iterations = 10000000;console.time(&quot;Number.parseInt()&quot;);for(let i=0; i&lt;iterations; i++)&#123; Number.parseInt(&quot;1.1&quot;); // Number.parseInt(): 561.062ms&#125;console.timeEnd(&quot;Number.parseInt()&quot;);console.time(&quot;Number.parseInt() with radix&quot;);for(let i=0; i&lt;iterations; i++)&#123; Number.parseInt(&quot;1.1&quot;, 10); // Number.parseInt() with radix: 511.062ms&#125;console.timeEnd(&quot;Number.parseInt() with radix&quot;);console.time(&quot;Number.parseFloat()&quot;);for(let i=0; i&lt;iterations; i++)&#123; Number.parseFloat(&quot;1.1&quot;); // Number.parseFloat(): 737.437ms&#125;console.timeEnd(&quot;Number.parseFloat()&quot;);console.time(&quot;new Number().valueOf()&quot;);for(let i=0; i&lt;iterations; i++)&#123; new Number(&quot;1.1&quot;).valueOf(); // new Number().valueOf(): 1112.782ms&#125;console.timeEnd(&quot;new Number().valueOf()&quot;);console.time(&quot;Number()&quot;);for(let i=0; i&lt;iterations; i++)&#123; Number(&quot;1.1&quot;); // Number(): 1066.577ms&#125;console.timeEnd(&quot;Number()&quot;);console.time(&quot;+string&quot;);for(let i=0; i&lt;iterations; i++)&#123; +&quot;1.1&quot;; // +string: 20.724ms&#125;console.timeEnd(&quot;+string&quot;);console.time(&quot;1*string&quot;);for(let i=0; i&lt;iterations; i++)&#123; 1*&quot;1.1&quot;; // 1*string: 21.459ms&#125;console.timeEnd(&quot;1*string&quot;); Number to String Number.prototype.toString() String(number) “” + number Number.prototype.toString()1234567console.log(1.1.toString()); // &quot;1.1&quot;console.log(1.0.toString()); // &quot;1&quot;console.log(0b11.toString()); // &quot;3&quot;console.log(NaN.toString()); // &quot;NaN&quot;console.log(Infinity.toString()); // &quot;Infinity&quot;console.log(-Infinity.toString()); // -Infinityconsole.log(0.0.toString()); // &quot;0&quot; String(number)1234567console.log(String(1.1)); // &quot;1.1&quot;console.log(String(1)); // &quot;1&quot;console.log(String(0b11)); // &quot;3&quot;console.log(String(NaN)); // &quot;NaN&quot;console.log(String(Infinity)); // &quot;Infinity&quot;console.log(String(-Infinity)); // &quot;-Infinity&quot;console.log(String(0)); // &quot;0&quot; “” + number1234567console.log(&quot;&quot; + 1.1); // &quot;1.1&quot;console.log(&quot;&quot; + 1); // &quot;1&quot;console.log(&quot;&quot; + 0b11); // &quot;3&quot;console.log(&quot;&quot; + NaN); // &quot;NaN&quot;console.log(&quot;&quot; + Infinity); // &quot;Infinity&quot;console.log(&quot;&quot; + -Infinity); // &quot;-Infinity&quot;console.log(&quot;&quot; + 0); // &quot;0&quot; Performance12345678910111213141516const iterations = 10000000;console.time(&quot;Number.prototype.toString()&quot;);for(let i=0; i&lt;iterations; i++)&#123; 1.1.toString(); // Number.prototype.toString(): 268.619ms&#125;console.timeEnd(&quot;Number.prototype.toString()&quot;);console.time(&quot;String(number)&quot;);for(let i=0; i&lt;iterations; i++)&#123; String(1.1); // String(): 159.045ms&#125;console.timeEnd(&quot;String(number)&quot;);console.time(&quot;\\&quot;\\&quot; + number&quot;);for(let i=0; i&lt;iterations; i++)&#123; &quot;&quot; + 1.1; // &quot;&quot; + number: 20.594ms&#125;console.timeEnd(&quot;\\&quot;\\&quot; + number&quot;);","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Number","slug":"Number","permalink":"https://perfectacle.github.io/tags/Number/"}]},{"title":"(ES6) 숫자형","slug":"ES6-Number-type","date":"2016-12-23T09:37:53.000Z","updated":"2022-10-30T08:42:16.083Z","comments":true,"path":"2016/12/23/ES6-Number-type/","link":"","permalink":"https://perfectacle.github.io/2016/12/23/ES6-Number-type/","excerpt":"이 글을 읽고 (ES6) Number 객체와 함수를 이어서 보는 걸 추천한다. 자료형ES에서 숫자형은 단 하나의 자료형 뿐이다.Double: 자바나 C 등등의 언어에서 실수를 표현하기 위한 자료형, 8Byte &#x3D; 64BitDouble-precision floating-point format","text":"이 글을 읽고 (ES6) Number 객체와 함수를 이어서 보는 걸 추천한다. 자료형ES에서 숫자형은 단 하나의 자료형 뿐이다.Double: 자바나 C 등등의 언어에서 실수를 표현하기 위한 자료형, 8Byte &#x3D; 64BitDouble-precision floating-point format 부호(sign)를 표현하기 위한 1비트 (+, -) 지수부(exponent part)를 표현하기 위한 11비트 가수부(fraction part)를 표현하기 위한 52비트 유효 범위: -(253-1) ~ 253-1 1234console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991console.log(-(Math.pow(2, 53) - 1)); // -9007199254740991console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991console.log(Math.pow(2, 53) - 1); // 9007199254740991 즉 ES에서 정수형(Integer)은 존재하지 않는다.모든 숫자는 부동 소수점(Floating Point) 형태로 표현되는 실수(Real Number)이다.실수는 소수 표현이 가능하고, 실수를 표현하는 방법으로 고정 소수점(Fixed Point)와부동 소수점(Floating Point)이 있으니 직접 찾아보길 바란다. 12console.log(1 === 1.0); // trueconsole.log(1 .toString() === 1.0.toString()); // true 문제점 실수 계산 12console.log(.1 + .2); // 0.30000000000000004console.log(0.1 + 0.2 === 0.3); // false ES에서는 위와 같이 소수점 계산에서 고질적인 문제를 안고 있다.이는 아마 IEEE에서 제정한 부동소수점 표현 형식인 IEE754의 고질적인 문제라고 보여진다.실수 표현 문제 발생 이유 or 오차 발생 이유 자바스크립트의 숫자는 십진 부동 소수점 숫자로 접근하는데 반해 그 내부 동작 원리는 이진 부동 소수점 숫자이기 때문에 오차가 발생한다.원문 보기JavaScript’s numbers are usually entered as decimal floating-point numbers,but they are internally represented as binary floating-point numbers.That leads to imprecision. 위와 같은 문제는 IEE754를 사용하는 Java에서도 동일하게 발생한다. 123456public class test &#123; public static void main(String[] args) &#123; System.out.println(0.1 + 0.2); // 0.30000000000000004 System.out.println(0.3 == 0.1+0.2); // false &#125;&#125; 이를 위한 해결방안으로 Number.EPSILON이 나왔다. 신뢰할 수 없는 범위 부동 소수점에 대한 이해수의 표현범위가 다른 int와 float, 그리고 신뢰할 수 없는 부동소수점 12console.log(-9007199254740992 === -9007199254740993); // trueconsole.log(9007199254740992 === 9007199254740993); // true 부동 소수점의 단점은 일정 범위를 넘어가면 계산의 결과를 신뢰할 수 없다는 점이다.ES에서 쓰이는 숫자형에서 신뢰할 수 있는 범위는 위에 적어논 바와 같다. 123// &quot;-9007199254740991 ~ 9007199254740991&quot;console.log(-(Math.pow(2, 53) - 1) + &#x27; ~ &#x27; + (Math.pow(2, 53) - 1));console.log(Number.MIN_SAFE_INTEGER + &#x27; ~ &#x27; + Number.MAX_SAFE_INTEGER); 특수한 숫자들또한 숫자형에서는 특수한 네 가지 값이 존재한다. NaN(Not a Number) (+)Infinity -Infinity -0(Negative Zero) 1234567console.log(1 / &quot;A&quot;); // NaNconsole.log(Number.MAX_VALUE + 1e+291); // 1.7976931348623157e+308console.log(Number.MAX_VALUE + 1e+292); // Infinityconsole.log(Number.MAX_VALUE / -0.5); // -Infinityconsole.log(Number.MAX_VALUE * 1.000000000000001); // Infinityconsole.log(Number.MAX_VALUE * 1.0000000000000001); // 1.7976931348623157e+308console.log(1.0000000000000001 === 1); // true 음수 0+0과 -0은 같다?? 123456789console.log(0 == -0); // trueconsole.log(0 === -0); // trueconsole.log(0 != -0); // falseconsole.log(0 !== -0); // falseconsole.log(0 &lt; -0); // falseconsole.log(0 &gt; -0); // falseconsole.log(&quot;&quot; + -0); // &quot;0&quot;console.log(String(-0)); // &quot;0&quot;console.log(JSON.stringify(-0)); // &quot;0&quot; 하지만 아래 현상은 어떻게 설명할 수 있을까? 123456789101112console.log(1 / 0); // Infinityconsole.log(1 / -0); // -Infinityconsole.log(Infinity === -Infinity); // falseconsole.log(-0.0.toString()); // -0console.log(-0 .toString()); // -0console.log(-.0.toString()); // -0console.log(+&quot;-0&quot;); // -0console.log(Number(&quot;-0&quot;)); // -0console.log(JSON.parse(&quot;-0&quot;)); // -0console.log(Math.max(-0, 0)); // 0console.log(Math.min(-0, 0)); // -0console.log(Object.is(0, -0)); // false 필요성You Don’t Know JS: Types &amp; Grammar - Zeros스피드나 x, y와 같은 방향 같은 요소를 쓰는 어플리케이션에서 만약 -0이 0으로 바뀐다면,속도나 방향 등등의 정보를 잃게될 것이다. There are certain applications where developers use the magnitude of a value to represent one piece of information (like speed of movement per animation frame) and the sign of that number to represent another piece of information (like the direction of that movement).In those applications, as one example, if a variable arrives at zero and it loses its sign, then you would lose the information of what direction it was moving in before it arrived at zero. Preserving the sign of the zero prevents potentially unwanted information loss.&#96; 진수 리터럴2진수수학식: 11(2)기타 프로그래밍 언어: 0b11, 0B11 in ES 1console.log(parseInt(&#x27;11&#x27;, 2)); // 3 in ES6 12console.log(0b11); // 3console.log(0B11); // 3 8진수수학식: 71(8)기타 프로그래밍 언어: 071 in ES 1console.log(071); // 57 in strict mode 12&#x27;use strict&#x27;;console.log(071); // Uncaught SyntaxError: Octal literals are not allowed in strict mode. ES5의 strict mode에서는 8진수 리터럴이 적용되지 않는다.왜냐하면 ES5에는 8진수 문법이 존재하지 않기 때문이다.그럼에도 불구하고 브라우저 벤더들은 비표준 요소인 8진수 리터럴을 지원하게끔 구현하였다.따라서 strict mode에 따라서 8진수 리터럴의 사용 가능 여부가 달려있다. MDN Strict mode strict mode in ECMAScript 5 forbids octal syntax.Octal syntax isn’t part of ECMAScript 5,but it’s supported in all browsers by prefixing the octal number with a zero:0644 &#x3D;&#x3D;&#x3D; 420 and “\\045” &#x3D;&#x3D;&#x3D; “%”.&#96; in ES6 12console.log(0o71); // 57console.log(0O71); // 57 16진수수학식: FF(16)기타 프로그래밍 언어: 0xFF, xFF, hFF, etc. in ES 1234console.log(0xff); // 255console.log(0Xff); // 255console.log(0xA); // 10console.log(0XA); // 10 주의사항1console.log(0b11.1); // Uncaught SyntaxError: missing ) after argument list 10진수를 제외한 진수 리터럴은 정수만 표현 가능하다..을 붙인다고 해서 실수가 되는 게 아니라 Number.prototype.1로 접근을 하게 된다.10진수의 경우에는 실수 취급한다. 123Number.prototype.Aa = &#x27;Aa&#x27;;console.log(0b11.Aa); // &#x27;Aa&#x27;1.Aa; // Uncaught SyntaxError: Invalid or unexpected token","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Number","slug":"Number","permalink":"https://perfectacle.github.io/tags/Number/"}]},{"title":"JetBrains 회사 제품의 라이센스","slug":"JetBrains-License","date":"2016-12-18T22:01:28.000Z","updated":"2022-10-30T08:42:16.099Z","comments":true,"path":"2016/12/18/JetBrains-License/","link":"","permalink":"https://perfectacle.github.io/2016/12/18/JetBrains-License/","excerpt":"여름방학에 현장실습을 하면서 다음과 같은 경험을 했다. A: 권성 씨, 에디터 좋다. 뭐 써요?나: 저 웹스톰이요. 저희 학교는 교직원에게만 이메일을 줘서 친구 걸로 인증했어요.A: 뭐 같은 대학생이니까 상관 없으려나…(잠시 후…)A: 어, 웹스톰은 기업용이 아니면 기업에서는 쓰면 안 된다고 하는데요?나: (나니?!) 국내 유통 업체에서 팔고있는 웹스톰 개인용 라이센스&amp;nbsp;내가 느끼기에는 ‘개인용’이란 단어를 교묘하게‘가정용&#x2F;학생용’이라는 단어로 바꿔치운 상술로 밖에 보이지 않았다.이 당시에는 서로 바빠서 그냥 무시하고 웹스톰을 계속 썼었는데,나중에 취직을 하게 되면 계속 써야할텐데 그 비싼 기업용 라이센스를사야하나 싶어서 이번에 집중적으로 알아보았다.","text":"여름방학에 현장실습을 하면서 다음과 같은 경험을 했다. A: 권성 씨, 에디터 좋다. 뭐 써요?나: 저 웹스톰이요. 저희 학교는 교직원에게만 이메일을 줘서 친구 걸로 인증했어요.A: 뭐 같은 대학생이니까 상관 없으려나…(잠시 후…)A: 어, 웹스톰은 기업용이 아니면 기업에서는 쓰면 안 된다고 하는데요?나: (나니?!) 국내 유통 업체에서 팔고있는 웹스톰 개인용 라이센스&amp;nbsp;내가 느끼기에는 ‘개인용’이란 단어를 교묘하게‘가정용&#x2F;학생용’이라는 단어로 바꿔치운 상술로 밖에 보이지 않았다.이 당시에는 서로 바빠서 그냥 무시하고 웹스톰을 계속 썼었는데,나중에 취직을 하게 되면 계속 써야할텐데 그 비싼 기업용 라이센스를사야하나 싶어서 이번에 집중적으로 알아보았다. 개인용 라이센스를 기업에서도 쓸 수 있는가?&amp;nbsp;Can I use my personal license at work and at home? Yes, you can use your personal license at work as well as at home. You can use it working on your personal projects as well as projects of your company. Our EULAs do not restrict this. 그냥 써도 된다는 소리다. &nbsp; [Can I use my personal license for commercial development?](https://sales.jetbrains.com/hc/en-gb/articles/207241015-Can-I-use-my-personal-license-for-commercial-development-) Yes, you can use your license for any kind of development. However, only you may use your personal license; you may not share it with others. 직관적으로 상업용 개발을 하는데 개인용 라이센스를 써도 되느냐? Yes, 하지만 타인과 공유는 하지 말란다. &nbsp; 개인용 라이센스를 데스크탑과 랩탑에 동시에 설치해도 되는가?&amp;nbsp;Can I use my personal license on multiple machines?You may install the product on multiple machines and multiple OS's. However, please note, that our licenses do not allow concurrent connections. This means that the license may only be used on one machine at a time. 다수의 컴퓨터와 다수의 OS에 설치 해도 되지만 동시에 사용하지 말라고 하는데... 무슨 탐지 기술이라도 있나 싶어서 다른 글을 더 찾아보니... &nbsp; [Using IDE on different machines and operating systems with the same license](https://intellij-support.jetbrains.com/hc/en-us/articles/207241005-Using-IDE-on-different-machines-and-operating-systems-with-the-same-license) However, IDE checks for the number of running copies on the local network when starting. In case it finds any copies started with the same license, they are all shut down except the last one. 로컬 네트워크(같은 공유기에 물려있는 경우)에 동일한 라이센스의 IDE가 감지된 경우 마지막에 실행된 IDE를 빼고 종료를 시킨다고 한다. 그럼 전 세계의 만날 일 없는 개발자들과 공유하면... 양심에 맡기자. &nbsp; 개인용 라이센스와 기업용 라이센스는 무슨 차이인가?&amp;nbsp;What is the difference between commercial and personal licenses? A Commercial license is the standard licensing option for organizations and business entities. Licenses are purchased by the company and can be used by any person within this organization. 기업용(상업용, Commercial) 라이센스는 기업이나 기관에서 살 수 있으며, 즉 `개인이 기업용 라이센스를 사는 것`은 `불가능`하며, 해당 기업과 기관에 속한 조직원이라면 누구나 해당 라이센스를 쓸 수 있다. &nbsp; A Personal license is an option for private individuals who purchase a license with their own funds, and solely for their own use. Personal licenses are not to be purchased, refunded or in any way financed by companies. 개인용 라이센스는 개인이 살 수 있으며, 즉 `기업이 개인용 라이센스를 사주는 것`은 `불가능`하다. &nbsp; 위 사항만 보면 아래와 같은 사항에 대해 어떠한 차이점이 존재하는지 의문점이 생긴다. 개인용 라이센스를 개인이 사서 개인이 회사에서 작업하나기업용 라이센스를 기업이 사서 개인이 회사에서 작업하나 [Commercial vs Personal software licenses](http://softwareengineering.stackexchange.com/questions/233898/commercial-vs-personal-software-licenses) For Jetbrains, the corporate license is a license that's not linked to an individual. The personal license is linked to a specific person. What that means inside a company is that if you buy a corporate license for 10 users, any 10 people can use the product at any given time. If however you buy 10 personal licenses, only the 10 specific people who are mentioned can ever use the product. Were one of them to leave the company, that license becomes useless (though they might have a means to get the license transfered to another person, you'd have to contact Jetbrains about that). 허접한 영어 실력으로 해석해보자면 기업용 라이센스는 몇 명의 유저가 쓸 수 있는지에 따라서 가격이 달라지는 것 같다.위에서 구매한 유저 인원수에 따라 로컬 네트워크에 동시 사용을 제한하는 것 같다.만약 조직 구성원 중 한 명이 떠나면 새로운 개발자에게 기업용 라이센스가 위임되는 것 같다. 마지막으로 `기업용 라이센스를 가진 개인이 집에서 작업을 할 수 있는가?`라는 의문이 들었다. [Can I use a commercial license purchased by my company at home?](https://sales.jetbrains.com/hc/en-gb/articles/206544349-Can-I-use-a-commercial-license-purchased-by-my-company-at-home-) We, in our EULAs, do not prohibit using commercial licenses of your company at home. However, please inquire your employer about it as this may vary depending on your company's policies. 사용해도 된다는 소리 같은데, 두 번째 문장을 `Young Gratia` 님께서 친히 번역해주셨다. 회사 정책에 따라 달라질 수 있으니, 사용 전에 고용주에게 문의해보라는 내용이다. &nbsp; 학생용 라이센스는 개인용 라이센스와 동일한가?이 부분에 있어서는 참 질문이 많았다.링크에 접속이 되지 않아 직접 주고받은 메일의 pdf 파일을 직접 첨부한다.질문 메일답변 메일&amp;nbsp; 나는 대학생인데 우리 학교는 교직원을 제외하고는 이메일이 제공되지 않는다.그래서 친구의 대학 이메일을 빌려서 인증하여 사용 중인데, 이는 유효한 라이센스인가?&amp;nbsp; You will not need a university email address, it is only necessary to upload an official document showing you are currently a student (you have an option \"official document\").이메일 주소 필요없이 내가 현재 대학생이라는 사실을 입증할 수 있는 공식적인 서류만 보내면 된단다. 즉 현재 대학생이라 하더라도 나같이 타인의 이메일을 빌려 학생 라이센스를 취득한 경우 유효하지 않다. &nbsp; 학생용 라이센스를 가지고 기업에서도 사용할 수 있는가?&amp;nbsp; The free student license cannot be used at work for commercial purposes. It is only intended for learning, educational purposes.무료 학생용 라이센스는 상업적 목적인 작업에서는 쓰일 수 없단다. 기업에서는 상업적이지 않을 수가 없으므로 즉 기업에서는 못 쓴다고 보면 된다. 학생용 라이센스는 오직 학습과 교육을 위해서만 쓰여야한다. &nbsp; 학생용 라이센스 인증 기간 도중에 졸업을 하는 경우, 남은 기간동안도 유효한가?&amp;nbsp;나의 영어 실력이 미흡하여 질문의 의도를 파악하지 못하고,졸업생들에게 할인을 해주는 제도에 대해 설명을 하였다.만약 졸업 후에 학생용 라이센스 기간이 몇 달 남았다면 집에서만 조용히 쓰도록 하자.&amp;nbsp; 대학교 졸업 후에도 이메일이 사라지지 않는 경우, 계속 사용하는 것이 유효한가?&amp;nbsp;이 역시 나의 영어 실력이 미흡하여 제대로된 답변을 받지 못했으나다음의 링크를 보고 답을 얻게 되었다.&amp;nbsp;Free for students: Professional developer tools from JetBrains **Is a free Student License perpetual?** No, the Student License is valid for one year and perpetual licenses are not provided. After one year you will need to renew your Student License for the next year, **or purchase a license if you’re no longer a student.**마지막 or 부분부터 해석하자면 만약 더이상 학생이 아닌 경우에는 구매하라고 한다. 즉 대학교 이메일이 졸업후에도 사라지지 않더라도 본인이 학생이 아니라면 그 라이센스는 유효하지 않다. 만약 사용 가능하다면 집안에서만 조용히 써야할 것이다. 다른 제품들의 라이센스에 있어서도 상술에 찌든 국내 유통 업체보다는해석하기 어렵지만 보다 정확하고 정직한 공식 사이트의 문서들을 참조해야겠다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://perfectacle.github.io/tags/IDE/"},{"name":"Editor","slug":"Editor","permalink":"https://perfectacle.github.io/tags/Editor/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://perfectacle.github.io/tags/JetBrains/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://perfectacle.github.io/tags/WebStorm/"},{"name":"PhpStorm","slug":"PhpStorm","permalink":"https://perfectacle.github.io/tags/PhpStorm/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"https://perfectacle.github.io/tags/IntelliJ/"}]},{"title":"CDN 무료 호스팅하기","slug":"CDN-Free-Hosting","date":"2016-11-28T19:54:03.000Z","updated":"2022-10-30T08:42:16.063Z","comments":true,"path":"2016/11/28/CDN-Free-Hosting/","link":"","permalink":"https://perfectacle.github.io/2016/11/28/CDN-Free-Hosting/","excerpt":"","text":"남들의 사랑과 관심이 고파서 라이브러리를 CDN 호스팅 업체에 등록하고자 며 칠 간 고생했던 내용을 적어봤다.CDN에 대해서는 구글링하면 많이 나오는데 CDN은 각 지역 별로 서버를 두는 서비스 형식으로 대충 알고있다.국내 무료 호스팅 업체에 그냥 나의 라이브러리를 업로드해도 되지만 일정 기간마다 서비스를 연장하거나 트래픽 등등의 문제가 존재하였다.그리고 제이쿼리나 부트스트랩 등등의 프레임워크&amp;라이브러리들이 외국 CDN 호스팅 업체에 등록된 걸 보면 뭔가 동경의 대상이었다.나의 라이브러리도 한 번 그렇게 만들어 보고 싶었다.뭔가 좋아보인다 싶으면 따라하는 게 나의 단점이지만 그래도 해보고 싶었다. maxCDN cdnjs jsdelivr &amp;nbsp;혼자서 깃헙 문서를 보고 따라할 사람은 아래 링크로 들어가면 된다.https://github.com/jsdelivr/jsdelivr/blob/master/CONTRIBUTING.md&amp;nbsp;준비사항: 라이브러리가 올라가 있는 본인의 깃헙 저장소.그리고 그 깃헙 저장소에 태그가 있어야한다.태그가 뭔지 모르는 사람은 아래 링크를 참조하자.http://www.whatwant.com/377 &amp;nbsp;그 이후에 아래 링크로 접속한다.https://github.com/jsdelivr/jsdelivr/tree/master/files 12345author = &quot;name of lib author&quot;github = &quot;https://github.com/user_id/repository&quot;homepage = &quot;없으면 그냥 깃헙 저장소 주소 입력해도 되고, npm 주소 입력해도 됨.&quot;description = &quot;설명&quot;mainfile = &quot;lib.min.js&quot; 12345678910// 패키지 매니저에는 npm이라고 입력해도 되는 것 같다.// files에는 호스팅 될 파일을 입력하면 된다.&#123; &quot;packageManager&quot;: &quot;github&quot;, &quot;name&quot;: &quot;lib-name&quot;, &quot;repo&quot;: &quot;user_id/lib-name&quot;, &quot;files&quot;: &#123; &quot;include&quot;: [&quot;lib-name.js&quot;, &quot;lib-name.min.js&quot;] &#125;&#125; 예제 작성을 위해 한글을 썼더니 ascii 케릭터로만 적으라는 오류를 뿜는다.하단의 Close pull request를 눌러서 취소 시키고, 오류를 수정한 후 다시 풀리퀘를 날리면 된다. 감격의 순간이다 흑흑흑…버전 별로 호스팅이 되어있고, unminify, minify한 js 파일 모두 다 호스팅 되었다.세상 어딘가에 나의 발자취를 남긴 것 같아 굉장히 뿌듯하다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://perfectacle.github.io/tags/CDN/"},{"name":"Hosting","slug":"Hosting","permalink":"https://perfectacle.github.io/tags/Hosting/"}]},{"title":"(ES) 정규표현식 응용하기","slug":"ES-RegExp-ex","date":"2016-11-27T23:14:30.000Z","updated":"2022-10-30T08:42:16.071Z","comments":true,"path":"2016/11/27/ES-RegExp-ex/","link":"","permalink":"https://perfectacle.github.io/2016/11/27/ES-RegExp-ex/","excerpt":"이 포스트는 정규표현식에 대한 기초 사항을 설명하진 않는다.대신 다양한 케이스와 테스트 하는 방법 등등에 대해 포커스를 맞춘다.정규표현식의 기초에 대해 궁금한 사람들은 아래 링크를 참조하길 바란다.http://www.nextree.co.kr/p4327/정규표현식을 책의 목차의 제일 마지막에 있는 것을 보아 가장 어려운 내용인 줄 알았는데,안 어렵다. 쉽다.클로저, 콜백 등등의 개념을 몰라도 당장 익히는데 전혀 무리가 없다.그리고 안 써먹으면 까먹는다. 당연하다.필자도 쓸 때마다 찾아봐서 테스트하지, 그렇다 해도 시간이 절대 오래 걸리지 않는다.필요한 내용만 찾아서 쓰고 테스트하면 되고, 도움을 주는 여러가지 것들이 많으니 당장 배워보길 바란다.또한 다른 프로그래밍 언어에서도 조금씩 다른 형태로 지원하니 알아두면 좋다. 목차 정규표현식은 왜 쓸까 테스트해보기 응용하기 and의 원리 파악하기 정규표현식은 왜 쓸까?","text":"이 포스트는 정규표현식에 대한 기초 사항을 설명하진 않는다.대신 다양한 케이스와 테스트 하는 방법 등등에 대해 포커스를 맞춘다.정규표현식의 기초에 대해 궁금한 사람들은 아래 링크를 참조하길 바란다.http://www.nextree.co.kr/p4327/정규표현식을 책의 목차의 제일 마지막에 있는 것을 보아 가장 어려운 내용인 줄 알았는데,안 어렵다. 쉽다.클로저, 콜백 등등의 개념을 몰라도 당장 익히는데 전혀 무리가 없다.그리고 안 써먹으면 까먹는다. 당연하다.필자도 쓸 때마다 찾아봐서 테스트하지, 그렇다 해도 시간이 절대 오래 걸리지 않는다.필요한 내용만 찾아서 쓰고 테스트하면 되고, 도움을 주는 여러가지 것들이 많으니 당장 배워보길 바란다.또한 다른 프로그래밍 언어에서도 조금씩 다른 형태로 지원하니 알아두면 좋다. 목차 정규표현식은 왜 쓸까 테스트해보기 응용하기 and의 원리 파악하기 정규표현식은 왜 쓸까?정규표현식은 문자열을 가지고 놀 때 쓴다.정규표현식을 쓰지 않아도 되지만 코드를 줄이기 위해서 사용한다.아래 코드를 봐보자. 12345678910111213141516var gender = &#x27;M&#x27;;// case 1.if(gender.indexOf(&#x27;m&#x27;) &gt; -1 || gender.indexOf(&#x27;M&#x27;) &gt; -1) &#123; // 블라블라...&#125;// case 2.if(gender.toLowerCase().indexOf(&#x27;m&#x27;) &gt; -1) &#123; // 블라블라...&#125;// case 3.if(/m/i.test(gender)) &#123; // 블라블라...&#125; 3번 케이스가 정규표현식을 사용한 경우이다.이렇듯 정규표현식은 꼭 쓰지 않아도 되지만 코드의 길이를 확연하게 줄여주기도 한다. 테스트해보기테스트 해보려고 일일이 콘솔창에 찍는 방법이 있지만 귀찮다.정규표현식 테스트를 지원하는 에디터도 있지만, 그런 것에 구애받지 않고 테스트 하는 방법을 소개한다.아래 사이트로 접속해보자.http://regexr.com/ 설명이 필요 없을 정도로 사용 방법은 쉽다.좌측 메뉴를 적극 활용하면 자신이 원하는 케이스들을 쉽게 찾을 수 있다. 응용하기이제부터는 다양한 사례를 통해 어떻게 응용해야할지 알아보자. 끝말잇기 한방 단어 금지시키기사용 기법: not whitespace → \\S, one or more → +, character set → [슘륨녘]끝말잇기를 하다보면 한방 단어로 끝낼 때가 있다.한 판이면 상관 없지만 매번 똑같이 당하면 아주 짜증나기 마련이다.특히 륨, 늄, 슘 등등으로 끝나는 화학 원소 기호들…슘페터란 인물이 있지만, 막는 건 한 번에 불과하다.이를 위한 정규표현식을 작성해보자. 가나다 순으로 구분하기사용 기법: range → [다-딯], one or more → +알파벳과 다르게 가나다 순에서 가는 가, 갸, 거, 겨 등등 가 하나만 놓고 봐도 매우 많다.단어장을 만든다 할 때 정규표현식 없이 구분하려면 if문의 도가니에 빠지게 될 것이다. 단어 뒤에 공백(스페이스바, 탭, 엔터키)가 아닌 경우에는 \\S를 쓰면 안 된다.if 문을 써서 다로 시작하는 단어, 도로 시작하는 단어, 대로 시작하는 단어, …이 모든 케이스들을 구분한다면 상당한 삽질이 예상된다. 몇 학년인지 구하기사용 기법: Digit → \\d, one or more → +, positive lookahead → (?&#x3D;학년) 이는 몇 학년인지, 몇 반인지, 몇 동에 사는지 등등구하려는 정보가 특정 접미어 앞에 존재할 때 유용하다. 학번 구하기사용 기법: capturing → (\\d+), Digit → \\d, one or more → +이번에는 구하려는 정보가 특정 접두어 뒤에 뒤에 존재하는 정보를 구하려 한다. 어쩔 수 없이 트릭을 써야한다. 출처는 아래 링크다.Positive look behind in JavaScript regular expression테스트 하려면 사이트가 아닌 콘솔 창 등등에서 테스트해야만 한다. 123var str = &#x27;양권성 간장대학교 3학년 학번: 20120012&#x27;;var regExp = /학번: (\\d+)/;console.log(str.match(regExp)[1]); // &#x27;20120012&#x27; 삼둥이 중에 둘 째 찾기사용 기법: capturing → (.+), any character except line breaks → ., one or more → +이제는 접두어와 접미어 사이에 낀 녀석을 찾아보자.어… 예제가 적절치 않은데 그냥 이런 것도 있다고 생각하고 나중에 참고하면 될 것 같다.이번에도 테스트 하려면 사이트가 아닌 콘솔 창 등등에서 테스트해야만 한다.전국에 삼둥이는 참 많다.그 중에 첫 째는 대한이, 셋 째는 만세, 둘 째는…?둘 째의 이름을 구해보자! 12345const name = `대한, 민국, 만세대한, 간장, 짱짱조선, 민국, 만세`;const regExp = /대한, (.+), 만세/;console.log(name.match(regExp)[1]); // 민국 스팸 단어 정하기사용 기법: capturing → (도박|마카오|카지노), or → |스팸 게시물은 언제나 골칫거리다.이를 약간이라도 줄이고자 필터링을 하는 방법으로 정규표현식이 많이 쓰인다. 비밀번호의 강도 높이기요즘 크래커들의 크래킹 수준은 날이 갈 수록 높아져 비밀번호에 신경을 써야한다.단순히 길다고 해서 끝나는 게 아니라 좀 더 복잡해야한다.기본적으로 알파벳, 숫자, 특수기호가 들어가면서 8자 이상 20자 이하의 비밀번호를 작성해보자.출처는 오래 전이라 까먹었다. 스택 오버플로우였는데… 1/(?=.*[a-z])(?=.*\\d)(?=.*[\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\&#x27;\\&quot;])[a-z\\d\\&#123;\\&#125;\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\&#x27;\\&quot;]&#123;8,20&#125;/ 이상한 외계어가 보인다.그냥 가져다 쓰실 분은 쓰시고, 혹시 여기서 좀 더 보안을 강화하고 싶거나호기심 충만하신 분들만 아래 내용을 보면 될 것 같다. 먼저 이걸 이해하기 전에 정규표현식의 and에 대해 알아야 한다.기본적으로 자바스크립트의 정규표현식에서는 and 연산자가 없다.아래와 같은 편법이 필요하다.regexp logic and or이해를 돕기 위해 정규표현식을 합성해서 공백을 넣었다. (?&#x3D;)은 접미어 앞에 존재하는 단어를 긁어내는 연산자이다.you 라는 단어 앞에 글자가 0개 이상 있고, I 라는 단어 앞에 글자가 0개 이상 있다.풀어서 쓰면 아래와 같다. 1you 앞에 글자 0개 이상 + I 앞에 글자 0개 이상(you를 포함) + 그 뒤에 글자 0개 이상(I를 포함) (?&#x3D;.*word1)(?&#x3D;.*word2)와 같은 기법으로 순서가 상관 없는 and를 구현할 수 있다.그리고 어떠한 글자들을 허용할 것인지 .*을 이용하여 표현하였다. 여기까지 이해했다면 이제 위 비밀번호 외계어 정규 표현식을 이해할 수 있다.하나씩 까서 보자. (?&#x3D;.*[a-z])(?&#x3D;.*\\d)(?&#x3D;.*[{}[]/?.,;:|)*~&#96;!^-_+&lt;&gt;@#$%&amp;\\=(&#39;&quot;])첫 번째 포함 키워드는 알파벳, 두 번째 포함 키워드는 숫자, 세 번째 포함 키워드는 특수기호특수기호는 입맛에 맞게 더 넣던지 빼던지 하면 된다. [a-z\\d{}[]/?.,;:|)*~&#96;!^-_+&lt;&gt;@#$%&amp;\\=(&#39;&quot;]알파벳과 숫자, 특수기호의 입력을 허용 {8, 20}8자 이상 20자 이하 이를 다 조합해보면알파벳, 숫자, 특수기호를 무조건 포함해야하며, 순서는 상관 없고,알파벳, 숫자, 특수기호만 허용하고, 8자 이상 20자 이하의 패스워드가 만들어지게 된다. 그럼…알파벳, 숫자는 무조건 포함하면서 특수기호는 입력 해도 그만 안 해도 그만인 정규표현식은 어떻게 만들면 될까?댓글 유도 및 방문자 여러분에게 질문을 던져본다. and의 원리 파악하기호기심이 멈추지 않아 and를 왜 (?&#x3D;.*word1)(?&#x3D;.*word2)와 같이 구현한 건지 파보았다.머리가 돌아가지 않아 순전히 노가다였다. 우선 word1이라는 단어가 포함되게 하려면 위와 같이 작성하여야 한다. word1이란 단어 앞에 있는 패턴만 얻고 싶을 때 &#x2F;패턴(?&#x3D;word1)&#x2F;을 쓴다.하지만 정규표현식을 보면 (?&#x3D;word1)앞에 아무런 패턴이 없다.따라서 (?&#x3D;word1)으로 얻어지는 패턴은 word1의 시작 위치이다.그 시작 위치 이후에 .*, 즉 글자가 0개 이상이므로 위와 같이 word1의 시작 지점 이후부터의 문자만 가져온다.두 번째 1word1에서 word1의 앞 부분인 1은 얻어오질 못하는 것이다. @+word1의 정보까지 얻어오려면 위와 같이 .*을 붙여줘야한다.그래야 @+word1이 시작하는 위치를 얻어와서 1word1도 정상적으로 인식한다. 이 경우에는 왜 아무것도 못 얻어오는지 보자.(?&#x3D;word1)로 word1이 시작하는 위치를 얻어왔다. 저 위치에서 (?&#x3D;word2)가 실행이 된다.저 위치에선 word2 앞에 있는 정보를 얻어올 수 없다.word1이 가로막고 있기 때문이다. (?&#x3D;word2)를 (?&#x3D;.*word2)로 바꿔줘야 (?&#x3D;word1)가 반환한 위치로 가도가로막히지 않고 제대로 정보를 얻어올 수 있다. 마지막 케이스는 word1이 없으므로 반환하는 위치가 없다.처음에 .*을 붙여버리면 각 라인 별 빨간 박스로 표시해둔 .*word1의 정보까지 받아오는 것 같다. (?&#x3D;.*word1)을 수행한 후에 빨간색 박스친 정보를 가지고 있다.그 이후에 (?&#x3D;.*word2)를 수행하면 word2가 시작되는 파란색 화살표 위치로 이동하게 된다.그 이후에 .*이 실행되서 하늘색 결과를 얻어올 수 있다. 먼저 (?&#x3D;.*word1)이 시작하는 위치와 정보를 저렇게 받아온다. 먼저 (?&#x3D;.*word2)이 시작하는 위치는 (?&#x3D;.*word1)이 시작하는 위치와 같다.그리고 (?&#x3D;.*word2)이 얻어오는 정보는 파란색 박스와 같다.두 패턴이 얻어온 정보를 짬뽕해서 그 뒤에 .*이 실행되면서 원하는 정보를 얻어온다. 내가 이해한 게 잘 이해한 건지, 설명이 틀리지는 않았는지는 장담하지 못하겠다…넘나 어렵다…그냥 쓰기나 할 걸 괜히 파고 든 것 같다는 생각이 살짜쿵 든다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"RegExp","slug":"RegExp","permalink":"https://perfectacle.github.io/tags/RegExp/"}]},{"title":"(Markdown) 개발자스러운 뱃지","slug":"Markdown-Badge","date":"2016-11-26T23:14:30.000Z","updated":"2022-10-30T08:42:16.099Z","comments":true,"path":"2016/11/26/Markdown-Badge/","link":"","permalink":"https://perfectacle.github.io/2016/11/26/Markdown-Badge/","excerpt":"이번 포스트는 정말 별 것 없다.마크다운 문법에 대한 설명도 아니고 그냥 좀 더 개발자스러운 이미지들을 써보는 글이다. 목차 뭐가 개발자스러운 뱃지인가? 뱃지를 직접 사용해보자 커스텀 뱃지 만들기 NPM 뱃지 뭐가 개발자스러운 뱃지인가?","text":"이번 포스트는 정말 별 것 없다.마크다운 문법에 대한 설명도 아니고 그냥 좀 더 개발자스러운 이미지들을 써보는 글이다. 목차 뭐가 개발자스러운 뱃지인가? 뱃지를 직접 사용해보자 커스텀 뱃지 만들기 NPM 뱃지 뭐가 개발자스러운 뱃지인가?유명한 라이브러리&amp;프레임워크를 보면 위와 같은 이미지? 스티커?들이 보인다.bower며 npm이며 build 등등의 뱃지가 보인다.이번 포스트에서 소개할 것은 위 사항들을 사용하는 방법에 대해서 배워보자. 뱃지를 직접 사용해보자.우선 http://shields.io/로 접속하자.여기서 나는 내가 npm에 올린 check-browsers라는 라이브러리의 다운로드 수와 버전을 표시하기로 했다. 나는 총 다운로드 수를 표현하고 싶어서 npm의 두 번째 이미지를 클릭하였다. npm 패키지의&#x2F;dt(다운로드 토탈)&#x2F;패키지 이름의 형식을 가진다.마크다운 문법에서 사용하려면 그냥 복붙하면 된다. 이번엔 내 패키지의 버전을 표시해보자. npm 패키지의&#x2F;v(버전)&#x2F;패키지 이름의 형식을 가진다. 깃헙에서 내 저장소가 따봉 몇 개나 받았는지도 표현할 수 있다. 유저이름&#x2F;저장소 이름의 형식을 가진다. 이외에 커밋 갯수나 트위터 팔로워 뱃지 등등은 직접 찾아서 사용하면 된다.또한 뱃지는 svg, json, png 포맷을 지원한다. 커스텀 뱃지 만들기 커스톰 뱃지의 형태도 나오고 직접 만들어볼 수도 있다. 다양한 파라미터를 통해 스타일, 레이블 등등을 바꿔치기 할 수 있다.이는 커스텀 뱃지나 기존에 만들어져있는 형태의 뱃지에서도 사용이 가능하다. NPM 뱃지NPM 뱃지는 NPM만을 위한 뱃지이다.백문이 불여일견, https://nodei.co/로 접속해보자. npm에 특화된 다양한 뱃지들이 존재한다. 복잡시럽게 읽기 귀찮은 사람들은 간단하게 패키지 이름만 입력하면 다양한 뱃지가 나온다. 좀 더 커스터마이징 하고 싶은 사람들은 해당 페이지를 읽으면 된다.","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://perfectacle.github.io/tags/Markdown/"},{"name":"md","slug":"md","permalink":"https://perfectacle.github.io/tags/md/"}]},{"title":"(git) 정리 노트","slug":"git-Reference","date":"2016-11-19T16:55:28.000Z","updated":"2022-10-30T08:42:16.611Z","comments":true,"path":"2016/11/19/git-Reference/","link":"","permalink":"https://perfectacle.github.io/2016/11/19/git-Reference/","excerpt":"이 포스트는 git을 접하다 보면 마주치는 다양한 상황들에 대해 대처하기 위해 정리한 글이다.Ctrl+F 키를 눌러 원하시는 키워드를 검색하시면 다양한 케이스들을 볼 수 있다.이 문서는 계속해서 업데이트 될 예정이고, 댓글로 제보 해주면 감사할 것 같다 &gt;_&lt;혹시 문제 해결이 되지 않는다면 검색 키워드들을 조합해서 검색해보길 바란다.취소, 되돌아가기, 삭제: undo, reset, remove되돌아가기: revert, retrieve특정: specific미작동: not working .gitignore가 작동하지 않을 때검색 키워드: .gitignore not working 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot;","text":"이 포스트는 git을 접하다 보면 마주치는 다양한 상황들에 대해 대처하기 위해 정리한 글이다.Ctrl+F 키를 눌러 원하시는 키워드를 검색하시면 다양한 케이스들을 볼 수 있다.이 문서는 계속해서 업데이트 될 예정이고, 댓글로 제보 해주면 감사할 것 같다 &gt;_&lt;혹시 문제 해결이 되지 않는다면 검색 키워드들을 조합해서 검색해보길 바란다.취소, 되돌아가기, 삭제: undo, reset, remove되돌아가기: revert, retrieve특정: specific미작동: not working .gitignore가 작동하지 않을 때검색 키워드: .gitignore not working 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot; 커밋 메시지는 자기 입맛에 맞게 수정하면 된다. 특정 브랜치 클론하기검색 키워드: git specific branch clone 1git clone -b &lt;브랜치명&gt; &lt;원격 저장소 주소&gt; &lt;폴더명&gt; 폴더명을 입력하지 않으면 원격 저장소 이름으로 폴더가 생성된다. 특정 커밋 클론하기검색 키워드: git clone specific commit 123git clone &lt;원격 저장소 주소&gt; &lt;폴더명&gt;cd &lt;폴더명&gt;git reset --hard &lt;커밋 해시&gt; 한 번에 땡겨오는 명령어는 없는 것 같다. add한 파일 취소시키기검색 키워드: git undo add 1git reset &lt;file&gt; 커밋을 하기 전에 add한 파일을 취소시킬 때 유용하다.add한 모든 파일을 취소 시키려면 file을 빼고 입력하면 된다.git status를 찍어보면 untracked 상태로 돌아간 걸 확인할 수 있다. 특정 커밋으로 돌아가기검색 키워드: git reset commit to master 123git reset --hard &lt;커밋 해시&gt;// 아래까지 하면 리모트 저장소까지 돌림.git push --force origin master 로컬에서 가장 최근 커밋 삭제검색 키워드: git reset recent commit 1git reset HEAD~ git log –oneline을 찍어보면 가장 최근 커밋이 날아간 걸 볼 수 있다. 리모트 저장소 특정 커밋까지 삭제검색 키워드: git undo remote push 1git push -f &lt;리모트 저장소 이름&gt; &lt;삭제하기 직전 커밋 해시:브랜치 이름&gt; 삭제하기 직전 커밋까지만 살고 그 이후의 커밋은 날아간다. 워킹 디렉토리 깔끔하게 하기검색 키워드: git reset untracked files 1git clean -f -d untracked 파일들이 날아간다.특정 커밋으로 돌아갔을 때 잡다구레한 파일들을 날릴 때 유용하다. 로컬&#x2F;리모트 브랜치 삭제하기검색 키워드: git remove remote branch 12git branch -d branch_namegit push origin :&lt;branch_name&gt; 순서대로 로컬&#x2F;리모트 저장소에서 브랜치를 삭제하는 명령어이다. Alias123git config --global alias.unstage &quot;reset HEAD --&quot;git unstage fileAgit reset HEAD fileA 첫 번째 라인에서 alias(별칭)을 글로벌로 선언함.2, 3번 라인은 동일함. add와 commit 동시에 하기12git config --global alias.commitx &#x27;!git add . &amp;&amp; git commit -a -m &#x27;git commitx &quot;커밋 메시지&quot; 명령어 두 개가 혼재돼있을 때는 첫 명령어에 !을 붙여야 정상 작동한다.윈도우에서는 ‘’ 대신에 “”을 써야 작동하는 것 같다add와 commit을 매번하기 귀찮으므로 필자가 자주 쓰는 alias이다. alias 관리12git config --get-regexp aliasgit config --global --unset alias.untage 첫 번째 라인은 alias 목록을 보여주고,두 번째 라인은 alias를 삭제해주는 역할을 한다. commit 메세지에 timestamp 넣기.검색 키워드: git commit message time 12git commit -m &quot;`date`&quot;git commit -m &quot;`date +\\&quot;%Y/%m/%d %H:%M:%S\\&quot;`&quot; 첫 번째 라인은 Sun Dec 4 22:12:42 KST 2016 같은 형식으로 커밋 메시지가 나오고두 번째 라인은 2016&#x2F;12&#x2F;04 22:25:13 같은 형식으로 커밋 메시지가 나온다. 로컬 저장소를 원격 저장소로부터 싱크 맞추기검색 키워드: git sync with remote 12git fetch // 커밋 로그들만 받아옴.git reset --hard origin/&lt;your-working-branch&gt; 로컬 브랜치 이름 바꾸기검색 키워드: git branch rename 12git branch -m &lt;oldname&gt; &lt;newname&gt;git branch -m &lt;newname&gt; // 현재 브랜치","categories":[{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"git","slug":"Middle-end/git","permalink":"https://perfectacle.github.io/categories/Middle-end/git/"}],"tags":[{"name":"형상 관리","slug":"형상-관리","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EC%83%81-%EA%B4%80%EB%A6%AC/"},{"name":"버전 관리","slug":"버전-관리","permalink":"https://perfectacle.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"배포","slug":"배포","permalink":"https://perfectacle.github.io/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"git","slug":"git","permalink":"https://perfectacle.github.io/tags/git/"}]},{"title":"(Webpack) 모듈? 번들링?","slug":"Module-bundling-with-Webpck","date":"2016-11-18T09:38:50.000Z","updated":"2022-10-30T08:42:16.107Z","comments":true,"path":"2016/11/18/Module-bundling-with-Webpck/","link":"","permalink":"https://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/","excerpt":"목차 들어가기에 앞서 모듈, 너는 누구니? 웹팩을 사용해보자 웹팩에게 모듈이란…? 개발용? 배포용? 부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용해보자. 홈페이지, IE8에서도 웹팩을 써보자. 마치며… 들어가기에 앞서아주 많이 참조한 링크웹팩입문자를 위한 튜토리얼 파트1 - 웹팩 입문 !","text":"목차 들어가기에 앞서 모듈, 너는 누구니? 웹팩을 사용해보자 웹팩에게 모듈이란…? 개발용? 배포용? 부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용해보자. 홈페이지, IE8에서도 웹팩을 써보자. 마치며… 들어가기에 앞서아주 많이 참조한 링크웹팩입문자를 위한 튜토리얼 파트1 - 웹팩 입문 ! 이 포스트에서는 Node.js, npm, ES(ECMAScript), Babel 등등에 대해서는 설명하지 않는다.해당 내용들은 구글링을 통해 직접 찾아보길 바란다. 이번 포스트에서는 모듈이 왜 필요한지, 무엇인지, 번들링이란 무엇인지 등등에 대해 다룬다.또한 홈페이지나 SPA가 여러 개 있는 다중 페이지, IE8에서도 모듈 번들링을 하는 방법까지 다뤄보자. 모듈, 너는 누구니?ES5(3)를 공부해본 사람이라면 자바스크립트의 스코프 관리는 지저분하다는 것을 알 수 있다.이를 해결하고자 아래와 같은 방법들이 있다.private module을 구현하는 코드 (전역의 공간을 더럽히지 않는 코드)대신 script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 없다. 12345// ES3+ (IE 8+)(function() &#123; &#x27;use strict&#x27;; // 소스코드 끄적끄적...&#125;()); 1234// ES6 (Moden Browser)&#123; // 소스코드 끄적끄적...&#125; public module을 구현하는 코드script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 있다. 1234567891011121314151617// ES3+ (IE 8+), 전역 스코프에 변수가 추가된다는 단점이 존재한다.// 네임스페이스 패턴이라고 부른다.// script.js&#x27;use strict&#x27;;var car = (function() &#123; var namespace = &#123;&#125;; var color = &#x27;blue&#x27;; // 외부에 노출시키지 않음, 캡슐화. // 아래 메소드는 네임스페이스의 메소드임. namespace.getColor = function() &#123; return color; &#125;; namespace.setColor = function(_color) &#123; color = _color; &#125;; // 메소드를 달고 있는 네임스페이스 객체 리턴. return namespace;&#125;()); 123456// ES3+ (IE 8+), 전역 스코프에 car라는 변수가 추가된다는 단점이 존재한다.// script2.js&#x27;use strict&#x27;;console.log(car.getColor()); // &#x27;blue&#x27;;car.setColor(&#x27;red&#x27;);console.log(car.getColor()); // &#x27;red&#x27;; 123456// ES6 (현재 지원하는 브라우저 없음)// 이 방법이 베스트인데, 크롬마저도 미지원이다.// script.jslet color = &#x27;blue&#x27;;export const getColor = () =&gt; color;export const setColor = (_color) =&gt; color = _color; 1234567// ES6 (현재 지원하는 브라우저 없음)// 이 방법이 베스트인데, 크롬마저도 미지원이다.// script2.jsimport &#123;getColor, setColor&#125; from &#x27;./script&#x27;;console.log(getColor());setColor(&#x27;red&#x27;);console.log(getColor()); 이렇 듯 모듈은 변수의 스코프를 관리하는 기능을 한다.물론 이게 모듈의 전부는 아니지만, 그건 이 포스트의 주제를 벗어나므로 설명하지 않겠다.브라우저에서 ES6의 모듈이 지원되지는 않지만 모듈을 사용하는 두 가지 방법이 존재한다. 자바스크립트 파일&#x2F;모듈 로더인 requireJS를 사용. 모듈 번들러인 Webpack이나 Browserify 등등을 사용. 이 중에서 나는 2번의 Webpack을 택했다.참고로 번들러는 번들링하는 놈을 지칭하고,번들링은 여러가지 파일을 모아서 하나로 만드는 것이라고 보면 된다.여러 모듈을 하나로 합쳐서 http 리퀘스트 횟수를 줄여서퍼포먼스를 향상시키는 등등의 효과를 불러일으킬 수 있다. 웹팩을 사용해보자터미널 창에서 아래와 같이 입력해보자. 12$ npm i -g webpack$ npm i -D webpack babel-core babel-preset-latest babel-loader 위 명령어들을 하나 하나 헤짚어 보자. npm i -g webpack터미널에서 webpack 명령어를 사용하기 위해 글로벌로 웹팩을 설치 npm i -D webpack현재 프로젝트에서 웹팩을 사용하기 위해 설치 babel-corerequireJS 문법을 이용해도 모듈 번들링을 할 수 있지만,ES6의 import, export를 사용해보기 위해 babel을 사용하였다. babel-preset-latestbabel에는 plugin이라는 게 존재한다.이 plugin은 es6의 애로우 펑션을 지원하는 플러그인, 클래스를 지원하는 플러그인 등등이 있다.그러한 플러그인을 모아놓은 걸 preset이라고 부른다.es2015 preset은 es6의 플러그인들을 모아놓은 것이고,latest preset은 ES2015~ES2017까지의 프리셋들을 모아놓은 것이다.시간이 지나면 latest의 지원 프리셋 범위는 더 늘어날 수도 있다. babel-loader웹팩과 바벨을 연동해서 사용하기 위한 로더. 이제는 아래와 같이 디렉토리를 구성해보자. .babelrc entry-index.js index.html module-a.js module-b.js module-c.js webpack.config.js 1234567891011&lt;!-- index.html --&gt;&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ES6의 import와 export 문은 이 포스트에서 다루지 않겠다. 123// module-a.jsconst a = &#x27;나는 a&#x27;;export const ab = a + &#x27;, a를 외부에 노출시키지 않고 변수 a를 활용!&#x27;; 12// module-b.jsexport const a = &#x27;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&#x27;; 12// module-c.jsexport const b = &#x27;나도 써주랑!&#x27;; 123456// entry-index.jsimport &#123;ab&#125; from &#x27;./module-a&#x27;;import &#123;a&#125; from &#x27;./module-b&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;; console.log(ab); // &quot;나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!&quot;console.log(a); // &quot;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&quot; .babelrc 파일은 바벨의 설정 파일이다.아래와 같이 써주자. 123&#123; &quot;presets&quot;: [&quot;latest&quot;]&#125; webpack.config.js 파일은 웹팩의 기본 설정 파일이다.아래와 같이 써주자. 12345678910111213141516171819202122const webpack = require(&#x27;webpack&#x27;); module.exports = &#123; devtool: &#x27;source-map&#x27;, entry: &#x27;./entry-index.js&#x27;, output: &#123; filename: &quot;bundle.js&quot;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;] &#125;&#125;; 설정 파일을 하나씩 파헤쳐보자. devtool소스맵과 디버깅을 요긴하게 하기 위한 옵션이다.자세한 건 devtool 옵션 퍼포먼스를 참고하자. entryJavaScript 모듈화 도구, webpack에서는 아래와 같이 말하고 있다. 서로 의존 관계에 있는 다양한 모듈을 사용하는 시작점이 되는 파일이다. [Webpack 적용기 2 : 어떻게 사용하는가?](https://hjlog.me/post/118)에서는 다음과 같이 설명하고 있다. > 번들링의 진입점에 해당하는 entry point에서부터 require으로 명시된 의존성들을 해석하며 의존성 트리(dependency tree)를 그린다. output결과물이 어느 폴더, 어떤 파일명으로 저장될지 정하는 옵션이다. pluginsjs 난독화 플러그인, 번들 파일을 html에 자동으로 삽입해주는 플러그인 등등 종류가 많다. UglifyJsPluginjs 난독화 플러그인 modules파일들에 영향을 주는 옵션들 loadersWebpack 적용기 2 : 어떻게 사용하는가?에서는 다음과 같이 설명하고 있다. 이 때 require된 모듈들은 불러들어지는 과정에서 파이프라이닝 된일련의 로더 들을 거치게 된다.로더를 하나의 정해진 역할을 수행하는, 일종의 함수라고 생각할 수 있다.로더는 직전 단계의 모듈을 입력으로 받아,다양한 변형을 가한 뒤 다음 로더의 입력으로 넘겨준다.마지막 로더는 최종적으로 적절하게 변형된 모듈을번들 자바스크립트 파일에 넣어주게 된다. 그럼 실제로 번들링을 해보자. 1$ webpack -w 위 명령어를 실행하면 모듈들이 번들링되며 엔트리 포인트와 엔트리 포인트에 관련된 모듈들이변경될 때마다 다시 번들링되는 감시(watch)를 진행하게 된다.Ctrl+C 키를 누르면 빠져나올 수 있다. 그리고나서 다시 디렉토리를 보면 다음과 같은 파일이 생긴 것을 볼 수 있다. bundle.js bundle.js.map 한번 index.html 파일을 열어보고 콘솔창을 보자. 디버깅하여 모듈은 어떠한 스코프를 가지는지 알아보자. 6번 라인에 브레이크 포인트를 걸고 새로고침을 해보았다.module-c는 import 시켰지만 모듈의 변수를 사용하지 않았으므로불필요하게 스코프를 생성하지 않았다. 만약 모듈화가 브라우저 자체 내에서 지원된다면index.html은 아래와 같이 마크업해야하지 않을까 싶다. 12345678910111213&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;module&quot; src=&quot;./module-a.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;./module-b.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;./module-c.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./entry-index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 웹팩의 모듈 번들링 방식은 bundle.js 파일 하나만 요청해서 리퀘스트 횟수가 1회였는데,저렇게 의존하는 모듈이 많으면 많을 수록 리퀘스트 횟수가 증가하여 큰 비용을 지불하게 될 것이다.위와 같이 웹팩을 사용하면 큰 효과를 얻어낼 수 있다. 웹팩에게 모듈이란…?ES6의 관점에서 모듈과 웹팩의 관점에서 모듈은 다르다.ES6는 js 파일만 모듈이라고 한정하는데 반해 웹팩은 이미지, css 파일 등등도 모듈로 취급한다.js 모듈을 import 시키는 것은 따로 로더를 요구하지 않지만,다른 모듈들은 로더를 필요로 한다.다음 예제를 통해 css, scss 모듈을 import 시켜보자.또한 번들링 된 모듈(bundle.js)을 자동으로 추가시켜보자.위 디렉토리에서 아래 파일들을 추가하자. style.css style.scss 1234/* style.css */p &#123; user-select: none&#125; 12345/* style.scss */$color: red;h1 &#123; color: $color&#125; 그리고 index.html을 아래와 같이 수정해주자. 1234567891011&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;나는 문서의 제목이얌! 내가 짱이지!&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 이제 entry-index.js에 (s)css 모듈을 추가해보자. 1234567import &#x27;../styles/style.css&#x27;;import &#x27;../styles/style.scss&#x27;; import &#123;ab&#125; from &#x27;./module-a&#x27;;import &#123;a&#125; from &#x27;./module-b&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;; console.log(ab); // &quot;나는 a, a를 외부에 노출시키지 않고 변수 a를 활용!&quot;console.log(a); // &quot;모듈 a에 존재하는 변수 a와는 다른 스코프를 가짐&quot; 그리고 관련 로더들을 설치해보자. 1$ npm i -D html-webpack-plugin style-loader css-loader node-sass sass-loader postcss-loader autoprefixer 하나씩 까보자. html-webpack-pluginhtml에 번들링 된 bundle.js 파일을 넣어주는 역할을 한다. style-loader css-loadercss 모듈을 import 시키기 위한 로더이다. node-sass sass-loaderscss 모듈을 import 시키기 위한 로더이다. postcss-loader autoprefixer(s)css 파일 등등에 벤더 프리픽스를 자동으로 붙이는 로더이다. webpack.config.js는 아래와 같이 고쳐보자. 123456789101112131415161718192021222324252627282930313233343536373839const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;); module.exports = &#123; devtool: &#x27;source-map&#x27;, entry: &#x27;./entry-index.js&#x27;, output: &#123; filename: &quot;bundle.js&quot;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27;, filename: &#x27;./index2.html&#x27; &#125;) ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;, &#x27;sass?sourceMap&#x27;, &#x27;postcss-loader&#x27;] &#125;] &#125;&#125;; 추가된 옵션들을 하나씩 살펴보자. html webpack pluginhtml에 번들링 한 파일을 자동으로 삽입해준다.tmplate에 ejs 등등의 html 템플릿 엔진으로 작성한 걸 넣어주고,filename에 그 템플릿을 토대로 새롭게 만들어질 html 파일을 지정해주면 된다.자세한 내용은 플러그인 api를 참조하길 바란다. postcss스타일 시트에 벤더 프리픽스를 지정하기 위해 추가하였다.사용하고자 하는 쿼리는 Browserslist에서 확인 가능하고,쿼리문 테스트는 browserl.ist에서 확인 가능하며,데모는 Autoprefixer CSS online에서 가능하다. css-loader, sass-loadertest에는 정규표현식이 들어가고, 로더의 순서는 바뀌면 오류가 난다.아마 오른쪽에서부터 왼쪽으로 적용이 되는 게 아닐까 싶다.또한 소스맵 옵션을 제거하면 아래와 같이 난독화된 소스를 보게돼 디버깅하기가 쉽지 않다. 개발용? 배포용?뭔가 이제 그럴듯 하게 보이긴 하지만 현재 프로젝트 디렉토리를 보자. node_modules - 패키지들이 설치된 폴더로 개발할 때 수정할 일이 없는 파일. .babelrc - 바벨의 설정파일로서 개발할 때 수정할 일이 없는 파일. bundle.js - 개발할 때는 필요없는 배포용 파일 bundle.js.map - 실제 사용자가 디버깅 할 필요는 없으므로 이 파일도 개발용 파일. entry-index.js - 개발용 파일 index.html - 템플릿이 되는 파일이므로 개발용 파일 index2.html - 템플릿을 토대로 만들어진 배포용 파일 module-a.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 module-b.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 module-c.js - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 package.json - 패키지들의 의존성을 도와주는 파일로서 바벨의 설정파일로서 개발할 때 수정할 일이 없는 파일. style.css - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 styles.css - bundle.js에 번들링된 내용이므로 실제 배포할 때 필요없는 개발용 파일 webpack.config.js - 번들을 하기 위한 설정 파일이므로 개발할 때 수정할 일이 없는 파일. 개발용 파일과 배포용 파일이 너무 난잡하게 섞여있다.이는 나중에 개발 &amp; 배포를 할 때 상당한 혼란을 초래한다. 또한 스타일 시트를 bundle.js 안에 번들링하면 아래와 같은 현상이 발생한다. 위 현상은 스타일 시트의 규모가 커질 수록 스타일이 적용되지 않은 모습이 노출되는 시간이 길어진다.이를 해결하고자 css 파일에 소스맵을 안 붙여서 내부 스타일 시트로 배포하는 수가 있지만,bundle.js의 몸뚱아리만 키워 로딩속도를 저하시키는 요인이 되기도 한다.http 리퀘스트 횟수를 줄이라고는 하지만 기본적으로 http 리퀘스트는 4개의 병렬로 처리된다.따라서 몸뚱아리만 큰 bundle.js를 로딩시키는 것보다css 파일을 따로 빼서 bundle.js와 병렬로 로딩시키게끔 처리하는 게 훨씬 효율적이다. 그럼 개발용 파일과 배포용 파일을 분리해 보자!우선 디렉토리를 아래와 같이 바꾼다. 123456789101112131415+ node_modules+ src - index.html + scripts - entry-index.js - module-a.js - module-b.js - module-c.js + styles - style.css - style.scss.babelrcpackage.jsonwebpack.config.dev.jswebpack.config.prod.js 우선 개발과 상관없는 설정 파일들은 루트 디렉토리로 빼버렸다.그리고 개발에 집중하고자 개발용 파일들을 src 폴더에 체계적으로 분류하였다.또한 웹팩의 설정 파일을 개발용과 배포용으로 나눴는데 이유는 다음과 같다. 개발용 파일은 디버깅이 주 목적이라 소스맵이 필요하다.또한 난독화시키는 것은 번들링 타임을 증가시키는 주범이므로 뺀다.그리고 HTML 파일을 핫리로드하게 만들어야 한다. 핫리로드란 서버의 재시작 없이 내용이 재교체되는 것을 뜻한다. 또한 브라우저에서 자동으로 새로고침이 이루어진다. 그리고 스타일 시트를 외부로 빼면 HMR을 이용할 수 없으므로 따로 빼지 않는다. > HMR(Hot Module Replacement)이란 서버의 재시작 없이, 브라우저가 새로고침하지 않고, 수정된 부분만 바꾸는 것을 의미한다. 배포용 파일은 실 사용이 주 목적이라 용량을 경량화 시킬 난독화 작업이 진행되고,디버깅 할 필요가 없으므로 소스맵도 붙이지 않고,또한 HTML 파일은 핫리로드하게 만들 필요가 없고,HMR을 사용할 필요가 없으므로 스타일 시트를 외부로 뺀다. 이를 위해서 추가로 패키지를 설치할 필요가 있다. 12$ npm i -g webpack-dev-server$ npm i -D webpack-dev-server raw-loader webpack-browser-plugin extract-text-webpack-plugin webpack-strip clean-webpack-plugin webpack-dev-server-g로 설치하는 이유는 해당 명령어를 터미널에서 쓰기 위함이고다시 한 번 -D로 설치하는 이유는 현재 프로젝트에서 해당 패키지를 쓰기 위함이다.webpack-dev-server는 실제 눈에 보이지 않는 디렉토리를 만들고 그 디렉토리에번들링을 진행하고 watch하며 테스트를 하는 웹팩 개발용 서버이다. raw-loader는 html 파일을 핫리로드하게 만드는 로더이다. webpack-browser-pluginwebpack-dev-server에서 번들링을 끝낸 후 자동으로 브라우저를 열어주는 플러그인이다.자세한 옵션은 webpack-browser-plugin을 확인하자. extract-text-webpack-plugin스타일 시트를 따로 빼기 위한 플러그인이다. webpack-stripjs 파일에서 디버깅을 위해 찍어본 로그를 삭제해준다. clean-webpack-plugin배포용 파일을 빌드하기 전에 배포용 디렉토리를 지워주는 플러그인이다. 이제 webpack.config.dev.js 부터 수정해보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const WebpackBrowserPlugin = require(&#x27;webpack-browser-plugin&#x27;);module.exports = &#123; devtool: &#x27;cheap-eval-source-map&#x27;, entry: [ &#x27;webpack-dev-server/client?http://localhost:8080&#x27;, &#x27;webpack/hot/dev-server&#x27;, &#x27;./src/scripts/entry-index.js&#x27; ], output: &#123; publicPath: &#x27;http://127.0.0.1:8080/&#x27;, filename: &#x27;scripts/bundle.js&#x27;, &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;sass?sourceMap,outputStyle=expanded&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.html$/, loader: &#x27;raw-loader&#x27; &#125;] &#125;, devServer: &#123; hot: true &#125;&#125;; 추가된 속성들을 하나씩 살펴보자. entry두 개의 새로운 엔트리포인트가 서버와 브라우저에 접속하여 HMR을 허용한다. publicPath자세히는 모르겠지만 저렇게 설정해주지 않으면, 이미지나 폰트가 제대로 붙지 않음. new webpack.HotModuleReplacementPlugin()HMR을 사용하기 위한 플러그인 new WebpackBrowserPlugin()번들링이 끝나면 자동으로 브라우저를 열어줌. css?sourceMap,-minimize, sass?sourceMap,outputStyle&#x3D;expanded(s)css 파일을 압축시키지 않으면서 소스맵을 붙이고자 할 때 씀. raw-loaderHTML을 핫리로드하게 만드는 로더. devServerhot은 HMR의 활성화 여부이다. 이제는 배포용 설정 파일인 webpack.config.prod.js를 아래와 같이 바꿔보자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;); module.exports = &#123; entry: &#x27;./src/scripts/entry-index.js&#x27;, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;scripts/bundle.js&#x27;, &#125;, plugins: [ new CleanWebpackPlugin([&#x27;dist&#x27;]), new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;) &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin(&#x27;styles/bundle.css&#x27;) ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: [&#x27;babel&#x27;, &#x27;webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir&#x27;], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!postcss-loader&#x27;) &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!sass!postcss-loader&#x27;) &#125;] &#125;&#125;; 추가된 속성들을 하나씩 살펴보자. new CleanWebpackPlugin([‘dist’])빌드를 시작하기 전에 먼저 배포용 디렉토리를 지워줘야한다. new webpack.DefinePlugin()process.env.NODE_ENV는 개발환경인지 배포환경인지 알고자 할 때 쓰인다.production이면 배포 모드, development이면 개발환경이다.이는 HTML을 핫리로드하게 만들지 안 만들지를 결정하기 위해 썼다. new webpack.optimize.OccurrenceOrderPlugin() 모듈을 할당하고 발생 카운트 아이디들을 발생(?chunk)시킨다.ID들은 종종 적은(짧은) id들을 얻는데 사용된다.이것은 id가 예상가능하며 파일 전체 크기를 경감시켜 추천한다. new HtmlWebpackPlugin({ minify: {}})html 난독화 옵션을 참고하자. new ExtractTextPlugin(‘styles&#x2F;bundle.css’)번들링한 스타일 시트 파일을 어디에다 추출할지 정해주는 플러그인. ‘webpack-strip?strip[]&#x3D;debug,strip[]&#x3D;console.log,strip[]&#x3D;console.dir’webpack-strip 로더를 사용하여 디버깅을 위해 로그에 찍었던 로그를 삭제했다. ExtractTextPlugin.extract()해당 스타일 시트를 css파일로 뽑아내는 로더이다. 또한 html을 핫리로드하게 만들어주려면 엔트리에 html 모듈을 추가해야한다.하지만 배포용에서는 핫리로드하게 만들어줄 필요가 없기 때에 조건문을 쓰면 된다. 1234567891011121314// entry-index.jsif (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;../index.html&#x27;)&#125;import &#x27;../styles/style.css&#x27;;import &#x27;../styles/style.scss&#x27;; import &#123;ab&#125; from &#x27;./module-a&#x27;;import &#123;a&#125; from &#x27;./module-b&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;; console.log(ab);console.log(a); 웹팩의 설정 파일의 기본적인 이름은 webpack.config.js이다.그래서 webpack 이라는 명령어만 붙여도 자동으로 webpack.config.js 파일을 인식했는데,우리는 임의로 설정 파일의 이름을 바꿨기 때문에 달리 진행해야한다. 개발을 진행하기 위해서는 터미널에 아래와 같이 입력을 해야한다. 1$ webpack-dev-server -d --config webpack.config.dev.js 배포를 진행하기 위해서는 아래와 같이 입력을 해야한다. 1$ webpack --config webpack.config.prod.js 하지만 위와 같은 작업은 매우 귀찮다.npm의 스크립트를 이용해보자.우선 package.json에서 scripts 부분을 아래와 같이 수정해준다. 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server -d --config webpack.config.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.config.prod.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;&#125; 이제는 개발을 진행하고자 할 때는 아래와 같이 입력해주면 된다. 1$ npm run dev 배포를 진행하고자 할 때는 아래과 같이 입력해주면 된다. 1$ npm run build 우선 개발용 서버로 진입해서 살펴보자. js 파일에서 스타일을 렌더링하는 코드가 있기 때문에 js파일을 전부 로드한 이후에스타일 시트가 적용돼서 초반에 스타일 시트가 적용되지 않은 모습이 잠깐 보이게 된다.또한 html 파일에 넣지 않았던 번들링된 파일과 스타일 시트가 들어가있다. 그럼 style.scss 파일을 고쳐보자. 12345$color: red;/*gg*/h1 &#123; color: $color&#125; 위와 같이 새로고침 없이 필요한 부분만 갱신하는 게 HMR이다. 그럼 index.html 파일을 고쳐보자. 1234567891011&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;댓글을 달아주시면 짱짱맨&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 이는 js 파일도 마찬가지인데, js 파일과 html 파일은 핫모듈이 아니기 때문에 핫리로드를 하는 것이다. 그럼 이제 실제 배포를 진행해보자.빌드를 하고 나서 배포용 디렉토리를 살펴보자. 123456+ dist + scripts - bundle.js + styles - bundle.css - index.html 각각의 파일을 열어보면 파일이 1줄로 압축돼있어서 용량을 최소화하여트래픽을 줄이고 로딩 속도를 높여 퍼포먼스를 향상시켰다. 이제 index.html 파일을 브라우저에서 열어보자. 실제로 웹팩으로 모듈 번들링을 할 때는 이렇게 개발용과 배포용으로 나누어서 진행하고,개발용 서버로 개발하다 개발을 완료하면빌드를 해서 배포용 디렉토리 안의 파일만 실서버에 올리면 된다. 부트스트랩, 폰트어썸, 제이쿼리, 이미지 모듈을 사용해보자.우선 위 모듈들을 설치해야한다. 12$ npm i -S jquery bootstrap font-awesome$ npm i -D url-loader file-loader font-awesome은 폰트를 쓰는 대표적인 라이브러리이다.웹팩에서는 폰트와 이미지도 하나의 모듈로 보고, 그러한 모듈을 사용하기 위해서는url-loader와 file-loader가 필요한 것이다. 이를 위해서는 개발용, 배포용 설정 파일의 모듈 로더에 다음과 같은 걸 추가해줘야한다. 12345678910&#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]&#x27;&#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;file?name=fonts/[name].[ext]&#x27;&#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: &#x27;file?name=img/[name].[ext]&#x27;&#125; 폰트와 이미지는 로더를 통해야만 정상적으로 작업이 가능하고,name 파라미터를 통해 저장될 디렉토리와 이름을 정했다. 추가적으로 extract-text-webpack-plugin의 버그 때문에 배포용 설정에서(s)css 로더 부분을 수정해주자. 1234567&#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;),&#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!sass!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;)&#125; 번들된 css 파일에서 url()과 같은 경로가 꼬이길래 강제로 경로를 지정해준 것이다. 그리고 src 디렉토리 내에 img 폴더를 만들고 임의의 이미지를 넣는다.그 후에 src&#x2F;index.html을 다음과 같이 수정하자. 1234567891011121314&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;댓글을 달아주시면 짱짱맨&lt;/h1&gt;&lt;p&gt;IE11+에서 나는 드래그 안 될 걸?!&lt;/p&gt;&lt;span&gt;&lt;/span&gt;&lt;button id=&quot;btn&quot; class=&quot;btn btn-warning&quot;&gt;&lt;i class=&quot;fa fa-address-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;img src=&quot;./img/logo.png&quot; alt=&quot;로고&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 부트스트랩과 폰트 어썸을 썼다. src&#x2F;styles&#x2F;style.scss는 아래와 같이 수정해주자. 123456789101112$color: blue;$square: 90px;h1 &#123; color: $color&#125;span &#123; display: inline-block; background-image: url(&#x27;../img/logo.png&#x27;); width: $square; height: $square;&#125; 실제로 라이브러리&amp;프레임워크를 써보자.src&#x2F;scripts&#x2F;entry-index.js를 수정하자. 123456789101112131415161718192021if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;../index.html&#x27;)&#125;import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;;import &#x27;font-awesome/css/font-awesome.min.css&#x27;;import $ from &#x27;jquery&#x27;;import &#x27;../styles/style.css&#x27;;import &#x27;../styles/style.scss&#x27;;import &#123;ab&#125; from &#x27;./module-a&#x27;;import &#123;a&#125; from &#x27;./module-b&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;;console.log(ab);console.log(a);$(&#x27;#btn&#x27;).click(function() &#123; alert(&#x27;a&#x27;);&#125;); 제이쿼리, 부트스트랩, 폰트 어썸을 import 시켰고,btn 아이디를 가진 엘리먼트를 클릭하면 경고창이 뜨게 제이쿼리를 사용하였다. 이제 $ npm run dev를 치고 실제 개발용 서버에서 보자. 버튼을 누르면 경고창도 뜨고, (s)css와 js의 소스맵 모두 잘 붙는다. 이제 $ npm run build를 치고 실제 배포용 파일을 보자. index.html을 브라우저에 띄워보자. 디버깅 용 로그도 사라졌고, 디버깅 할 필요가 없으니 소스맵도 안 붙였다. 기본적인 외부 모듈들 사용방법은 이러하고,자신이 필요한 건 그때 그때 사용법을 익히면 된다. 홈페이지, IE8에서도 웹팩을 써보자.기본적으로 홈페이지와 SPA 사이에는 차이점을 모듈화 관점에서 바라보자.홈페이지는… 페이지가 여러 개다. 각 페이지 별로 적용되는 모듈들이 다르다. IE8을 지원해야하는 경우가 많다. 우리가 예제로 작업한 페이지는 하나였다. 그럼 다중 페이지에서 모듈화를 진행하고자 할 때를 가정하고 실습을 진행하자.우선 디렉토리를 아래와 같이 만든다. 123456789101112131415161718192021+ node_modules+ src + img - 임의의 이미지 파일 + scripts - entry-index.js - entry-sub.js - module-a.js - module-b.js - module-c.js + styles - style.css - style.scss - sub.css - sub.scss - index.html - sub.html- .babelrc- package.json- webpack.config.dev.js- webpack.config.prod.js 새로 추가된 파일의 소스는 아래와 같이 바꾸자. 1234567891011121314// entry-sub.jsif (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;../sub.html&#x27;)&#125;import &#x27;../styles/sub.css&#x27;;import &#x27;../styles/sub.scss&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;;const btn = document.getElementById(&#x27;btn&#x27;);btn.addEventListener(&#x27;click&#x27;, function() &#123; alert(b);&#125;); 1234/* sub.css */button &#123; width: 500px&#125; 12345678910111213/* sub.scss */$bgColor: orange;$boxSize: 500px;button &#123; background-color: $bgColor&#125;section &#123; width: $boxSize; height: $boxSize + 100px; background-color: $bgColor&#125; 123456789101112&lt;!-- sub.html --&gt;&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt;IE8에서도 제대로 보이나?&lt;/section&gt;&lt;button id=&quot;btn&quot;&gt;내가 바로 버튼이다.&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 이제 개발용 파일을 수정해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const WebpackBrowserPlugin = require(&#x27;webpack-browser-plugin&#x27;);const dev = [ &#x27;webpack-dev-server/client?http://localhost:8080&#x27;, &#x27;webpack/hot/dev-server&#x27;];module.exports = &#123; devtool: &#x27;cheap-eval-source-map&#x27;, entry: &#123; index: [ dev[0], dev[1], &#x27;./src/scripts/entry-index.js&#x27; ], sub: [ dev[0], dev[1], &#x27;./src/scripts/entry-sub.js&#x27; ] &#125;, output: &#123; publicPath: &#x27;http://127.0.0.1:8080/&#x27;, filename: &#x27;scripts/[name].bundle.js&#x27;, &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, chunks: [&#x27;index&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./src/sub.html&#x27;, filename: &#x27;sub.html&#x27;, chunks: [&#x27;sub&#x27;] &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;sass?sourceMap,outputStyle=expanded&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.html$/, loader: &#x27;raw&#x27; &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;file?name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: &#x27;file?name=img/[name].[ext]&#x27; &#125;] &#125;, devServer: &#123; hot: true &#125;&#125;; entryentry를 객체로 만들어서 객체 프로퍼티들이 엔트리가 되게 된다.각 엔트리별로 webpack-dev-server 설정들을 붙여야해서 배열화 시켜서 넣었다. filename[name]에는 엔트리의 이름이 들어간다. new HtmlWebpackPlugin()각 엔트리별로 모듈을 각각 삽입해줘야한다.filename은 기본이 index.html이라 생략을 했고,chunks에는 원하는 엔트리들을 넣으면 된다. 이번엔 배포용 설정 파일을 수정하자. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);module.exports = &#123; entry: &#123; index: &#x27;./src/scripts/entry-index.js&#x27;, sub: &#x27;./src/scripts/entry-sub.js&#x27; &#125;, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;scripts/[name].bundle.js&#x27;, &#125;, plugins: [ new CleanWebpackPlugin([&#x27;dist&#x27;]), new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;) &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, chunks: [&#x27;index&#x27;], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./src/sub.html&#x27;, filename: &#x27;sub.html&#x27;, chunks: [&#x27;sub&#x27;], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin(&#x27;style/[name].bundle.css&#x27;) ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: [&#x27;babel&#x27;, &#x27;webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir&#x27;], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;), &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!sass!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;) &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;file?name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: &#x27;file?name=img/[name].[ext]&#x27; &#125;] &#125;&#125;; new ExtractTextPlugin()에서도 [name]은 각 엔트리 별 이름이 들어간다. $ npm run dev 를 치고 한 번 확인해보자. http://127.0.0.1/8080/sub.html 으로 접속해보자. $ npm run build 를 치고 배포용 파일을 확인해보자. 하지만 IE8에서 결과를 확인하면 처참한 결과를 확인할 수 있다. 이를 위해서는 ES5 Polyfill 붙이기babel로 트랜스파일한 ES5 전용 폴리필인 babel-polyfill이 있고,이벤트 리스너 관련해서는 수동으로 추가해줘야한다.자세한 내용은 아래 링크를 참고하자.(Babel) ES6를 IE8에서도 써보자 HTML5 Sectioning Elements Polyfill 붙이기HTML5는 다양한 API가 있어서 하나의 폴리필로는 커버가 힘들다.우선 내가 쓴 section 엘리먼트를 커버하기 위해 html5shiv를 쓰겠다. CSS3 폴리필도 상당히 많으므로 본인이 원하는 걸 직접 찾아봐야한다.이는 이번 포스트에서 생략한다. 폴리필들을 설치하자. 12$ npm i -S html5shiv$ npm i -D babel-plugin-transform-es3-property-literals babel-plugin-transform-es3-member-expression-literals 그리고 src&#x2F;scripts 폴더 안에 eventListener.polyfill.js 파일을 만들자. 123456789101112131415161718192021222324252627!window.addEventListener &amp;&amp; (function(WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) &#123; WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function(type, listener) &#123; var target = this; registry.unshift([target, type, listener, function(event) &#123; event.currentTarget = target; event.preventDefault = function() &#123; event.returnValue = false &#125;; event.stopPropagation = function() &#123; event.cancelBubble = true &#125;; event.target = event.srcElement || target; listener.call(target, event); &#125;]); this.attachEvent(&quot;on&quot; + type, registry[0][3]); &#125;; WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function(type, listener) &#123; for(var index = 0, register; register = registry[index]; ++index) &#123; if(register[0] == this &amp;&amp; register[1] == type &amp;&amp; register[2] == listener) &#123; return this.detachEvent(&quot;on&quot; + type, registry.splice(index, 1)[0][3]); &#125; &#125; &#125;; WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function(eventObject) &#123; return this.fireEvent(&quot;on&quot; + eventObject.type, eventObject); &#125;;&#125;)(Window.prototype, HTMLDocument.prototype, Element.prototype, &quot;addEventListener&quot;, &quot;removeEventListener&quot;, &quot;dispatchEvent&quot;, []); src&#x2F;scripts 폴더 안에 preRender.polyfill.js 파일을 만들자.이 파일에는 렌더링 되기 이전, head에 들어가야하는 폴리필,대표적인 게 html5, css3 폴리필 등등이 해당한다. 1import &#x27;html5shiv&#x27;; 폴리필을 적용하고자하는 엔트리와 html 파일을 수정해줘야한다.sub만 건드려보자. 12345678910111213141516// entry-sub.jsif (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;../sub.html&#x27;)&#125;import &#x27;./eventListener.polyfill&#x27;;import &#x27;../styles/sub.css&#x27;;import &#x27;../styles/sub.scss&#x27;;import &#123;b&#125; from &#x27;./module-c&#x27;;const btn = document.getElementById(&#x27;btn&#x27;);btn.addEventListener(&#x27;click&#x27;, function() &#123; alert(b);&#125;); 다른 코드가 오기 전에 폴리필을 먼저 import 시켜야한다. 1234567891011121314&lt;!-- sub.html --&gt;&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./scripts/preRender.polyfill.bundle.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt;IE8에서도 제대로 보이나?&lt;/section&gt;&lt;button id=&quot;btn&quot;&gt;내가 바로 버튼이다.&lt;/button&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.16.0/polyfill.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; head에 폴리필을 넣어줬다.현재는 존재하지 않지만 번들링을 통해 만들 예정이다.html webpack plugin이 head와 body 동시에 다른 파일 삽입이 불가능해서부득이하게 이러한 방법을 사용했다.또한 babel-polyfill을 minify하게 되면 IE8에서 오류가 나게 된다.따라서 부득이하게 cdn을 이용하였다. .babelrc 설정도 바꿔주자. 1234567&#123; &quot;presets&quot;: [&quot;latest&quot;], &quot;plugins&quot;: [ &quot;transform-es3-property-literals&quot;, &quot;transform-es3-member-expression-literals&quot; ]&#125; 이제 웹팩 설정들을 바꿔보자.우선 개발용 파일부터 손 보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const WebpackBrowserPlugin = require(&#x27;webpack-browser-plugin&#x27;);const dev = &#x27;webpack-dev-server/client?http://localhost:8080&#x27;;module.exports = &#123; devtool: &#x27;cheap-eval-source-map&#x27;, entry: &#123; index: [dev, &#x27;./src/scripts/entry-index.js&#x27;], sub: [dev, &#x27;./src/scripts/entry-sub.js&#x27;], [&#x27;preRender.polyfill&#x27;]: &#x27;./src/scripts/preRender.polyfill.js&#x27; &#125;, output: &#123; publicPath: &#x27;http://127.0.0.1:8080/&#x27;, filename: &#x27;scripts/[name].bundle.js&#x27;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, chunks: [&#x27;index&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./src/sub.html&#x27;, filename: &#x27;sub.html&#x27;, chunks: [&#x27;sub&#x27;] &#125;), new WebpackBrowserPlugin() ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap,-minimize&#x27;, &#x27;sass?sourceMap,outputStyle=expanded&#x27;, &#x27;postcss-loader&#x27;] &#125;, &#123; test: /\\.html$/, loader: &#x27;raw&#x27; &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;file?name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: &#x27;file?name=img/[name].[ext]&#x27; &#125;] &#125;&#125;; 우선 IE8에서는 HMR을 못 쓴다.ES5 폴리필이 붙기 전에 HMR이 먼저 로딩돼서 오류가 난다.따라서 해당 내용을 빼버렸다. preRender.polyfill을 번들링했다. 이번에는 배포용 설정 파일을 손대자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const CleanWebpackPlugin = require(&#x27;clean-webpack-plugin&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const autoprefixer = require(&#x27;autoprefixer&#x27;);const ExtractTextPlugin = require(&#x27;extract-text-webpack-plugin&#x27;);module.exports = &#123; entry: &#123; index: [&#x27;./src/scripts/entry-index.js&#x27;], sub: [&#x27;./src/scripts/entry-sub.js&#x27;], [&#x27;preRender.polyfill&#x27;]: [&#x27;./src/scripts/preRender.polyfill.js&#x27;] &#125;, output: &#123; path: &#x27;./dist&#x27;, filename: &#x27;scripts/[name].bundle.js&#x27;, &#125;, plugins: [ new CleanWebpackPlugin([&#x27;dist&#x27;]), new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(&#x27;production&#x27;) &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, chunks: [&#x27;index&#x27;], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./src/sub.html&#x27;, filename: &#x27;sub.html&#x27;, chunks: [&#x27;sub&#x27;], minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;), new ExtractTextPlugin(&#x27;style/[name].bundle.css&#x27;) ], postcss: [ autoprefixer(&#123; browsers: [&#x27;last 2 versions&#x27;, &#x27;&gt; 10%&#x27;, &#x27;ie 9&#x27;] &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: [&#x27;babel&#x27;, &#x27;webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir&#x27;], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;), &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract(&#x27;style&#x27;, &#x27;css!sass!postcss-loader&#x27;, &#123;publicPath: &#x27;../&#x27;&#125;) &#125;, &#123; test: /\\.woff(2)?(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;url?limit=10000&amp;mimetype=application/font-woff&amp;name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(ttf|eot|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9])?$/, loader: &#x27;file?name=fonts/[name].[ext]&#x27; &#125;, &#123; test: /\\.(jp(e)g|gif|png)?$/, loader: &#x27;file?name=img/[name].[ext]&#x27; &#125;] &#125;&#125;; 크게 바뀐 건 없고, 바뀐 사항은 위에서 다 설명하였다. $ npm run build를 쳐서 빌드를 하고 dist&#x2F;sub.html을 IE8에서 켜보자. 마치며…이번 글은 작성하는데 엄청난 시간이 걸렸다.또한 나의 지식이 매우 부족하여 구글링을 하여도 당췌 답이 안 나오는 게 태반이었고,지금 포스트를 쓰면서도 내가 맞게 쓰고 있는 건지도 모르겠다.방문자 분들께서 잘못된 부분을 지적해주시면 정말 감사할 것 같다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"Cross Browsing","slug":"Cross-Browsing","permalink":"https://perfectacle.github.io/tags/Cross-Browsing/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"https://perfectacle.github.io/tags/Webpack/"}]},{"title":"(Webpack) devtool 옵션 퍼포먼스","slug":"Webpack-devtool-option-Performance","date":"2016-11-14T22:48:48.000Z","updated":"2022-10-30T08:42:16.123Z","comments":true,"path":"2016/11/14/Webpack-devtool-option-Performance/","link":"","permalink":"https://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/","excerpt":"목차 들어가기에 앞서 소스맵 devtool 마치며… 들어가기에 앞서이 포스트에서는 웹팩에 대한 기초 내용을 설명하지 않는다.웹팩을 모르는 사람은 살포시 뒤로가기를 누르는 걸 권장한다.","text":"목차 들어가기에 앞서 소스맵 devtool 마치며… 들어가기에 앞서이 포스트에서는 웹팩에 대한 기초 내용을 설명하지 않는다.웹팩을 모르는 사람은 살포시 뒤로가기를 누르는 걸 권장한다. 소스맵소스맵은 원본 소스와 난독화된 소스를 매핑해주는 방법 중 하나이다.*.map 파일을 통해 제공되고, json 형태로 돼있다.사진을 통해 한번 보자. devtool웹팩에서 devtool 옵션은 개발을 용이하게 하기 위해 소스맵을 제공하는 옵션이다.하지만 devtool 옵션은 굉장히 많고, 그 중 8가지를 테스트 해봤다. eval eval-source-map cheap-eval-source-map cheap-module-eval-source-map source-map inline-source-map cheap-source-map cheap-module-source-map 또한 웹팩에는 배포용 설정과 개발용 설정이 따로 존재하고,webpack 명령어와 webpack -d 명령어가 존재하는 등 총 32가지의 테스트를 해봤다.먼저 배포용 설정 파일을 보자.아래와 같은 설정이 들어있다. ES6 to ES5, 디버깅용 로그들 삭제, js 난독화((이걸 하지 않으면 소스맵이 제대로 붙지 않음.) css 난독화 및 소스맵 적용 scss 난독화 및 소스맵 적용 html 난독화 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; devtool: &#x27;devtool 옵션 입력&#x27;, entry: &#x27;./src/script/entry&#x27;, output: &#123; path: path.join(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27;, &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27;, minify: &#123; collapseWhitespace: true, keepClosingSlash: true, removeComments: true, &#125;, xhtml: true &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loaders: [&#x27;babel&#x27;, &#x27;webpack-strip?strip[]=debug,strip[]=console.log,strip[]=console.dir&#x27;], exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;, &#x27;sass?sourceMap&#x27;] &#125;] &#125;&#125;; 이제 개발용 설정 파일을 보자.아래와 같은 설정이 들어있다. ES6 to ES5, js 난독화 (이걸 하지 않으면 소스맵이 제대로 붙지 않음.) css 난독화 및 소스맵 적용 scss 난독화 및 소스맵 적용 핫 모듈 리플레이스먼트 적용(이 예제에서는 (s)css 파일만 적용됨) 핫 리로드 적용(이 예제에서는 js, html 파일만 적용됨) 12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require(&#x27;path&#x27;);const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; devtool: &#x27;devtool 옵션 입력&#x27;, entry: [ &#x27;webpack-dev-server/client?http://localhost:8080&#x27;, &#x27;webpack/hot/dev-server&#x27;, &#x27;./src/script/entry&#x27; ], output: &#123; path: path.join(__dirname, &#x27;_dist&#x27;), filename: &#x27;bundle.js&#x27;, &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.optimize.UglifyJsPlugin(&#123; compressor: &#123; warnings: false, &#125;, &#125;) ], module: &#123; loaders: [&#123; test: /\\.js$/, loader: &#x27;babel&#x27;, exclude: /(node_modules|bower_components)/ &#125;, &#123; test: /\\.css$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;] &#125;, &#123; test: /\\.scss$/, loaders: [&#x27;style&#x27;, &#x27;css?sourceMap&#x27;, &#x27;sass?sourceMap&#x27;] &#125;, &#123; test: /\\.html$/, loader: &#x27;raw-loader&#x27; &#125;] &#125;, devServer: &#123; contentBase: &#x27;./_dist&#x27;, hot: true &#125;&#125;; 마치며…배포용은 용량이 가장 작은 cheap-module-source-map 옵션을 사용하고 webpack 명령어를 사용하는 게 가장 좋다.개발용은 로그, 디버깅, 번들링 타임을 고려하면 inline-source-map 옵션을 사용하고 webpack-dev-server 명령어를 사용하는 게 가장 좋을 것 같다.뭐 거의 비슷비슷 하므로 본인의 입맛에 맞게 찾아 쓰면 되겠다.또한 devtool은 js 파일의 소스맵하고만 관련 있지, (s)css의 소스맵과는 무관하다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Webpack","slug":"Webpack","permalink":"https://perfectacle.github.io/tags/Webpack/"},{"name":"Debugging","slug":"Debugging","permalink":"https://perfectacle.github.io/tags/Debugging/"},{"name":"Performance","slug":"Performance","permalink":"https://perfectacle.github.io/tags/Performance/"},{"name":"Source Map","slug":"Source-Map","permalink":"https://perfectacle.github.io/tags/Source-Map/"}]},{"title":"(Babel) ES6를 IE8에서도 써보자","slug":"Babel-ES6-with-IE8","date":"2016-11-11T23:09:39.000Z","updated":"2022-10-30T08:42:16.055Z","comments":true,"path":"2016/11/11/Babel-ES6-with-IE8/","link":"","permalink":"https://perfectacle.github.io/2016/11/11/Babel-ES6-with-IE8/","excerpt":"목차 들어가기에 앞서 ES6 왜 써? ES6에서 ES5로 트랜스파일하기 ES5를 IE8에서도 지원하기 바벨은 안전한가? 들어가기에 앞서아주 많이 참조한 링크지금 바로 시작하는 ES6","text":"목차 들어가기에 앞서 ES6 왜 써? ES6에서 ES5로 트랜스파일하기 ES5를 IE8에서도 지원하기 바벨은 안전한가? 들어가기에 앞서아주 많이 참조한 링크지금 바로 시작하는 ES6 이 포스트에서는 Node.js, npm, ES(ECMAScript) 등등에 대해서는 설명하지 않는다.해당 내용들은 구글링을 통해 직접 찾아보길 바란다.또한 import, export로 모듈화 시키는 것은 현재 지원 브라우저도 없고,다양한 모듈 번들러 중 하나인 웹팩를 이용하거나 RequireJS를 이용하거나 등등 방법은 많지만해당 포스트에서는 다루지 않고 건너 뛴다. 해당 포스트에서는 ES6를 왜 써야하는지,어떻게 하면 Windows XP IE8 유저들에게까지우리의 우아한 코드를 전달할 수 있는지에 대해 중점을 뒀다. ES6 왜 써?백문이 불여일견. 코드로 보자. 배열의 모든 요소를 더한 후 반환하는 코드. 1234567// ES3 (IE 8+)var arr = [1, 2, 3];var sumArr = 0;for(var i = 0; i &lt; arr.length;) &#123; sumArr += arr[i++];&#125;console.log(sumArr); // 6 1234567// ES5 (IE 9+)&#x27;use strict&#x27;;var arr = [1, 2, 3, 0];var sumArr = arr.reduce(function(p, c) &#123; return a+b;&#125;);console.log(sumArr); // 6 1234// ES6 (Modern Browser)const arr = [1, 2, 3, 0];const sumArr = arr.reduce((p, c) =&gt; p+c);console.log(sumArr); // 6 private module을 구현하는 코드 (전역의 공간을 더럽히지 않는 코드)대신 script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 없다. 12345// ES3+ (IE 8+)(function() &#123; &#x27;use strict&#x27;; // 소스코드 끄적끄적...&#125;()); 1234// ES6 (Moden Browser)&#123; // 소스코드 끄적끄적...&#125; public module을 구현하는 코드script 모듈에서 script2 모듈에 있는 데이터를 불러올 수 있다. 12345678910111213141516// ES3+ (IE 8+), 전역 스코프에 변수가 추가된다는 단점이 존재한다.// script.js&#x27;use strict&#x27;;var car = (function() &#123; var namespace = &#123;&#125;; var color = &#x27;blue&#x27;; // 외부에 노출시키지 않음, 캡슐화. // 아래 메소드는 네임스페이스의 메소드임. namespace.getColor = function() &#123; return color; &#125;; namespace.setColor = function(_color) &#123; color = _color; &#125;; // 메소드를 달고 있는 네임스페이스 객체 리턴. return namespace;&#125;()); 123456// ES3+ (IE 8+), 전역 스코프에 car라는 변수가 추가된다는 단점이 존재한다.// script2.js&#x27;use strict&#x27;;console.log(car.getColor()); // &#x27;blue&#x27;;car.setColor(&#x27;red&#x27;);console.log(car.getColor()); // &#x27;red&#x27;; 12345678910// ES6 (현재 지원하는 브라우저 없음)// 바벨을 사용하면 CommonJS 모듈로 변환해주는데// Node.js는 CommonJS를 지원해주는데 반해 브라우저는 이를 미지원한다.// 이를 위해서는 모듈 번들러인 Browserify나 Webpack을 쓰거나// 브라우저에서 지원이 되는 RequireJS 모듈로 변환해주는 바벨용 플러그인을 쓴 후// RequireJS를 사용하면 된다.// script.jslet color = &#x27;blue&#x27;;export const getColor = () =&gt; color;export const setColor = (_color) =&gt; color = _color; 1234567891011// ES6 (현재 지원하는 브라우저 없음)// 바벨을 사용하면 CommonJS 모듈로 변환해주는데// Node.js는 CommonJS를 지원해주는데 반해 브라우저는 이를 미지원한다.// 이를 위해서는 모듈 번들러인 Browserify나 Webpack을 쓰거나// 브라우저에서 지원이 되는 RequireJS 모듈로 변환해주는 바벨용 플러그인을 쓴 후// RequireJS를 사용하면 된다.// script2.jsimport &#123;getColor, setColor&#125; from &#x27;./script&#x27;;console.log(getColor());setColor(&#x27;red&#x27;);console.log(getColor()); 이외에도 정말 무궁무진할 정도로 생산성을 향상시키는 코드들이 많다. ES6에서 ES5로 트랜스파일하기ES6의 호환성 보기 하지만 우리에게는 방법이 있다!바로 트랜스파일러인 바벨을 이용하는 것이다.컴파일은 사람이 이해할 수 있는 하이 레벨의 코드를컴퓨터가 이해할 수 있는 로우 레벨의 기계어로 바꾸는 것을 말한다.트랜스파일이란 같은 레벨의 다른 언어로 변환하는 것을 뜻한다.브라우저별로 ES6의 지원율이 상이하기 때문에같은 레벨인 ES6를 같은 레벨의 ES5로 트랜스파일하면 되는 것이다.그럼 우선 babel을 설치해보자. 12$ npm i -g babel-cli$ npm i -D babel-cli babel-preset-latest 위 명령어를 하나씩 파헤쳐보자. babel-cli를 global로 설치하지 않으면, 터미널에서 babel이라는 명령어를 인식하지 못한다. babel-cli는 터미널에서 babel을 돌려주는 것으로써 현재 프로젝트에 또 설치를 해줘야 동작을 제대로 한다. babel에는 plugin이라는 게 존재한다.이 plugin은 es6의 애로우 펑션을 지원하는 플러그인, 클래스를 지원하는 플러그인 등등이 있다.그러한 플러그인을 모아놓은 걸 preset이라고 부른다.es2015 preset은 es6의 플러그인들을 모아놓은 것이고,latest preset은 ES2015~ES2017까지의 프리셋들을 모아놓은 것이다.시간이 지나면 latest의 지원 프리셋 범위는 더 늘어날 수도 있다. 그리고 바벨 설정 파일을 하나 만들어줘야한다..babelrc라는 파일을 만들고 아래와 같이 적어주자. 123&#123; &quot;presets&quot;: [&quot;latest&quot;]&#125; 바벨의 설정파일이 바뀔 때마다 babel-cli가 watch중이라면 꺼줬다 켜야 제대로 적용된다.그리고 폴더 구조를 아래와 같이 만들어보자. (다르게 해도 상관없다.) 12345+ es6 - script.js.babelrcindex.htmlpackge.json es6 폴더에는 es6+로 작성한 코드가 담길 것이다.script.js에는 아래와 같이 코딩해보자. 123456789&#123; const A = &#x27;1&#x27;; const arr = [1, 2]; const sumArr = arr.reduce((p, c) =&gt; p+c); console.log(sumArr); // 3 const btn = document.getElementById(&#x27;btn&#x27;); const evtClick = () =&gt; console.log(A); btn.addEventListener(&#x27;click&#x27;, evtClick);&#125; 그 이후 터미널 창에서 아래와 같이 입력한다. 1$ babel es6 -d script -w 또 하나하나 파헤쳐보자. babel: babel-cli를 쓴다는 것이다. es6: es6 디렉토리에 있는 파일을 트랜스파일 한다. -d script: 결과물을 script라는 폴더에다가 던져준다. -w: watch, 계속 주시하면서 파일이 바뀔 때마다 트랜스파일해준다.watch를 끝내려면 Ctrl+C키를 누른 후 y키를 누른 후 Enter 키를 누르면 된다. 그리고 나서 디렉토리를 보면 다음과 같다. 1234567+ es6 - script.js+ script - script.js.babelrcindex.htmlpackge.json 한 번 우리의 코드가 어떻게 바뀌었는지 script&#x2F;script.js를 열어보자. 12345678910111213141516&#x27;use strict&#x27;; &#123; (function () &#123; var A = &#x27;1&#x27;; var arr = [1, 2]; var sumArr = arr.reduce(function (p, c) &#123; return p + c; &#125;); console.log(sumArr); // 3 var btn = document.getElementById(&#x27;btn&#x27;); var evtClick = function evtClick() &#123; return console.log(A); &#125;; btn.addEventListener(&#x27;click&#x27;, evtClick); &#125;)();&#125; 쓸 데 없는 블록으로 감싸고 있긴 하지만 그래도 전역을 더럽히지 않고,훌륭하게 코드를 ES5로 트랜스파일 하였다.즉 우리가 개발할 때는 es6의 디렉토리 내의 파일로 개발을 하고배포할 때는 script 디렉토리 내의 코드를 배포하면 된다.여기까지가 IE9+ 프로젝트에서 하면 되는 내용이다. ES5를 IE8에서도 지원하기우리나라는 MS 공화국이다.저기 산골짝에 가면 XP를 쓰는 사람도 있고, 아직도 공공기관에서도 XP를 쓴다는 소리가 들린다.XP가 날고 기어봤자 IE8까지 밖에 지원이 안 되고, 그러한 악의 근원들까지 커버를 쳐야할 때가 온다.또한 윈도우 7의 기본 브라우저도 IE8이기 때문에 업데이트를 안 하는 사람들이 많다.그럴 경우를 대비해 바벨에서도 Polyfill을 준비해두었다.Polyfill이란 아래와 같이 미지원 환경에서도 해당 내용을 지원하게끔 하는 것이다. 123456789if ( !Array.prototype.forEach ) &#123; // for IE8 Array.prototype.forEach = function(fn, scope) &#123; for(var i = 0, len = this.length; i &lt; len; ++i) &#123; if (i in this) &#123; fn.call(scope, this[i], i, this); &#125; &#125; &#125;;&#125; 설치하기 귀찮은 사람을 CDN을 이용하자. (이상하게 min은 오류가 나는 것 같다.) 1https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.16.0/polyfill.js 아닌 사람은 아래와 같이 입력하여 설치해보자. 1$ npm i -S babel-polyfill 그리고 index.html에 폴리필을 넣어주자. (무조건 사용자가 작성한 코드보다 위에 존재해야한다.) 12&lt;script src=&quot;./node_modules/babel-polyfill/dist/polyfill.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./script/script.js&quot;&gt;&lt;/script&gt; 그리고 IE8에서 실행해보자. addEventListener, removeEventListener 등등의 Polyfill을 수동으로 추가해줘야한다.아래 링크로 가면 minify 버전의 소스코드도 볼 수 있다.Polyfill the EventListener interface in IE8 12345678910111213141516171819202122232425262728// eventListener.polyfill.js!window.addEventListener &amp;&amp; (function(WindowPrototype, DocumentPrototype, ElementPrototype, addEventListener, removeEventListener, dispatchEvent, registry) &#123; WindowPrototype[addEventListener] = DocumentPrototype[addEventListener] = ElementPrototype[addEventListener] = function(type, listener) &#123; var target = this; registry.unshift([target, type, listener, function(event) &#123; event.currentTarget = target; event.preventDefault = function() &#123; event.returnValue = false &#125;; event.stopPropagation = function() &#123; event.cancelBubble = true &#125;; event.target = event.srcElement || target; listener.call(target, event); &#125;]); this.attachEvent(&quot;on&quot; + type, registry[0][3]); &#125;; WindowPrototype[removeEventListener] = DocumentPrototype[removeEventListener] = ElementPrototype[removeEventListener] = function(type, listener) &#123; for(var index = 0, register; register = registry[index]; ++index) &#123; if(register[0] == this &amp;&amp; register[1] == type &amp;&amp; register[2] == listener) &#123; return this.detachEvent(&quot;on&quot; + type, registry.splice(index, 1)[0][3]); &#125; &#125; &#125;; WindowPrototype[dispatchEvent] = DocumentPrototype[dispatchEvent] = ElementPrototype[dispatchEvent] = function(eventObject) &#123; return this.fireEvent(&quot;on&quot; + eventObject.type, eventObject); &#125;;&#125;)(Window.prototype, HTMLDocument.prototype, Element.prototype, &quot;addEventListener&quot;, &quot;removeEventListener&quot;, &quot;dispatchEvent&quot;, []); 그리고 index.html에 폴리필을 넣어주자. (무조건 사용자가 작성한 코드보다 위에 존재해야한다.) 123&lt;script src=&quot;./node_modules/babel-polyfill/dist/polyfill.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./script/eventListener.polyfill.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./script/script.js&quot;&gt;&lt;/script&gt; 아직 끝난 게 아니다.아래와 같은 코드를 보자. 1234const foo = &#123; catch: function () &#123;&#125;&#125;;foo.catch(); 이제 위 코드가 어떻게 트랜스파일 되는지 보자. 12345&quot;use strict&quot;; var foo = &#123; catch: function _catch() &#123;&#125;&#125;;foo.catch(); 위와 같은 코드를 IE8에서 테스트 해보자. 2번 라인과 4번 라인에서 객체의 메소드와 메소드 호출로 catch를 사용하였다.IE8은 ES3를 지원하고, ES3에서는 catch 같은 키워드를 저렇게 식별자로 쓰게 되면 오류를 뿜는다.ES3를 위한 플러그인이 바벨에는 또 존재한다. 1$ npm i -D babel-plugin-transform-es3-property-literals babel-plugin-transform-es3-member-expression-literals babel-plugin-transform-es3-property-literals을 쓰면 아래와 같이 바뀐다. 123var foo = &#123; &quot;catch&quot;: function _catch() &#123;&#125;&#125;; 프로퍼티에서 키워드인 catch에 쌍따옴표를 붙인 걸 볼 수 있다. babel-plugin-transform-es3-member-expression-literals을 쓰면 아래와 같이 바뀐다. 1foo[&quot;catch&quot;](); 표현식에서 키워드인 catch를 []로 감싸고, 쌍따옴표를 붙인 걸 볼 수 있다.플러그인을 쓰기 위해 .babelrc 파일을 수정하자. 1234567&#123; &quot;presets&quot;: [&quot;latest&quot;], &quot;plugins&quot;: [ &quot;transform-es3-property-literals&quot;, &quot;transform-es3-member-expression-literals&quot; ]&#125; 여기까지 완료하면 IE8까지 ES6의 문법을 그대로 쓸 수 있다. 바벨은 안전한가?아래와 같은 ES6 코드를 보자. 12console.log(a); // Uncaught ReferenceError: a is not definedconst a = 2; 변수 a가 선언 되기도 전에 사용을 하고 있고, TDZ에 존재하는 a는 사용할 수 없는 예제이다.하지만 위 코드를 ES5로 트랜스파일하면 아래와 같다. 123&quot;use strict&quot;; console.log(a); // undefinedvar a = 2; var의 호이스팅 때문에 ES6와는 다른 값이 나오게 된다.이러한 점 말고도 더 있는지 모르겠지만 바벨이 ES5 전부를 커버할 수 있는 건 아니다.이는 바벨이 꼬지기 때문이 아니라 ES6와 ES5 사이의 언어의 설계에 대한 차이 때문에일어나는 어쩔 수 없는 현상이다.실제 배포하는 파일은 ES5 파일이기 때문에 바벨이 존재한다 하더라도 ES5까지 알아둬야개발하는데 훨씬 수월할 것이다.따라서 ES5와 ES6를 병행하여 공부하는 게 현명한 방법이 아닐까 싶다.또한 팀원들이 ES6, npm 등등에 대한 지식이 없다면 학습하는 비용까지 포함하면지금 당장은 실무에 적용하기엔 무리가 있을 것이다.하지만 다같이 스터디를 하고, 추후에 있을 프로젝트에서 사용한다고 가정했을 때생산성이 향상되는 효과를 볼 수 있지 않을까 싶다.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Babel","slug":"Front-end/Babel","permalink":"https://perfectacle.github.io/categories/Front-end/Babel/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"Babel","slug":"Babel","permalink":"https://perfectacle.github.io/tags/Babel/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Cross Browsing","slug":"Cross-Browsing","permalink":"https://perfectacle.github.io/tags/Cross-Browsing/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"}]},{"title":"(ES6) Scope","slug":"ES6-Scope","date":"2016-11-10T21:18:24.000Z","updated":"2022-10-30T08:42:16.083Z","comments":true,"path":"2016/11/10/ES6-Scope/","link":"","permalink":"https://perfectacle.github.io/2016/11/10/ES6-Scope/","excerpt":"목차 들어가기에 앞서 ES5의 함수 단위의 스코프 함수 단위 스코프의 위험성 함수 단위 스코프의 극복, 모듈화 ES6의 블록 단위의 스코프 TDZ 들어가기에 앞서스코프, 콜 스택, 실행 컨텍스트가 무엇인지, ES5, ES6가 무엇인지에 대해서는 설명하지 않는다.ES5와 ES6 사이에 있어서 스코프의 차이점은ES5는 함수 단위의 스코프이고, ES6는 블록 단위의 스코프라는 점이다.ES5와 ES6를 병행하여 학습하는 방법이 필자는 좋다고 여겨 한 포스트에 몰아 넣어서 분량이 길다.따뜻한 사랑과 관심이 많이 필요하다.ES5의 스코프에 대해 충분히 숙지한 사람들은 ES6의 블록 단위의 스코프부터 읽도록 하자.그럼 스코프에 대해서 심화하여 다뤄보도록 하자.","text":"목차 들어가기에 앞서 ES5의 함수 단위의 스코프 함수 단위 스코프의 위험성 함수 단위 스코프의 극복, 모듈화 ES6의 블록 단위의 스코프 TDZ 들어가기에 앞서스코프, 콜 스택, 실행 컨텍스트가 무엇인지, ES5, ES6가 무엇인지에 대해서는 설명하지 않는다.ES5와 ES6 사이에 있어서 스코프의 차이점은ES5는 함수 단위의 스코프이고, ES6는 블록 단위의 스코프라는 점이다.ES5와 ES6를 병행하여 학습하는 방법이 필자는 좋다고 여겨 한 포스트에 몰아 넣어서 분량이 길다.따뜻한 사랑과 관심이 많이 필요하다.ES5의 스코프에 대해 충분히 숙지한 사람들은 ES6의 블록 단위의 스코프부터 읽도록 하자.그럼 스코프에 대해서 심화하여 다뤄보도록 하자. ES5의 함수 단위의 스코프우선 ES5의 함수 단위 스코프부터 살펴보자. 12345678910&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123// index2.jsvar A = &#x27;a&#x27;;var AA = &#x27;c&#x27;; 우선 크롬의 **개발자 도구(F12)**에서 소스 탭으로 들어간 후에 자바스크립트 소스 파일을 선택해준다.그리고 변수를 초기화하는 2, 3번 라인에 브레이크 포인트를 걸어준 후에 새로고침하면2번 라인을 실행하기 전에 브레이크가 걸리게 된다.콜 스택에는 전역 실행 컨텍스트만 쌓여있는 상태인데,여기서 실행 컨텍스트가 생기는 경우를 되짚어보자. 전역코드 함수를 호출한 경우 eval() 함수를 호출한 경우 위 예제는 1번에 해당한다.전역 코드의 실행 컨텍스트는 콜 스택에 Push되고,**(anonymous function)**이 그 실행 컨텍스트를 가리킨다.전역 실행 컨텍스트의 스코프는 Global 객체인 window 객체의 프로퍼티로 들어간 것 처럼 보인다.브라우저가 아닌 Node.js에서는 Global 객체가 window 객체가 아니라global이라는 이름을 가진 객체이므로 예제는 반드시 브라우저에서 실행하자.http://stackoverflow.com/questions/19849136/does-node-js-have-equivalent-to-window-object-in-browser또한 delete 연산자로 삭제되지 않으므로 프로퍼티가 아니니 혼동하지 말길 바란다.하지만 window.A와 같이 사용이 가능하므로 window 객체의 프로퍼티의 이름을 피해서변수 네이밍 하는 걸 추천한다.또한 코드가 실행되기도 이전에 A와 AA 변수가 선언되고 undefined라는 값을 가진 걸 볼 수 있다.ES5의 이러한 호이스팅 때문에 갖은 오류를 양산하기도 하였다. 이번에는 함수를 호출한 경우에 스코프가 어떻게 형성되는지 알아보자. 12345678910&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./index4.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112// index4.js&#x27;use strict&#x27;;var A = &#x27;A&#x27;;var B = function() &#123; var A = &#x27;B&#x27;; var C = function() &#123; console.log(A) &#125;; C();&#125;; console.log(A); // &#x27;A&#x27;B(); // &#x27;B&#x27; 6번 라인에서 브레이크 포인트를 걸고 콜스택을 보자. C B (anonymous function) 순으로 콜스택에 쌓여있다.이를 풀어 써보자면… 함수 C의 실행 컨텍스트 함수 B의 실행 컨텍스트 전역 실행 컨텍스트 그리고 각 컨텍스트를 한번 뒤집어 까보자!먼저 위 사진을 보면 전역 실행 컨텍스트에는 사용자가 변수로 선언한 A가 “A”라는 값을 갖고 있다.물론 내리면 변수 B에 함수가 할당된 것도 볼 수 있다. 그 다음으로 함수 B의 실행 컨텍스트를 까보자.파란색이 함수 B의 실행 컨텍스트, 빨간색이 전역 실행 컨텍스트다.함수 B의 실행 컨텍스트는 따로 Local이라는 스코프를 가지고 있다.그 안에 존재하는 변수들이 지역 변수가 되는 것이다.서로 같은 A라는 변수지만 지역 변수가 더 우선순위가 높아서함수 B 안에서는 전역 변수 A가 아닌 지역 변수 A를 갖고 놀게 된다.만약 지역 변수 A가 없는데 A를 갖고 놀려면 스코프 체인이란 걸 타고 전역까지 뒤지게 될 것이다. 마지막으로 함수 C의 실행 컨텍스트를 까보자.빨간색이 함수 B의 실행 컨텍스트, 파란색이 함수 C의 실행 컨텍스트이다.함수 C의 실행 컨텍스트의 스코프 내부에는 this 밖에 없다.하지만 함수 C에서는 A라는 변수를 갖고 놀고 있다.자신의 스코프에 해당 변수가 없으므로 스코프 체인을 타고 올라가서바로 상위 스코프인 함수 B의 실행 컨텍스트에 변수 A가 있으므로 그걸 가지고 논다.하지만 자신의 스코프가 아닌 상위 스코프를 가지고 노는 것이므로 클로저다.다시 한번 클로저의 정의를 상기시켜보자. 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수 생성 당시의 스코프에 대한 연결을 갖는 블록 함수 B의 스코프가 이미 생명 주기가 끝난 외부 함수의 변수, 생성 당시의 스코프이고,함수 C의 스코프가 참조하는 함수, 연결을 갖는 블록과 매칭이 된다.왜 그런지 궁금하면 아래 링크를 참조하고 공부하자.http://blog.javarouka.me/2012/01/closure.html 함수 단위 스코프의 위험성123456789101112&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./index3.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678// index2.js&#x27;use strict&#x27;;var A = &#x27;1&#x27;;var btn = document.getElementById(&#x27;btn&#x27;);var evtClick = function() &#123; console.log(A);&#125;;btn.addEventListener(&#x27;click&#x27;, evtClick); 123// index3.js&#x27;use strict&#x27;;var A = &#x27;2&#x27;; index2.js의 5, 7번 라인에서 브레이크 포인트를 걸고 현재 전역 컨텍스트의A의 값을 보면 “1”이라는 값이 들어간 것을 볼 수 있다.그리고 나서 index.html에서 버튼을 클릭해보자. index2.js의 7번 라인에서 브레이크가 걸린다.그리고 전역 컨텍스트의 A의 값을 보면 쥐도새도 모르게 “2”라는 값으로 바뀌어있다.바로 index3.js에서 바꿔치기 한 것이다.index.html의 소스를 보면 index2.js를 먼저 로드하고 그 이후에 index3.js를그 후에 로드하기 때문에 위 소스를 합쳐보면 아래와 같이 된다. 1234567891011// index2.js&#x27;use strict&#x27;;var A = &#x27;1&#x27;;var btn = document.getElementById(&#x27;btn&#x27;);var evtClick = function() &#123; console.log(A); // 바꿔치기 된 애를 콘솔창에 찍음.&#125;;btn.addEventListener(&#x27;click&#x27;, evtClick);// index3.js&#x27;use strict&#x27;;var A = &#x27;2&#x27;; // 여기서 바꿔치기 됨. 함수 단위 스코프의 극복, 모듈화위와 같이 전역 스코프가 더러워지는 것을 방지하고자자바나 C++과 같이 자바스크립트도 모듈화하려는 시도는 많았다.CommonJS와 RequireJS가 대표적이었으나 현재는 Webpack이 대세인 것 같다.위와 관련된 글들도 인터넷에 상당히 널려있으니 찾아서 공부하자.여기서 위의 내용을 다루기에는 광범위하므로 순수 ES5만으로만 구현해보자.index2.js와 index3.js의 소스를 아래와 같이 고쳐보자. 12345678910// index2.js(function() &#123; &#x27;use strict&#x27;; var A = &#x27;1&#x27;; var btn = document.getElementById(&#x27;btn&#x27;); var evtClick = function() &#123; console.log(A); &#125;; btn.addEventListener(&#x27;click&#x27;, evtClick);&#125;()); 12345// index3.js(function() &#123; &#x27;use strict&#x27;; var A = &#x27;2&#x27;;&#125;()); 위 코드는 즉시 실행 함수(IIFE)를 이용한 패턴으로,코드를 로드하자마자 함수를 실행시켜버려서 스코프로 감싸버리는 것이다.따라서 위와 같이 하면 전역에 아무런 변수도 노출시키지 않게 된다. 6, 8번 라인에 브레이크 포인트를 걸고 콜스택을 보면 아래와 같다. (anonymous function) (anonymous function) 풀어서 쓰면 아래와 같다. index.js의 실행 컨텍스트 전역 실행 컨텍스트 index.js의 실행 컨텍스트를 보면 자기 자신이 가지고 있는 변수만 가지고 있다.Global 객체를 까봐도 전혀 자신의 정보를 노출하고 있지 않다. 이제 index.html에서 버튼을 눌러서 실제로 어떻게 작동하는지 보자. 색깔로 구분해서 클로저를 사용했다는 것을 쉽게 알 수 있다.그리고 모듈화를 하였으므로 다른 파일과 소통을 하지 않아 자기 자신의 값을 그대로 지키고 있다.모듈화 패턴은 IIFE말고도 위에 언급한 프레임워크를 쓴다거나 네임스페이스 패턴을 쓰거나방법은 무궁무진하므로 본인의 입맛대로 코딩하는 걸 추천한다. ES6의 블록 단위의 스코프이제부터가 본 게임의 시작이다.ES6에서는 const와 let이라는 키워드로 변수를 선언한다.레거시 환경 때문인지 여전히 var를 지원하지만 함수 단위의 스코프는위에서 말한 단점들이 존재해서 더 이상 쓰지 않는 걸 권장한다.const는 상수를 선언할 때 쓰며 선언과 동시에 할당을 무조건 해야한다.let은 var에서 블록 단위의 스코프로 바뀐 것과 TDZ 빼고는 크게 차이점은 없다.그럼 한번 다시 위의 코드를 const와 let을 써서 바꿔보자. 12345678910&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234// index2.jsconst A = &#x27;a&#x27;;let AA = &#x27;c&#x27;;A = &#x27;a&#x27;; // Uncaught TypeError 참고로 ES6에서는 항상 strict 모드로 작동한다.http://stackoverflow.com/questions/31685262/not-recommended-to-write-out-use-strict-with-es6 소스 코드 전체에 브레이크 포인트를 걸고 지켜봤더니 신기하게 Global 객체에 A와 AA 변수가 없다.호이스팅이 일어나지 않는 걸까…? 파이어폭스에서는 호이스팅이 일어난다.크롬의 오류다. 크롬이 만능은 아니었다. 1번 라인을 실행 한 후 2번 라인이 실행되기 전에 브레이크가 걸리는데이 때 스코프에 새로운 스코프가 생성된다.새로운 함수를 실행한 것이 아닌데도 Script라는 새로운 스코프가 생성되었다.const와 let을 사용하면 global 객체의 프로퍼티와 변수명이 충돌이 일어나지 않게 되어좀 더 자유로운 네이밍이 가능해졌다. 2번 라인을 실행 후 3번 라인이 실행되기 전에 브레이크가 걸리고,이 때 스코프를 보면 2번 라인의 AA 변수가 Script라는 스코프에 생성된 걸 볼 수 있다.3번 라인까지 실행시키면*Uncaught TypeError: Assignment to constant variable.*라는 오류 메시지를 볼 수 있다.상수에 값을 할당하려고 했기 때문이다. (설령 같은 값일지라도…)ES6는 변수를 새로운 스코프에 할당하는 모양이다. 그럼 위에서 작성했던 코드를 다시 한번 고쳐보자. 123456789101112&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./index3.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567// index2.jsconst A = &#x27;1&#x27;;const btn = document.getElementById(&#x27;btn&#x27;);const evtClick = function() &#123; console.log(A);&#125;;btn.addEventListener(&#x27;click&#x27;, evtClick); 12// index3.jsconst A = &#x27;2&#x27;; // Uncaught SyntaxError: Identifier &#x27;A&#x27; has already been declared 분명 파일을 분리했는데도 A를 중복해서 선언했다고 오류를 뿜는다.테스트를 위해 index3.js의 소스를 아래와 같이 고쳐보자. 123// index3.jsconst B = &#x27;2&#x27;;console.log(A); // 1 이해를 돕고자 index3.js의 2번 라인에 브레이크 포인트를 걸었다.엄머나… Script라는 스코프 안에 index2.js와 index3.js의 변수가 짬뽕 리믹스 돼있다…결과적으로 ES5와 다른 점은 글로벌 객체가 아닌 별도의 스코프를 생성할 뿐, 큰 차이는 없다.사실 호이스팅이 일어나기는 하지만, TDZ라는 것을 알아야하기 때문에 마지막에 설명한다.그럼 블록이 무엇인지에 대해서 생각해보자.{ … } 이게 블록이다. 끝이다.if(bool) {…}, while(bool) {…}, for(…) {…}, function(…) {…}등등 **{**와 **}**으로 감싸진다면 다 블록이다. 즉 블록 단위 스코프가 함수 단위 스코프를 포함하고 있는 관계가 된다.이제 그럼 js 파일들을 블록으로 감싸보자.디버깅하려고 로그도 찍어봤다. 1234567891011// index2.js&#123; const A = &#x27;1&#x27;; console.log(1); const btn = document.getElementById(&#x27;btn&#x27;); const evtClick = function() &#123; console.log(A); console.log(1); &#125;; btn.addEventListener(&#x27;click&#x27;, evtClick);&#125; 12345// index3.js&#123; const A = &#x27;2&#x27;; console.log(1);&#125; console.log 부분을 전부 브레이크 포인트를 걸어준다.3번에서 멈췄고 스코프를 보니 Block이라는 스코프가 새로 생겼다.이름만 들어도 블록 스코프임이 틀림 없어보인다. 그 다음은 index3.js에서 브레이크가 걸린다.새로운 Block 스코프가 생겼다.블록을 만날 때마다 블록 스코프가 생기니 즉시 실행 함수와 같이지저분한 패턴을 쓰지 않아도 모듈화가 가능하다. 버튼을 누르고 나서 브레이크가 찍힌 모습이다.스코프는 클릭 이벤트 리스너의 스코프만이 존재한다.함수로 감싼 게 아니기 때문에 클로저도 아니라 성능면에서도 훨씬 좋다.하지만 다른 파일에서 현재 파일의 변수의 값을 얻어오지 못한다.블록 스코프로 구현한 모듈은 반쪽짜리 모듈,자바로 치면 private class 밖에 되지 않는다.이를 해결하기 위한 문법으로 import, export 문이 ES6에 존재하지만 지원하는 브라우저가 없다.때문에 모듈화를 하고 싶다면 웹팩이란 녀석을 쓰면 된다.이것도 마찬가지로 웹서핑 하면 많이 나오므로 자세한 설명은 생략하도록 하자. TDZ드디어 대망의 마지막 챕터다.TDZ는 Temporal Dead Zone의 줄임말로 호이스팅, 스코프와 연관이 깊다.아래 코드를 보면서 얘기하자. 1234567891011&lt;!doctype html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot;&gt;버튼&lt;/button&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567// index2.js&#123; const A = &#x27;1&#x27;; console.log(1); console.log(btn); // Uncaught ReferenceError: btn is not defined const btn = document.getElementById(&#x27;btn&#x27;);&#125; 2번 라인에 브레이크 포인트를 걸고 보면 btn이 undefined라는 값을 가지고 있다.5번에 도달하기도 전이니 호이스팅이 된 것이다.하지만 4번 라인을 만나는 순간 오류를 뿜게 된다.이유는 변수 btn은 선언되기 전까지 호이스팅은 되지만 TDZ에 존재하기 때문이다.TDZ에 존재하는 변수에 접근하면 위와 같은 에러를 뿜는 것이고,선언이 되는 순간 TDZ에서 빠져나오게 된다.선언되기 전까지 임시적(Temporal)으로 죽어(Dead)있기 때문에 그런 이름이 붙지 않았나 싶다.아마 레거시 환경(var) 때문에 호이스팅을 살려둬야 했고, 그로 인한 오류를 줄이고자ES6 환경에서는 TDZ를 만들어서 두 가지 요구사항을 동시에 충족시킨 것 같다.이렇게만 보면 점점 자바스럽게 변하는 게 아닐지 모르겠지만아래 코드를 보면 생각이 달라질 것이다. 1234567891011public class HelloWorld&#123; int x = 10; void print() &#123; System.out.println(x); // 10 int x = 20; &#125; public static void main(String []args)&#123; HelloWorld _class = new HelloWorld(); _class.print(); &#125;&#125; 자바의 경우 호이스팅이 일어나지 않는다.TDZ라는 것도 존재하지 않는다.하지만 ES6에서는 위 두 개념들이 존재한다.호이스팅 된 변수는 선언되기 전까지 TDZ에 존재해 접근이 불가능하다.ES6에서 위 코드를 비슷하게 구현에 포커스를 두고 코딩을 하면 아래와 같다. 12345678&#123; let x = 10; let print = () =&gt; &#123; console.log(x); // Uncaught ReferenceError: x is not defined let x = 15; // 얘가 없다면 콘솔 창에 10이 찍힘. &#125;; print();&#125; 5번 라인의 x가 호이스팅 되고, 5번 라인에 다다르기 전까지는 TDZ에 존재하여 접근이 불가능해진다.하지만 4번 라인에서 접근을 하고 있으므로 에러를 뿜는 것이다.이 또한 좀 아이러니하게 설계가 된 것 같다.레거시 환경을 버릴 수 없으니 이러한 문제점을 떠안고 가는 것 같은데…그래도 이렇게 만들어진 걸 어찌하랴, 나중에 또 극복하는 방법들을 찾아보거나위와 같은 패턴으로 코딩하는 걸 피하게끔 이런 개념들을 중요시 여기고 익혀야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"Scope","slug":"Scope","permalink":"https://perfectacle.github.io/tags/Scope/"}]},{"title":"블로그를 시작하다","slug":"Start-Blog","date":"2016-11-10T09:38:50.000Z","updated":"2022-10-30T08:42:16.119Z","comments":true,"path":"2016/11/10/Start-Blog/","link":"","permalink":"https://perfectacle.github.io/2016/11/10/Start-Blog/","excerpt":"기존의 네이버 블로그를 포기하고 새로 블로그를 이전했다.다소 어려움들이 있었지만 제대로 해보려고 한다. 왜 블로그를 옮겼는가? 네이버 블로그는 꾸미는데 제약사항이 많다. 기존의 블로그는 너무 중구난방식이었다. 깃헙 페이지를 이용하면 뭔가 개발자스럽다. 마크다운 문법에 익숙해지고 싶다. 포트폴리오 파일들을 내 블로그에 올리는 게 가능하다. 포스트의 버전관리도 가능하다. 내가 네이버 블로그를 제대로 관리 안 한 탓도 있었지만,구글링을 하다보면 티스토리나 기타 블로그들은 정말 멋진 개발자다운 블로그였다.하지만 그런 걸 네이버 블로그로 하려면 엄두가 나지 않았다.티스토리가 유력한 후보였지만, 깃헙 페이지가 더 개발자스러워보이고,깃헙을 쓴다면 마크다운 문법에 익숙해질 필요가 있다고 판단하여 깃헙 페이지를 선정하였다.또한 블로그의 포스트를 마이그레이션 할 때도 마크다운 문법은 매우 좋다고 들었다.타 블로그들을 인라인 스타일 때문에 마이그레이션 할 때 문제가 많다지만,마크업 문법을 HTML로 바꾸는 것은 매우 쉽다고 들었기 때문이다.","text":"기존의 네이버 블로그를 포기하고 새로 블로그를 이전했다.다소 어려움들이 있었지만 제대로 해보려고 한다. 왜 블로그를 옮겼는가? 네이버 블로그는 꾸미는데 제약사항이 많다. 기존의 블로그는 너무 중구난방식이었다. 깃헙 페이지를 이용하면 뭔가 개발자스럽다. 마크다운 문법에 익숙해지고 싶다. 포트폴리오 파일들을 내 블로그에 올리는 게 가능하다. 포스트의 버전관리도 가능하다. 내가 네이버 블로그를 제대로 관리 안 한 탓도 있었지만,구글링을 하다보면 티스토리나 기타 블로그들은 정말 멋진 개발자다운 블로그였다.하지만 그런 걸 네이버 블로그로 하려면 엄두가 나지 않았다.티스토리가 유력한 후보였지만, 깃헙 페이지가 더 개발자스러워보이고,깃헙을 쓴다면 마크다운 문법에 익숙해질 필요가 있다고 판단하여 깃헙 페이지를 선정하였다.또한 블로그의 포스트를 마이그레이션 할 때도 마크다운 문법은 매우 좋다고 들었다.타 블로그들을 인라인 스타일 때문에 마이그레이션 할 때 문제가 많다지만,마크업 문법을 HTML로 바꾸는 것은 매우 쉽다고 들었기 때문이다. 아쉬운 점 테마의 디자인이 조금 옛스럽다. 테마의 디자인이 이쁘면 기능이 구지다. 블로그 개발용과 배포용 저장소를 따로 만들어야한다. 나는 블로그에 글 쓰는 것에 초점을 두고 싶었으나깃헙 페이지는 나에게 너무나 많은 것을 요구했다.일단 git은 어느정도 사용해서 문제될 게 없었으나 망할놈의 Jekyll…또한 Jekyll을 쓰려면 Ruby를 설치해야했고, Windows OS를 쓰는 나에게는 크나큰 장벽이 되었다.경로가 꼬이거나 해줘야하는 잡다한 작업들이 많아서 그냥 포기해버렸다. 해서 찾아낸 게 Hexo다.Node 위에서 돌아가기 때문에 Windows OS에서도 전혀 문제가 없다.하지만 이 역시 직접 커스터마이징 하기가 귀찮고 시간이 오래 걸려서…그렇게 해서 테마찾기의 여정 끝에 Hueman이라는 테마를 찾았다.디자인 개선하려면 무지하게 귀찮고 엄청난 삽질이 예상된다. 좋은 점 검색 기능 댓글 기능 멀티 카테고리 기능 카테고리 별 페이지네이션 태그 기능 태그 별 페이지네이션 최근 포스트 반응형 짱짱맨 여러가지 테마를 찾아본 가운데 위 사항들이 나를 매료했다.디자인이 제일 마음에 걸렸지마는…나에게는 글 쓰는 것이 메인이기 때문에, 더 이상 시간을 허비할 수 없었다.나중에 좋은 테마를 또 발견한다면 포스트만 들고 날아가면 되기 때문이다. 자, 이제 시작이다!내 꿈을!내 꿈을 펼칠 블로그의 토대가 마련되었다.당분간은 좀 더 뻘짓을 할 수도 있겠지만…일단은 기존의 블로그에서 있던 내용 조금씩 정리하며 퍼다 나르고,밀렸던 리액트며, ES6 등등의 공부를 해야겠다!!","categories":[{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}],"tags":[{"name":"잡동사니","slug":"잡동사니","permalink":"https://perfectacle.github.io/tags/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"}]}],"categories":[{"name":"Note","slug":"Note","permalink":"https://perfectacle.github.io/categories/Note/"},{"name":"DB","slug":"Note/DB","permalink":"https://perfectacle.github.io/categories/Note/DB/"},{"name":"Test","slug":"Test","permalink":"https://perfectacle.github.io/categories/Test/"},{"name":"tomcat","slug":"tomcat","permalink":"https://perfectacle.github.io/categories/tomcat/"},{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/categories/gradle/"},{"name":"Notes","slug":"Notes","permalink":"https://perfectacle.github.io/categories/Notes/"},{"name":"독서","slug":"Notes/독서","permalink":"https://perfectacle.github.io/categories/Notes/%EB%8F%85%EC%84%9C/"},{"name":"기타","slug":"기타","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/"},{"name":"잡동사니","slug":"기타/잡동사니","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/categories/Spring-Boot/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/categories/Spring/"},{"name":"Programming","slug":"Programming","permalink":"https://perfectacle.github.io/categories/Programming/"},{"name":"Java","slug":"Programming/Java","permalink":"https://perfectacle.github.io/categories/Programming/Java/"},{"name":"Back-end","slug":"Back-end","permalink":"https://perfectacle.github.io/categories/Back-end/"},{"name":"DB","slug":"Back-end/DB","permalink":"https://perfectacle.github.io/categories/Back-end/DB/"},{"name":"JPA","slug":"Back-end/DB/JPA","permalink":"https://perfectacle.github.io/categories/Back-end/DB/JPA/"},{"name":"Spring","slug":"Back-end/Spring","permalink":"https://perfectacle.github.io/categories/Back-end/Spring/"},{"name":"Netty","slug":"Note/Netty","permalink":"https://perfectacle.github.io/categories/Note/Netty/"},{"name":"Study","slug":"Note/Study","permalink":"https://perfectacle.github.io/categories/Note/Study/"},{"name":"삽질","slug":"Note/삽질","permalink":"https://perfectacle.github.io/categories/Note/%EC%82%BD%EC%A7%88/"},{"name":"Dev","slug":"Note/Dev","permalink":"https://perfectacle.github.io/categories/Note/Dev/"},{"name":"Kotlin","slug":"Note/Kotlin","permalink":"https://perfectacle.github.io/categories/Note/Kotlin/"},{"name":"경제","slug":"기타/경제","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EA%B2%BD%EC%A0%9C/"},{"name":"Troubleshooting","slug":"Note/Troubleshooting","permalink":"https://perfectacle.github.io/categories/Note/Troubleshooting/"},{"name":"Middle-end","slug":"Middle-end","permalink":"https://perfectacle.github.io/categories/Middle-end/"},{"name":"DevOps","slug":"Middle-end/DevOps","permalink":"https://perfectacle.github.io/categories/Middle-end/DevOps/"},{"name":"Spring","slug":"Programming/Spring","permalink":"https://perfectacle.github.io/categories/Programming/Spring/"},{"name":"등등","slug":"기타/등등","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EB%93%B1%EB%93%B1/"},{"name":"Java","slug":"Note/Java","permalink":"https://perfectacle.github.io/categories/Note/Java/"},{"name":"Network","slug":"Middle-end/Network","permalink":"https://perfectacle.github.io/categories/Middle-end/Network/"},{"name":"TDD","slug":"Middle-end/TDD","permalink":"https://perfectacle.github.io/categories/Middle-end/TDD/"},{"name":"Front-end","slug":"Front-end","permalink":"https://perfectacle.github.io/categories/Front-end/"},{"name":"Web Server","slug":"Middle-end/Web-Server","permalink":"https://perfectacle.github.io/categories/Middle-end/Web-Server/"},{"name":"Elasticsearch","slug":"Back-end/DB/Elasticsearch","permalink":"https://perfectacle.github.io/categories/Back-end/DB/Elasticsearch/"},{"name":"ECMAScript","slug":"Programming/ECMAScript","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/"},{"name":"자알쓰","slug":"Programming/ECMAScript/자알쓰","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"Pattern","slug":"Middle-end/Pattern","permalink":"https://perfectacle.github.io/categories/Middle-end/Pattern/"},{"name":"음악","slug":"기타/음악","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9D%8C%EC%95%85/"},{"name":"자료구조","slug":"Middle-end/자료구조","permalink":"https://perfectacle.github.io/categories/Middle-end/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Spring Boot","slug":"Note/Spring-Boot","permalink":"https://perfectacle.github.io/categories/Note/Spring-Boot/"},{"name":"ES2015+","slug":"Programming/ECMAScript/ES2015","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/ES2015/"},{"name":"자작","slug":"기타/자작","permalink":"https://perfectacle.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EC%9E%91/"},{"name":"함수형 JS","slug":"Programming/ECMAScript/함수형-JS","permalink":"https://perfectacle.github.io/categories/Programming/ECMAScript/%ED%95%A8%EC%88%98%ED%98%95-JS/"},{"name":"Node.js","slug":"Programming/Node-js","permalink":"https://perfectacle.github.io/categories/Programming/Node-js/"},{"name":"Webpack","slug":"Front-end/Webpack","permalink":"https://perfectacle.github.io/categories/Front-end/Webpack/"},{"name":"React","slug":"Front-end/React","permalink":"https://perfectacle.github.io/categories/Front-end/React/"},{"name":"C/C++","slug":"Programming/C-C","permalink":"https://perfectacle.github.io/categories/Programming/C-C/"},{"name":"ASM","slug":"Programming/ASM","permalink":"https://perfectacle.github.io/categories/Programming/ASM/"},{"name":"git","slug":"Middle-end/git","permalink":"https://perfectacle.github.io/categories/Middle-end/git/"},{"name":"Babel","slug":"Front-end/Babel","permalink":"https://perfectacle.github.io/categories/Front-end/Babel/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://perfectacle.github.io/tags/MySQL/"},{"name":"HikariCP","slug":"HikariCP","permalink":"https://perfectacle.github.io/tags/HikariCP/"},{"name":"DB","slug":"DB","permalink":"https://perfectacle.github.io/tags/DB/"},{"name":"TDD","slug":"TDD","permalink":"https://perfectacle.github.io/tags/TDD/"},{"name":"mock","slug":"mock","permalink":"https://perfectacle.github.io/tags/mock/"},{"name":"test","slug":"test","permalink":"https://perfectacle.github.io/tags/test/"},{"name":"design","slug":"design","permalink":"https://perfectacle.github.io/tags/design/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://perfectacle.github.io/tags/Spring-Boot/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://perfectacle.github.io/tags/Tomcat/"},{"name":"gradle","slug":"gradle","permalink":"https://perfectacle.github.io/tags/gradle/"},{"name":"독서노트","slug":"독서노트","permalink":"https://perfectacle.github.io/tags/%EB%8F%85%EC%84%9C%EB%85%B8%ED%8A%B8/"},{"name":"제로 투 원","slug":"제로-투-원","permalink":"https://perfectacle.github.io/tags/%EC%A0%9C%EB%A1%9C-%ED%88%AC-%EC%9B%90/"},{"name":"ZERO to ONE","slug":"ZERO-to-ONE","permalink":"https://perfectacle.github.io/tags/ZERO-to-ONE/"},{"name":"reinvent","slug":"reinvent","permalink":"https://perfectacle.github.io/tags/reinvent/"},{"name":"여행","slug":"여행","permalink":"https://perfectacle.github.io/tags/%EC%97%AC%ED%96%89/"},{"name":"Spring","slug":"Spring","permalink":"https://perfectacle.github.io/tags/Spring/"},{"name":"Jackson","slug":"Jackson","permalink":"https://perfectacle.github.io/tags/Jackson/"},{"name":"Web","slug":"Web","permalink":"https://perfectacle.github.io/tags/Web/"},{"name":"Java","slug":"Java","permalink":"https://perfectacle.github.io/tags/Java/"},{"name":"Iterator","slug":"Iterator","permalink":"https://perfectacle.github.io/tags/Iterator/"},{"name":"Collection","slug":"Collection","permalink":"https://perfectacle.github.io/tags/Collection/"},{"name":"JPA","slug":"JPA","permalink":"https://perfectacle.github.io/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://perfectacle.github.io/tags/Hibernate/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://perfectacle.github.io/tags/Spring-Data-JPA/"},{"name":"TCP","slug":"TCP","permalink":"https://perfectacle.github.io/tags/TCP/"},{"name":"Netty","slug":"Netty","permalink":"https://perfectacle.github.io/tags/Netty/"},{"name":"RestTemplate","slug":"RestTemplate","permalink":"https://perfectacle.github.io/tags/RestTemplate/"},{"name":"JUnit","slug":"JUnit","permalink":"https://perfectacle.github.io/tags/JUnit/"},{"name":"Test","slug":"Test","permalink":"https://perfectacle.github.io/tags/Test/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"https://perfectacle.github.io/tags/IntelliJ/"},{"name":"Gradle","slug":"Gradle","permalink":"https://perfectacle.github.io/tags/Gradle/"},{"name":"Hexo","slug":"Hexo","permalink":"https://perfectacle.github.io/tags/Hexo/"},{"name":"Theme","slug":"Theme","permalink":"https://perfectacle.github.io/tags/Theme/"},{"name":"NexT","slug":"NexT","permalink":"https://perfectacle.github.io/tags/NexT/"},{"name":"보안","slug":"보안","permalink":"https://perfectacle.github.io/tags/%EB%B3%B4%EC%95%88/"},{"name":"공인인증서","slug":"공인인증서","permalink":"https://perfectacle.github.io/tags/%EA%B3%B5%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%84%9C/"},{"name":"암호화","slug":"암호화","permalink":"https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8%ED%99%94/"},{"name":"AES","slug":"AES","permalink":"https://perfectacle.github.io/tags/AES/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://perfectacle.github.io/tags/Kotlin/"},{"name":"경제","slug":"경제","permalink":"https://perfectacle.github.io/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"자본주의","slug":"자본주의","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B3%B8%EC%A3%BC%EC%9D%98/"},{"name":"재테크","slug":"재테크","permalink":"https://perfectacle.github.io/tags/%EC%9E%AC%ED%85%8C%ED%81%AC/"},{"name":"자산","slug":"자산","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%82%B0/"},{"name":"부채","slug":"부채","permalink":"https://perfectacle.github.io/tags/%EB%B6%80%EC%B1%84/"},{"name":"현금흐름","slug":"현금흐름","permalink":"https://perfectacle.github.io/tags/%ED%98%84%EA%B8%88%ED%9D%90%EB%A6%84/"},{"name":"퇴사","slug":"퇴사","permalink":"https://perfectacle.github.io/tags/%ED%87%B4%EC%82%AC/"},{"name":"이직","slug":"이직","permalink":"https://perfectacle.github.io/tags/%EC%9D%B4%EC%A7%81/"},{"name":"면접","slug":"면접","permalink":"https://perfectacle.github.io/tags/%EB%A9%B4%EC%A0%91/"},{"name":"금리","slug":"금리","permalink":"https://perfectacle.github.io/tags/%EA%B8%88%EB%A6%AC/"},{"name":"기축통화","slug":"기축통화","permalink":"https://perfectacle.github.io/tags/%EA%B8%B0%EC%B6%95%ED%86%B5%ED%99%94/"},{"name":"인플레이션","slug":"인플레이션","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"디플레이션","slug":"디플레이션","permalink":"https://perfectacle.github.io/tags/%EB%94%94%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"중앙은행","slug":"중앙은행","permalink":"https://perfectacle.github.io/tags/%EC%A4%91%EC%95%99%EC%9D%80%ED%96%89/"},{"name":"Lambda","slug":"Lambda","permalink":"https://perfectacle.github.io/tags/Lambda/"},{"name":"Java8","slug":"Java8","permalink":"https://perfectacle.github.io/tags/Java8/"},{"name":"Bean","slug":"Bean","permalink":"https://perfectacle.github.io/tags/Bean/"},{"name":"AWS","slug":"AWS","permalink":"https://perfectacle.github.io/tags/AWS/"},{"name":"Network","slug":"Network","permalink":"https://perfectacle.github.io/tags/Network/"},{"name":"Troubleshooting","slug":"Troubleshooting","permalink":"https://perfectacle.github.io/tags/Troubleshooting/"},{"name":"JVM","slug":"JVM","permalink":"https://perfectacle.github.io/tags/JVM/"},{"name":"Thread","slug":"Thread","permalink":"https://perfectacle.github.io/tags/Thread/"},{"name":"Redis","slug":"Redis","permalink":"https://perfectacle.github.io/tags/Redis/"},{"name":"Monitoring","slug":"Monitoring","permalink":"https://perfectacle.github.io/tags/Monitoring/"},{"name":"GC","slug":"GC","permalink":"https://perfectacle.github.io/tags/GC/"},{"name":"JMX","slug":"JMX","permalink":"https://perfectacle.github.io/tags/JMX/"},{"name":"ORM","slug":"ORM","permalink":"https://perfectacle.github.io/tags/ORM/"},{"name":"Heap","slug":"Heap","permalink":"https://perfectacle.github.io/tags/Heap/"},{"name":"ELB","slug":"ELB","permalink":"https://perfectacle.github.io/tags/ELB/"},{"name":"Nginx","slug":"Nginx","permalink":"https://perfectacle.github.io/tags/Nginx/"},{"name":"Proxy","slug":"Proxy","permalink":"https://perfectacle.github.io/tags/Proxy/"},{"name":"Deployment","slug":"Deployment","permalink":"https://perfectacle.github.io/tags/Deployment/"},{"name":"Docker","slug":"Docker","permalink":"https://perfectacle.github.io/tags/Docker/"},{"name":"Srping","slug":"Srping","permalink":"https://perfectacle.github.io/tags/Srping/"},{"name":"Webflux","slug":"Webflux","permalink":"https://perfectacle.github.io/tags/Webflux/"},{"name":"Reactive","slug":"Reactive","permalink":"https://perfectacle.github.io/tags/Reactive/"},{"name":"Time","slug":"Time","permalink":"https://perfectacle.github.io/tags/Time/"},{"name":"Date","slug":"Date","permalink":"https://perfectacle.github.io/tags/Date/"},{"name":"UTC","slug":"UTC","permalink":"https://perfectacle.github.io/tags/UTC/"},{"name":"GMT","slug":"GMT","permalink":"https://perfectacle.github.io/tags/GMT/"},{"name":"Zulu","slug":"Zulu","permalink":"https://perfectacle.github.io/tags/Zulu/"},{"name":"Unix","slug":"Unix","permalink":"https://perfectacle.github.io/tags/Unix/"},{"name":"Security Group","slug":"Security-Group","permalink":"https://perfectacle.github.io/tags/Security-Group/"},{"name":"YAML","slug":"YAML","permalink":"https://perfectacle.github.io/tags/YAML/"},{"name":"BNF","slug":"BNF","permalink":"https://perfectacle.github.io/tags/BNF/"},{"name":"log","slug":"log","permalink":"https://perfectacle.github.io/tags/log/"},{"name":"VPC","slug":"VPC","permalink":"https://perfectacle.github.io/tags/VPC/"},{"name":"Subnet","slug":"Subnet","permalink":"https://perfectacle.github.io/tags/Subnet/"},{"name":"Security","slug":"Security","permalink":"https://perfectacle.github.io/tags/Security/"},{"name":"JSON","slug":"JSON","permalink":"https://perfectacle.github.io/tags/JSON/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://perfectacle.github.io/tags/Travis-CI/"},{"name":"Coveralls","slug":"Coveralls","permalink":"https://perfectacle.github.io/tags/Coveralls/"},{"name":"Rollup","slug":"Rollup","permalink":"https://perfectacle.github.io/tags/Rollup/"},{"name":"CommonJS","slug":"CommonJS","permalink":"https://perfectacle.github.io/tags/CommonJS/"},{"name":"ESModule","slug":"ESModule","permalink":"https://perfectacle.github.io/tags/ESModule/"},{"name":"UMD","slug":"UMD","permalink":"https://perfectacle.github.io/tags/UMD/"},{"name":"Typescript","slug":"Typescript","permalink":"https://perfectacle.github.io/tags/Typescript/"},{"name":"TSLint","slug":"TSLint","permalink":"https://perfectacle.github.io/tags/TSLint/"},{"name":"Mocha","slug":"Mocha","permalink":"https://perfectacle.github.io/tags/Mocha/"},{"name":"Chai","slug":"Chai","permalink":"https://perfectacle.github.io/tags/Chai/"},{"name":"ts-node","slug":"ts-node","permalink":"https://perfectacle.github.io/tags/ts-node/"},{"name":"NYC","slug":"NYC","permalink":"https://perfectacle.github.io/tags/NYC/"},{"name":"CDN","slug":"CDN","permalink":"https://perfectacle.github.io/tags/CDN/"},{"name":"CD","slug":"CD","permalink":"https://perfectacle.github.io/tags/CD/"},{"name":"DNS","slug":"DNS","permalink":"https://perfectacle.github.io/tags/DNS/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://perfectacle.github.io/tags/Elasticsearch/"},{"name":"JS","slug":"JS","permalink":"https://perfectacle.github.io/tags/JS/"},{"name":"ES","slug":"ES","permalink":"https://perfectacle.github.io/tags/ES/"},{"name":"자알쓰","slug":"자알쓰","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EC%95%8C%EC%93%B0/"},{"name":"HTTP","slug":"HTTP","permalink":"https://perfectacle.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://perfectacle.github.io/tags/HTTPS/"},{"name":"GET","slug":"GET","permalink":"https://perfectacle.github.io/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://perfectacle.github.io/tags/POST/"},{"name":"Web Server","slug":"Web-Server","permalink":"https://perfectacle.github.io/tags/Web-Server/"},{"name":"CertificateManager","slug":"CertificateManager","permalink":"https://perfectacle.github.io/tags/CertificateManager/"},{"name":"EC2","slug":"EC2","permalink":"https://perfectacle.github.io/tags/EC2/"},{"name":"Route53","slug":"Route53","permalink":"https://perfectacle.github.io/tags/Route53/"},{"name":"LetsEncrypt","slug":"LetsEncrypt","permalink":"https://perfectacle.github.io/tags/LetsEncrypt/"},{"name":"Certbot","slug":"Certbot","permalink":"https://perfectacle.github.io/tags/Certbot/"},{"name":"Performance","slug":"Performance","permalink":"https://perfectacle.github.io/tags/Performance/"},{"name":"API","slug":"API","permalink":"https://perfectacle.github.io/tags/API/"},{"name":"DI","slug":"DI","permalink":"https://perfectacle.github.io/tags/DI/"},{"name":"Jazz","slug":"Jazz","permalink":"https://perfectacle.github.io/tags/Jazz/"},{"name":"Hiphop","slug":"Hiphop","permalink":"https://perfectacle.github.io/tags/Hiphop/"},{"name":"JazzHop","slug":"JazzHop","permalink":"https://perfectacle.github.io/tags/JazzHop/"},{"name":"Lofi","slug":"Lofi","permalink":"https://perfectacle.github.io/tags/Lofi/"},{"name":"Chill","slug":"Chill","permalink":"https://perfectacle.github.io/tags/Chill/"},{"name":"Sleepy","slug":"Sleepy","permalink":"https://perfectacle.github.io/tags/Sleepy/"},{"name":"독학","slug":"독학","permalink":"https://perfectacle.github.io/tags/%EB%8F%85%ED%95%99/"},{"name":"Closure","slug":"Closure","permalink":"https://perfectacle.github.io/tags/Closure/"},{"name":"JIT","slug":"JIT","permalink":"https://perfectacle.github.io/tags/JIT/"},{"name":"IT","slug":"IT","permalink":"https://perfectacle.github.io/tags/IT/"},{"name":"Computer","slug":"Computer","permalink":"https://perfectacle.github.io/tags/Computer/"},{"name":"기계어","slug":"기계어","permalink":"https://perfectacle.github.io/tags/%EA%B8%B0%EA%B3%84%EC%96%B4/"},{"name":"컴파일","slug":"컴파일","permalink":"https://perfectacle.github.io/tags/%EC%BB%B4%ED%8C%8C%EC%9D%BC/"},{"name":"인터프리터","slug":"인터프리터","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0/"},{"name":"진법","slug":"진법","permalink":"https://perfectacle.github.io/tags/%EC%A7%84%EB%B2%95/"},{"name":"자료구조","slug":"자료구조","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"Queue","slug":"Queue","permalink":"https://perfectacle.github.io/tags/Queue/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://perfectacle.github.io/tags/LinkedList/"},{"name":"List","slug":"List","permalink":"https://perfectacle.github.io/tags/List/"},{"name":"Stack","slug":"Stack","permalink":"https://perfectacle.github.io/tags/Stack/"},{"name":"자바의 정석","slug":"자바의-정석","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%95%EC%84%9D/"},{"name":"내장 클래스","slug":"내장-클래스","permalink":"https://perfectacle.github.io/tags/%EB%82%B4%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"날짜와 시간","slug":"날짜와-시간","permalink":"https://perfectacle.github.io/tags/%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84/"},{"name":"형식화","slug":"형식화","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EC%8B%9D%ED%99%94/"},{"name":"오류","slug":"오류","permalink":"https://perfectacle.github.io/tags/%EC%98%A4%EB%A5%98/"},{"name":"에러","slug":"에러","permalink":"https://perfectacle.github.io/tags/%EC%97%90%EB%9F%AC/"},{"name":"예외","slug":"예외","permalink":"https://perfectacle.github.io/tags/%EC%98%88%EC%99%B8/"},{"name":"디버깅","slug":"디버깅","permalink":"https://perfectacle.github.io/tags/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"ES6","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"EPSILON","slug":"EPSILON","permalink":"https://perfectacle.github.io/tags/EPSILON/"},{"name":"Entity Lifecycle","slug":"Entity-Lifecycle","permalink":"https://perfectacle.github.io/tags/Entity-Lifecycle/"},{"name":"Vector","slug":"Vector","permalink":"https://perfectacle.github.io/tags/Vector/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://perfectacle.github.io/tags/ArrayList/"},{"name":"OOP","slug":"OOP","permalink":"https://perfectacle.github.io/tags/OOP/"},{"name":"VO","slug":"VO","permalink":"https://perfectacle.github.io/tags/VO/"},{"name":"Lombok","slug":"Lombok","permalink":"https://perfectacle.github.io/tags/Lombok/"},{"name":"Ant","slug":"Ant","permalink":"https://perfectacle.github.io/tags/Ant/"},{"name":"Maven","slug":"Maven","permalink":"https://perfectacle.github.io/tags/Maven/"},{"name":"blog","slug":"blog","permalink":"https://perfectacle.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"https://perfectacle.github.io/tags/hexo/"},{"name":"starter","slug":"starter","permalink":"https://perfectacle.github.io/tags/starter/"},{"name":"review","slug":"review","permalink":"https://perfectacle.github.io/tags/review/"},{"name":"node.js","slug":"node-js","permalink":"https://perfectacle.github.io/tags/node-js/"},{"name":"crawler","slug":"crawler","permalink":"https://perfectacle.github.io/tags/crawler/"},{"name":"phantomjs","slug":"phantomjs","permalink":"https://perfectacle.github.io/tags/phantomjs/"},{"name":"mecab","slug":"mecab","permalink":"https://perfectacle.github.io/tags/mecab/"},{"name":"promise","slug":"promise","permalink":"https://perfectacle.github.io/tags/promise/"},{"name":"ES2015+","slug":"ES2015","permalink":"https://perfectacle.github.io/tags/ES2015/"},{"name":"async","slug":"async","permalink":"https://perfectacle.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://perfectacle.github.io/tags/await/"},{"name":"변수","slug":"변수","permalink":"https://perfectacle.github.io/tags/%EB%B3%80%EC%88%98/"},{"name":"자료형","slug":"자료형","permalink":"https://perfectacle.github.io/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"객체","slug":"객체","permalink":"https://perfectacle.github.io/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"원시값","slug":"원시값","permalink":"https://perfectacle.github.io/tags/%EC%9B%90%EC%8B%9C%EA%B0%92/"},{"name":"함수형","slug":"함수형","permalink":"https://perfectacle.github.io/tags/%ED%95%A8%EC%88%98%ED%98%95/"},{"name":"Node.js","slug":"Node-js","permalink":"https://perfectacle.github.io/tags/Node-js/"},{"name":"Value","slug":"Value","permalink":"https://perfectacle.github.io/tags/Value/"},{"name":"Expression","slug":"Expression","permalink":"https://perfectacle.github.io/tags/Expression/"},{"name":"Statement","slug":"Statement","permalink":"https://perfectacle.github.io/tags/Statement/"},{"name":"Loop","slug":"Loop","permalink":"https://perfectacle.github.io/tags/Loop/"},{"name":"Operator","slug":"Operator","permalink":"https://perfectacle.github.io/tags/Operator/"},{"name":"Unary","slug":"Unary","permalink":"https://perfectacle.github.io/tags/Unary/"},{"name":"잡동사니","slug":"잡동사니","permalink":"https://perfectacle.github.io/tags/%EC%9E%A1%EB%8F%99%EC%82%AC%EB%8B%88/"},{"name":"Module","slug":"Module","permalink":"https://perfectacle.github.io/tags/Module/"},{"name":"import","slug":"import","permalink":"https://perfectacle.github.io/tags/import/"},{"name":"export","slug":"export","permalink":"https://perfectacle.github.io/tags/export/"},{"name":"Namespace","slug":"Namespace","permalink":"https://perfectacle.github.io/tags/Namespace/"},{"name":"Scope","slug":"Scope","permalink":"https://perfectacle.github.io/tags/Scope/"},{"name":"ES6+","slug":"ES6","permalink":"https://perfectacle.github.io/tags/ES6/"},{"name":"callback","slug":"callback","permalink":"https://perfectacle.github.io/tags/callback/"},{"name":"npm","slug":"npm","permalink":"https://perfectacle.github.io/tags/npm/"},{"name":"Promise","slug":"Promise","permalink":"https://perfectacle.github.io/tags/Promise/"},{"name":"Hoisting","slug":"Hoisting","permalink":"https://perfectacle.github.io/tags/Hoisting/"},{"name":"Interface","slug":"Interface","permalink":"https://perfectacle.github.io/tags/Interface/"},{"name":"Symbol","slug":"Symbol","permalink":"https://perfectacle.github.io/tags/Symbol/"},{"name":"Generator","slug":"Generator","permalink":"https://perfectacle.github.io/tags/Generator/"},{"name":"Webpack2","slug":"Webpack2","permalink":"https://perfectacle.github.io/tags/Webpack2/"},{"name":"Optimize","slug":"Optimize","permalink":"https://perfectacle.github.io/tags/Optimize/"},{"name":"gzip","slug":"gzip","permalink":"https://perfectacle.github.io/tags/gzip/"},{"name":"babel","slug":"babel","permalink":"https://perfectacle.github.io/tags/babel/"},{"name":"React","slug":"React","permalink":"https://perfectacle.github.io/tags/React/"},{"name":"Hot","slug":"Hot","permalink":"https://perfectacle.github.io/tags/Hot/"},{"name":"Loader","slug":"Loader","permalink":"https://perfectacle.github.io/tags/Loader/"},{"name":"Router","slug":"Router","permalink":"https://perfectacle.github.io/tags/Router/"},{"name":"CLI","slug":"CLI","permalink":"https://perfectacle.github.io/tags/CLI/"},{"name":"this","slug":"this","permalink":"https://perfectacle.github.io/tags/this/"},{"name":"Array","slug":"Array","permalink":"https://perfectacle.github.io/tags/Array/"},{"name":"ES5","slug":"ES5","permalink":"https://perfectacle.github.io/tags/ES5/"},{"name":"C","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"C++","slug":"C","permalink":"https://perfectacle.github.io/tags/C/"},{"name":"Variable","slug":"Variable","permalink":"https://perfectacle.github.io/tags/Variable/"},{"name":"Static","slug":"Static","permalink":"https://perfectacle.github.io/tags/Static/"},{"name":"HTML","slug":"HTML","permalink":"https://perfectacle.github.io/tags/HTML/"},{"name":"Table","slug":"Table","permalink":"https://perfectacle.github.io/tags/Table/"},{"name":"ajax","slug":"ajax","permalink":"https://perfectacle.github.io/tags/ajax/"},{"name":"배열","slug":"배열","permalink":"https://perfectacle.github.io/tags/%EB%B0%B0%EC%97%B4/"},{"name":"ASM","slug":"ASM","permalink":"https://perfectacle.github.io/tags/ASM/"},{"name":"Assembly","slug":"Assembly","permalink":"https://perfectacle.github.io/tags/Assembly/"},{"name":"Endian","slug":"Endian","permalink":"https://perfectacle.github.io/tags/Endian/"},{"name":"인터넷","slug":"인터넷","permalink":"https://perfectacle.github.io/tags/%EC%9D%B8%ED%84%B0%EB%84%B7/"},{"name":"속도","slug":"속도","permalink":"https://perfectacle.github.io/tags/%EC%86%8D%EB%8F%84/"},{"name":"암호","slug":"암호","permalink":"https://perfectacle.github.io/tags/%EC%95%94%ED%98%B8/"},{"name":"용량","slug":"용량","permalink":"https://perfectacle.github.io/tags/%EC%9A%A9%EB%9F%89/"},{"name":"상식","slug":"상식","permalink":"https://perfectacle.github.io/tags/%EC%83%81%EC%8B%9D/"},{"name":"Literal","slug":"Literal","permalink":"https://perfectacle.github.io/tags/Literal/"},{"name":"Memory","slug":"Memory","permalink":"https://perfectacle.github.io/tags/Memory/"},{"name":"Pointer","slug":"Pointer","permalink":"https://perfectacle.github.io/tags/Pointer/"},{"name":"Address","slug":"Address","permalink":"https://perfectacle.github.io/tags/Address/"},{"name":"반복문","slug":"반복문","permalink":"https://perfectacle.github.io/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"name":"연산자","slug":"연산자","permalink":"https://perfectacle.github.io/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"조건문","slug":"조건문","permalink":"https://perfectacle.github.io/tags/%EC%A1%B0%EA%B1%B4%EB%AC%B8/"},{"name":"형변환","slug":"형변환","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EB%B3%80%ED%99%98/"},{"name":"정규화","slug":"정규화","permalink":"https://perfectacle.github.io/tags/%EC%A0%95%EA%B7%9C%ED%99%94/"},{"name":"부동소수점","slug":"부동소수점","permalink":"https://perfectacle.github.io/tags/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90/"},{"name":"Number","slug":"Number","permalink":"https://perfectacle.github.io/tags/Number/"},{"name":"IDE","slug":"IDE","permalink":"https://perfectacle.github.io/tags/IDE/"},{"name":"Editor","slug":"Editor","permalink":"https://perfectacle.github.io/tags/Editor/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://perfectacle.github.io/tags/JetBrains/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://perfectacle.github.io/tags/WebStorm/"},{"name":"PhpStorm","slug":"PhpStorm","permalink":"https://perfectacle.github.io/tags/PhpStorm/"},{"name":"Hosting","slug":"Hosting","permalink":"https://perfectacle.github.io/tags/Hosting/"},{"name":"RegExp","slug":"RegExp","permalink":"https://perfectacle.github.io/tags/RegExp/"},{"name":"Markdown","slug":"Markdown","permalink":"https://perfectacle.github.io/tags/Markdown/"},{"name":"md","slug":"md","permalink":"https://perfectacle.github.io/tags/md/"},{"name":"형상 관리","slug":"형상-관리","permalink":"https://perfectacle.github.io/tags/%ED%98%95%EC%83%81-%EA%B4%80%EB%A6%AC/"},{"name":"버전 관리","slug":"버전-관리","permalink":"https://perfectacle.github.io/tags/%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC/"},{"name":"배포","slug":"배포","permalink":"https://perfectacle.github.io/tags/%EB%B0%B0%ED%8F%AC/"},{"name":"git","slug":"git","permalink":"https://perfectacle.github.io/tags/git/"},{"name":"Cross Browsing","slug":"Cross-Browsing","permalink":"https://perfectacle.github.io/tags/Cross-Browsing/"},{"name":"Webpack","slug":"Webpack","permalink":"https://perfectacle.github.io/tags/Webpack/"},{"name":"Debugging","slug":"Debugging","permalink":"https://perfectacle.github.io/tags/Debugging/"},{"name":"Source Map","slug":"Source-Map","permalink":"https://perfectacle.github.io/tags/Source-Map/"},{"name":"Babel","slug":"Babel","permalink":"https://perfectacle.github.io/tags/Babel/"}]}