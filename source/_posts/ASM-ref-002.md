---
title: (ASM) 참고용 정리 - 리틀 엔디안, 빅 엔디안
date: 2017-01-24 09:52:21
category: [Programming, ASM]
tag: [ASM, Assembly, Endian]
---
![](ASM-ref-002/thumb.png)  
엔디안은 시스템 프로그래밍에서 많이 쓰이는 용어이다.  
엔디안은 메모리의 저장 및 처리 방식을 말하는 것이다.  
이는 바이트 순서(Byte Order)와도 큰 관련이 있다.

1. 빅 엔디안(Big Endian)  
메모리의 높은 번지 부터 저장하는 방식  
MSB(Most Significant Byte), 최상위 바이트부터 차례로 저장한다.  
2. 리틀 엔디안(Little Endian)  
메모리의 낮은 번지 부터 저장 하는 방식  
LSB(Least Significant Byte), 최하위 바이트부터 차례로 저장한다.  

4바이트에 값이 저장되는 방식을 알아보자.

10진수 | 빅 엔디안 | 리틀 엔디안
--- | --- | ---
0 | 0x00000000 | 0x00000000
1 | 0x00000001 | 0x01000000
2 | 0x00000002 | 0x02000000
3 | 0x00000003 | 0x03000000
4 | 0x00000004 | 0x04000000
5 | 0x00000005 | 0x05000000
6 | 0x00000006 | 0x06000000
7 | 0x00000007 | 0x07000000
8 | 0x00000008 | 0x08000000
9 | 0x00000009 | 0x09000000
10 | 0x0000000A | 0x0A000000
11 | 0x0000000B | 0x0B000000
12 | 0x0000000C | 0x0C000000
13 | 0x0000000D | 0x0D000000
14 | 0x0000000E | 0x0E000000
15 | 0x0000000F | 0x0F000000

빅 엔디안 방식이 우리가 자주 생각하는 저장 방식이다.  
빅 엔디안은 가독성이 뛰어나고 대소 비교도 편하고 등등의 장점이 많다.  
또한 네트워크 통신에서는 빅 엔디안 방식을 이용하자고 약속하였다.  
0x00000001을 A 컴퓨터는 빅 엔디안 방식으로 숫자 '1'을 보낸것인데  
리틀 엔디안 방식인 컴퓨터 B는 데이터를 받을 때 0x01000000으로 받는다.
그럼 A는 숫자 '1'을 보냈는데 컴퓨터 B는 '268435456'을 받은 꼴이 돼버리기 때문이다.

그럼 리틀 엔디안은 왜 나왔을까...?  
가산기를 설계할 때 올림수를 계산하기 편하고, 빠르기 위함이란다.  
15 + 1 을 빅 엔디안 방식으로 계산하면  
0x0000000F + 0x00000001 = 0x00000010  
으로 계산 후 최하위 바이트로 이동해서 올림수가 발생한다.  
이번앤 리틀 엔디안 방식으로 계산해보자.  
0x0F000000 + 0x01000000 = 0x10000000  
올림수를 계산할 때 최상위 바이트에서 바로 올림수가 가능하기 때문이다.  
라고 이해했는데 뭐 케바케기도 할 것 같고 요즘엔 둘 사이에 차이가 거의 없다고 한다.  

또한 이런 엔디안은 CPU에 의존적이다.  
주로 인텔 CPU가 리틀 엔디안 방식을 사용한다고 한다.  
비디오 게임기인 SFC, NDS 등등에서도 리틀 엔디안 방식을 사용하는 경우가 많으니 참고하자.  

## 참조 링크
* [시스템 프로그래밍 리틀 엔디안(Little Endian), 빅 엔디안(Big Endian)](http://blog.naver.com/krinlion/40137959041)  
* [리틀 엔디안 VS 빅 엔디안](http://genesis8.tistory.com/37)  
